<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[单例设计模式]]></title>
      <url>%2F2017%2F03%2F17%2Fdanli%2F</url>
      <content type="text"><![CDATA[前言在介绍单例设计模式之前，先简单介绍一下java的内存分析，可以帮助我们更好的了解相关内容。在此之前，先简单介绍几个相关概念 Stack（栈）存放基本数据类型的数据和对象的引用及存放变量，如果存放的是基本数据类型（非static），直接将变量名和值存入stack中，如果是引用，只将变量名存入栈，然后指向它new的对象（存放在堆中） Heap（堆）存放new产生的数据 静态域存放在对象中用static定义的静态成员（基本类型） 常量池存放所有数据 案例下面将模拟几个实例先说明在证明。（此外注意String不是基本数据类型）上面给出了一个实例，意在了解内存分配，接下来将以String为例说明 12345678String str="abc";String str1="abc";String str2=str;String str3=new String("abc");String str4=new String("abc");String str5=str3;static String str6="abc";static String str7=new String("abc"); 对应的测试内存地址是否相等 123 System.out.println(str==str1);System.out.println(str==str2);System.out.println(str1==str2); 测试结果 true true true说明String 是引用类型，而且上面方法产生的变量都只在栈中并且都是同一个地址 12 System.out.println(str==str3);System.out.println(str3==str4); 测试结果：false false说明：new 之后的对象地址存放在堆中，同时堆中每个new之后的对象地址都是不一样的 1234 System.out.println(str==str6);System.out.println(str3==str6);System.out.println(str6==str7);System.out.println(str3==str7); 测试结果：true false false false说明：String类型的静态变量存放在栈中，而new之后的静态变量存放在堆中 关于内存分配，比较复杂，这里只简单验证其中一些，其他可以自己设计案例模拟 单例顾名思义就是指唯一的对象实例具体点说就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例只存在一个，通常其结构如下所示。入门案例：首先是单例类 1234567891011package com.zwl.pojo;public class Singleton &#123; private static Singleton singleton=new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 测试用junit4进行测试 12345678@Testpublic void test1()&#123; System.out.println("start test.."); Singleton obj1=Singleton.getInstance(); Singleton obj2=Singleton.getInstance(); System.out.println(obj1==obj2); System.out.println("end test..");&#125; 测试结果：start test.. true end test..说明，obj1与obj2是同一个实例，间接说明了单例的特性 至此我们对单例有了一个初步的形式上的认识了，那么它的特点是什么了？主要为三点一：单例类确保自己只有一个实例（构造函数私有：不被外部实例化，也不被继承）二：单例类必须自己创建自己的实例三：单例类必须为其他对象提供唯一的实例 说到单例就必然涉及到多线程，不多说，先模拟一个多线程来说明单例中存在的并发问题。友情提醒一下，上面用的是饿汉式创建单例，就一开始就创建了一个实例，显然浪费内存，接下来将用懒汉式创建单例主体类代码： 1234567891011private static Singleton singleton; private Singleton()&#123; &#125; public static Singleton getInstance() &#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; return singleton; &#125; 下面将用三个线程模拟，两个线程调用单例类，第三个线程启动前两个线程，测试用junit 123456789101112131415161718192021222324public class thread1 implements Runnable&#123; Singleton singleton; public Singleton getSingleton() &#123; return singleton; &#125; public void setSingleton(Singleton singleton) &#123; this.singleton = singleton; &#125; @Override public void run() &#123; singleton=Singleton.getInstance(); &#125;&#125; public class Thread2 implements Runnable&#123; Singleton singleton; public Singleton getSingleton() &#123; return singleton; &#125; public void setSingleton(Singleton singleton) &#123; this.singleton = singleton; &#125; @Override public void run() &#123; singleton=Singleton.getInstance(); &#125;&#125; 简单说明一下，这两个线程目的是调用单例类（注意如果是单例，决不允许出现不同实例）先贴出测试类： 123 thread3 t=new thread3();Thread tt=new Thread(t);tt.start(); 这里我们通过控制第三个线程来构造并发，(这里采用数学中的极限思想) 123456789101112131415public class thread3 implements Runnable&#123; thread1 t1=new thread1(); Thread2 t2=new Thread2(); Thread t=new Thread(t1); Thread t3=new Thread(t2); @Override public void run() &#123; long start=System.currentTimeMillis(); t.start(); t3.start(); long end=System.currentTimeMillis(); System.out.println(end-start); //并发的时间间隔 System.out.println(t1.getSingleton()); System.out.println(t2.getSingleton()); &#125; 测试结果：0 null null多次运行，又出现另一种结果：6com.zwl.pojo.Singleton@8fdcd1null和其他不同步结果说明在很短的时间间隔类，一个居然已经有了实例，而另一个居然是空，显然不是单例，想想倘若在此时去操作该单例，可能就会是静态类发生变化，也就是并发问题了。 很自然。那么怎么去解决了，一种很通用的方法就是加锁实现同步 双锁机制12345678910111213public static Singleton getInstance() &#123; if(singleton==null) &#123; synchronized(Singleton.class) &#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; &#125; &#125; return singleton; &#125; Synchronized关键字，声明使该线程在某处同步，也就是一个线程先占用，另一个线程被阻塞，显然如果不为空，就直接返回对象，对应第二个线程也就不执行if语句了，达到单例效果，可以想象如果为计数变量，同样可以通过二次加锁实现同步 但是实际还是出现不同步，原因是jvm的一个bug，它允许无序写入线程，导致不同步，当然我们可以通过申明volatile关键字。 为什么就可以解决双重解锁的bug了？原因是volatile保证原子性，顺序性，即在双重加锁前保证多线程实现顺序性，举个例子吧，现在有两个线程t1和t2，分别执行b，c操作，如果乱序写入，可能出现t1正在操作b还没完成，t2操作c，致使单例失败，所以需要保证顺序性。经过不断的测试，发现完全同步，只不过时间间隔为0，和null，null，至少是同步了~ 接下来简单比较一下饿汉式和懒汉式的区别从速度和反应时间上，饿汉式加载好，从资源利用率上懒汉式好，饿汉式很明显不会出现多线程并发问题，所以是线程安全的，而懒汉式则是非线程安全的 关于单例模式的应用，笔者在当初学习过程中，遇到很多，学习总是一个不断压缩与重新认识的过程，像sql工具类，hibernate的懒加载，mybatis及 spring中的一些配置等等，往往把握不好，就会出现错误，这里只列举一些工具类，因为它是笔者接触的第一个单例应用。 12345678910111213141516Private static Connection connection;Private sqlhelper()&#123;&#125;； public static Connection mysqlconn() throws Exception &#123; try &#123; // 加载驱动 Class.forName("com.mysql.jdbc.Driver"); // 连接数据库 connection = DriverManager.getConnection( "jdbc:mysql://localhost:3306/software", "root", ""); System.out.println("获得数据库"); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return connection; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用nat123搭建本地服务器]]></title>
      <url>%2F2017%2F03%2F17%2Fnat123%2F</url>
      <content type="text"><![CDATA[前言这是笔者去年第一次将web项目通过外网访问，当然结果很美好，过程很艰难，当时也是第一次用文档记录了探索过程，当然也是在google老师的帮助下，诚然学习最大的乐趣就是通过自己忘我的想尽一切办法最后solve的那种快感进入正题 1 因为要把服务器架在自己的机子上，所以可以选择花生壳和nat123，于是当时百度了一堆关于该技术，充其量只是了解了概念，然后修改tomcat配置文件，先将默认的8080端口改为100（按理讲应该改为80，之后注意中讲为什么），然后将root文件夹全部删掉，当然还有一部（但是我配置了只要一输入域名就是空白页，所以我舍弃了这一步）配置域名与tomcat项目的映射 1&lt;Context path="" debug="0" docBase="你项目的决定路径" reloadable="true"&gt;&lt;/Context&gt; 2 tomcat部分算是完成了，之后我选择了用nat123，建议去官网下载最新版本，注册，登录然后按照百度步骤，懒得写了就截个图吧 注意应用类型我们选80（http）网站，毕竟这是相对来说最佳选择，内网端口（默认可以写80）我选择了100（之后一定要打开和开放端口，后面再说），内网地址，命令行中输入ipconfig查看ip4就是内网，当然也可以用localhost等等（因为他们在tomcat配置，或者在c盘的一个文件中为他们设置了常量，百度就能找到c盘那个源码，tomcat不多说就在配置里面，很好找），其他配置不动，然后保存 这样就有了域名 在打开nav123客户端，出现笑脸，如图等表示映射正常， 然后下面才是最恐怖的地方了（出现各种问题） 1 如果你内网和tomcat选择的是80端口，注意80端口默认不打开的，先开启控制面板-系统与安全-windows防火墙-高级设置-入站规则-新建规则-端口-80-下一步。。-完成， 然后在用netstat –a看看有没有80端口，假设有了，然后以为顺利 了，结果点击客户端的设置，发现最上面出现无公网连接，也就是说内网的80端口不能映射外网，这下麻烦了，好吧，据需钻研解决方案。试着其中一个靠谱的，说路由器配置中没有开放外网，好吧 先在计算机中输入192.168.1.1（这是电信的），打开路由器（然后简单去了解了一下路由器）先开启dmz主机，指派一个特定内网ip（那个机子对外开放），然后 在虚拟服务中打开相应端口80（暂且不是100），然后自以为一切顺利，在点开客户端那个设置或打开命名行输入ipconfig，都显示自己的公网了，相当于一道闸门打开了，当然也找不出问题了，结果又出现将域名输入出现错误。 结果觉得可能是80端口被封（可是已经在客户端能做的范围内把80打开了，最好的解释是要去电信局备案，才能在服务器端解封80端口），也就是说，80端口我们用不了了） 居然一时用不了，就用其他端口吧，就100吧，把之前所有的80开放改为100，然后在打开网页（注意：tomcat没有配置项目初始化，自己指定），然后在用手机或者其他机子试一次，即域名+项目名，结果成功了，但是网速不行啊（又头疼了~~）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[window分区导致双系统无引导界面]]></title>
      <url>%2F2017%2F03%2F17%2Ffenqu%2F</url>
      <content type="text"><![CDATA[先简单介绍一下情境，笔者电脑上装的是双系统，而且bios上设置了system password（当然，已经忘记了是多少了），然后心血来潮在阿里云买了一个学生优惠的服务器，安装了mysql+tomcat7+jdk，在电脑上d盘已经装了linux，在c盘上分了一个分区，那么问题来了，当再次打开电脑时，无引导界面，取而代之的是 然后google了许多解决方案，当然是在彩果许多坑之后找到了适合自己的解决方案，毕竟一个问题的解决总不是一帆风顺的。 进入正题 如果我们要重装系统，肯定得用到bios设置，那么问题来了，如果你设置了密码，并且密码忘记了，那怎么办? 一种办法是通过硬件，通过把电池正负极按照网上说的折腾一下，就可以恢复bios出厂设置，显然这种方法有极大风险，可能会损坏硬件（具体参考google）或者用相关修复工具，但是笔者的电脑都无引导界面，尴尬了~ 还有一种办法就是在你输入3次错误的密码时会出现如下错误代码 然后就是在这里面设置，如下图，输入上述的错误代码，就出现了bios密码， 当然，笔者电脑里有许多宝贵的数据，不可能也不愿意重装系统，经过google一番，发现是分区导致引导盘不能引导，只需要找到该分区，在llinux上重新修复就行了 首先在页面中输入如下lsgrub rescue&gt; ls出现如下（基本都差不多）hd0，（hd0，nsdoc9），（hd0，nsdoc8），（hd0，nsdoc7），（hd0，nsdoc6），（hd0，nsdoc5），（hd0，nsdoc2），（hd0，nsdoc1） 然后通过ls 如上的分区循环一遍，如ls （hd0，nsdoc9）/上述有一个会出现详细信息，他就是安装linux那个分区，其余都是unknown filesystem，当然如果出现bad filesystem那是你没加/如下图： 接下来设置root引导盘 set root=(hd0，nsdoc6）这里设置的是上述找到分区的那个盘set prefix=(hd0，nsdoc6）/boot/grub/ 然后可以用set验证一下 set会出现上述设置的信息 最后执行下述命令 insmod normal在输入normal，就会自动跳转到引导界面，我们选择ubuntu进入，在里面进行修复即可 进入linux系统打开终端，先更新grub，即输入 sudo update-grub ok后在输入 sudo grub-install /dev/sda结束后，我们就可以重启电脑，一切都ok了。进入电脑后笔者做的第一件事就是备份数据，毕竟要给自己留条后路，如果遇到更复杂的情况就后悔莫及了。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阿里云服务器上搭建javaweb站点]]></title>
      <url>%2F2017%2F03%2F16%2Fdajianserver%2F</url>
      <content type="text"><![CDATA[事实上笔者在去年8月份的时候就已经在自己电脑上通过nat123搭建了一台服务器，即p2p，自己的电脑作为服务器，但是这很不安全，而且每次别人通过外网访问，电脑必须打开而且开着服务器，由于是免费的，导致别人访问网速跟不上等等，最近阿里云有学生9.9元购买服务器，所以笔者买了一个，也很有兴趣将笔者之前写的两个网站部署上，结果很美好，但过程很坑，所以就需要总结来提高自己进入正题笔者也是google了许多例子和前人的经验找到适合自己的方法 首先需要租一台云服务器，我选择了阿里云 注意这里操作系统有四个选项，笔者发现只有第四个符合自己（貌似是自定义），然后按照步骤，其中有些需要注意 安全组，这里暂时可以选择默认的第一个，因为后面如果在搭建web时需要一些端口（如mysql默认3306端口改掉，tomcat8080端口换成80等等），到时可以在后台操作） 关于镜像选择，因为笔者是window7，而且还是32位的，相对64位只能有不大于4g的内存， 这里的密码就是之后在本地机子上远程登录这个服务器所要的密码 ok至此，成功租了一台服务器，这时你会收到一条短信，里面有你这台服务器的公网地址 然后笔者就开始着手在本机上登录该服务器，当然是为了搭建javaweb准备的 在本机上准备javaweb需要的环境 在本机上新建一个分区用来放上述软件供服务器远程使用（其实也可以不用分区，直接复制也行，毕竟笔者被分区坑了，导致后来的双系统引导界面消失） 本机上登录远程连接可以用运行-mstsc-直接进入到如下界面其中计算机就是你的公网地址，如果你是新建了一个分区，那么就点选项在本地资源的详细信息中就新建的那个分区勾上，笔者这里是x盘（如果没有的话就直接连接） 后面什么证书，安全啊先不管了，应该是进入远程服务器了 接下来就是将mysql，jdk等复制到c盘中，因为只有一个盘，后续就是安装配置了 安装jdk，笔者的是jdk1.6（注意jdk版本不同，后续运行高版本会出像版本错误，笔者已吃过亏），配置环境变量 安装tomcat，配置tomcat环境变量，注意上述不需要自定义文件夹，因为只有一个c盘，tomcat默认端口是8080 安装mysql，这里面需要注意的是里面有端口设置，可以选择默认的3306或者自定义，然后就是用户与密码设置 可以使用可视化数据库工具，这里笔者使用了navicat至此算是搭建了一个简单web环境，可以先测试一下拷贝一个已经被编译过的web项目，启动tomcat与mysql，然后利用localhost:8080/项目名访问，如果出现界面就表示以上配置成功 接下来需要买一个域名 成功后点击解析，在里面找到新手设置，点进去点击设置网站解析，然后输入公网，即可。 在远程服务器中，找到tomcat下conf下的server.xml文件，如果我们不想要8080端口并且输入域名时不想要端口的话，就先把8080端口改成80 Connector port=”80” protocol=”HTTP/1.1” connectionTimeout=”20000” redirectPort=”8443” /&gt; 3.然后找到host Host name=”你刚刚解析的域名” appBase=”webapp” unpackWARs=”true” autoDeploy=”true”&gt; &lt;Context path=”” docBase=”/项目名” debug=”0” reloadable=”true” 注意这里appBase是放项目的站点，context内的docBase是你的项目名，目前我们只是一个tomcat运行一个域名执行一个项目然后打开C:\Windows\System32\drivers\etc下的host文件增加如下设置 127.0.0.1 localhost ::1 localhost192.168.1.11 刚刚的域名 保存，然后重启服务器，可能会发现会遇到一些问题，如80端口被占用，80端口未开放等等，假设未被占有（如果占用，google上有解决方法），如果未开放，这里我们就需要在云服务器上进行端口开放设置 进入我们购买的云服务器，点击安全组，选中一个实例，点击配置，选择公网入方向，按照步骤开放想要的端口 至此只要输入域名就可以访问了。 当然，如果我们想要一个tomcat上配置多个域名，每个域名运行各自不同的项目，那如何做了，经过踩坑后，大概如下步骤 可以选择在tomcat下新建一个站点，类似于原来的webapp，然后在server.xml中进行配置一个新host Host name=”第二个域名” appBase=”新创建的站点” unpackWARs=”true” autoDeploy=”true”&gt; &lt;Context path=”” docBase=”/第二个项目名” debug=”0” reloadable=”true” 2.然后在hosts文件汇总加入第二个域名 127.0.0.1 localhost ::1 localhost192.168.1.11 刚刚的域名192.168.1.11 第二个域名 最后重启服务器。笔者在这里遇到了一个很奇怪的坑，同一服务器下的项目出现奇怪的jar包冲突，只要删掉xerces包就行了（当然是在远程服务器上才产生冲突的）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初步搭建hexo博客]]></title>
      <url>%2F2017%2F03%2F12%2Fhexo1%2F</url>
      <content type="text"><![CDATA[博客是一种能够更好提高自己的途径，关于利用hexo搭建博客，笔者是一路google一路踩坑，才完成的，当然关于这方面的搭建，实在太多了，笔者也只是稍微总结一下 首先在github上注册一个账号 创建代码库（repository），一般以yourname/youname.github.io setting中选择主题 购买一个域名（这里以笔者在阿里云买的为例） 点击域名里的解析注意CNAME为你的仓库名，其他套用6.回到setting中在Custom domain下填写你刚才的域名，然后在code中会出现一个CNAME文件7.yourname.gthub.io访问你的博客，目前应该只是一个默认主页 接下来就是本地安装hexo与github page联系起来 1.官网安装node.js（注意是32位还是64位） 2安装git（在过程中会有一项自带环境变量设置，选中，不然后面无法识别git） 3安装hexo（以笔者的在e:/blog下为例） 在git bush中 1npm install hexo-cli -g 然后在输入 1npm install hexo --save 然后利用 hexo -v 验证安装是否成功 4.然后在要创建的目录下初始化hexo hexo init 5安装所需的组件和依赖组件 npm install 笔者当时一下子全部安装了很多扩展组件如: npm install hexo-deployer-git –save 在看看目录下应该产生如下目录 6 生成静态文件 hexo g 7 启动服务器，进行本地预览访问 hexo s 然后在浏览器中打开http://localhost:4000/，会出现一个默认的hexo主页 8 Hexo与github page 联系首先是配置Git个人信息 git config –global user.name “用户名”git config –global user.email “邮箱地址” 9 生成密钥 sh-keygen -t rsa -C “邮箱地址” 这里笔者遇到一个坑，默认是在administrator目录下生成一个.ssh文件夹里面包含结果没有，所以自己在该目录下创建一个.ssh文件夹 10 配置Deployment（以笔者的为例） deploy: type: gitrepository: http://github.com/slycmiaoxi/slycmiaoxi.github.io.gitbranch: master 这里的repository是git上对应的use ssh进行clone的 11 登录到git的use ssh将.ssh文件下的id_rsa.pub里的内容复制到改里面 12 写文章上传 hexo new post “article title” 新建一个文章，默认放再_post下 hexo clean 清空public里的文件，该文件夹是上传到git上 hexo g 生成到public文件夹中 hexo d 部署，此过程要输入用户名和密码， 笔者在hexo d过程中曾出现一致无权限，后来在google老师的指引下需要设置用户名和密码，在.ssh文件下生成known_hosts文件，如果没有遇到，那是比较幸运了 目前还是默认的主题，显然不好看，其次编写文章需要markdown语言，笔者使用的是小书匠，因为其组件丰富，操作简单 13 更换主题 首先需要cd到你的hexo根目录，然后 git clone https://github.com/iissnan/hexo-theme-next themes/next 我选择的是next主题，因为其功能，配置方面相对较强大，当然在主题配置方面一路是坑，这里推荐去next官网看配置，大部分都涉及到 如果我们启用next主题，只要在_config.yml（站配置文件中）找到theme，将默认的改成next即可， 另一方面，在theme文件夹下的next文件夹下的_config.yml(主题配置文件）进行主题的配置，当然里面其他文件也是可以配置的，当然google是最好的帮手 最后主题也配置好了，只需要输入yourname.github.io就可以访问你的博客了 当然笔者是一路踩坑过来，很多google也不一定适合自己，只有自己探索过的才是最适合自己的。 最后需要说一下，多说老是注册异常，后来干脆选择友言代替，总之theme里面有很多需要探索的，google是最好的老师]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇仅为测试]]></title>
      <url>%2F2017%2F03%2F10%2Fhi%2F</url>
      <content type="text"><![CDATA[花了好几天业余时间终于搞好了，正是一路踩坑，一路请教google老师，一路折腾，一路不断学习，搭建了一个比较丑的博客 cout&lt;&lt;“so hard”cout&lt;&lt;“这仅仅是一个测试” 1这是一个测试代码! java c c++ hello world c c++ java hello]]></content>
    </entry>

    
  
  
</search>
