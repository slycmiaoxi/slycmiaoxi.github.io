<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[腾讯云linux服务器上搭建javaweb站点]]></title>
      <url>http://www.myzwl.win/2017/11/03/linux_2/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我一直坚信没有过程就不会有好的结果。回顾大学期间的学习历程，关于别人访问自己的站点，从刚开始的基于swing的cs系统，到基于socket的聊天框，再到局域网访问的web与在分别虚拟机和双系统的linux下搭建web，到后来基于nat123的p2p访问，再到后来阿里云的window8 server服务器搭建java web站点，到最后的腾讯云linux服务器集成，每一次的探索，都是与踩坑做斗战，也是进步最快的方法。不多说，这里记录一下之前搭建的步骤</p>
<h4 id="远程连接工具"><a href="#远程连接工具" class="headerlink" title="远程连接工具"></a>远程连接工具</h4><p>故名思议，举世通过远程的方式去连接Linux并操作它，Linux远程的操作工具有很多。像xshell、Puttty、secureCRT、SSH Secure等，一般情况下习惯用命令去控制，所以这里选择了SSH Secure。该工具是免费的图形化界面及命令行窗口集一身的远程工具，具体可以去网上下载。</p>
<h4 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h4><p>步骤：<br>1）查看当前Linux系统是否已经安装java<br>输入 rpm -qa | grep java<br>2）卸载两个openJDK<br>输入rpm -e –nodeps 要卸载的软件<br>如果未安装直接跳过前面两个步骤<br>3）上传jdk到linux（我的是Ubuntu Server 16.04.1 LTS 64位注意版本问题）<br>4.解压jdk到/usr/local下 tar –xvf jdk-7u71-linux-i586.tar.gz –C /usr/local<br>5 配置jdk环境变量，打开/etc/profile配置文件，将下面配置拷贝进去，这个一定要用vi打开，gedit可能会不行</p>
<blockquote>
<p>#set java environment<br>    JAVA_HOME=/usr/local/jdk1.7.0_71<br>    CLASSPATH=.:$JAVA_HOME/lib.tools.jar<br>    PATH=$JAVA_HOME/bin:$PATH<br>    export JAVA_HOME CLASSPATH PATH</p>
</blockquote>
<p>6）重新加载/etc/profile配置文件 source /etc/profile</p>
<h4 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h4><p>必选要先安装jdk<br>1）上传Tomcat到linux上<br>2）解压Tomcat到/usr/local下<br>3.cd 到/usr/local下，将apache-tomcat-7.0.57改名成tomcat，为了方便，可自定义名<br>mv apache-tomcat-7.0.57 tomcat<br>4.开放Linux的对外访问的端口8080<br>/sbin/iptables -I INPUT -p tcp –dport 8080 -j ACCEPT<br>/etc/rc.d/init.d/iptables save 关闭防火墙，这里不成功没关系，我的没成功但是可以正常运行<br>5）启动关闭Tomcat<br>进入tomcat的bin下启动：./startup.sh<br>进入tomcat的bin下关闭：./shutdown.sh</p>
<h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><p>1 sudo apt-get install mysql-server<br>运行完这句命令后，不是root的话会要你输入root密码，密码输入正确后，系统就自动给你下载MySQL了<br>2.授权用户，并允许远程登录<br>mysql -u root -p<br>系统会要你输入密码，密码输入无误后，进入MySQL<br>远程登录mysql的权限<br>登录mysql后输入如下命令：<br>grant all privileges on <em>.</em> to ‘账户名称’ @’%’ identified by ‘密码’;<br>然后更新数据库<br>flush privileges;<br>用管理员权限编辑一下文件<br>sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf<br>添加’#’注释掉其中的”bind-address = 127.0.0.1”<br>注释后:wq保存，重启MySQL服务：<br>service mysql restart<br>但是这里仍然不能远程连接，后来找到了解决办法<br>更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”:<br>切换数据库,<br>mysql&gt;use mysql;<br>查看root账号的登录权限,<br>mysql&gt;select host, user from user;<br>修改登录权限<br>mysql&gt;update user set host = ‘%’ where user = ‘root’;<br>刷新,生效,最后一步,至关重要<br>mysql&gt;flush   privileges;</p>
<p>最后解决了</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>有时候别人的步骤不一定适合你，造成很多时候都需要自己去踩坑，去探索。</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux命令小结]]></title>
      <url>http://www.myzwl.win/2017/11/02/linux_1/</url>
      <content type="html"><![CDATA[<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><img src="/images/imgs5/5.jpg" alt="Alt text"></p>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>cd 进入某个目录。 如cd use<br>cd ../    切换到上一层目录<br>cd /    切换到系统根目录<br>cd ~    切换到用户主目录<br>cd -    切换到上一个所在目录</p>
<h4 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h4><p>mkdir 创建文件夹<br>rmdir 删除文件夹 文件夹有内容时不可删</p>
<h4 id="查看目录"><a href="#查看目录" class="headerlink" title="查看目录"></a>查看目录</h4><p>ls 看到该目录下的所有的目录和文件<br>ls -a 可以看到该目录下的所有文件和目录，包括隐藏的<br>ls -l或者ll或者ls -alh 可以看到该目录下的所有目录和文件的详细信息<br>ls z* 显示所有文件名以z开头的文件<br>ls z? 显示文件名只有两个字母且第一个字符为z的文件<br>ls &gt;2.txt 重定向 将ls的内容显示在2.txt中<br>ls &gt;&gt;2.txt 将ls的内容追加在2.txt中</p>
<h4 id="寻找目录"><a href="#寻找目录" class="headerlink" title="寻找目录"></a>寻找目录</h4><p>find ./ -name ‘zw*’ 显示当前目录下文件名以zw的开头的文件</p>
<h4 id="修改目录的名称"><a href="#修改目录的名称" class="headerlink" title="修改目录的名称"></a>修改目录的名称</h4><p>mv 目录名称 新目录名称<br>如 mv zwl zwlzwl<br>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进重命名的操作</p>
<h4 id="移动目录的位置—剪切"><a href="#移动目录的位置—剪切" class="headerlink" title="移动目录的位置—剪切"></a>移动目录的位置—剪切</h4><p>mv 目录名称 目录的新位置<br>如 mv 1.txt ../<br>注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</p>
<h4 id="拷贝与删除目录"><a href="#拷贝与删除目录" class="headerlink" title="拷贝与删除目录"></a>拷贝与删除目录</h4><p>cp 复制文件，格式：cp 源文件 目标文件<br>rm 删除文件 （rm 文件夹 -r 递归删除文件夹内所有内容，并删除文件夹）<br>强制删除，使用rm -rf newTest</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>touch 1.txt 创建1.txt文件<br>cat 1.txt 查看1.txt里的内容<br>more 1.txt 1.txt内容过多时，分页显示<br>less 1.txt，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看<br>tail -10 1.txt 查看后10行，Ctrl+C结束</p>
<h4 id="解压打包"><a href="#解压打包" class="headerlink" title="解压打包"></a>解压打包</h4><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。<br>命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件<br>tar -zcvf xxx.tar.gz aaa.txt bbb.txt ccc.txt<br>或：tar -zcvf xxx.tar.gz /test/*<br>解压压缩包<br>tar -zxvf FileName.tar.gz 压缩到本目录<br>tar -zxvf xxx.tar.gz -C /usr——C代表指定解压的位置</p>
<h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><p>pwd 显示当前所在位置<br>grep 要搜索的字符串 要搜索的文件 –color（搜索命令）<br>ps -ef 查看当前系统中运行的进程<br>kill -9 进程的pid 强制杀死某进程<br>命令：|   将前一个命令的输出作为本次目录的输入<br>如 ps -ef | grep system 查看当前系统中所有的进程中包括system字符串的进程<br>ifconfig  查看当前系统的网卡信息<br>ping 查看与某台机器的连接情况<br>netstat -an 查看当前系统的端口使用</p>
<h4 id="Linux的权限命令"><a href="#Linux的权限命令" class="headerlink" title="Linux的权限命令"></a>Linux的权限命令</h4><p>之前用ll的命令可以查看文件的详细信息<br><img src="/images/imgs5/6.jpg" alt="Alt text"><br>d：代表目录<br>-：代表文件<br>l：代表链接（可以认为是window中的快捷方式）<br>后面的9位分为3组，每3位置一组，分别代表属主的权限，与当前用户同组的    用户的权限，其他用户的权限<br>r：代表权限是可读，r也可以用数字4表示<br>w：代表权限是可写，w也可以用数字2表示<br>x：代表权限是可执行，x也可以用数字1表示<br><img src="/images/imgs5/7.jpg" alt="Alt text"><br>修改文件/目录的权限的命令：chmod<br>chmod u=rwx，g=rw，o=r 1.txt<br>或者 chmod 764 2.txt</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈lucene]]></title>
      <url>http://www.myzwl.win/2017/11/01/lucene_1/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不知不觉，从九月份后就已经很少写博总结了，有点小颓废了。好吧，回到正题，本着应用为主，了解原理为辅的原则总结。<br>以我的微型论坛中的文章内容检索为例作为应用<a href="http://www.slycmiaoxi.xyz" target="_blank" rel="external">网站链接</a></p>
<h4 id="全文检索定义"><a href="#全文检索定义" class="headerlink" title="全文检索定义"></a>全文检索定义</h4><p>全文检索首先对要搜索的文档进行分词，然后形成索引，通过查询索引来查询文档，比如：字典<br>字典的偏旁部首页，就类似于luence的索引<br>字典的具体内容，就类似于luence的文档内容<br>同时，Lucene是一个工具包，它不能独立运行，不能单独对外提供服务。说白了，就是几个jar包</p>
<h4 id="Lucene实现全文检索的流程"><a href="#Lucene实现全文检索的流程" class="headerlink" title="Lucene实现全文检索的流程"></a>Lucene实现全文检索的流程</h4><p><img src="/images/imgs5/1.jpg" alt="Alt text"><br>其主要分为索引流程和搜索流程<br>索引流程：采集数据—文档处理-存储到索引库中<br>搜索流程：输入查询条件—通过lucene的查询器查询索引—从索引库中取出结果</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>需求：对进入论坛的所有文章进行全文检索<br>首先我们利用jdbc采集数据库，为了方便直接利用中文查询器，只贴出核心代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public interface LuceneService &#123;</div><div class="line">	    //初始化采集本地数据</div><div class="line">		public void getIndex() throws Exception;</div><div class="line">		//增加一个term到本地数据</div><div class="line">		public void addIndex(Comment bc)  throws Exception ;</div><div class="line">		//删除一个term</div><div class="line">		public void deleteIndex(String blogId) throws Exception;</div><div class="line">		//更新本地数据</div><div class="line">		public void updateIndex(Blogcomment bc) throws Exception;</div><div class="line">		//根据条件查询数据		</div><div class="line">		public List&lt;Comment&gt; findAllIndex(String q)throws Exception;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 评论实体类</div><div class="line"> * @author zwl</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class Comment &#123;</div><div class="line">	</div><div class="line">    private Date commentDate;</div><div class="line">    </div><div class="line">	private String content;</div><div class="line">	</div><div class="line">	private int id;</div><div class="line">	</div><div class="line">	private String title;</div><div class="line">	</div><div class="line">	private String userIp;</div><div class="line">	</div><div class="line">	private String username;</div><div class="line">	</div><div class="line">	private int hasread;    //访问量</div><div class="line">	</div><div class="line">	private int state;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是其实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div></pre></td><td class="code"><pre><div class="line">@Service("luceneService")</div><div class="line">public class LuceneServiceImpl implements LuceneService &#123;</div><div class="line"></div><div class="line">	@Resource</div><div class="line">	private CommentMapper commentMapper;</div><div class="line">	</div><div class="line">	private Directory dir;</div><div class="line">	</div><div class="line">	//得到索引维护核心对象</div><div class="line">	private IndexWriter getWriter() throws Exception &#123;</div><div class="line">		File indexFile = new File("C:\\lucene\\");</div><div class="line">		Directory d=FSDirectory.open(indexFile);</div><div class="line">		 Analyzer analyzer =new IKAnalyzer();</div><div class="line">		 IndexWriterConfig conf=new IndexWriterConfig(Version.LUCENE_4_9_1, analyzer);</div><div class="line">			IndexWriter write=new IndexWriter(d, conf);</div><div class="line">			return write;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">	public void addIndex(Comment bc)  throws Exception &#123;</div><div class="line">		IndexWriter write=getWriter();</div><div class="line">		Document document=new Document();</div><div class="line">		</div><div class="line">		// store:如果是yes，则说明存储到文档域中</div><div class="line">		Field id=new TextField("id",String.valueOf(bc.getId()), Store.YES);</div><div class="line">		Field username=new TextField("username",bc.getUsername(),Store.YES);</div><div class="line">		Field blogCommentDate=new TextField("commentDate",bc.getCommentDate().toLocaleString(),Store.YES);</div><div class="line">		Field content=new TextField("content",bc.getContent(),Store.YES);</div><div class="line">		Field title=new TextField("title",bc.getTitle(),Store.YES);</div><div class="line">		Field hasread=new TextField("hasread",bc.getHasread()+"",Store.YES);</div><div class="line">		Field state=new TextField("state",bc.getState()+"",Store.YES);	</div><div class="line">	             </div><div class="line">     // 将field域设置到Document对象中</div><div class="line">		document.add(id);</div><div class="line">		document.add(username);</div><div class="line">		document.add(blogCommentDate);</div><div class="line">		document.add(content);</div><div class="line">		document.add(title);</div><div class="line">		document.add(hasread);</div><div class="line">		document.add(state);</div><div class="line">					</div><div class="line">					write.addDocument(document);</div><div class="line">	             write.close();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public List&lt;Comment&gt; findAllIndex(String q)throws Exception&#123;</div><div class="line">		File indexFile = new File("C:\\lucene\\");</div><div class="line">		dir=FSDirectory.open(indexFile);</div><div class="line">		IndexReader reader = DirectoryReader.open(dir);</div><div class="line">		IndexSearcher searcher = new IndexSearcher(reader);</div><div class="line">		QueryParser parser = new QueryParser("content",</div><div class="line">				 new IKAnalyzer());</div><div class="line">		Query query = parser.parse(q);</div><div class="line">		TopDocs topDocs = searcher.search(query, 5);</div><div class="line">		List&lt;Comment&gt; list=new ArrayList&lt;Comment&gt;();</div><div class="line">		Comment cc=null;</div><div class="line">		// 根据查询条件匹配出的记录总数</div><div class="line">		int count = topDocs.totalHits;</div><div class="line">		System.out.println("匹配出的记录总数:" + count);</div><div class="line">		// 根据查询条件匹配出的记录</div><div class="line">		ScoreDoc[] scoreDocs = topDocs.scoreDocs;</div><div class="line">		for (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">			// 获取文档的ID</div><div class="line">			int docId = scoreDoc.doc;</div><div class="line">			// 通过ID获取文档</div><div class="line">			Document doc = searcher.doc(docId);</div><div class="line">			cc=new Comment();</div><div class="line">			cc.setId(Integer.parseInt(doc.get("id")));</div><div class="line">			cc.setUsername( doc.get("username"));</div><div class="line">			cc.setTitle(doc.get("title"));</div><div class="line">			cc.setCommentDate(DateUtil.formatString(doc.get("commentDate"),"yyyy-MM-dd HH:mm"));</div><div class="line">			cc.setHasread(Integer.parseInt(doc.get("hasread")));	 </div><div class="line">		    cc.setContent(doc.get("content"));</div><div class="line">		    list.add(cc);</div><div class="line">		&#125;</div><div class="line">		// 关闭资源</div><div class="line">		reader.close();</div><div class="line">	return list;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//删除指定博客的索引</div><div class="line">			public void deleteIndex(String blogId) throws Exception &#123;</div><div class="line">				IndexWriter write=getWriter();</div><div class="line">				write.deleteDocuments(new Term("id",blogId));</div><div class="line">				write.commit();</div><div class="line">				write.close();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			//更新博客索引</div><div class="line">			public void updateIndex(Blogcomment bc) throws Exception &#123;</div><div class="line">				IndexWriter write=getWriter();</div><div class="line">				Document document=new Document();</div><div class="line">				</div><div class="line">				// store:如果是yes，则说明存储到文档域中</div><div class="line">							Field id=new TextField("id",String.valueOf(bc.getId()), Store.YES);</div><div class="line">							Field username=new TextField("username",bc.getUsername(),Store.YES);</div><div class="line">							Field blogCommentDate=new TextField("blogCommentDate",bc.getBlogCommentDate().toLocaleString(),Store.YES);</div><div class="line">							Field comments=new TextField("comments",bc.getComments(),Store.YES);</div><div class="line">							Field title=new TextField("title",bc.getComment().getTitle(),Store.YES);</div><div class="line">							Field hasread=new TextField("hasread",bc.getComment().getHasread()+"",Store.YES);</div><div class="line">							Field cid=new TextField("cid",bc.getComment().getId()+"",Store.YES);	</div><div class="line">			             </div><div class="line">							// 将field域设置到Document对象中</div><div class="line">							document.add(id);</div><div class="line">							document.add(username);</div><div class="line">							document.add(blogCommentDate);</div><div class="line">							document.add(comments);</div><div class="line">							document.add(title);</div><div class="line">							document.add(hasread);</div><div class="line">							document.add(cid);</div><div class="line">							</div><div class="line">							write.updateDocument(new Term("id",bc.getId()+""), document);</div><div class="line">			               write.close();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">	//初始化采集本地数据</div><div class="line">	public void getIndex() throws Exception&#123;</div><div class="line">	</div><div class="line">		// 采集数据</div><div class="line">				List&lt;Comment&gt; list=commentMapper.readAll();</div><div class="line">				</div><div class="line">				// 将采集到的数据封装到Document对象中</div><div class="line">				List&lt;Document&gt; docList=new ArrayList&lt;Document&gt;();</div><div class="line">				Document document=null;</div><div class="line">				for(Comment bc:list)&#123;</div><div class="line">					document=new Document();</div><div class="line">					// store:如果是yes，则说明存储到文档域中</div><div class="line">					Field id=new TextField("id",String.valueOf(bc.getId()), Store.YES);</div><div class="line">					Field username=new TextField("username",bc.getUsername(),Store.YES);</div><div class="line">					Field blogCommentDate=new TextField("commentDate",bc.getCommentDate().toLocaleString(),Store.YES);</div><div class="line">					Field content=new TextField("content",bc.getContent(),Store.YES);</div><div class="line">					Field title=new TextField("title",bc.getTitle(),Store.YES);</div><div class="line">					Field hasread=new TextField("hasread",bc.getHasread()+"",Store.YES);</div><div class="line">					Field state=new TextField("state",bc.getState()+"",Store.YES);</div><div class="line">					</div><div class="line">					</div><div class="line">					// 将field域设置到Document对象中</div><div class="line">					document.add(id);</div><div class="line">					document.add(username);</div><div class="line">					document.add(blogCommentDate);</div><div class="line">					document.add(content);</div><div class="line">					document.add(title);</div><div class="line">					document.add(hasread);</div><div class="line">					document.add(state);</div><div class="line">					</div><div class="line">					docList.add(document);			</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				IndexWriter write=this.getWriter();</div><div class="line">				// 通过IndexWriter对象将Document写入到索引库中</div><div class="line">				for(Document doc:docList)&#123;</div><div class="line">					write.addDocument(doc);</div><div class="line">				&#125;</div><div class="line">				// 关闭writer</div><div class="line">				write.close();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="索引文件的逻辑结构"><a href="#索引文件的逻辑结构" class="headerlink" title="索引文件的逻辑结构"></a>索引文件的逻辑结构</h4><p><img src="/images/imgs5/2.jpg" alt="Alt text"><br>通过图示，可以发现最重要的就是文档域和索引域<br>文档域存储的信息就是采集到的信息，通过Document对象来存储，具体说是通过Document对象中field域来存储数据。<br>比如：数据库中一条记录会存储一个一个Document对象，数据库中一列会存储成Document中一个field域。<br>索引域主要是为了搜索使用的。索引域内容是经过lucene分词之后存储的（这里的分词根据所引入的分词器不同，分词效果不一样）<br>传统方法是先找到文件，如何在文件中找内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大就搜索慢<br>但是lucene采用倒排索引结构，它是在索引中匹配搜索关键字，由于索引内容量有限并且采用固定优化算法搜索速度很快，找到了索引中的词汇，词汇与文档关联，从而最终找到了文档。</p>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p><img src="/images/imgs5/3.jpg" alt="Alt text"><br>其中，IndexWriter是索引过程的核心组件，通过IndexWriter可以创建新索引、更新索引、删除索引操作。IndexWriter需要通过Directory对索引进行存储操作。<br>Directory描述了索引的存储位置，底层封装了I/O操作，负责对索引进行存储。它是一个抽象类，它的子类常用的包括FSDirectory（在文件系统存储索引）、RAMDirectory（在内存存储索引）。</p>
<h4 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h4><p>Lucene中分词主要分为两个步骤：分词、过滤<br>分词：将field域中的内容一个个的分词。<br>过滤：将分好的词进行过滤，比如去掉标点符号、大写转小写、词的型还原（复数转单数、过去式转成现在式）、停用词过滤<br>停用词：单独应用没有特殊意义的词。比如的、啊、等，英文中的this is a the等等。</p>
<h4 id="搜索流程"><a href="#搜索流程" class="headerlink" title="搜索流程"></a>搜索流程</h4><p><img src="/images/imgs5/4.jpg" alt="Alt text"><br>Field的属性，主要有三个<br>是否分词（Tokenized）<br>是：对该field存储的内容进行分词，分词的目的，就是为了索引。<br>是否索引（Indexed）<br>是：将分好的词进行索引，索引的目的，就是为了搜索<br>是否存储（Stored）<br>是：将field域中的内容存储到文档域中。存储的目的，就是为了搜索页面显示取值用的。</p>
<h4 id="创建查询对象的方式"><a href="#创建查询对象的方式" class="headerlink" title="创建查询对象的方式"></a>创建查询对象的方式</h4><p>通过QueryParser来创建查询对象（其他方式就不介绍了）<br>通过QueryParser来创建query对象，可以指定分词器，搜索时的分词器和创建该索引的分词器一定要一致。还可以输入查询语句。<br>查询语法<br>1、基础的查询语法，关键词查询：<br>域名+“：”+搜索的关键字<br>例如：content:java<br>2、范围查询<br>域名+“:”+[最小值 TO 最大值]<br>例如：size:[1 TO 1000]<br>3、组合条件查询<br>条件1 AND 条件2<br>条件1 OR 条件2<br>条件1 NOT 条件2</p>
<h4 id="TopDocs"><a href="#TopDocs" class="headerlink" title="TopDocs"></a>TopDocs</h4><p>Lucene搜索结果可通过TopDocs遍历<br>earch方法需要指定匹配记录数量n：indexSearcher.search(query, n)<br>TopDocs.totalHits：是匹配索引库中所有记录的数量<br>TopDocs.scoreDocs：匹配相关度高的前边记录数组，scoreDocs的长度小于等于search方法指定的参数n</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当然lucene的知识体系远不止这些，这里只是通过应用主导学习来浅尝全文检索。</p>
]]></content>
      
        <categories>
            
            <category> 全文检索 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 全文检索 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[丑数]]></title>
      <url>http://www.myzwl.win/2017/10/22/offer_44/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>由丑数的定义知道丑数只有以上三个因子，所以在排序的丑数列表中，后面的某个丑数一定是前面某个丑数乘以2或3或5的结果，所以我们以这三个因子的到的丑数进行排序，把最小的丑数更新到丑数列表中，如果刚好是丑数中的最小值，则把该数对应的下标加1，然后继续寻找下一个丑数</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public int GetUglyNumber_Solution(int index) &#123;</div><div class="line">       if(index&lt;=0)return 0;</div><div class="line">       int[] ugly=new int[index];</div><div class="line">       ugly[0]=1;</div><div class="line">       int count=1;</div><div class="line">       int num2=0;</div><div class="line">       int num3=0;</div><div class="line">       int num5=0;</div><div class="line">       while(count&lt;index)&#123;</div><div class="line">           int min=IsUglyNumber(ugly[num2]*2,ugly[num3]*3,ugly[num5]*5);</div><div class="line">           ugly[count]=min;</div><div class="line">           count++;</div><div class="line">           if(min==ugly[num2]*2)</div><div class="line">               num2++;</div><div class="line">           if(min==ugly[num3]*3)</div><div class="line">               num3++;</div><div class="line">           if(min==ugly[num5]*5)</div><div class="line">               num5++;</div><div class="line">       &#125;    </div><div class="line">       return ugly[index-1];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private int IsUglyNumber(int num2,int num3,int num5)&#123;</div><div class="line">       int min=num2&lt;num3?num2:num3;</div><div class="line">       return min&lt;num5?min:num5;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[左旋转字符串]]></title>
      <url>http://www.myzwl.win/2017/10/21/offer_43/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>我的想法是构造两个字符数组，一个用来保存要移位的字符集，另一个是不移位的字符，最后将其按照顺序保存在一个新的字符数组中即可</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public String LeftRotateString(String str,int n) &#123;</div><div class="line">      if(str==null||str.equals("")||n&gt;str.length())</div><div class="line">          return "";</div><div class="line">      if(n==0)</div><div class="line">          return str;</div><div class="line">          char[] s1=new char[n];</div><div class="line">      char[] s2=new char[str.length()-n];</div><div class="line">      char[] s3=str.toCharArray();</div><div class="line">      for(int i=0;i&lt;str.length();i++)&#123;</div><div class="line">          if(i&gt;=0&amp;&amp;i&lt;n)</div><div class="line">              s1[i]=s3[i];</div><div class="line">          else</div><div class="line">              s2[i-n]=s3[i];</div><div class="line">      &#125;</div><div class="line">      StringBuffer sb=new StringBuffer(str.length());</div><div class="line">      for(int i=0;i&lt;s2.length;i++)</div><div class="line">          sb.append(s2[i]);</div><div class="line">      for(int i=0;i&lt;s1.length;i++)</div><div class="line">          sb.append(s1[i]);</div><div class="line">      return sb.toString();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[翻转单词顺序列]]></title>
      <url>http://www.myzwl.win/2017/10/20/offer_42/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>关于这个题目，有很多种解法，其中一个解法是利用倒序，即从数组的最后一个数开始依次加入到stringBuffer中即可</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public String ReverseSentence(String str) &#123;</div><div class="line">       if(str == null)&#123; return null;&#125;</div><div class="line">        if(str.trim().equals(""))&#123;</div><div class="line">           return str;</div><div class="line">       &#125;</div><div class="line">           String[] s=str.split(" ");</div><div class="line">       StringBuffer sb=new StringBuffer(s.length);</div><div class="line">       for(int i=s.length-1;i&gt;=0;i--)&#123;</div><div class="line">           if(i!=0)</div><div class="line">           sb.append(s[i]+" ");</div><div class="line">           else</div><div class="line">               sb.append(s[i]);</div><div class="line">       &#125;</div><div class="line">       return sb.toString();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扑克牌顺子]]></title>
      <url>http://www.myzwl.win/2017/10/19/offer_41/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>先将大小王约定为0，可以补充任何相差的数字，然后进行排序并且统计出其中0的个数，然后对后面的数进行判断，如果相邻数字小于0的个数，是可以填补的，然后在减少0的个数，依次比较，直到最后连续</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public boolean isContinuous(int [] numbers) &#123;</div><div class="line">         if(numbers==null)</div><div class="line">             return false;</div><div class="line">       Arrays.sort(numbers);</div><div class="line">       int i=0,zero=0;</div><div class="line">       for(;i&lt;numbers.length&amp;&amp;numbers[i]==0;i++)</div><div class="line">           zero++;</div><div class="line">       for(;i&lt;numbers.length-1&amp;&amp;zero&gt;=0;i++)&#123;</div><div class="line">           if(numbers[i]==numbers[i+1])</div><div class="line">               return false;</div><div class="line">           if(numbers[i]+1+zero&gt;=numbers[i+1])&#123;</div><div class="line">               zero-=numbers[i+1]-numbers[i]-1;</div><div class="line">           &#125;</div><div class="line">           else</div><div class="line">               return false;</div><div class="line">       &#125;</div><div class="line">       if(i==numbers.length -1)</div><div class="line">           return true;</div><div class="line">       else</div><div class="line">           return false;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[求1+2+3+...+n]]></title>
      <url>http://www.myzwl.win/2017/10/18/offer_40/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>根据题目的约束，只能使用递归操作了。当n递归到最小值1时结束，并且每次递归调用一次，值就减少1，直至n为1为止</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private int result=0;</div><div class="line">    public int Sum_Solution(int n) &#123;</div><div class="line">        cale(n);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private boolean cale(int n)&#123;</div><div class="line">        result+=n;</div><div class="line">        return n!=0&amp;&amp;cale(n-1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[不用加减乘除做加法]]></title>
      <url>http://www.myzwl.win/2017/10/17/offer_39/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>核心思想是采用位运算，主要分为三步，比如5（101）+17（10001），第一步各位相加但不进位，得10100，第二部记下进位，的10，最后一步把前两部相加，得22（10110），根据异或和与逻辑与的运算规则，很容易知道第一步符合异或规则，第二部先与在左移一位进位即可</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public int Add(int num1,int num2) &#123;</div><div class="line">       int sum,carry;</div><div class="line">       do&#123;</div><div class="line">           sum=num1^num2;</div><div class="line">           carry=(num1&amp;num2)&lt;&lt;1;</div><div class="line">           num1=sum;</div><div class="line">           num2=carry;</div><div class="line">       &#125;while(num2!=0);</div><div class="line">       return num1;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数组中重复的数字]]></title>
      <url>http://www.myzwl.win/2017/10/16/offer_38/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>核心思想可以相对整个数组进行排序，这样如果相邻元素一样说明是重复的，只要遍历整个数组，找到第一个相同的就找到了第一个重复的数字</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public boolean duplicate(int numbers[],int length,int [] duplication) &#123;</div><div class="line">        if(length==0||numbers==null)</div><div class="line">        &#123;</div><div class="line">            duplication[0]=-1;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">           Arrays.sort(numbers);</div><div class="line">           for(int i=0;i&lt;numbers.length-1;i++)&#123;</div><div class="line">               if(numbers[i]==numbers[i+1])</div><div class="line">               &#123;</div><div class="line">                   duplication[0]=numbers[i];</div><div class="line">                   return true;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[正则表达式匹配]]></title>
      <url>http://www.myzwl.win/2017/10/15/offer_37/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>先考虑模式串中有’<em>‘的情况，因为</em>可以匹配0个或多个，所以如果模式串的下一个字符是<em>的时候就有三种情况<br>1.匹配0个主串的字符，比如主串是abc，模式串是b</em>，那么下一步匹配的策略是主串保持不变，模式串跳到下两个字符重新比较，<br>2.匹配1个字符，比如主串是abc，模式串是a<em>，下一步比较策略是主串跳到下一个字符，模式串移动两个字符<br>3.匹配多个字符，比如主串aac，模式串是a</em>cb，因为只匹配aa两个字符，下一步策略是主串移动一个字符，模式串移动两个字符，如果当前字符与主串字符不能匹配，则主串不变，模式串移动两个位置<br>如果当前字符是’.’，直接按逐个字符进行比较</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public boolean match(char[] str,char[] pattern)&#123;</div><div class="line">    if(str==null||pattern==null)</div><div class="line">      return false;</div><div class="line">    return matchRegCore(str,0,str.length,pattern,0,pattern.length);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  private boolean matchRegCore(char[] str,int i,int length1,char[] pattern,int j,int length2)&#123;</div><div class="line">    if(i==length1&amp;&amp;j==length2)&#123;</div><div class="line">      if(j==length2||pattern[j]=='*')</div><div class="line">        return true;</div><div class="line">      else</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    if(i!=length1&amp;&amp;j==length2)</div><div class="line">      return false;</div><div class="line">    if(j+1&lt;length2&amp;&amp;pattern[j+1]=='*')&#123;</div><div class="line">      if(i&lt;length1&amp;&amp;(pattern[j]==str[i]||pattern[j]=='.'))&#123;</div><div class="line">        return matchRegCore(str,i+1,length1,pattern,j,length2)||</div><div class="line">            matchRegCore(str,i+1,length1,pattern,j+2,length2)||</div><div class="line">            matchRegCore(str,i,length1,pattern,j+2,length2);</div><div class="line">      &#125;else&#123;</div><div class="line">        return matchRegCore(str,i,length1,pattern,j+2,length2);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    if(i&lt;length1&amp;&amp;(str[i]==pattern[j]||pattern[j]=='.'))&#123;</div><div class="line">      return matchRegCore(str,i+1,length1,pattern,j+1,length2);</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[表示数值的字符串]]></title>
      <url>http://www.myzwl.win/2017/10/14/offer_36/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>核心思路就是分情况讨论，主要分为三类：整数、浮点数和科学计数法。<br>对于整数的判断，就是字符串中没有出现非0到9的字符即可，否则返回错误<br>对于浮点数，只要考虑整数后面出现一个小数点，而后面的判断与整数相同，<br>对于科学计数法，就是e和E后其后面的字符串与整数一样，同时如果后面没有数字是不被允许的</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public boolean isNumeric(char[] str) &#123;</div><div class="line">        if(str==null||str.length==0)return false;</div><div class="line">        int index=0;</div><div class="line">        int length=str.length;</div><div class="line">        while(index&lt;length&amp;&amp;str[index]==' ')index++;</div><div class="line">        if(index&gt;=length)return false;</div><div class="line">        while(str[length-1]==' ')length--;</div><div class="line">        if(str[index]=='+'||str[index]=='-')index++;</div><div class="line">        if(index&gt;=length)return false;</div><div class="line">        </div><div class="line">        while(index&lt;length&amp;&amp;str[index]&gt;='0'&amp;&amp;str[index]&lt;='9')index++;</div><div class="line">        if(index==length) return true;</div><div class="line">        int index2=index;</div><div class="line">        </div><div class="line">        if(str[index]=='.')&#123;</div><div class="line">          index++;</div><div class="line">          if(index==length)return true;</div><div class="line">          index2=index;</div><div class="line">          while(index&lt;length&amp;&amp;str[index]&gt;='0'&amp;&amp;str[index]&lt;='9')index++;</div><div class="line">          if(index==index2) return false;</div><div class="line">          if(index==length) return true;</div><div class="line">        &#125;</div><div class="line">       </div><div class="line">        if(str[index]=='e'||str[index]=='E')&#123;</div><div class="line">          index++;</div><div class="line">          if(index==length)return false;</div><div class="line">          if(str[index]=='+'||str[index]=='-')index++;</div><div class="line">          index2=index;</div><div class="line">          while(index&lt;length&amp;&amp;str[index]&gt;='0'&amp;&amp;str[index]&lt;='9')index++;</div><div class="line">          if(index==index2) return false;</div><div class="line">          if(index==length) return true;</div><div class="line">        &#125;</div><div class="line">          return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字符流中第一个不重复的字符]]></title>
      <url>http://www.myzwl.win/2017/10/13/offer_35/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>核心思想就是创建一个map用来记录每个字符出现的次数，而list则记录只出现一次的字符集合，遍历字符，如果map中不存在说明是第一次，则把字符作为key加入，然后在放到list中，如果map中包含了该键，一方面记录该字符次数，另一方面看list中是否包含该元素，在删除，最后list中只保留出现一次的字符</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.List;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">private Map&lt;Character, Integer&gt; map=new HashMap&lt;Character, Integer&gt;();</div><div class="line">  private List&lt;Character&gt; list=new ArrayList&lt;Character&gt;();</div><div class="line">  </div><div class="line">  //Insert one char from stringstream</div><div class="line">  public void Insert(char ch)</div><div class="line">  &#123;</div><div class="line">      if(!map.containsKey(ch))&#123;</div><div class="line">          map.put(ch, 1);</div><div class="line">          list.add(ch);</div><div class="line">      &#125;else&#123;</div><div class="line">          map.put(ch, map.get(ch)+1);</div><div class="line">          if(list.contains(ch))</div><div class="line">              list.remove(Character.valueOf(ch));</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">  &#125;</div><div class="line">//return the first appearence once char in current stringstream</div><div class="line">  public char FirstAppearingOnce()</div><div class="line">  &#123;</div><div class="line">  if(list.isEmpty())return '#';</div><div class="line">  return list.get(0);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数组中只出现一次的数字]]></title>
      <url>http://www.myzwl.win/2017/10/12/offer_34/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>核心思想就是如果数组中元素是第一次出现，则加入集合中，继续往后遍历，如果包含该元素，则删除那个元素，最后通过筛选只剩下出现一次的元素了</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//num1,num2分别为长度为1的数组。传出参数</div><div class="line">//将num1[0],num2[0]设置为返回结果</div><div class="line">import java.util.List;</div><div class="line">import java.util.ArrayList;</div><div class="line">public class Solution &#123;</div><div class="line">   public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123;</div><div class="line">          ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();</div><div class="line">        for(int i=0;i&lt;array.length;i++)&#123;</div><div class="line">            if(list.contains(array[i]))&#123;</div><div class="line">                list.remove((Integer)array[i]);</div><div class="line">            &#125;else&#123;</div><div class="line">                list.add(array[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        num1[0]=list.get(0);</div><div class="line">        num2[0]=list.get(1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[和为S的两个数字]]></title>
      <url>http://www.myzwl.win/2017/10/11/offer_33/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>核心思想就是设置两个变量，起始变量start和指向尾的变量end，刚开始先比较和cur=start+end与s的和，如果比s大说明最后的end数较大，end应前移，直至小于等于，反之则是start较小，start应后移。直至最后等于为止，此时因为end处于最大的情况，所以start处于最小，也是所要找的两个数。但是如果不存在，则返回空</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123;</div><div class="line">        ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();</div><div class="line">         ArrayList&lt;Integer&gt; lists=new ArrayList&lt;Integer&gt;();</div><div class="line">        if(array==null||sum&lt;=0) return list;</div><div class="line">        int start=0;</div><div class="line">        int end=array.length-1;</div><div class="line">        int curSum=array[start]+array[end];</div><div class="line">        while(start&lt;end)&#123;</div><div class="line">            if(curSum==sum)&#123;</div><div class="line">                    list.add(array[start]);</div><div class="line">                    list.add(array[end]);</div><div class="line">                &#125;</div><div class="line">            while(curSum&gt;sum)&#123;</div><div class="line">                end--;</div><div class="line">                 curSum=array[start]+array[end];</div><div class="line">                if(curSum==sum)&#123;</div><div class="line">                    list.add(array[start]);</div><div class="line">                    list.add(array[end]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            start++;  </div><div class="line">            curSum=array[start]+array[end];</div><div class="line">        &#125;</div><div class="line">        if(list.size()==0)return list;</div><div class="line">        lists.add(list.get(0));</div><div class="line">        lists.add(list.get(1));</div><div class="line">        return lists;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[和为S的连续正数序列]]></title>
      <url>http://www.myzwl.win/2017/10/10/offer_32/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>核心思想就是通过两个变量small（最小值）和big（最大值）来控制，比如s为12，起始samll为1，big为2，和为3小于12，说明big需要后移一位，此时为{1,2,3}为6，小于12，big在增大直至{1,2,3,4,5}为15大于12，说明最小值应该后移，所以为{2,3,4,5}，继续后移{3,4,5}满足，找到了，思路大致就是这样，但是small移动时不能超过（sum+1）/2，也就是平均值，因为超过平均值后面肯定会大于s了</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123;</div><div class="line">      ArrayList&lt;ArrayList&lt;Integer&gt;&gt; sqList=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">       if(sum&lt;3)return sqList;</div><div class="line">       int small=1;</div><div class="line">       int big=2;</div><div class="line">       int curSum=small+big;</div><div class="line">       int middle=(1+sum)/2;</div><div class="line">       while(small&lt;middle)&#123;</div><div class="line">           ArrayList&lt;Integer&gt; sq=new ArrayList&lt;Integer&gt;();</div><div class="line">          if(curSum==sum)&#123;</div><div class="line">               for(int i=small;i&lt;=big;i++)</div><div class="line">                   sq.add(i);</div><div class="line">           &#125;</div><div class="line">           while(curSum&gt;sum&amp;&amp;small&lt;middle)&#123;</div><div class="line">               curSum-=small;</div><div class="line">               small++;</div><div class="line">               if(curSum==sum)&#123;</div><div class="line">               for(int i=small;i&lt;=big;i++)</div><div class="line">                   sq.add(i);</div><div class="line">           &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       if(sq.size()&gt;0)sqList.add(sq);</div><div class="line">       big++;</div><div class="line">       curSum+=big;</div><div class="line">       &#125;</div><div class="line">       return sqList;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数字在排序数组中出现的次数]]></title>
      <url>http://www.myzwl.win/2017/10/09/offer_31/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>统计一个数字在排序数组中出现的次数。</p>
<h4 id="思路分析-解法一"><a href="#思路分析-解法一" class="headerlink" title="思路分析(解法一)"></a>思路分析(解法一)</h4><p>最直观的想法就是通过顺序查找，即依次比较数组与给定元素大小，然后设置一个计数变量，又由于数组是排序的，所以直接当比较的数大于给定数时，结束</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int GetNumberOfK(int [] array , int k) &#123;</div><div class="line">         if(array==null)return 0;</div><div class="line">         int count=0;</div><div class="line">         for(int i=0;i&lt;array.length;i++)&#123;</div><div class="line">           if(array[i]==k)&#123;</div><div class="line">             count++;</div><div class="line">           &#125;</div><div class="line">           if(array[i]&gt;k)</div><div class="line">             return count;</div><div class="line">         &#125;</div><div class="line">         return count;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="思路分析-解法二"><a href="#思路分析-解法二" class="headerlink" title="思路分析(解法二)"></a>思路分析(解法二)</h4><p>由于是已排序的，所以查找最好的就是通过二分查找，即先找出第一次出现和最后一次出现该数即可，但是由于当我们找到该数时，比如第一次找到该数时，先比较在他前面是否有重复该数，如果是，这说明据需向前面比较，知道找到第一次出现该数，同理，最后一次出现该数也是比较后面是否有该数重复</p>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public int GetNumberOfK(int [] array , int k) &#123;</div><div class="line">    int length = array.length;</div><div class="line">         if(length == 0)&#123;</div><div class="line">             return 0;</div><div class="line">         &#125;</div><div class="line">         int firstK = getFirstK(array, k, 0, length-1);</div><div class="line">         int lastK = getLastK(array, k, 0, length-1);</div><div class="line">         if(firstK != -1 &amp;&amp; lastK != -1)&#123;</div><div class="line">              return lastK - firstK + 1;</div><div class="line">         &#125;</div><div class="line">         return 0;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> private int getFirstK(int array[],int k,int start,int end)&#123;</div><div class="line">   if(start&gt;end)return -1;</div><div class="line">    int mid=(start+end)&gt;&gt;1;</div><div class="line">   if(array[mid]&gt;k)return getFirstK(array,k,start,mid-1);</div><div class="line">   else if(array[mid]&lt;k) return getFirstK(array,k,mid+1,end);</div><div class="line">       else if(mid-1 &gt;=0 &amp;&amp; array[mid-1] == k)&#123;</div><div class="line">           return getFirstK(array, k, start, mid-1);</div><div class="line">       &#125;</div><div class="line">   else return mid;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> private int getLastK(int array[],int k,int start,int end)&#123;</div><div class="line">       int length = array.length;</div><div class="line">   int mid=(start+end)&gt;&gt;1;</div><div class="line">   while(start&lt;=end)&#123;</div><div class="line">     if(array[mid]&lt;k)</div><div class="line">       start=mid+1;</div><div class="line">     else if(array[mid]&gt;k)</div><div class="line">       end=mid-1;</div><div class="line">           else if(mid+1 &lt; length &amp;&amp; array[mid+1] == k)&#123;</div><div class="line">               start = mid+1;</div><div class="line">           &#125;</div><div class="line">     else </div><div class="line">       return mid;</div><div class="line">     mid=(start+end)&gt;&gt;1;</div><div class="line">   &#125;</div><div class="line">   return -1;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[滑动窗口的最大值]]></title>
      <url>http://www.myzwl.win/2017/10/08/offer_30/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>我的想法是先设置一个变量k用来记录每个滑动窗口的起始位置，如第一个滑动窗口k=0；然后取出数组中相应滑动窗口大小的数组的最大值，目前用选择排序思想取出每个滑动窗口最大值，如第一个[2,3,4]最大值为4，然后通过循环条件k与size，当k+size大于数组长度，也就是遍历完所有滑动窗口，每次都将每个窗口最大值保存起来即可</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">public class Solution &#123;</div><div class="line">   public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size)</div><div class="line">    &#123;</div><div class="line">        ArrayList&lt;Integer&gt; array=new ArrayList&lt;Integer&gt;();</div><div class="line">        if(num==null||size&lt;=0)return array;</div><div class="line">        int len=num.length;</div><div class="line">        int k=0;</div><div class="line">       while(k+size&lt;=len)&#123;</div><div class="line">          array.add(maxInWindow(num,k,size));</div><div class="line">          k++;</div><div class="line">       &#125;</div><div class="line">   return array;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private int maxInWindow(int[] num,int k,int size)&#123;</div><div class="line">        int i=k;</div><div class="line">        int top=num[k];</div><div class="line">        for(;i&lt;k+size;i++)&#123;</div><div class="line">            if(num[i]&gt;top)</div><div class="line">                top=num[i];</div><div class="line">        &#125;</div><div class="line">            return top;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[魔法币_网易2018校招编程题]]></title>
      <url>http://www.myzwl.win/2017/09/17/face_9/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。<br>魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币<br>魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币<br>小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。<br>输入描述:<br>输入包括一行,包括一个正整数n(1 ≤ n ≤ 10^9),表示小易需要的魔法币数量。<br>输出描述:<br>输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符’1’和’2’。<br>输入例子1:<br>10<br>输出例子1:<br>122</p>
<h4 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h4><p>除了内存超出规定外，其余都符合算法要求<br><img src="/images/imgs4/34.jpg" alt="Alt text"><br>思路如下:</p>
<blockquote>
<p>1.先构造并初始化一个完全二叉树，如图所示<br>2.然后从左子树开始遍历二叉树，同时将遍历的结点放到一个集合中，并且将该集合也就是到该节点的路径放到另一个集合中，如果没有找到该节点，则向上（父节点）开始遍历，同时删掉向下遍历的结点和路径，然后右递归<br>3.找到指定结点后，对应也找到对应的结点路径，剩下就是观察发现，如果路径中结点的值为偶数（右子树）对应2，左子树对应1，放在一个可变字符串中<br>4.本地测试（不考虑内存消耗过大），ok</p>
</blockquote>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">public class Main&#123;</div><div class="line">    </div><div class="line">	  public static class TreeNode&#123;</div><div class="line">	        int val;</div><div class="line">	        TreeNode left;</div><div class="line">	        TreeNode right;</div><div class="line">	        </div><div class="line">	        public TreeNode(int val)&#123;</div><div class="line">	            this.val=val;</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	     </div><div class="line">    public static void main(String[] args) throws Exception&#123;</div><div class="line">        Main m=new Main();</div><div class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in ));</div><div class="line">       int n=Integer.parseInt(br.readLine());</div><div class="line">        String s=m.getpa(n,new ArrayList&lt;Integer&gt;(),new ArrayList&lt;List&lt;Integer&gt;&gt;());</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">     public String  getpa(int n,List&lt;Integer&gt;  nodes,List&lt;List&lt;Integer&gt;&gt; paths)&#123;</div><div class="line">          TreeNode root=new TreeNode(0);</div><div class="line">         if(n&lt;=0)return null;</div><div class="line">         paths=getPath(root,n,nodes,paths);      </div><div class="line">          List&lt;Integer&gt; target=paths.get(0);</div><div class="line">          StringBuilder s=new StringBuilder(); </div><div class="line">          target.remove(0);</div><div class="line">         for(Integer val:target)&#123;</div><div class="line">        	 if((val&amp;0x1)==0)    &#123;       	 </div><div class="line">                 s.append("2");             </div><div class="line">             &#125;</div><div class="line">              else&#123;            	</div><div class="line">                  s.append("1");</div><div class="line">              &#125;</div><div class="line">            </div><div class="line">         &#125;</div><div class="line">          return s.toString();</div><div class="line">      &#125;</div><div class="line">    </div><div class="line">    List&lt;List&lt;Integer&gt;&gt; getPath(TreeNode root,int n,List&lt;Integer&gt; nodes,List&lt;List&lt;Integer&gt;&gt; paths)&#123;</div><div class="line">          if(root==null)</div><div class="line">            return paths;</div><div class="line">              init(root,n);</div><div class="line">            nodes.add(root.val);</div><div class="line">         if(root.val==n)&#123;</div><div class="line">             List&lt;Integer&gt; temp=new ArrayList&lt;Integer&gt;();</div><div class="line">              for(Integer t:nodes)&#123;</div><div class="line">                  temp.add(t);</div><div class="line">              &#125;</div><div class="line">               paths.add(temp);           </div><div class="line">         &#125;</div><div class="line">        if(root.left!=null)</div><div class="line">            getPath(root.left,n,nodes,paths);</div><div class="line">        if(root.right!=null)</div><div class="line">            getPath(root.right,n,nodes,paths);        </div><div class="line">        Integer tt=nodes.remove(nodes.size()-1);</div><div class="line">         return paths;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    void init(TreeNode root,int n)&#123;</div><div class="line">        if(root==null)</div><div class="line">            return;</div><div class="line">        if(root.val&lt;n)</div><div class="line">            &#123;</div><div class="line">            if(2*root.val+1&lt;=n)</div><div class="line">                root.left=new TreeNode(2*root.val+1);</div><div class="line">            if(2*root.val+2&lt;=n)</div><div class="line">                root.right=new TreeNode(2*root.val+2);</div><div class="line">        &#125;</div><div class="line">        init(root.left,n);</div><div class="line">        init(root.right,n);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="奇偶倒退法"><a href="#奇偶倒退法" class="headerlink" title="奇偶倒退法"></a>奇偶倒退法</h4><p>核心思路就是从最后一个数，通过判断最后一个数是否是奇偶，来倒推，直至为0为止</p>
<blockquote>
<p>public class Main{<br>   public static void main(String[] args) {<br>        Scanner in = new Scanner(System.in);<br>        while (in.hasNext()) {<br>            int Count = in.nextInt();<br>            StringBuilder sb = new StringBuilder();<br>            while (Count &gt; 0) {<br>                if (Count % 2 == 0) {<br>                    Count = (Count - 2) / 2;<br>                    sb.append(“2”);<br>                } else {<br>                    Count = (Count - 1) / 2;<br>                    sb.append(“1”);<br>                }<br>            }<br>            System.out.println(sb.reverse().toString());<br>        }<br>    }<br>}</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 笔试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 校招笔试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的大学书单]]></title>
      <url>http://www.myzwl.win/2017/09/05/my_books/</url>
      <content type="html"><![CDATA[<h4 id="读书的看法"><a href="#读书的看法" class="headerlink" title="读书的看法"></a>读书的看法</h4><p>真正喜欢上编程是在16年初两次大学兼职之后，一次是去某工厂做了几天的生产流水线，另一次是在快递分拣员（太坑了，几百人抢十个位置）。这两次兼职让我认识到了自身的不足，也认识到了如果自己不努力没有什么优势，也只能干着苦力廉价的劳动。<br>也很感谢网上那些开源的免费的优秀视频，像严蔚敏、马士兵、韩顺平等，还有其他许许多多，只要有耐心，会发现网上还是有许多开源的视频能帮助自己。<br>当你回过头来发现，读书能让自己学到许多，也是提升技术能力的一个重要手段。虽然看一些技术博客和视频能有帮助，但是发现自己的技术提高并没有实质性进步，原因就是缺乏系统性的阐述。<br>而学习最好的途径就是看书。<br>下面是我对读书的看法</p>
<blockquote>
<p>1 一本优秀的书籍是作者经过反复推敲、思考和总结的结果，它能系统的阐述技术并且拥有较高的质量，同时它能是我们对技术能有更全面的了解<br>2其次，书上也会在相应重要位置有相应的代码，所以可以边学习边实践<br>3.当我们在实际中遇到问题或者看到技术博客有相应的知识，会在书中有个更全面的认识<br>4.大师经典的书籍总是会把复杂的问题具体化和简单化，读他们的书就像在倾听他们勾勒的故事，就像倾听一个良师益友的经验之谈</p>
</blockquote>
<p><java编程思想第四版><br><img src="/images/imgs4/20.jpg" alt="Alt text"></java编程思想第四版></p>
<blockquote>
<p>作者： Bruce Eckel<br>标签： java基础<br>本书是一本非常经典的java基础书籍，本书主要介绍从java基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），同时在介绍的过程中，穿插着各种设计模式，总之，这本书是对于理解java基础非常有帮助和值得反反复复研读</p>
</blockquote>
<p>&lt;设计模式-java中的应用&gt;<br><img src="/images/imgs4/24.jpg" alt="Alt text"></p>
<blockquote>
<p>作者： 结城浩<br>标记： 设计模式<br>本书是书单中为数不多完整看完和实践的书，作者以浅显易懂的语言逐一说明了GoF的23个Design Pattern，让初次学习面向对象的读者也能立即掌握。作者以理论结合实际的思想从初学者角度阐述如何编写可复用、可扩展性的程序而且作者幽默的语言功底不得不让人佩服，总之，本书非常适合入门，而且还能收获许多</p>
</blockquote>
<p>&lt;大话数据结构&gt;<br><img src="/images/imgs4/21.jpg" alt="Alt text"></p>
<blockquote>
<p>作者：程杰<br>标记： 数据结构<br>本书是书单中为数不多完整看完和实践的书，作者以一个计算机教师教学为场景，讲解数据结构和相关算法的知识，通篇以一种趣味方式来叙述，大量引用了各种各样的生活知识来类比，并充分运用图形语言来体现抽象内容，对数据结构所涉及到的一些经典算法做到逐行分析、多算法比较。这里不得不佩服，作者将初学者引入从计算机角度去思考问题，看完之后的收获颇多，也对许多计算机底层有了进一步的认识。总之，这本书非常适合入门</p>
</blockquote>
<p><java与模式><br><img src="/images/imgs4/23.jpg" alt="Alt text"></java与模式></p>
<blockquote>
<p>作者：阎宏<br>标签： 设计模式<br>本书是我在对设计模式有了一定理解之后在看的。不得不说作者将设计模式介绍到了极致，全书详详细细的介绍了设计原则和设计模式，并就许多案例从设计角度多方位去思考并设计。总之，这是一本非常详细的关于设计模式的经典书籍</p>
</blockquote>
<p><spring实战><br><img src="/images/imgs4/27.jpg" alt="Alt text"></spring实战></p>
<blockquote>
<p>作者： Craig Walls<br>标签： spring<br>本书是一本讲解spring应用的经典书籍，目前也只看了前四章IOC和AOP，作者以勇者的故事贯穿这几章，看完之后对spring的这两个重要特性有了一个全新的认识。同时，概述非常适合作为学习指南参考书。总之，学习spring，读这本书非常有益</p>
</blockquote>
<p>&lt;剑指offer&gt;<br><img src="/images/imgs4/22.jpg" alt="Alt text"></p>
<blockquote>
<p>作者：何海涛<br>标签： 面试笔试<br>书中的65道面试题都很经典，刷完之后能对常见题型形成比较清晰的思路，而且对解决面试中的算法题有很好的帮助。也很惭愧，由于时间关系，只刷了一半的题。当然，如果认真对待每一个算法，你会发现对自己的编程有很大帮助，在你编码时，会有意识的从算法的角度去思考问题，同时考虑各种可能有隐患的情况。总之，对于算法思维的养成非常有帮助</p>
</blockquote>
<p>&lt;程序员的数学&gt;<br><img src="/images/imgs4/29.jpg" alt="Alt text"></p>
<blockquote>
<p>作者： 结城浩<br>标签： 数学与计算机<br>编程的基础是计算机科学，而计算机科学的基础是数学。本书保持作者一贯的作风，从初学者的角度去阐述问题。本书介绍了编程中常用的数学知识和一些经典的算法，慢慢的引导读者深入理解编程中的数学方法和思路，总之，结城浩先生的书总给人看完收获颇多</p>
</blockquote>
<p><java多线程设计模式><br><img src="/images/imgs4/25.jpg" alt="Alt text"></java多线程设计模式></p>
<blockquote>
<p>作者： 结城浩<br>标签： 多线程<br>本书从初学者角度介绍了java的多线程，同时包含了重要的12个线程设计模式和趣味的案例，同时，在看的过程中总是引导读者举一反三。也很惭愧，由于时间关系，只看了前几章。总之，这本书非常适合入门多线程。</p>
</blockquote>
<p>&lt;人月神话&gt;<br><img src="/images/imgs4/28.jpg" alt="Alt text"></p>
<blockquote>
<p>作者：布鲁克斯(Brooks, F. P.)<br>本书是一本在软件工程领域具有深远影响力和畅销不衰的经典著作。作者为人们管理复杂项目提供了具有洞察力的见解和各种管理经验。说来也惭愧，本书是在认真学习完&lt;软件工程&gt;这本书看的，由于时间的原因也只是浅尝了一下经典之作。但是这本书启发我们做工程类，一定要有软件工程的思想和全局观，而不能盲目的只重视编程这一阶段。而且按照软件工程的规范来，才能更好做出一个合格的项目。</p>
</blockquote>
<h4 id="毕业前努力浅尝的目标书单"><a href="#毕业前努力浅尝的目标书单" class="headerlink" title="毕业前努力浅尝的目标书单"></a>毕业前努力浅尝的目标书单</h4><p>&lt;深入理解java虚拟机&gt;<br><img src="/images/imgs4/30.jpg" alt="Alt text"></p>
<blockquote>
<p>作者：周志明<br>标签 ： jvm<br>作为一个优秀的java程序员，此书是必读之作，不动java底层运行机制，就不会洞悉如何优化。惭愧，还没读过，不做过多评论。</p>
</blockquote>
<p><algorithms 4th="" edition=""><br><img src="/images/imgs4/31.jpg" alt="Alt text"></algorithms></p>
<blockquote>
<p>作者：Robert Sedgewick/Kevin Wayne<br>标签： 算法<br>算法是程序的灵魂。而本书是作为算法领域经典的参考书，所以是一本必读之物。惭愧，还没读过，不做过多评论。</p>
</blockquote>
<p><effective java=""><br><img src="/images/imgs4/32.jpg" alt="Alt text"></effective></p>
<blockquote>
<p>作者： Joshua Bloch<br>标签： java基础<br>本书对编程中需要注意的点做了很好的总结，如果不想被自己的烂代码坑的话，此书是必读之物。惨愧，还没读过，不做过多评论。</p>
</blockquote>
<p>&lt;分布式Java应用 :基础与实践&gt;<br><img src="/images/imgs4/33.jpg" alt="Alt text"></p>
<blockquote>
<p>作者： 林昊<br>标签： 分布式<br>本书是分布式系统开发的入门之作，作者是淘宝网架构师，主要是以理论联系实践为主。惨愧，还没读过，不做过多评论。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 个人感想 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习历程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见面试题八之javaweb基础]]></title>
      <url>http://www.myzwl.win/2017/09/04/face_8/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="使用spring框架的好处是什么"><a href="#使用spring框架的好处是什么" class="headerlink" title="使用spring框架的好处是什么"></a>使用spring框架的好处是什么</h4><p>轻量级、控制反转、面向切面编程（AOP）、容器（包含并管理应用中对象的生命周期和配置）、mvc框架、事务管理、异常处理</p>
<h4 id="applicationContext通常的实现是什么"><a href="#applicationContext通常的实现是什么" class="headerlink" title="applicationContext通常的实现是什么"></a>applicationContext通常的实现是什么</h4><p>FileSystemXmlApplicationContext（从一个xml文件中加载beans的定义）<br>classPathXmlApplicationContext：（也是从一个xml文件中加载beans文件，但是在classpath里找bean配置）<br>WebXmlApplicationContext：定义一个web应用的所有bean</p>
<h4 id="什么是spring的依赖注入？有哪些方法进行依赖注入？"><a href="#什么是spring的依赖注入？有哪些方法进行依赖注入？" class="headerlink" title="什么是spring的依赖注入？有哪些方法进行依赖注入？"></a>什么是spring的依赖注入？有哪些方法进行依赖注入？</h4><p>你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件和服务，之后一个容器负责把他们组装起来<br>构造器依赖注入、setter方法注入</p>
<h4 id="解释spring支持的几种bean的作用域"><a href="#解释spring支持的几种bean的作用域" class="headerlink" title="解释spring支持的几种bean的作用域"></a>解释spring支持的几种bean的作用域</h4><blockquote>
<p>singleton：bean在每个spring ioc容器中只有一个实例<br>prototype： 一个bean的定义可以有多个实例<br>request： 每次http请求都会创建一个bean，改作用域仅在web的spring applicationContext情形下有效<br>session、global-session</p>
</blockquote>
<h4 id="解释spring框架中bean的生命周期"><a href="#解释spring框架中bean的生命周期" class="headerlink" title="解释spring框架中bean的生命周期"></a>解释spring框架中bean的生命周期</h4><blockquote>
<p>1.spring容器从XML文件中读取bean的定义，并实例化bean<br>2.spring根据bean的定义填充所有的属性<br>3.如果bean实现了beanNameAware接口，spring传递bean的ID到setBeanName方法<br>4.如果Bean实现了BeanFactoryAware接口，spring传递beanfactory给setBeanFactory<br>5.如果有任何与bean相关联的beanpostprocessors，spring会在postprocesserBeforeInitalzation（）方法内部调用他们<br>6.如果bean实现了intialzingBean了，调用它的afterPropertySet方法，如果bean声明初始化方法，调用此初始化方法<br>7.如果bean实现了disposableBean，它将调用destroy（）方法</p>
</blockquote>
<h4 id="spring中如何注入一个java集合"><a href="#spring中如何注入一个java集合" class="headerlink" title="spring中如何注入一个java集合"></a>spring中如何注入一个java集合</h4><p><list>、<set>,<map>,<props></props></map></set></list></p>
<h4 id="有哪些不同方式的自动装配"><a href="#有哪些不同方式的自动装配" class="headerlink" title="有哪些不同方式的自动装配"></a>有哪些不同方式的自动装配</h4><p>有五种自动装配的方式</p>
<blockquote>
<p>no:默认方式，通过显示设置ref属性来进行装配<br>byName：通过参数名自动装配<br>byType：通过参数类型自动装配<br>constructor ： 类似于bytype，但是要提供构造器参数<br>autodetect：首次尝试construc，其次是bytype</p>
</blockquote>
<h4 id="hibernate中sessionFactory是线程安全吗？session是线程安全的吗"><a href="#hibernate中sessionFactory是线程安全吗？session是线程安全的吗" class="headerlink" title="hibernate中sessionFactory是线程安全吗？session是线程安全的吗"></a>hibernate中sessionFactory是线程安全吗？session是线程安全的吗</h4><p>sessionfactory对应一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。一般在启动的时候通过单例模式进行封装便于访问<br>session是一个轻量级的非线程安全的对象，线程间不能共享session，session默认会延迟获取数据库连接</p>
<h4 id="mybatis中的动态SQL是什么意思"><a href="#mybatis中的动态SQL是什么意思" class="headerlink" title="mybatis中的动态SQL是什么意思"></a>mybatis中的动态SQL是什么意思</h4><p>动态sql主要包括if、choose、when、otherwise、trim、where、set、foreach</p>
<h4 id="简单说一下mybatis的一级缓存和二级缓存"><a href="#简单说一下mybatis的一级缓存和二级缓存" class="headerlink" title="简单说一下mybatis的一级缓存和二级缓存"></a>简单说一下mybatis的一级缓存和二级缓存</h4><p>mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从从缓存取出返回结果集。mybatis内部缓存使用一个hashmap，key为hashcode+sqlid+sql语句。value从查询出来映射生成java对象<br>mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个namespace中查询sql可以从缓存中存取数据，二级缓存是可以跨sqlsession的</p>
<h4 id="什么是泛型是如何工作？什么是类型擦除？如何工作？"><a href="#什么是泛型是如何工作？什么是类型擦除？如何工作？" class="headerlink" title="什么是泛型是如何工作？什么是类型擦除？如何工作？"></a>什么是泛型是如何工作？什么是类型擦除？如何工作？</h4><blockquote>
<p>1类型检查：在生成字节码之前提供类型检查<br>2.类型擦除：所有的类型参数都用他们的限定类型替换，包括类、变量和方法<br>3：如果调用类型擦除和多态性发生冲突时，则在调用该方法时插入强制类型转换<br>类型擦除：<br>所有类型参数都用他们的限定类型替换：比如T,Object</p>
</blockquote>
<p>如何工作</p>
<blockquote>
<p>泛型通过类型擦除来实现的，编译器在编译时期擦除了所有类型相关的信息，所有在运行时不存在任何类型相关的信息</p>
</blockquote>
<h4 id="Ajax的实现流程是主怎样的"><a href="#Ajax的实现流程是主怎样的" class="headerlink" title="Ajax的实现流程是主怎样的"></a>Ajax的实现流程是主怎样的</h4><blockquote>
<p>1创建XMLHttpRequest对象，也就是创建一个异步调用对象<br>2.创建一个新的HTTp请求，并指定该HTTP请求的方法，url及验证信息<br>3设置http请求状态变化的函数<br>4.发送HTTp请求<br>5获取异步调用返回的数据<br>6.使用javascript和DOM实现局部刷新</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习效果检验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见面试题七之javaweb基础]]></title>
      <url>http://www.myzwl.win/2017/09/04/face_7/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="说一说servlet的生命周期"><a href="#说一说servlet的生命周期" class="headerlink" title="说一说servlet的生命周期"></a>说一说servlet的生命周期</h4><p>包括加载和实例化、初始化、处理请求及服务结束，有javax.servlet.Servlet接口的相关方法实现<br>web容器加载servlet，生命周期开始。通过调用servlet的init（）方法进入初始化，通过service（）方法实现，根据不同的请求调用do<em>*</em>（）方法，服务结束，web容器调用servlet的destroy（）方法</p>
<h4 id="servlet-API中forward（）与redirect（）区别？"><a href="#servlet-API中forward（）与redirect（）区别？" class="headerlink" title="servlet API中forward（）与redirect（）区别？"></a>servlet API中forward（）与redirect（）区别？</h4><blockquote>
<p>从地址栏显示来说：<br>forward是服务器请求的地址资源，通过内部转发方式最后只返回一次内容，而redirect是重新转发，也就是需要经过两次请求与响应<br>从数据共享来说<br>forward可以共享request里的数据，而redirect不行，forward是服务器内部的一种操作，而redirect是服务器通知客户端，然后客户端重新发起请求<br>从运用地方<br>forward一般用于用户登录的时候，根据角色转发到相应的模块<br>redirect一般用于用户注销登录时返回主页和跳转到其它的网站<br>从效率上<br>forward高，redirect低</p>
</blockquote>
<h4 id="request-getAttribute-和request-getParameter-有什么区别"><a href="#request-getAttribute-和request-getParameter-有什么区别" class="headerlink" title="request.getAttribute()和request.getParameter()有什么区别"></a>request.getAttribute()和request.getParameter()有什么区别</h4><blockquote>
<p>后者取得通过容器的实现来取得通过类似post，get等方式传入的数据<br>前者返回对象，后者返回字符串</p>
</blockquote>
<h4 id="jsp有哪些内置对象？作用分别是什么"><a href="#jsp有哪些内置对象？作用分别是什么" class="headerlink" title="jsp有哪些内置对象？作用分别是什么"></a>jsp有哪些内置对象？作用分别是什么</h4><p>总共有九大内置对象</p>
<blockquote>
<p>request、reponse、pageContext、session、application、out、config、page、exception</p>
</blockquote>
<h4 id="Http中，get和post方法区别"><a href="#Http中，get和post方法区别" class="headerlink" title="Http中，get和post方法区别"></a>Http中，get和post方法区别</h4><blockquote>
<p>1.get请求的数据会被浏览器缓存起来，并以明文方式出现在url中，不太安全而post则更安全<br>2get传输数据有大小限制get请求的参数会跟在url后进行传递</p>
</blockquote>
<h4 id="jdbc访问数据库的基本步骤是什么？"><a href="#jdbc访问数据库的基本步骤是什么？" class="headerlink" title="jdbc访问数据库的基本步骤是什么？"></a>jdbc访问数据库的基本步骤是什么？</h4><blockquote>
<p>1.加载驱动<br>2.通过driverManager对象获取连接对象Connection<br>3.通过连接对象获取会话<br>4.通过会话进行数据的增删改查，封装对象<br>5。关闭数据库</p>
</blockquote>
<h4 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h4><p>幻读是指一个事务多次执行一条查询语句返回的确是不同的值。假设一个事务正根据某个条件进行数据库查询，然后另一个事务插入了一行满足这个查询条件的数据，之后这个事务再次执行了这条查询，返回的结果集中包含在刚插入的那条数据</p>
<h4 id="谈谈你对struts的理解"><a href="#谈谈你对struts的理解" class="headerlink" title="谈谈你对struts的理解"></a>谈谈你对struts的理解</h4><blockquote>
<p>1.structs本质就是一个servlet，而这个servlet就是ActionServlet或是其子类，即将所有请求都交给servlet去处理，而该servlet参考配置文件将请求分发给不同action处理<br>2.在把请求交给action之前，会将参数封装成一个frombean对象，而该对象只有通过validate方法，才能将对象传递给execute方法，否则将返回一个错误页面，并且这个页面由input属性指定<br>3.action执行完之后要返回显示的结果视图，这个结果一个actionForward来表示，而其是通过在struts配置文件中配置获得返回页面</p>
</blockquote>
<h4 id="谈谈你对hibernate的理解"><a href="#谈谈你对hibernate的理解" class="headerlink" title="谈谈你对hibernate的理解"></a>谈谈你对hibernate的理解</h4><blockquote>
<p>1.使用hibernate的基本流程：配置Configuration对象、产生sessionfactory、创建session对象、启动事务，完成CRUD操作，提交事务，关闭session<br>2.使用hibernate时，先要配置hibernate.cfg.xml文件，其中配置数据库连接信息和方言，还要为每个实体配置相应的hbm.xml文件<br>3.在应用hibernate时，重点要了解session的缓存原理，级联，延迟加载和hql语句</p>
</blockquote>
<h4 id="谈谈你对spring的理解"><a href="#谈谈你对spring的理解" class="headerlink" title="谈谈你对spring的理解"></a>谈谈你对spring的理解</h4><blockquote>
<p>1.spring是实现了工厂模式的工厂类，这个类为beanFactory，通常为其子类applicationContext，spring相当于一个大的工厂类，在其配置文件中通过<bean>元素配置用于创建实例对象名和实例对象的属性<br>2.spring提供了对IOC的良好支持，利用IOC可以很好的实现模块间的解耦<br>3.spring提供了对AOP技术的良好封装，即把系统中很多不相干的类的方法，在这些众多的方法中加入某种系统功能的代码，例如，加入日志，权限判断，异常处理等等，称为AOP<br>4实现AOP采用代理类，在jdk中采用proxy类产生动态代理的方式为某个接口生成实现类，</bean></p>
</blockquote>
<h4 id="谈谈struts的优缺点"><a href="#谈谈struts的优缺点" class="headerlink" title="谈谈struts的优缺点"></a>谈谈struts的优缺点</h4><p>优点：</p>
<blockquote>
<p>1.实现mvc模式，结构清晰，使开发者只关注业务逻辑的实现<br>2有丰富的tag可以使用，大大提高开发效率<br>3.页面导航使系统的脉络更加清晰<br>4.提供Exception处理机制</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>1.structs的action是一种thread-safe方式，它仅仅允许一个实例处理所有的请求。容易引起线程安全问题<br>2 测试不方便。struts的每个action都同web层耦合在一起，这样它的测试依赖于web容器，单元测试很难实现<br>3.对servlet的依赖性过强，struts处理action时必须依赖servletRequest和servletRespouse，所以它摆脱不了servlet容器</p>
</blockquote>
<h4 id="mybatis和hibernate有什么不同"><a href="#mybatis和hibernate有什么不同" class="headerlink" title="mybatis和hibernate有什么不同"></a>mybatis和hibernate有什么不同</h4><p>相同点：</p>
<blockquote>
<p>都屏蔽了jdbc api底层访问细节，编程流程固定，还将sql语句与java代码混杂在一起</p>
</blockquote>
<p>不同点</p>
<blockquote>
<p>半自动，将sql语句与代码进行分离，提供了将结果集自动封装成为实体对象和对象集合的功能<br>全自动，hibernate，提供hql语句</p>
</blockquote>
<h4 id="介绍一下hibernate的二级缓存"><a href="#介绍一下hibernate的二级缓存" class="headerlink" title="介绍一下hibernate的二级缓存"></a>介绍一下hibernate的二级缓存</h4><p>回答思路：1.首先说清楚什么是缓存<br>2.再说有了hibernate的session就是一级缓存，即有了一级缓存，为什么还要有二级缓存<br>3.最后说如何配置hibernate的二级缓存</p>
<blockquote>
<p>1.缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中，这个数据结构通常类似于hashmap，当以后要使用某个对象时，先查询缓存中是否有这个对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在缓存中，以便下次使用<br>2.hibernate的session就是一级缓存，当想要使用session从数据库中查询出的一个对象时，session也是先从自己内部查看是否存在这个对象，存在则直接返回，不存在则查询数据库<br>由于session代表依次会话，一个session与一个数据库连接的相关性，通常仅用一个事务，用完就关闭，由于一级缓存是线程不安全的，要被多个线程共享，而二级缓存是全局缓存，可以被多个线程和事务共享<br>3二级缓存是独立于hibernate的软件部件，如ehcache</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习效果检验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见面试题六之java基础]]></title>
      <url>http://www.myzwl.win/2017/09/03/face_6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="说出math的取整函数及其意义"><a href="#说出math的取整函数及其意义" class="headerlink" title="说出math的取整函数及其意义"></a>说出math的取整函数及其意义</h4><p>提供了三种，分别为ceil（向上取整），如math.ceil（11.3）为12；<br>floor（向下取整），如math.floor（11.3），结果为11<br>round（四舍五入），如math.round（11.5）为12</p>
<h4 id="Overload与Override的区别？Overload的方法是否可以改变返回值的类型？"><a href="#Overload与Override的区别？Overload的方法是否可以改变返回值的类型？" class="headerlink" title="Overload与Override的区别？Overload的方法是否可以改变返回值的类型？"></a>Overload与Override的区别？Overload的方法是否可以改变返回值的类型？</h4><p>Overload是重载，Overrride是覆盖，也就是重写</p>
<blockquote>
<p>重载表示方法名相同，但是参数个数或类型不同）<br>重写表示子类中的方法可以与父亲中某个方法的名称和参数完全相同，通过子类创建实例调用父类这个方法，也就是相当于覆盖了父类的这个方法，但是当父类是private时相当于子类增加了一个全新的方法，就不存在覆盖了。并且子类应该比父类抛出更少的异常或者拥有更大的权限<br>如果参数名不同会改变返回类型，但是如果都一样肯定不会改变返回类型</p>
</blockquote>
<h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4><p>接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？抽象类是否可以有静态的main方法？</p>
<blockquote>
<p>接口可以继承接口，抽象类可以实现接口，抽象类可以继承具体类，抽象类可以有静态的main方法<br>抽象类和普通类唯一的区别就是不能创建实例对象和允许有abstract方法</p>
</blockquote>
<h4 id="java中实现多态的机制是什么？"><a href="#java中实现多态的机制是什么？" class="headerlink" title="java中实现多态的机制是什么？"></a>java中实现多态的机制是什么？</h4><p>靠的是父类或接口定义的引用变量可以指向子类或者具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量类型中定义的方法</p>
<h4 id="abstractclass和interface语法上有什么区别"><a href="#abstractclass和interface语法上有什么区别" class="headerlink" title="abstractclass和interface语法上有什么区别"></a>abstractclass和interface语法上有什么区别</h4><blockquote>
<p>1.抽象类可以有构造方法，接口不能有构造方法<br>2.抽象类中可以有普通成员方法，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。<br>4.抽象类中的抽象方法访问类型可以是public、protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型<br>5.抽象类中可以包含静态方法，接口中不能包含静态方法<br>6.抽象类和接口类中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以是任意，但是接口中定义的变量只能是public static final类型<br>7一个类可以实现多个接口，但只能继承一个抽象类</p>
</blockquote>
<h4 id="abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？"><a href="#abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？" class="headerlink" title="abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？"></a>abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？</h4><blockquote>
<p>abstract的method不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系<br>native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在被子类实现的问题，所以，它也不能为抽象的，<br>synchronized应该是作用在一个具体的方法上才有意义，而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法无法确定this是什么</p>
</blockquote>
<h4 id="下面这条语句一共创建了多少个对象？"><a href="#下面这条语句一共创建了多少个对象？" class="headerlink" title="下面这条语句一共创建了多少个对象？"></a>下面这条语句一共创建了多少个对象？</h4><p>String s=”a”+”b”+”c”+”d”;<br>对于如下代码</p>
<blockquote>
<p>String s1=”a”;<br>String s2=s1+”b”;<br>String s3=”a”+”b”;<br>System.out.println(s2=”ab”);<br>System.out.println(s3=”ab”);<br>第一句打印为false，第二句为true，说明编译器对字符串常量直接进行了优化，所以产生了一个对象</p>
</blockquote>
<h4 id="java中堆和栈有什么区别？"><a href="#java中堆和栈有什么区别？" class="headerlink" title="java中堆和栈有什么区别？"></a>java中堆和栈有什么区别？</h4><p>jvm中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个jvm的所有线程共享</p>
<h4 id="什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？"><a href="#什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？" class="headerlink" title="什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？"></a>什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？</h4><p>将一个对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如将一个java对象存储到硬盘或者送给网络上的其他计算机，可以用代码把一个java对象变成某个格式的字节流在传输<br>如果要让java自动帮我们做，就需要实现serializable接口，编译的类才被writeObject方法操作，例如，在web中，如果对象被保存在了session中，tomcat在重启时要把session对象序列化到硬盘</p>
<h4 id="描述一下JVM加载class文件的原理机制？"><a href="#描述一下JVM加载class文件的原理机制？" class="headerlink" title="描述一下JVM加载class文件的原理机制？"></a>描述一下JVM加载class文件的原理机制？</h4><p>JVM中类的装载是由classLoader和它的子类来实现的，java classLoader是一个重要的运行时系统组件。他负责在运行时查找和装入文件的类</p>
<h4 id="heap和stack有什么区别？"><a href="#heap和stack有什么区别？" class="headerlink" title="heap和stack有什么区别？"></a>heap和stack有什么区别？</h4><p>java的内存分为两类，栈内存和堆内存</p>
<blockquote>
<p>栈内存是指程序进入一个方法时，会为这个方法单独分配一块私有存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈的变量也将随之释放<br>堆是用于存放不在当前方法栈中的那些数据，例如使用new创建的对象放在堆里，所以，它不会随方法结束而消失，局部变量使用final修饰后，放在堆中</p>
</blockquote>
<h4 id="GC是是什么？为什么要有GC？"><a href="#GC是是什么？为什么要有GC？" class="headerlink" title="GC是是什么？为什么要有GC？"></a>GC是是什么？为什么要有GC？</h4><p>GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定性甚至崩溃，java提供GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，java语言没有提供释放已分配内存的显示操作方法</p>
<h4 id="垃圾回收的优点和原理，并考虑2种回收机制"><a href="#垃圾回收的优点和原理，并考虑2种回收机制" class="headerlink" title="垃圾回收的优点和原理，并考虑2种回收机制"></a>垃圾回收的优点和原理，并考虑2种回收机制</h4><p>垃圾回收可以有效的防止内存泄漏，有效的使用可以使用的内存。垃圾回收期是作为一个单独低级别的线程运行，不可预知的情况下对内存中已经死亡或者长时间没有使用的对象进行清除和回收，程序员不能实时调用垃圾回收器对某个对象或所有对象进行垃圾回收<br>回收机制有标记垃圾回收和增量垃圾回收</p>
<h4 id="垃圾回收器基本原理，可以马上回收内存及有什么办法主动通知JVM进行垃圾回收"><a href="#垃圾回收器基本原理，可以马上回收内存及有什么办法主动通知JVM进行垃圾回收" class="headerlink" title="垃圾回收器基本原理，可以马上回收内存及有什么办法主动通知JVM进行垃圾回收"></a>垃圾回收器基本原理，可以马上回收内存及有什么办法主动通知JVM进行垃圾回收</h4><blockquote>
<p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小、及使用情况。通常，GC采用有向图的方式记录和管理堆里中的所有对象，通过这种方式确定哪些对象是可达的，哪些对象是不可达的。当GC确定一些对象不可达的，GC有责任回收这些内存空间<br>程序员可以手动执行System.gc（），通知gc运行，但是java语言规范并不保证GC一定会执行</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习效果检验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见面试题之五]]></title>
      <url>http://www.myzwl.win/2017/09/03/face_5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="http协议的请求包含哪些内容"><a href="#http协议的请求包含哪些内容" class="headerlink" title="http协议的请求包含哪些内容"></a>http协议的请求包含哪些内容</h4><p>HTTP请求是指从客户端到服务器端的请求消息。包括：消息首行中，对资源的请求方法、资源的标识符及使用的协议。从客户端到服务器端的请求消息包括，消息首行中，对资源的请求方法、资源的标识符及使用的协议。<br>HTTP请求信息由3部分组成：<br>请求方法URI协议/版本<br>请求头(Request Header)<br>请求正文<br>如下</p>
<blockquote>
<p>1.GET /index.jsp HTTP/1.1<br> 2.Accept-Language: zh-cn<br>3.Connection: Keep-Alive<br>4.Host: 192.168.0.106<br>5.Content-Length: 37<br>6.userName=new_andy&amp;password=new_andy</p>
</blockquote>
<p>HTTP响应也由3个部分构成，分别是：<br>状态行<br>响应头(Response Header)<br>响应正文<br>如下：</p>
<blockquote>
<p>1.HTTP/1.1 200 OK<br>2.Server: Microsoft-IIS/4.0<br>3.Date: Mon, 3 Jan 2005 13:13:33 GMT<br>4.Content-Type: text/html<br>5.Last-Modified: Mon, 11 Jan 2004 13:23:42 GMT<br>6.Content-Length: 90<br>7.<html><br>8.<head><br>9.<title>解读HTTP包示例</title></head><body><br>10.Hello WORLD!<br>11.</body><br>12.</html></p>
</blockquote>
<h4 id="session和cookie的比较"><a href="#session和cookie的比较" class="headerlink" title="session和cookie的比较"></a>session和cookie的比较</h4><p>区别:</p>
<blockquote>
<p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>   考虑到安全应当使用session。<br>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>   考虑到减轻服务器性能方面，应当使用COOKIE。<br>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
</blockquote>
<p>联系</p>
<blockquote>
<p>session和cookie之间是通过$_COOKIE[‘PHPSESSID’]来联系的，通过$_COOKIE[‘PHPSESSID’]可以知道session的id，从而获取到其他的信息。</p>
</blockquote>
<h4 id="hibernate对象的三种状态"><a href="#hibernate对象的三种状态" class="headerlink" title="hibernate对象的三种状态"></a>hibernate对象的三种状态</h4><p>transient(瞬时状态)，persistent(持久化状态)以及detached(离线状态)</p>
<blockquote>
<p>瞬时状态就是刚new出来一个对象，还没有被保存到数据库中，持久化状态就是已经被保存到数据库中，离线状态就是数据库中有，但是session中不存在该对象<br>①.对于刚创建的一个对象，如果session中和数据库中都不存在该对象，那么该对象就是瞬时对象(Transient)<br>②.瞬时对象调用save方法，或者离线对象调用update方法可以使该对象变成持久化对象，如果对象是持久化对象时，那么对该对象的任何修改，都会在提交事务时才会与之进行比较，如果不同，则发送一条update语句，否则就不会发送语句<br>③.离线对象就是，数据库存在该对象，但是该对象又没有被session所托管</p>
</blockquote>
<h4 id="对restful的了解"><a href="#对restful的了解" class="headerlink" title="对restful的了解"></a>对restful的了解</h4><p>资源与URI:<br>任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值),要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI,URI既可以看成是资源的地址，也可以看成是资源的名称<br>统一资源接口:<br>不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。<br>资源的表述:<br>在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。 资源的表述包括数据和描述数据的元数据，例如，HTTP头“Content-Type” 就是这样一个元数据属性。<br>资源的链接:<br>状态的转移<br>应用状态与资源状态:<br>客户端负责维护应用状态，而服务端维护资源状态,浏览器随各次请求发出去的Cookie是被用于构建会话状态的。 当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。</p>
<h4 id="json是什么"><a href="#json是什么" class="headerlink" title="json是什么?"></a>json是什么?</h4><p>JavaScript对象表示法，它是一种基于文本，独立于语言的轻量级数据交换格式.XML虽然可以作为跨平台的数据交换格式，但是在JS(JavaScript的简写)中处理XML非常不方便，同时XML标记比数据多，增加了交换产生的流量，而JSON没有附加的任何标记，在JS中可作为对象处理<br>JSON的两种结构<br>对象</p>
<blockquote>
<p>{<br>    key1:value1,<br>    key2:value2,<br>    …<br>}</p>
</blockquote>
<p>数组</p>
<blockquote>
<p>[<br>    {<br>        key1:value1,<br>        key2:value2<br>    },<br>    {<br>         key3:value3,<br>         key4:value4<br>    }<br>]</p>
</blockquote>
<p>认识JSON字符串</p>
<blockquote>
<p>字符串：指使用“”双引号或’’单引号包括的字符。例如：var comStr = ‘this is string’;<br>json字符串：指的是符合json格式要求的js字符串。例如：var jsonStr = “{StudentID:’100’,Name:’tmac’,Hometown:’usa’}”;<br>json对象：指符合json格式要求的js对象。例如：var jsonObj = { StudentID: “100”, Name: “tmac”, Hometown: “usa” };</p>
</blockquote>
<p>遍历JSON对象<br>可以使用for…in…循环来遍历JSON对象中的数据，比如我们要遍历输出obj对象的值</p>
<blockquote>
<p>function Traversal() {<br>            for (var c in obj) {<br>                console.log(c + “:”, obj[c]);<br>            }<br>        }</p>
</blockquote>
<p>在客户端，读写json对象可以使用”.”操作符或”[“key”]”，json字符串转换为json对象使用eval()函数</p>
<h4 id="对多线程的认识以及线程池的原理及作用"><a href="#对多线程的认识以及线程池的原理及作用" class="headerlink" title="对多线程的认识以及线程池的原理及作用"></a>对多线程的认识以及线程池的原理及作用</h4><p>回答思路：多线程是什么，它是干什么的&gt;开启线程的方式&gt;线程的生命周期&gt;线程安全问题&gt;实现同步的方式</p>
<blockquote>
<p>多线程就是多个工作让CPU交互处理。java用Runnalbe接口实现或者继承Thread类就可以, 线程的生命周期是 创建》就绪（runnable）==》运行（running）==》死亡（dead） 在运行时也会有堵塞（blocked）的情况<br>线程是交互执行的，所以如果发现了一个线程一直在一个资源里执行，那么其他线程不能使用这个资源，就会一直停在那里，也就是死锁，解决线程安全的办法一般是让同一时刻，只能让一个线程访问该资源。也就是同步。 java实现同步的方法是用synchronized和Lock关键字。<br>线程池就相当于操作系统的缓冲区，把程序启动的若干线程存放在线程池中，等到程序收到请求了就唤醒某一个线程。 作用就是为了性能，让程序更能节省效率。</p>
</blockquote>
<h4 id="选择算法要考虑哪些因素，说说你熟悉的算法思想"><a href="#选择算法要考虑哪些因素，说说你熟悉的算法思想" class="headerlink" title="选择算法要考虑哪些因素，说说你熟悉的算法思想"></a>选择算法要考虑哪些因素，说说你熟悉的算法思想</h4><p>因素：时间、空间复杂度、稳定性、要操作数据的特点······<br>思想：递归、迭代、分治······</p>
<h4 id="一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</h4><p>可以有多个类，但是只能有一个public的类，并且public的类名必须与文件名相一致</p>
<h4 id="说说-amp-与-amp-amp-的区别"><a href="#说说-amp-与-amp-amp-的区别" class="headerlink" title="说说&amp;与&amp;&amp;的区别"></a>说说&amp;与&amp;&amp;的区别</h4><blockquote>
<p>&amp;与&amp;&amp;都可以用作逻辑与（and）的运算符<br>&amp;&amp;具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。而&amp;则会同时计算<br>&amp;可以作为位运算符，当&amp;两边表达式不是boolean时，&amp;表示按位与操作，通常使用Ox0f来与一个整数&amp;运算，来取该整数的最低4个bit位</p>
</blockquote>
<h4 id="switch语句能否作用在byte上，能否作用在long上，能否作用在String上？"><a href="#switch语句能否作用在byte上，能否作用在long上，能否作用在String上？" class="headerlink" title="switch语句能否作用在byte上，能否作用在long上，能否作用在String上？"></a>switch语句能否作用在byte上，能否作用在long上，能否作用在String上？</h4><blockquote>
<p>在switch（e）中，e只能是一个整数表达式或者枚举常量，整数表达式可以是int基本类型或者Integer包装类型，而byte、short、char都可以隐含转换成int，所以可以，但long和String不符合</p>
</blockquote>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>short s=1;s=s+1;有什么错？<br>等号左边s是short类型，而等号右边是int类型，需要强制转换否则报错，<br>而short s=1;s+=1；不会报错<br>因为+=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确处理</p>
<h4 id="用最有效的方法算出2乘以8等于几？"><a href="#用最有效的方法算出2乘以8等于几？" class="headerlink" title="用最有效的方法算出2乘以8等于几？"></a>用最有效的方法算出2乘以8等于几？</h4><blockquote>
<p>2&lt;&lt;3（左移三位），将一个数左移n位相当于乘以2的n次方，而位运算cpu是直接支持的，效率最高</p>
</blockquote>
<h4 id="使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h4><p>当使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的，例如<br>s xx=new s(“yy”),xx=new s(“”)(编译器会报错)，但是xx.add(“zz”)可以通过编译</p>
]]></content>
      
        <categories>
            
            <category> 面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习效果检验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见面试题之四]]></title>
      <url>http://www.myzwl.win/2017/09/02/face_4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="如何去除多表查询产生重复的数据-连接查询"><a href="#如何去除多表查询产生重复的数据-连接查询" class="headerlink" title="如何去除多表查询产生重复的数据(连接查询)"></a>如何去除多表查询产生重复的数据(连接查询)</h4><p>如果一个查询需要对多个表进行操作就称为连接查询,连接查询的结果集或结果称为表之间的连接.<br>连接查询实际上是通过各个表之间共同列的关联性来查询数据的,它是关系数据库查询最主要的特征.<br>连接查询分类：<br>1.自连接查询，对同一个表进行连接操作<br>2.内连接查询，&lt;又分为：自然连接、等值连接、不等值连接三种&gt;<br>3.外连接查询，&lt;又分为：左外连接、右外连接、全外连接三种&gt;<br>4.交叉连接查询，也作无条件查询。<br>5.联合查询</p>
<h4 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h4><p>一个表自己与自己建立连接称为自连接或自身连接，如：</p>
<blockquote>
<p>select x.* from sclass x,sclass y<br>where x.cno=’’101’’ and x.degree&gt;y.degree and y.sno=’’9505201’’ and y.cno=’’101’’<br>order by x.degree desc</p>
</blockquote>
<h4 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接(INNER JOIN)"></a>内连接(INNER JOIN)</h4><p>它只返回两个数据集合之间匹配关系的那些行.<br>将位于两个互相交叉的数据集合中重叠部分以内的那些数据行连接起来.<br>语法：<br>select 字段名列表 from 表名 [inner] join 表名 on 连接条件 [where 条件表达式]<br>select x.sno,x.sname,y.cno,y.degree from student x<br>INNER join sclass y on x.sno=y.sno where x.sclass=’’xx’’</p>
<blockquote>
<p>等值连接：<br>所谓等值连接，是指表之间通过“等于”关系连接起来，产生一个临时表，<br>然后对该临时表进行处理后生成最终结果。其查询结果中列出被连接表中的所有列，<br>包括其中的重复列。<br>如：SELECT x.sno,y.cname,x.degree<br>FROM score x,course y<br>WHERE x.cno=y.cno<br>不等值连接：<br>是指表之间的连接关系不是“等于”，而是其它关系。<br>这些运算符包括&gt;、&gt;=、&lt;=、&lt;、!&gt;、!&lt;和&lt;&gt;<br>select x.sno,x.sname,y.cno,y.degree<br>from student x,score y<br>where x.sno!=y.sno<br>自然连接：<br>在等值连接中消除重复列就是自然连接。<br>关键词 DISTINCT 用于返回唯一不同的值。<br>SELECT DISTINCT 列名称 FROM 表名称</p>
</blockquote>
<h4 id="jre和jdk的区别"><a href="#jre和jdk的区别" class="headerlink" title="jre和jdk的区别"></a>jre和jdk的区别</h4><blockquote>
<p>JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。<br>JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java</p>
</blockquote>
<h4 id="java基本数据类型"><a href="#java基本数据类型" class="headerlink" title="java基本数据类型"></a>java基本数据类型</h4><blockquote>
<p>byte、short、int、long、float、double、char、boolean</p>
</blockquote>
<h4 id="能否重写构造方法"><a href="#能否重写构造方法" class="headerlink" title="能否重写构造方法"></a>能否重写构造方法</h4><p>重载构造方法是可以的。<br>但是重写则不可以，因为被重写的前提是被继承，而构造方法根本就不能被继承，所以谈不上被重写。只能调用父类的构造方法</p>
<h4 id="依赖注入的底层实现方式"><a href="#依赖注入的底层实现方式" class="headerlink" title="依赖注入的底层实现方式"></a>依赖注入的底层实现方式</h4><p>依赖注入（Dependency Injection）是用于实现控制反转（Inversion of Control）的最常见的方式之一<br>为什么需要依赖注入？<br>比如下面这段模拟代码</p>
<blockquote>
<p>public class MovieLister {<br>    private MovieFinder finder;<br>    public MovieLister() {<br>        finder = new MovieFinderImpl();<br>    }<br>    public Movie[] moviesDirectedBy(String arg) {<br>    }<br>    …<br>}<br>public interface MovieFinder {<br>    List findAll();<br>}</p>
</blockquote>
<p>我们创建了一个名为MovieLister的类来提供需要的电影列表，它moviesDirectedBy方法提供根据导演名来搜索电影的方式。真正负责搜索电影的是实现了MovieFinder接口的MovieFinderImpl，我们的MovieLister类在构造函数中创建了一个MovieFinderImpl的对象<br>当我们希望修改finder，将finder替换为一种新的实现时（比如为MovieFinder增加一个参数表明Movie数据的来源是哪个数据库），我们不仅需要修改MovieFinderImpl类，还需要修改我们MovieLister中创建MovieFinderImpl的代码。<br>这就是依赖注入要处理的耦合。这种在MovieLister中创建MovieFinderImpl的方式，使得MovieLister不仅仅依赖于MovieFinder这个接口，它还依赖于MovieListImpl这个实现<br>依赖注入的实现方式</p>
<blockquote>
<p>构造函数注入<br>setter注入<br>接口注入(接口注入使用接口来提供setter方法)</p>
</blockquote>
<h4 id="父类能否调用子类方法"><a href="#父类能否调用子类方法" class="headerlink" title="父类能否调用子类方法"></a>父类能否调用子类方法</h4><p>能.把子类传递到父类的有参构造中，然后调用。<br>使用反射的方式调用<br>如下模拟</p>
<blockquote>
<p>package com.zwl.test;<br>public class exam {<br>    private examson son;<br>    public exam(examson son){<br>        this.son=son;<br>    }<br>    public exam(){<br>    }<br>    public void Reflaction() throws InstantiationException, IllegalAccessException{<br>        try {<br>            Class ref=Class.forName(“com.zwl.test.examson”);<br>            examson s=(examson) ref.newInstance();<br>            s.method();<br>            s.staMethod();<br>        } catch (ClassNotFoundException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>    public void showByDI(){<br>        son.staMethod();<br>        son.method();<br>    }<br>    public static void main(String[] args)  {<br>         try {<br>             exam e=new exam(new examson());<br>              e.showByDI();<br>              e.Reflaction();<br>        } catch (InstantiationException e1) {<br>            e1.printStackTrace();<br>        } catch (IllegalAccessException e1) {<br>            e1.printStackTrace();<br>        }<br>    }<br>}<br>class examson extends exam{<br>        public static void staMethod(){<br>        System.out.println(“it is a static method”);<br>    }</p>
</blockquote>
<pre><code>public void method(){
    System.out.println(&quot;ok&quot;);
}
</code></pre><p>}</p>
<h4 id="构造代码块和构造方法的执行顺序"><a href="#构造代码块和构造方法的执行顺序" class="headerlink" title="构造代码块和构造方法的执行顺序"></a>构造代码块和构造方法的执行顺序</h4><p>父类静态块-自身静态块-父类块-父类构造器-自身块-自身构造器</p>
<h4 id="接口属性为什么定义为final"><a href="#接口属性为什么定义为final" class="headerlink" title="接口属性为什么定义为final"></a>接口属性为什么定义为final</h4><p>interface中的变量是当作常量来设计的，它不但是final，而且还是public static的，也即interface中的变量一定是public static final的</p>
<ol>
<li>接口中的数据对所有实现类只有一份,所以是static<br>2.要使实现类为了向上转型成功,所以必须是final的，这样不用关心你到底是通过社么方式实现实现类的，进而统一了</li>
</ol>
<h4 id="类变量有没有默认值，局部变量呢？"><a href="#类变量有没有默认值，局部变量呢？" class="headerlink" title="类变量有没有默认值，局部变量呢？"></a>类变量有没有默认值，局部变量呢？</h4><p>静态成员变量和非静态成员变量jvm都会赋初值，而局部变量不会，如果局部变量没有被初始化，并且在方法中一直没有被使用，则编译和运行都会通过，但是用了，会在编译器报错</p>
<h4 id="内部类能否调用外部类方法"><a href="#内部类能否调用外部类方法" class="headerlink" title="内部类能否调用外部类方法"></a>内部类能否调用外部类方法</h4><p>内部类可以看成一个外部类的方法或成员属性，直接 方法();<br>或者 外部类名称.this.方法()</p>
<h4 id="静态方法能否调用非静态方法"><a href="#静态方法能否调用非静态方法" class="headerlink" title="静态方法能否调用非静态方法"></a>静态方法能否调用非静态方法</h4><p>不能直接调用，但可以通过将一个对象的引用传入static方法中，再去调用该对象的non-static方法<br>类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。</p>
<h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><blockquote>
<p>这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。<br>sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。<br>锁: 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。<br>sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。<br>使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。<br>synchronized(x){<br>      x.notify()<br>     //或者wait()<br>   }</p>
</blockquote>
<h4 id="内存溢出和内存泄露的区别"><a href="#内存溢出和内存泄露的区别" class="headerlink" title="内存溢出和内存泄露的区别"></a>内存溢出和内存泄露的区别</h4><p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。<br>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>memory leak会最终会导致out of memory！<br>内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出</p>
]]></content>
      
        <categories>
            
            <category> 面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习效果检验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见面试题之三]]></title>
      <url>http://www.myzwl.win/2017/09/02/face_3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="题型一"><a href="#题型一" class="headerlink" title="题型一"></a>题型一</h4><p>说说String s1 = “123”；<br>String s2 = new String（“123”）；第二句产生了几个对象，为什么？</p>
<blockquote>
<p>一个，此处有一个陷阱，如果单独来看第二句，首先堆里有一个引用对象，然后指向数据域中常量池中的值123，但是第一句已经产生了此常量值，所以只有一个。此外s2是放在堆里的，而s1是放在常量池中的</p>
</blockquote>
<h4 id="SpringMVC的工作流程"><a href="#SpringMVC的工作流程" class="headerlink" title="SpringMVC的工作流程"></a>SpringMVC的工作流程</h4><p>答题思路：url&gt;DispatcherServlet&gt;HandlerMapping映射器&gt;Controller&gt;ModelAndView&gt;DispatcherServlet&gt;viewResoler</p>
<blockquote>
<p>spring mvc和大部分mvc框架一样，底层也是依赖servlet api的，所以spring mvc的请求处理也是从一个servlet开始，这个servlet就是DispatcherServlet<br>然后就是DispatcherServlet.对一个请求的处理过程<br>1.Handle Mapping映射控制器，负责将url映射成对应的controller<br>2.controller  spring的控制器，相当于servlet或者structs的action，负责主要的业务处理，并返回一个modelandview给DispatcherServlet.<br>3:ModelAndView 包含着一个页面文件(jsp和html等)的逻辑视图名,<br>4:ViewResoler 视图解析器,根据ModelAndView提供的视图对象,查找对应的视图文件,并把他响应给客户.<br>在获得请求以后,DispatcherServlet首先会查询Handler Mapping对象(一个或多个)<br>Handler Mapping的主要工作是将请求的url映射成对应的Controller对象.<br>接着,DispatcherServlet根据Handler Mapping对象找到的结果,把请求分发给对应的Controller对象来处理,Controller负责处理具体的业务逻辑,并返回一个带有下一个页面信息的ModelView对象,最后ViewResoler 对象根据ModelAndView的信息查找对应的视图页面,并响应给用户</p>
</blockquote>
<h4 id="myBatis中-和-的区别"><a href="#myBatis中-和-的区别" class="headerlink" title="myBatis中$和#的区别"></a>myBatis中$和#的区别</h4><blockquote>
<ol>
<li>#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by “111”, 如果传入的值是id，则解析成的sql为order by “id”.</li>
<li>$将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id,  如果传入的值是id，则解析成的sql为order by id.</li>
<li>#方式能够很大程度防止sql注入<br>4.$方式无法防止Sql注入<br>5.$方式一般用于传入数据库对象，例如传入表名.<br>6.一般能用#的就别用$.<br>默认情况下，使用#{}格式的语法会导致MyBatis创建预处理语句属性并以它为背景设置安全的值（比如?）。这样做很安全,接受从用户输出的内容并提供给语句中不变的字符串，这样做是不安全的。这会导致潜在的SQL注入攻击，因此你不应该允许用户输入这些字段，或者通常自行转义并检查。</li>
</ol>
</blockquote>
<h4 id="悲观锁和乐观锁的比较"><a href="#悲观锁和乐观锁的比较" class="headerlink" title="悲观锁和乐观锁的比较"></a>悲观锁和乐观锁的比较</h4><p> 面试思路：什么是锁，用来干什么&gt;悲观锁乐观锁各自特点&gt;优缺点比较和各自应用场景</p>
<blockquote>
<p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。<br>悲观锁:<br>简单来说悲观锁认什么操作都可以改变数据，所以在改数据就锁住（在sql语句中加上for update就可以了）<br>MySQL InnoDB中使用悲观锁<br>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。 set autocommit=0;<br>//0.开始事务<br>begin;/begin work;/start transaction; (三者选一就可以)<br>//1.查询出商品信息<br>select status from t_goods where id=1 for update;<br>//2.根据商品信息生成订单<br>insert into t_orders (id,goods_id) values (null,1);<br>//3.修改商品status为2<br>update t_goods set status=2;<br>//4.提交事务<br>commit;/commit work;<br>上面的查询语句中，我们使用了 select…for update 的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。<br>优点与不足：<br>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数<br>乐观锁：<br>简单来说乐观锁很乐观 所以修改数据库后锁住 （一般在数据库中加上一个字段区别历史版本和当前版本）<br>1.查询出商品信息<br>select (status,status,version) from t_goods where id=#{id}<br>2.根据商品信息生成订单<br>3.修改商品status为2<br>update t_goods<br>set status=2,version=version+1<br>where id=#{id} and version=#{version};<br>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。<br>优点与不足<br>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
</blockquote>
<h4 id="mysql实现分页的sql语句"><a href="#mysql实现分页的sql语句" class="headerlink" title="mysql实现分页的sql语句"></a>mysql实现分页的sql语句</h4><p>面试思路：数据库分页的简单实现&gt;数据量变大时的优化方案</p>
<blockquote>
<p>sql语句是LIMIT m,n其中m是当前页，n是从当前页数n个记录，如果参数为一个就是数n个记录<br>一般我们都会这样写:当数据达到百万级的时候会慢死<br>SELECT <em> FROM table ORDER BY id LIMIT 1000000, 10;<br>优化一：<br>SELECT </em> FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10;<br>速度可以提升到0.x秒了<br>优化二：<br>SELECT <em> FROM table WHERE id BETWEEN 1000000 AND 1000010;<br>比上面提升5到10倍<br>另外，如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询<br>SELECT </em> FROM table WHERE id IN(10000, 100000, 1000000…); </p>
</blockquote>
<h4 id="内部类的种类，接口中可否有内部类"><a href="#内部类的种类，接口中可否有内部类" class="headerlink" title="内部类的种类，接口中可否有内部类"></a>内部类的种类，接口中可否有内部类</h4><p>四种内部类,接口中可以定义内部类</p>
<blockquote>
<p>静态内部类：<br>必须以static关键字标注<br>只能访问外部类中的静态的成员变量或者是静态的方法<br>访问一个内部类使应该这样outerClass.innerClass inter = new outerClass.innerClass();不能直接实例化内部类<br>成员内部类：<br>定义在一个类的内部，但是没有static关键字修饰<br>生成示例的方法outerClass.innerClass inter = (new outerClass()).new innerClass()<br>对外部类变量的引用outClass.this.variale<br>可以访问外部类的静态与非静态方法<br>局部内部类<br>匿名内部类</p>
</blockquote>
<h4 id="谈谈对gc的认识"><a href="#谈谈对gc的认识" class="headerlink" title="谈谈对gc的认识"></a>谈谈对gc的认识</h4><blockquote>
<p>gc是jvm的垃圾回收机制 程序里有一个System.gc(); 但这个不能说是调用jvm的回收系统，而是请求jvm回收。 jvm的回收机制不受代码控制，只能设置jvm的堆的常量 Xmx3550m Xms3550m Xmn2g Xss128k</p>
</blockquote>
<h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>回答思路：事务是干什么的&gt;事务的ACID特性&gt;事务的隔离级别</p>
<blockquote>
<p>事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取。事务的正确执行使得数据库从一种状态转换成另一种状态<br>原子性。即不可分割性，事务要么全部被执行，要么就全部不被执行。如果事务的所有子事务全部提交成功，则所有的数据库操作被提交，数据库状态发生转换；如果有子事务失败，则其他子事务的数据库操作被回滚，即数据库回到事务执行前的状态，不会发生状态转换<br>一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态<br>隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，即在事务正确提交之前，它可能的结果不应显示给任何其他事务<br>持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存<br>对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题，这些并发问题可归纳为以下几类<br>第一类丢失更新：撤销一个事务时，把其他事务已提交的更新数据覆盖。　<br>脏读：一个事务读到另一个事务为提交的更新数据。<br>虚读：一个事务读到另一个事务已提交的新插入的数据。<br>不可重复读：一个事务读到另一个事务已提交的更新数据。<br>第二类丢失更新：这是不可重复读中的特例，一个事务覆盖另一个事务已提交的更新数据。</p>
</blockquote>
<p>隔离级别</p>
<blockquote>
<p>Serializable(串行化)：一个事务在执行过程中完全看不到其他事务对数据库所做的更新。<br>    Repeatable Read(可重复读)：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务对已有记录的更新。<br>    Read Commited（读已提交数据）：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的对已有记录的更新<br>    Read Uncomitted（读未提交数据）：一个事务在执行过程中可以拷打其他事务没有提交的新插入的记录，而且能看到其他事务没有提交的对已有记录的更新。<br>    悲观锁<br>    .乐观锁</p>
</blockquote>
<h4 id="数据库设计三范式是什么"><a href="#数据库设计三范式是什么" class="headerlink" title="数据库设计三范式是什么"></a>数据库设计三范式是什么</h4><p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<blockquote>
<p>第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；<br>通俗的理解是，字段还可以再分吗？如过不能，则是符合1NF的设计。<br>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>也就是说主键列与非主键列遵循完全函数依赖关系<br>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。<br>也就是说非主键列之间没有传递函数依赖关系<br>打个比方，比如评论表，如果你将用户ID，用户头像都放在这留言表中，就是不合适的了。用户头像是依赖于用户ID，而不依赖该评论。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习效果检验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见面试题之java集合二]]></title>
      <url>http://www.myzwl.win/2017/09/01/face_2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="说说java集合框架"><a href="#说说java集合框架" class="headerlink" title="说说java集合框架"></a>说说java集合框架</h4><p>ArrayList和Vector有何异同点？</p>
<blockquote>
<p>ArrayList和Vector在很多时候都很类似。<br>（1）两者都是基于索引的，内部由一个数组支持。<br>（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。<br>（3）ArrayList和Vector的迭代器实现都是fail-fast的。<br>（4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。<br>ArrayList和Vector的不同点。<br>（1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。<br>（2）ArrayList比Vector快，它因为有同步，不会过载。<br>（3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表</p>
</blockquote>
<p>Array和ArrayList有何区别？什么时候更适合用Array？</p>
<blockquote>
<p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。<br>Array是指定大小的，而ArrayList大小是固定的。<br>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。<br>（1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。<br>（2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。<br>（3）如果你要使用多维数组，使用[][]比List<list<>&gt;更容易。</list<></p>
</blockquote>
<p>ArrayList和LinkedList有何区别？</p>
<blockquote>
<p>(1）ArrayList是由Array所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，复杂度为O(1)，但LinkedList存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为O(n)，比ArrayList要慢。<br>（2）与ArrayList相比，在LinkedList中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。<br>（3）LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。</p>
</blockquote>
<p>哪些集合类提供对元素的随机访问？</p>
<blockquote>
<p>ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问</p>
</blockquote>
<p>哪些集合类是线程安全的？</p>
<blockquote>
<p>Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。</p>
</blockquote>
<p>并发集合类是什么？</p>
<blockquote>
<p>Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。</p>
</blockquote>
<p>BlockingQueue是什么？</p>
<blockquote>
<p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>
</blockquote>
<p>队列和栈是什么，列出它们的区别？</p>
<blockquote>
<p>栈和队列两者都被用来预存储数据。java.util.Queue是一个接口，它的实现类在Java并发包中。队列允许先进先出（FIFO）检索元素，但并非总是这样。Deque接口允许从两端检索元素。<br>栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。<br>Stack是一个扩展自Vector的类，而Queue是一个接口。</p>
</blockquote>
<p>Collections类是什么？</p>
<blockquote>
<p>Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。这个类包含集合框架算法的方法，比如折半搜索、排序、混编和逆序等。</p>
</blockquote>
<p>Comparable和Comparator接口是什么？</p>
<blockquote>
<p>如果我们想使用Array或Collection的排序方法时，需要在自定义类里实现Java提供Comparable接口。Comparable接口有compareTo(T OBJ)方法，它被排序方法所使用。我们应该重写这个方法，如果“this”对象比传递的对象参数更小、相等或更大时，它返回一个负整数、0或正整数。但是，在大多数实际情况下，我们想根据不同参数进行排序。比如，作为一个CEO，我想对雇员基于薪资进行排序，一个HR想基于年龄对他们进行排序。这就是我们需要使用Comparator接口的情景，因为Comparable.compareTo(Object o)方法实现只能基于一个字段进行排序，我们不能根据对象排序的需要选择字段。Comparator接口的compare(Object o1, Object o2)方法的实现需要传递两个对象参数，若第一个参数比第二个小，返回负整数；若第一个等于第二个，返回0；若第一个比第二个大，返回正整数。</p>
</blockquote>
<p>Comparable和Comparator接口有何区别？</p>
<blockquote>
<p>Comparable和Comparator接口被用来对对象集合或者数组进行排序。Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。<br>Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。</p>
</blockquote>
<p>我们如何对一组对象进行排序？</p>
<blockquote>
<p>如果我们需要对一个对象数组进行排序，我们可以使用Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用Collection.sort()方法。两个类都有用于自然排序（使用Comparable）或基于标准的排序（使用Comparator）的重载方法sort()。Collections内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections需要花时间将列表转换为数组。</p>
</blockquote>
<p>当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？</p>
<blockquote>
<p>在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。</p>
</blockquote>
<p>我们如何从给定集合那里创建一个synchronized的集合？</p>
<blockquote>
<p>我们可以使用Collections.synchronizedCollection(Collection c)根据指定集合来获取一个synchronized（线程安全的）集合。</p>
</blockquote>
<p>大写的O是什么？举几个例子？</p>
<blockquote>
<p>大写的O描述的是，就数据结构中的一系列元素而言，一个算法的性能。Collection类就是实际的数据结构，我们通常基于时间、内存和性能，使用大写的O来选择集合实现。比如：例子1：ArrayList的get(index i)是一个常量时间操作，它不依赖list中元素的数量。所以它的性能是O(1)。例子2：一个对于数组或列表的线性搜索的性能是O(n)，因为我们需要遍历所有的元素来查找需要的元素。</p>
</blockquote>
<p>与Java集合框架相关的有哪些最好的实践？</p>
<blockquote>
<p>（1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。<br>（2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。<br>（3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。<br>（4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。<br>（5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。<br>（6）尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习效果检验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见面试题之java集合一]]></title>
      <url>http://www.myzwl.win/2017/09/01/face_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="说说java集合框架"><a href="#说说java集合框架" class="headerlink" title="说说java集合框架"></a>说说java集合框架</h4><p>回答思路：集合是什么，作用&gt;分类&gt;各自底层实现原理&gt;各自应用场景</p>
<p>集合框架的部分优点如下：</p>
<blockquote>
<p>一 使用核心集合类降低开发成本，而非实现我们自己的集合类<br>二：随着使用经过严格测试的集合框架类，代码质量会得到提高。<br>三：通过使用JDK附带的集合类，可以降低代码维护成本<br>四：复用性和可操作性。</p>
</blockquote>
<p>集合框架中的泛型有什么优点？</p>
<blockquote>
<p>Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息</p>
</blockquote>
<p>Java集合框架的基础接口有哪些？</p>
<blockquote>
<p>Collection为集合层级的根接口<br>Set是一个不能包含重复元素的集合<br>List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。<br>Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。<br>一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator</p>
</blockquote>
<p>为何Collection不从Cloneable和Serializable接口继承？</p>
<blockquote>
<p>Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。</p>
</blockquote>
<p>为何Map接口不继承Collection接口？<br>尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然<br>如果Map继承Collection接口，Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。</p>
<p>Iterator是什么？</p>
<blockquote>
<p>Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例、迭代器允许调用者在迭代过程中移除元素。</p>
</blockquote>
<p>为何迭代器没有一个方法可以直接获取下一个元素，而不需要移动游标？</p>
<blockquote>
<p>它可以在当前Iterator的顶层实现，但是它用得很少，如果将它加到接口中，每个继承都要去实现它，这没有意义。</p>
</blockquote>
<p>Iterater和ListIterator之间有什么区别？</p>
<blockquote>
<p>一:我们可以使用Iterator来遍历Set和List集合，而ListIterator只能遍历List。<br>二:Iterator只可以向前遍历，而LIstIterator可以双向遍历。<br>三:ListIterator从Iterator接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p>
</blockquote>
<p>通过迭代器fail-fast属性，你明白了什么？</p>
<blockquote>
<p>每次我们尝试获取下一个元素的时候，Iterator fail-fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计的（ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外）。</p>
</blockquote>
<p>fail-fast与fail-safe有什么区别？</p>
<blockquote>
<p>Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-fast的，而java.util.concurrent中的集合类都为fail-safe的。Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。</p>
</blockquote>
<p>在迭代一个集合的时候，如何避免ConcurrentModificationException？</p>
<blockquote>
<p>在遍历一个集合的时候，我们可以使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnWriteArrayList，而不是ArrayList。</p>
</blockquote>
<p>为何Iterator接口没有具体的实现？</p>
<blockquote>
<p>Iterator接口定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的Iterator的集合类都有它自己的Iterator实现内部类。<br>这就允许集合类去选择迭代器是fail-fast还是fail-safe的。比如，ArrayList迭代器是fail-fast的，而CopyOnWriteArrayList迭代器是fail-safe的。</p>
</blockquote>
<p>UnsupportedOperationException是什么？<br>UnsupportedOperationException是用于表明操作不支持的异常。在JDK类中已被大量运用，在集合框架java.util.Collections.UnmodifiableCollection将会在所有add和remove操作中抛出这个异常。</p>
<p>在Java中，HashMap是如何工作的？(重点)</p>
<blockquote>
<p>HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值<br>其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。HashMap默认的初始容量是32，负荷系数是0.75。阀值是为负荷系数乘以容量，无论何时我们尝试添加一个entry，如果map的大小比阀值大的时候，HashMap会对map的内容进行重新哈希，且使用更大的容量。容量总是2的幂，所以如果你知道你需要存储大量的key-value对，比如缓存从数据库里面拉取的数据，使用正确的容量和负荷系数对HashMap进行初始化是个不错的做法。</p>
</blockquote>
<p>hashCode()和equals()方法有何重要性？</p>
<blockquote>
<p>HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：<br>（1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。<br>（2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。</p>
</blockquote>
<p>我们能否使用任何类作为Map的key？</p>
<blockquote>
<p>我们可以使用任何类作为Map的key，然而在使用它们之前，需要考虑以下几点：<br>（1）如果类重写了equals()方法，它也应该重写hashCode()方法。<br>(2）类的所有实例需要遵循与equals()和hashCode()相关的规则。请参考之前提到的这些规则。<br>（3）如果一个类没有使用equals()，你不应该在hashCode()中使用它。<br>（4）用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。<br>比如，我有一个类MyKey，在HashMap中使用它<br>//传递给MyKey的name参数被用于equals()和hashCode()中<br>MyKey key = new MyKey(‘Pankaj’); //assume hashCode=1234<br>myHashMap.put(key, ‘Value’);<br>// 以下的代码会改变key的hashCode()和equals()值<br>key.setName(‘Amit’); //assume new hashCode=7890<br>//下面会返回null，因为HashMap会尝试查找存储同样索引的key，而key已被改变了，匹配失败，返回null<br>myHashMap.get(new MyKey(‘Pankaj’));<br>那就是为何String和Integer被作为HashMap的key大量使用。</p>
</blockquote>
<p>Map接口提供了哪些不同的集合视图？</p>
<blockquote>
<p>Map接口提供三个集合视图：<br>Set keyset()、Collection values()、Set<map.entry<k,v>&gt; entrySet()</map.entry<k,v></p>
</blockquote>
<p>HashMap和HashTable有何不同？</p>
<blockquote>
<p>（1）HashMap允许key和value为null，而HashTable不允许。<br>（2）HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。<br>（3）在Java1.4中引入了LinkedHashMap，HashMap的一个子类，假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。<br>（4）HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。</p>
</blockquote>
<p>如何决定选用HashMap还是TreeMap？</p>
<blockquote>
<p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习效果检验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图的深度和广度遍历]]></title>
      <url>http://www.myzwl.win/2017/08/01/graph_2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图是数据结构中最复杂的，正是因为它的复杂，它也是最优魅力的。当然图的存储结构有多种方式，最常用的就是邻接矩阵和邻接表。为了方便，这里图的遍历使用邻接矩阵表示</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><img src="/images/imgs4/35.gif" alt="Alt text"><br>如图，这里只画了无向图，其中顶点由一个一维数组表示，一个二维数组存储图中的边或弧的信息，可以发现无向图是一个对称矩阵，并且约定二维数组arc[i][j]=w，若边（vi，vj）属于该图，arc[i][j]=0，若i=j，否则arc[i][j]=一个无强大值，图中是用1代替了，实际中按上述规则<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">typedef char VertexType; /* 顶点类型应由用户定义 */</div><div class="line">typedef int EdgeType; /* 边上的权值类型应由用户定义 */</div><div class="line"></div><div class="line">#define MAXSIZE 9 /* 存储空间初始分配量 */</div><div class="line">#define MAXEDGE 15</div><div class="line">#define MAXVEX 9</div><div class="line">#define INFINITY 65535</div><div class="line"></div><div class="line">typedef struct&#123;</div><div class="line">	VertexType vexs[MAXVEX];          /* 顶点表 */</div><div class="line">	EdgeType arc[MAXVEX][MAXVEX];     /* 邻接矩阵，可看作边表 */</div><div class="line">	int numVertexes,numEdges;         /* 图中当前的顶点数和边数 */ </div><div class="line">&#125;MGraph;</div><div class="line"></div><div class="line">void CreateMGraph(MGraph *G)</div><div class="line">&#123;</div><div class="line">	int i,j,k,w;</div><div class="line">	printf("输入顶点数和边数:\n");</div><div class="line">	scanf("%d,%d",&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);</div><div class="line">	for(i=0;i&lt;G-&gt;numVertexes;i++)</div><div class="line">		scanf(&amp;G-&gt;vexs[i]);</div><div class="line">	for(i=0;i&lt;G-&gt;numVertexes;i++)</div><div class="line">		for(j=0;j&lt;G-&gt;numVertexes;j++)</div><div class="line">			G-&gt;arc[i][j]=INFINITY;</div><div class="line">		for(k=0;k&lt;G-&gt;numEdges;k++)</div><div class="line">		&#123;</div><div class="line">			printf("输入边（vi，vj）上的下标i，下标j和权值w：\n");</div><div class="line">		     scanf("%d,%d,%d",&amp;i,&amp;j,&amp;w);</div><div class="line">		     G-&gt;arc[i][j]=w;</div><div class="line">		     G-&gt;arc[j][i]=G-&gt;arc[i][j];</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p><img src="/images/imgs4/18.jpg" alt="Alt text"><br>图的遍历就是指从图中某一顶点出发遍历图中其余顶点且使每一个顶点仅被访问一次，然而由于同一个图可能在空间形式上有不同画法，所以造成不能采用之前使用的双亲等方法，所以可以把访问过的顶点打上标记，即设置一个访问数组visited[n]，n是图中原点个数，初值为0，访问过后设置为1，这样就可以避免访问重复的了<br>而深度优先遍历，也叫深度优先搜索，简称DFS，就像在一个房子中搜索一样，从每一个房间开始，而是不留死角的搜索，也就是说该房间内所有地方搜索完，在去搜索其他房间，以此类推<br>从图中可以发现它是一个递归过程，也就是像二叉树的先序遍历，只不过，已经遍历的结点可以跳过</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">void CreateMGraph(MGraph *G)</div><div class="line">&#123;</div><div class="line">	int i, j;</div><div class="line"></div><div class="line">	G-&gt;numEdges=15;</div><div class="line">	G-&gt;numVertexes=9;</div><div class="line"></div><div class="line">	/* 读入顶点信息，建立顶点表 */</div><div class="line">	G-&gt;vexs[0]='A';</div><div class="line">	G-&gt;vexs[1]='B';</div><div class="line">	G-&gt;vexs[2]='C';</div><div class="line">	G-&gt;vexs[3]='D';</div><div class="line">	G-&gt;vexs[4]='E';</div><div class="line">	G-&gt;vexs[5]='F';</div><div class="line">	G-&gt;vexs[6]='G';</div><div class="line">	G-&gt;vexs[7]='H';</div><div class="line">	G-&gt;vexs[8]='I';</div><div class="line"></div><div class="line"></div><div class="line">	for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */</div><div class="line">	&#123;</div><div class="line">		for ( j = 0; j &lt; G-&gt;numVertexes; j++)</div><div class="line">		&#123;</div><div class="line">			G-&gt;arc[i][j]=0;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	G-&gt;arc[0][1]=1;</div><div class="line">	G-&gt;arc[0][5]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[1][2]=1; </div><div class="line">	G-&gt;arc[1][8]=1; </div><div class="line">	G-&gt;arc[1][6]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[2][3]=1; </div><div class="line">	G-&gt;arc[2][8]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[3][4]=1;</div><div class="line">	G-&gt;arc[3][7]=1;</div><div class="line">	G-&gt;arc[3][6]=1;</div><div class="line">	G-&gt;arc[3][8]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[4][5]=1;</div><div class="line">	G-&gt;arc[4][7]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[5][6]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[6][7]=1; </div><div class="line"></div><div class="line">	</div><div class="line">	for(i = 0; i &lt; G-&gt;numVertexes; i++)</div><div class="line">	&#123;</div><div class="line">		for(j = i; j &lt; G-&gt;numVertexes; j++)</div><div class="line">		&#123;</div><div class="line">			G-&gt;arc[j][i] =G-&gt;arc[i][j];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Boolean visited[MAXSIZE];//访问标志的数组</div><div class="line"></div><div class="line">//深度优先递归算法</div><div class="line">void DFS(MGraph G,int i)&#123;</div><div class="line">	int j;</div><div class="line">	visited[i]=TRUE;</div><div class="line">	printf("%c",G.vexs[i]);</div><div class="line">	for(j=0;j&lt;G.numVertexes;j++)</div><div class="line">		if(G.arc[i][j]==1&amp;&amp;!visited[j]) //对未访问的顶点递归调用</div><div class="line">			DFS(G,j);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//深度遍历</div><div class="line">void DFSTraverse(MGraph G)&#123;</div><div class="line">	int i;</div><div class="line">	for(i=0;i&lt;G.numVertexes;i++) //初始化</div><div class="line">		visited[i]=FALSE;</div><div class="line">	for(i=0;i&lt;G.numVertexes;i++)</div><div class="line">		if(!visited[i])</div><div class="line">			DFS(G,i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	MGraph G;</div><div class="line">	CreateMGraph(&amp;G);</div><div class="line">	printf("\n深度遍历：");</div><div class="line">	DFSTraverse(G);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了方便，就创建图的过程写死，最终深度遍历的结果为ABCDEFGHI</p>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>又称为广度优先搜索，简称BFS，它像二叉树遍历中的层序遍历，也就是一层一层的遍历，如上图，与A相连的有B、F，先遍历，又与B相连的有C,I,G，F相连的有G,E，所以下一层为C,I,G,F，依次类推一层一层遍历<br><img src="/images/imgs4/19.jpg" alt="Alt text"><br>如图它的核心思想就是构造一个队列，每一层的结点，如A出队后，与它相连的下一层结点B、F就要入队开始遍历，然后B遍历完出队，与B相连的下一层结点C、I、J入队，依次类推<br><strong>队列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/* 循环队列的顺序存储结构 */</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	int data[MAXSIZE];</div><div class="line">	int front;    	/* 头指针 */</div><div class="line">	int rear;		/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</div><div class="line">&#125;Queue;</div><div class="line"></div><div class="line">/* 初始化一个空队列Q */</div><div class="line">Status InitQueue(Queue *Q)</div><div class="line">&#123;</div><div class="line">	Q-&gt;front=0;</div><div class="line">	Q-&gt;rear=0;</div><div class="line">	return  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */</div><div class="line">Status QueueEmpty(Queue Q)</div><div class="line">&#123; </div><div class="line">	if(Q.front==Q.rear) /* 队列空的标志 */</div><div class="line">		return TRUE;</div><div class="line">	else</div><div class="line">		return FALSE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列未满，则插入元素e为Q新的队尾元素 */</div><div class="line">Status EnQueue(Queue *Q,int e)</div><div class="line">&#123;</div><div class="line">	if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)	/* 队列满的判断 */</div><div class="line">		return ERROR;</div><div class="line">	Q-&gt;data[Q-&gt;rear]=e;			/* 将元素e赋值给队尾 */</div><div class="line">	Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;/* rear指针向后移一位置， */</div><div class="line">								/* 若到最后则转到数组头部 */</div><div class="line">	return  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</div><div class="line">Status DeQueue(Queue *Q,int *e)</div><div class="line">&#123;</div><div class="line">	if (Q-&gt;front == Q-&gt;rear)			/* 队列空的判断 */</div><div class="line">		return ERROR;</div><div class="line">	*e=Q-&gt;data[Q-&gt;front];				/* 将队头元素赋值给e */</div><div class="line">	Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;	/* front指针向后移一位置， */</div><div class="line">									/* 若到最后则转到数组头部 */</div><div class="line">	return  OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>广度遍历</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/* 邻接矩阵的广度遍历算法 */</div><div class="line">void BFSTraverse(MGraph G)</div><div class="line">&#123;</div><div class="line">	int i, j;</div><div class="line">	Queue Q;</div><div class="line">	for(i = 0; i &lt; G.numVertexes; i++)</div><div class="line">       	visited[i] = FALSE;</div><div class="line">    InitQueue(&amp;Q);		/* 初始化一辅助用的队列 */</div><div class="line">    for(i = 0; i &lt; G.numVertexes; i++)  /* 对每一个顶点做循环 */</div><div class="line">    &#123;</div><div class="line">		if (!visited[i])	/* 若是未访问过就处理 */</div><div class="line">		&#123;</div><div class="line">			visited[i]=TRUE;		/* 设置当前顶点访问过 */</div><div class="line">			printf("%c ", G.vexs[i]);/* 打印顶点，也可以其它操作 */</div><div class="line">			EnQueue(&amp;Q,i);		/* 将此顶点入队列 */</div><div class="line">			while(!QueueEmpty(Q))	/* 若当前队列不为空 */</div><div class="line">			&#123;</div><div class="line">				DeQueue(&amp;Q,&amp;i);	/* 将队对元素出队列，赋值给i */</div><div class="line">				for(j=0;j&lt;G.numVertexes;j++) </div><div class="line">				&#123; </div><div class="line">					/* 判断其它顶点若与当前顶点存在边且未访问过  */</div><div class="line">					if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) </div><div class="line">					&#123; </div><div class="line"> 						visited[j]=TRUE;			/* 将找到的此顶点标记为已访问 */</div><div class="line">						printf("%c ", G.vexs[j]);	/* 打印顶点 */</div><div class="line">						EnQueue(&amp;Q,j);				/* 将找到的此顶点入队列  */</div><div class="line">					&#125; </div><div class="line">				&#125; </div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	MGraph G;</div><div class="line">	CreateMGraph(&amp;G);</div><div class="line">	printf("\n深度遍历：");</div><div class="line">	DFSTraverse(G);</div><div class="line">	printf("\n广度遍历：");</div><div class="line">	BFSTraverse(G);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终的结果是</p>
<blockquote>
<p>A B F C I G E D H</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后发现深度优先和广度优先遍历的时间复杂度是一样的，他们的适用场景不一样，深度优先更适合目标比较明确，已找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[反射机制简单总结]]></title>
      <url>http://www.myzwl.win/2017/07/31/reflaction_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>反射机制是java中非常非常重要的东西，比如以前模拟jdk的代理实现和spring的aop实现都用到了反射（见以前设计模式总结），同时，正是由于反射机制，才让我们能更动态的去写程序，比如说在配置文件中配置配置，就能调用某些方法，是在太方便了，下面就开始探索反射机制，下图是类的加载模型<br><img src="/images/imgs4/33.gif" alt="Alt text"></p>
<h4 id="ClassLoad类加载过程"><a href="#ClassLoad类加载过程" class="headerlink" title="ClassLoad类加载过程"></a>ClassLoad类加载过程</h4><p>它的特点是1.并非一次性加载<br>2.需要的时候加载（运行期动态加载）<br>3.static语句块在加载后执行一次<br>4.dynamic语句块每次new新的对象都会执行（等同于构造方法中语句）<br><strong>程序验证</strong><br>在eclipse中有-verbose:class运行命令可详细的打印出jvm虚拟机第一次在内存中加载类的详细信息，如下：<br>先看模拟的程序<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		new A();		</div><div class="line">		System.out.println("**------------------------**");</div><div class="line">		new B();</div><div class="line">        new C();</div><div class="line">        new C();</div><div class="line">        new D();</div><div class="line">        new D();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class A&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C&#123;</div><div class="line">	static&#123;</div><div class="line">		System.out.println("CCCCCCCCCCCCCCCCCCCCCCCCCCC");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class D&#123;</div><div class="line">	&#123;</div><div class="line">		System.out.println("DDDDDDDDDDDDDDDDDDDDDDDDDDDD");</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中d就是动态方法<br>以下是输出结果</p>
<blockquote>
<p>[Opened E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.lang.Object from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.io.Serializable from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>。。。。。。<br>[Loaded com.zwl.tree.A from file:/E:/ecli/shiro/target/classes/]</p>
<hr>
<p>[Loaded com.zwl.tree.B from file:/E:/ecli/shiro/target/classes/]<br>[Loaded com.zwl.tree.C from file:/E:/ecli/shiro/target/classes/]<br>CCCCCCCCCCCCCCCCCCCCCCCCCCC<br>[Loaded com.zwl.tree.D from file:/E:/ecli/shiro/target/classes/]<br>DDDDDDDDDDDDDDDDDDDDDDDDDDDD<br>DDDDDDDDDDDDDDDDDDDDDDDDDDDD<br>[Loaded java.lang.Shutdown from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.lang.Shutdown$Lock from E:\myeclipse\jdk1.8\jre\lib\rt.jar]</p>
</blockquote>
<p>可以发现，jvm在初始化执行程序时需要加载很多类到内存中，并且是动态加载的，就像A和B中间输出语句打印出来，说明不是一次性加载的，这里静态函数只加载了一次，动态方法每次都会加载，其实还有一点，就是jvm会在类加载时，找到jdk中已有的类加载，加载过了一次，就不加载了如D</p>
<h4 id="classLoad类"><a href="#classLoad类" class="headerlink" title="classLoad类"></a>classLoad类</h4><p>事实上，jdk中有各种各样的ClassLoad将类加载进内存，大致分为以下几种</p>
<blockquote>
<p>一：bootstrap class loader<br>implemented by native language and load ths core classes of jdk<br>也就是说，它不是用java写的，而是用操作系统语言，如c、c++写的加载类，它是最核心的类用于加载java中核心的类，当然他没有具体名字<br>二:extesion class loader<br>loader the class from jre/lib/ext<br>三:application class loader<br>load user-define classes and ClassLoader.getSystemClassLoader()<br>也就是说它是java的核心类用于加载用户自定义的类和其他类<br>四:other class loaders<br>SecureClassLoader、URLClassLoader等等，该类是其他加载类加载其它类</p>
</blockquote>
<p><strong>程序验证</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(String.class.getClassLoader());</div><div class="line">	System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());</div><div class="line">	System.out.println(Test.class.getClassLoader().getClass().getName());</div><div class="line">	System.out.println(ClassLoader.getSystemClassLoader().getClass().getName());</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>null<br>sun.misc.Launcher$ExtClassLoader<br>sun.misc.Launcher$AppClassLoader<br>sun.misc.Launcher$AppClassLoader</p>
</blockquote>
<p>分析一下：String类bootstrap类加载的类，但是它的加载类是空，而DESKeyFactory的的加载类是扩展类，而第三和第四都是java核心类加载，总之，我们知道classload是有多种并且有顺序和层次的<br><img src="/images/imgs4/34.gif" alt="Alt text"></p>
<p>如</p>
<blockquote>
<p>ClassLoader c=Test.class.getClassLoader();<br>        while(c!=null){<br>            System.out.println(c.getClass().getName());<br>            c=c.getParent();<br>        }</p>
</blockquote>
<p>结果：</p>
<blockquote>
<p>sun.misc.Launcher$AppClassLoader<br>sun.misc.Launcher$ExtClassLoader</p>
</blockquote>
<p>注意这里的getparent（）是得到引用，不是继承。也就是说jdk底层深层次加载是，问上一层有没有加载我这个类，如果加载了就不加载了</p>
<h4 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h4><p>从classload的角度来看，内存中的一切包括方法等都是对象，也就是说我们可以动态的调用，jdk中为我们提供了类methods类如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;</div><div class="line">		</div><div class="line">		String str="com.zwl.tree.T";</div><div class="line">		Class c=Class.forName(str);</div><div class="line">		Object o=c.newInstance();</div><div class="line">		Method[] methods=c.getMethods();</div><div class="line">		for(Method m:methods)&#123;</div><div class="line">			if(m.getName().equals("mm"))&#123;</div><div class="line">			m.invoke(o);</div><div class="line">			&#125;</div><div class="line">			if(m.getName().equals("m1"))&#123;</div><div class="line">				m.invoke(o, 1,2);</div><div class="line">				System.out.println(m.getReturnType().getName());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	class T&#123;</div><div class="line">	</div><div class="line">	static&#123;</div><div class="line">		System.out.println("T loader!");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public T()&#123;</div><div class="line">		System.out.println("T constructed!");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	int i;</div><div class="line">	String s;</div><div class="line">	public void m1(int i,int j)&#123;</div><div class="line">		this.i=i+j;	</div><div class="line">		System.out.println(this.i);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void mm()&#123;</div><div class="line">		System.out.println("mm");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String getS()&#123;</div><div class="line">		return s;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<blockquote>
<p>T loader!<br>T constructed!<br>mm<br>3<br>void</p>
</blockquote>
<p>上面的程序通过class提供的forname（）方法将相应的类加载至内存，然后通过newInstance()方法取得实例，methods方法能够得到一个类的所有方法，最后通过public Object invoke(Object obj,Object… args)第二个参数是可变参数，也就是可以有多个参数来调用相应对象的相应方法，而getReturnType()是拿到方法的返回类型，也就是说我们通过class和methods可以动态的调用方法，就好比我们只要在配置文件中配置一下类或方法名，就可以动态的调用类或方法，是在是太方便了</p>
<h4 id="反射一些类常用方法"><a href="#反射一些类常用方法" class="headerlink" title="反射一些类常用方法"></a>反射一些类常用方法</h4><p><strong>ClassLoader常用方法</strong></p>
<blockquote>
<p>public abstract class ClassLoaderextends Object<br>构造方法：<br>protected ClassLoader()：使用方法 getSystemClassLoader() 返回的 ClassLoader 创建一个新的类加载器，将该加载器作为父类加载器<br>protected ClassLoader(ClassLoader parent)：使用指定的、用于委托操作的父类加载器创建新的类加载器<br>public final ClassLoader getParent()：返回委托的父类加载器<br>public URL getResource(String name)：查找具有给定名称的资源。</p>
</blockquote>
<p><strong>Class常用方法</strong></p>
<blockquote>
<p>public final class Class<t>extends Objectimplements Serializable, GenericDeclaration, Type, AnnotatedElement<br>Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的<br>public static Class&lt;?&gt; forName(String className)throws ClassNotFoundException：返回与带有给定字符串名的类或接口相关联的 Class 对象<br>public ClassLoader getClassLoader()：返回该类的类加载器<br>public Method[] getMethods()throws SecurityException：返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。<br>public String getName()：以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称<br>public String getName()：查找带有给定名称的资源。<br>public T newInstance()throws InstantiationException,IllegalAccessException： 创建此 Class 对象所表示的类的一个新实例。</t></p>
</blockquote>
<p><strong>Methods类常用方法</strong></p>
<blockquote>
<p>public final class Methodextends AccessibleObjectimplements GenericDeclaration, Member<br>public String getName():以 String 形式返回此 Method 对象表示的方法名称。<br>public Class&lt;?&gt; getReturnType():返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型。<br>public Object invoke(Object obj,<br>                     Object… args)<br>              throws IllegalAccessException,<br>                     IllegalArgumentException,<br>                     InvocationTargetException<br> 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法,此方法为可变参数   </p>
</blockquote>
<p> 反射的知识其实是很复杂的，这里只做了一次简单的总结，反射的应用也是在太广了，像strcts、spring、hibernate、mybatis、spring mvc包括shiro等等框架，你会发现他们的很多底层实现都基于反射机制。。             </p>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[哈夫曼树之压缩与解压]]></title>
      <url>http://www.myzwl.win/2017/07/30/huffman_2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>压缩与解压的另一种说法就是，压缩相当于对文件的加密过程，解压相当于对文件的解密过程，比如说，盲-z，僧-w，那么盲僧-zw，当然加密与解密各种各样，不一定非是字符型的</p>
<h4 id="压缩对比"><a href="#压缩对比" class="headerlink" title="压缩对比"></a>压缩对比</h4><p><img src="/images/imgs4/29.gif" alt="Alt text"><br>如图，最左边是未压缩的原始txt文本文件，里面有38个字节，所以占38字节，中间是利用哈夫曼编码压缩的，居然只占15个字节，最右边是好压自带的压缩，占185个字节，通过对比，发现哈夫曼压缩居然节约这么多空间！</p>
<h4 id="压缩原理"><a href="#压缩原理" class="headerlink" title="压缩原理"></a>压缩原理</h4><p>计算机只能存储二进制数，即非0即1，比如刚学c语言那会接触到的ASCII码，它是专门处理英文的，比如一个字节占8位（由8个01串组成）来表示各种英文字母以及符号，比如0在ASCII编码的十进制表示是48（00110000），a是97，所以英文共有2的8次方个，但是汉字远远不止256个，所以一个汉字用两个字节表示，所以共有2的16次方汉字，而汉字编码一般用UTF-8和GBK等<br><strong>存储过程</strong><br>比如在文件中存储aaabbc，理论上占6个字节，并且存储的二进制为01100001（a）01100001（a）01100001（a）01100010 （b）01100010 （b）01100011 （c）那么哈夫曼是怎么存储该数据的了<br>它是根据某个字出现的次数，比如a出现3次，b出现2次，c出现1次，将次数作为相应字的权值来构造哈夫曼树的<br><img src="/images/imgs4/30.gif" alt="Alt text"><br>所以得到：哈夫曼编码为a（1），b（01），c（00），所以的到压缩后的编码为aaabbc（111010100），注意这里变成2个字节了，然后将该二进制转换成10进制就行了</p>
<h4 id="压缩实现"><a href="#压缩实现" class="headerlink" title="压缩实现"></a>压缩实现</h4><p>一般有以下步骤<br>1.读取文件，统计文件中每个字节出现的次数，将该次数作为权值<br>2.根据权值构建哈夫曼树<br>3，根据哈夫曼树构建码表<br>4在读取文件，通过码表对文件中读取的字节进行加密处理<br><img src="/images/imgs4/31.gif" alt="Alt text"><br>在这里定义了一个256的整型数组（存取次数作为权值）和一个256的字符串数组（存取哈夫曼编码值）</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p><strong>哈夫曼结点</strong><br>与之前不同的是增加了索引，便于搜索<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class HuffmNode &#123;</div><div class="line">	//数据域  </div><div class="line">    private int data;  </div><div class="line">    //索引  </div><div class="line">    private int index;  </div><div class="line">    //左子节点  </div><div class="line">    private HuffmNode left;  </div><div class="line">    //右子节点  </div><div class="line">    private HuffmNode right;  </div><div class="line">      </div><div class="line">    //哈夫曼节点的构造函数  </div><div class="line">    public HuffmNode(int data,int index)&#123;  </div><div class="line">        this.data=data;  </div><div class="line">        this.index=index;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //私有属性的封装  </div><div class="line">    public int getData() &#123;  </div><div class="line">        return data;  </div><div class="line">    &#125;  </div><div class="line">    public void setData(int data) &#123;  </div><div class="line">        this.data = data;  </div><div class="line">    &#125;  </div><div class="line">    public int getIndex() &#123;  </div><div class="line">        return index;  </div><div class="line">    &#125;  </div><div class="line">    public void setIndex(int index) &#123;  </div><div class="line">        this.index = index;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getLeft() &#123;  </div><div class="line">        return left;  </div><div class="line">    &#125;  </div><div class="line">    public void setLeft(HuffmNode left) &#123;  </div><div class="line">        this.left = left;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getRight() &#123;  </div><div class="line">        return right;  </div><div class="line">    &#125;  </div><div class="line">    public void setRight(HuffmNode right) &#123;  </div><div class="line">        this.right = right;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>压缩实现类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">public class Compress &#123;</div><div class="line"></div><div class="line">	 public int[] times=new int[256];</div><div class="line">	 public String[] HuffmCodes=new String[256];</div><div class="line">	 public LinkedList&lt;HuffmNode&gt; list = new LinkedList&lt;HuffmNode&gt;();  </div><div class="line"></div><div class="line">	//初始化 </div><div class="line">     public Compress()&#123;</div><div class="line">    	 for(int i=0;i&lt;HuffmCodes.length;i++)</div><div class="line">    	 &#123;</div><div class="line">    		 HuffmCodes[i]="";</div><div class="line">    	 &#125;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     public void countTimes(String path)throws Exception&#123;</div><div class="line">    	//构造文件输入流</div><div class="line">    	 FileInputStream fis=new FileInputStream(path);</div><div class="line">    	//读取文件  </div><div class="line">    	 int value=fis.read();</div><div class="line">    	 while(value!=-1)&#123;</div><div class="line">    		 times[value]++;</div><div class="line">    		 value=fis.read();</div><div class="line">    	 &#125;</div><div class="line">    	 fis.close(); </div><div class="line">     &#125;</div><div class="line">     </div><div class="line">   //构造哈夫曼树 </div><div class="line">     public HuffmNode createTree()&#123;  </div><div class="line">         //将次数作为权值构造森林  </div><div class="line">         for (int i = 0; i &lt; times.length; i++) &#123;  </div><div class="line">             if(times[i]!=0)&#123;  </div><div class="line">                 HuffmNode node = new HuffmNode(times[i],i);  </div><div class="line">                 //将构造好的节点加入到容器中的正确位置  </div><div class="line">                 list.add(getIndex(node), node);  </div><div class="line">             &#125;  </div><div class="line">         &#125;  </div><div class="line">           </div><div class="line">         //将森林（容器中的各个节点）构造成哈夫曼树  </div><div class="line">         while(list.size()&gt;1) &#123;  </div><div class="line">             //获取容器中第一个元素（权值最小的节点）  </div><div class="line">             HuffmNode firstNode =list.removeFirst();  </div><div class="line">             //获取中新的第一个元素，原来的第一个元素已经被移除了（权值次小的节点）  </div><div class="line">             HuffmNode secondNode =list.removeFirst();  </div><div class="line">             //将权值最小的两个节点构造成父节点  </div><div class="line">             HuffmNode fatherNode =  </div><div class="line">                     new HuffmNode(firstNode.getData()+secondNode.getData(),-1);  </div><div class="line">             fatherNode.setLeft(firstNode);  </div><div class="line">             fatherNode.setRight(secondNode);  </div><div class="line">             //父节点加入到容器中的正确位置  </div><div class="line">             list.add(getIndex(fatherNode),fatherNode);  </div><div class="line">         &#125;  </div><div class="line">         //返回整颗树的根节点  </div><div class="line">         return list.getFirst();  </div><div class="line">     &#125;  </div><div class="line">     </div><div class="line">   //利用前序遍历获取编码表  </div><div class="line">     public void getHuffmCode(HuffmNode root,String code)&#123;  </div><div class="line">         //往左走，哈夫曼编码加0  </div><div class="line">         if(root.getLeft()!=null)&#123;  </div><div class="line">             getHuffmCode(root.getLeft(),code+"0");  </div><div class="line">         &#125;  </div><div class="line">         //往右走，哈夫曼编码加1  </div><div class="line">         if(root.getRight()!=null)&#123;  </div><div class="line">             getHuffmCode(root.getRight(),code+"1");  </div><div class="line">         &#125;  </div><div class="line">         //如果是叶子节点，返回该叶子节点的哈夫曼编码  </div><div class="line">         if(root.getLeft()==null &amp;&amp; root.getRight()==null)&#123;  </div><div class="line">//           System.out.println(root.getIndex()+"的编码为："+code);  </div><div class="line">             HuffmCodes[root.getIndex()]=code;  </div><div class="line">         &#125;  </div><div class="line">     &#125;  </div><div class="line">     </div><div class="line">   //压缩文件 </div><div class="line">     public void compress(String path,String destpath)throws Exception&#123;</div><div class="line">    	//构建文件输出流  </div><div class="line">    	 FileOutputStream fos=new FileOutputStream(destpath);</div><div class="line">    	 FileInputStream fis=new FileInputStream(path);</div><div class="line">    	        </div><div class="line">         //读文件，并将对应的哈夫曼编码串接成字符串  </div><div class="line">    	 int value=fis.read();</div><div class="line">    	 String str="";</div><div class="line">    	 while(value!=-1)&#123;</div><div class="line">    		 str+=HuffmCodes[value];</div><div class="line">    		 value=fis.read();</div><div class="line">    	 &#125;</div><div class="line">    	 System.out.println(str);</div><div class="line">    	 fis.close();</div><div class="line">    	 </div><div class="line">    	 String s="";</div><div class="line">    	 while(str.length()&gt;=8)&#123;</div><div class="line">    		 s=str.substring(0, 8);</div><div class="line">    		 int b=changeStringToInt(s);</div><div class="line">    		 fos.write(b);</div><div class="line">    		 fos.flush();</div><div class="line">    		 str=str.substring(8);</div><div class="line">    	 &#125;</div><div class="line">    	 </div><div class="line">    	 int last1=8-str.length();</div><div class="line">    	 for(int i=0;i&lt;last1;i++)&#123;</div><div class="line">    		 str+="0";</div><div class="line">    	 &#125;</div><div class="line">    	 s=str.substring(0, 8);  </div><div class="line">         int d=changeStringToInt(s);  </div><div class="line">         fos.write(d);</div><div class="line">         fos.close();</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">   //插入元素位置的索引  </div><div class="line">     public int getIndex(HuffmNode node) &#123;  </div><div class="line">         for (int i = 0; i &lt; list.size(); i++) &#123;  </div><div class="line">             if(node.getData()&lt;=list.get(i).getData())&#123;  </div><div class="line">                 return i;  </div><div class="line">             &#125;  </div><div class="line">         &#125;  </div><div class="line">        return list.size();  </div><div class="line">     &#125;  </div><div class="line">	 </div><div class="line">   //将字符串转换成整数  </div><div class="line">     public int changeStringToInt(String s)&#123; </div><div class="line">    	 int v1=(s.charAt(0)-48)*128;  </div><div class="line">         int v2=(s.charAt(1)-48)*64;  </div><div class="line">         int v3=(s.charAt(2)-48)*32;  </div><div class="line">         int v4=(s.charAt(3)-48)*16;  </div><div class="line">         int v5=(s.charAt(4)-48)*8;  </div><div class="line">         int v6=(s.charAt(5)-48)*4;  </div><div class="line">         int v7=(s.charAt(6)-48)*2;  </div><div class="line">         int v8=(s.charAt(7)-48)*1;  </div><div class="line">         return v1+v2+v3+v4+v5+v6+v7+v8;</div><div class="line">     &#125; </div><div class="line">	 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有几处需要注意下，首先changeStringToInt(String s）方法是根据二进制的定义做转换的，void countTimes(String path)throws Exception中那个value是根据其相应的字节的ASCII码值得，比如a是97，就是times[97]++，初始值都是0；<br>然后void compress(String path,String destpath)throws Exception中读文件刚开始是取8位然后转成int在写进文件，然后取第8未到末尾，在循环直至最后不足8位，在后面补0，在写进去。</p>
<p><strong>测试类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//创建压缩对象  </div><div class="line">      Compress compress = new Compress();  </div><div class="line">      //统计文件中0-255出现的次数  </div><div class="line">      compress.countTimes("C:\\Users\\Administrator\\Desktop\\test.txt");  </div><div class="line">      //构造哈夫曼树，并得到根节点  </div><div class="line">      HuffmNode root=compress.createTree();  </div><div class="line">      //得到哈夫曼编码  </div><div class="line">      compress.getHuffmCode(root, "");  </div><div class="line">      //压缩文件  </div><div class="line">      compress.compress("C:\\Users\\Administrator\\Desktop\\test.txt",  </div><div class="line">              "C:\\Users\\Administrator\\Desktop\\tes.zip");</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>1011010101110010110101011011011011100111011110011000010000100111010100010000010011111101101111110111111011000010000100</p>
</blockquote>
<p>同时会生成一个压缩文件，如前面的图所示</p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p><strong>解压原理</strong><br>之前说过哈夫曼编码不会出现像0和01这样前者是后者子串的情况，所以解压采取的办法就是在压缩时写进去每个编码的长度和对应的编码，就像密码本一样，记录着每个密码的详细信息（这里理解每个密码长度和密码数据域唯一确定一个解码）<br>打个比方，假设ab压缩后为0和10，当然压缩后是变成010，那怎么解码了？，首先在压缩时，在之前压缩代码上加上一个记录编码长度和对应的编码，像a不是97吗，那在写入时记录code[97]=1，对应的编码str[97]=0，code[98]=1；str[98]=0，一次类推，写入时是先写入编码长度的，不过要将字符串转换成十进制，然后通过字符串分割成不同编码，这样每个字节也就拿到手了<br>模拟一下，不妨把abbcc先压缩，然后读出它的二进制如下</p>
<blockquote>
<p>000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015214308</p>
</blockquote>
<p>再来分析分析：<br>前面在152之前都是存取密码长度的信息，212是对应ASSII码的相应字节的编码长度，如a（10）、b（0），c（11）所以长度分别对应212，接下来就是152也就是abc的二进制值了，10011，不足8位后面补0，即10011000，对应十进制就是152，后面143就是文本的需要解密的编码，后面08没有弄懂，在压缩文件中并没有输入这个东西，也做了大量实验发现都有后面这些数字，暂且认为就是压缩文件自带的标识吧（逻辑上还没有证明，所以勉强这么认为）<br>所以，解码思路就是先根据长度读取相应位置，然后分割每个位置得到相应二进制编码，最后再转回来，看看编码的打印结果</p>
<blockquote>
<p>0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000212000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000codeLength:1<br>int152<br>哈夫曼编码：10011000<br>huff10<br>huff0<br>huff11<br>需要解密的字符串：10001111<br>截取的字符串：10<br>截取后剩余编码长度：6<br>截取的字符串：0<br>截取后剩余编码长度：5<br>截取的字符串：0<br>截取后剩余编码长度：4<br>截取的字符串：11<br>截取后剩余编码长度：2<br>截取的字符串：11<br>截取后剩余编码长度：0</p>
</blockquote>
<p>不是很规范，但是大概跟踪了过程，长度为5（10011），不足8位不以为，所以codeLength为1,152就是哈夫曼密码手册值了，变成二进制为10011000，然后分割成10,0,11分别对应ASSII码为a、b、c三个字符，需要解密的是10001111，也就是143，解密分别对应abbcc，所以至此完成解密了<br>说了这么多，再来看看代码吧</p>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><p><strong>压缩编码</strong><br>由于解压需要的压缩编码在之前主要修改一点，所以这里就把增加的代码贴出来，分析分析<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//将整个哈夫曼编码以及每个编码的长度写入文件  </div><div class="line">     String code ="";  </div><div class="line">     for (int i = 0; i &lt; 256; i++) &#123;  </div><div class="line">         fos.write(HuffmCodes[i].length());  </div><div class="line">         code+=HuffmCodes[i];  </div><div class="line">         fos.flush();  </div><div class="line">     &#125;  </div><div class="line">     //把哈夫曼编码写入文件  </div><div class="line">       </div><div class="line">  System.out.println("code="+code);  </div><div class="line">     String str1="";  </div><div class="line">     while(code.length()&gt;=8)&#123;  </div><div class="line">         str1=code.substring(0, 8);  </div><div class="line">         int c=changeStringToInt(str1);  </div><div class="line">      System.out.println(c);  </div><div class="line">         fos.write(c);  </div><div class="line">         fos.flush();  </div><div class="line">         code=code.substring(8);  </div><div class="line">     &#125;  </div><div class="line">     //处理最后一个不为8的数  </div><div class="line">     int last=8-code.length();  </div><div class="line">     for (int i = 0; i &lt;last; i++) &#123;  </div><div class="line">         code+="0";  </div><div class="line">     &#125;  </div><div class="line">     str1=code.substring(0, 8);  </div><div class="line">     int c=changeStringToInt(str1); </div><div class="line">     System.out.println("c:"+c);</div><div class="line">     fos.write(c);  </div><div class="line">     fos.flush();</div></pre></td></tr></table></figure></p>
<p>上面代码是说首先我们已经统计了文本中字符出现的次数，压缩那里已经写过了，然后将长度表写入进压缩文件，也就是那一大串000中间含有长度的字符串，存在code里，注意长度为空就是空字符，所以code就是那5位的二进制，然后不足8位的补成8位，再变成十进制也就是152了，这是这段代码与之前增加的部分，我们也称为码表构造</p>
<p><strong>解压实现类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line">//每个编码的长度  </div><div class="line">    public int [] codelengths = new int [256];  </div><div class="line">    //对应的哈夫曼编码值  </div><div class="line">    public String [] codeMap=new String[256];  </div><div class="line">    </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		 Decompress d = new Decompress();  </div><div class="line">	        d.decompress("C:\\Users\\Administrator\\Desktop\\tes.zip",  </div><div class="line">	                "C:\\Users\\Administrator\\Desktop\\mytes.txt"); </div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/* </div><div class="line">     * 解压思路： </div><div class="line">     * 1、读取文件里面的码表 </div><div class="line">     * 2、得到码表 </div><div class="line">     * 3、读取数据 </div><div class="line">     * 4、还原数据 </div><div class="line">     */  </div><div class="line">      </div><div class="line">    public void decompress(String srcpath,String destpath) &#123;  </div><div class="line">    	   </div><div class="line">        try &#123;  </div><div class="line">            FileInputStream fis = new FileInputStream(srcpath);  </div><div class="line">            FileOutputStream fos = new FileOutputStream(destpath);  </div><div class="line">            int zwl;</div><div class="line">            int value;  </div><div class="line">            int codeLength=0;  </div><div class="line">            String code="";  </div><div class="line">            //还原码表  </div><div class="line">            for (int i = 0; i &lt; codelengths.length; i++) &#123;  </div><div class="line">                value=fis.read();  </div><div class="line">                codelengths[i]=value;  </div><div class="line">             System.out.print(codelengths[i]);  </div><div class="line">                codeLength+=codelengths[i];  </div><div class="line">            &#125;  </div><div class="line">           // System.out.println("总长度:"+codeLength);</div><div class="line">            //得到总长度  </div><div class="line">            //将总长度除以8的到字节个数  </div><div class="line">            int len=codeLength/8;  </div><div class="line">            //如果不是8的倍数，则字节个数加1（对应压缩补0的情况）  </div><div class="line">            if((codeLength)%8!=0)&#123;  </div><div class="line">                len++;  </div><div class="line">            &#125;  </div><div class="line">            //读取哈夫曼编码  </div><div class="line">          System.out.println("codeLength:"+len);  </div><div class="line">            for (int i = 0; i &lt; len; i++) &#123;  </div><div class="line">                //把读到的整数转换成二进制  </div><div class="line">            	int s=fis.read();</div><div class="line">            	System.out.println("int"+s);</div><div class="line">                code+=changeIntToString(s);  </div><div class="line">                  </div><div class="line">            &#125;  </div><div class="line">          System.out.println("哈夫曼编码："+code);  </div><div class="line">              </div><div class="line">            for (int i = 0; i &lt; codeMap.length; i++) &#123;  </div><div class="line">                //如果第i个位置不为0 ，则说明第i个位置存储有哈夫曼编码  </div><div class="line">                if(codelengths[i]!=0)&#123;  </div><div class="line">                    //将得到的一串哈夫曼编码按照长度分割分割  </div><div class="line">                    String ss=code.substring(0, codelengths[i]);  </div><div class="line">                    codeMap[i]=ss;  </div><div class="line">                    System.out.println("huff"+codeMap[i]);</div><div class="line">                    code=code.substring(codelengths[i]);  </div><div class="line">                &#125;else&#123;  </div><div class="line">                    //为0则没有对应的哈夫曼编码  </div><div class="line">                    codeMap[i]="";  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">              </div><div class="line">            //读取压缩的文件内容  </div><div class="line">            String codeContent="";  </div><div class="line">            while(fis.available()&gt;1)&#123;  </div><div class="line">                codeContent+=changeIntToString(fis.read());  </div><div class="line">            &#125;  </div><div class="line">            //读取最后一个  </div><div class="line">            value=fis.read();  </div><div class="line">            //把最后补的0给去掉  </div><div class="line">            codeContent=codeContent.substring(0, codeContent.length()-value);  </div><div class="line">                  </div><div class="line">            for (int i = 0; i &lt; codeContent.length(); i++) &#123;  </div><div class="line">                  </div><div class="line">                String codecontent=codeContent.substring(0, i+1);  </div><div class="line">                  </div><div class="line">                for (int j = 0; j &lt; codeMap.length; j++) &#123;  </div><div class="line">                    if(codeMap[j].equals(codecontent))&#123;  </div><div class="line">                     System.out.println("截取的字符串："+codecontent);  </div><div class="line">                        fos.write(j);  </div><div class="line">                        fos.flush();   </div><div class="line">                        codeContent=codeContent.substring(i+1);  </div><div class="line">                    System.out.println("截取后剩余编码长度："+codeContent.length());  </div><div class="line"> </div><div class="line">                        i=-1;  </div><div class="line">                        break;  </div><div class="line">                    &#125;  </div><div class="line">            &#125;  </div><div class="line">            &#125;  </div><div class="line"></div><div class="line">              </div><div class="line">            fos.close();  </div><div class="line">            fis.close();  </div><div class="line">              </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //十进制转二进制字符串  </div><div class="line">    public String changeIntToString(int value) &#123;  </div><div class="line">        String s="";  </div><div class="line">        for (int i = 0; i &lt; 8; i++) &#123;  </div><div class="line">            s=value%2+s;  </div><div class="line">            value=value/2;  </div><div class="line">        &#125;  </div><div class="line">        return s;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的codelengths[]和codeMap[]就是分别存放码表和码表值的数组，流程就是先读取文本内容，拿到长度表中有长度的编码，如212，然后判断其是多少个字节，然后读哈夫曼编码，根据字节数，转成二进制后，找到对应的码表，然后就是分割编码了，最后就得到我们想要的解码了。最后<br><img src="/images/imgs4/32.gif" alt="Alt text"><br>分别为压缩前，压缩后的，会发现压缩居然比压缩前占得空间还大，那是因为我们压缩的文件太小了，而之前也比较过了，压缩一般都是针对大文件的</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后不得不说哈夫曼树的精妙让人惊叹和着迷，同时也认识到了计算机底层知识的重要性，当你回过头来再去看以前的知识，会有另一种不同的感受，当然当再去看压缩与解压，原来是这么回事。当然探索的过程是很累的，会遇到各种难题和挫折，而在当下这个追求功利主义，很多时候都是表象的去用一些东西，当然有时候你把时间花在一些与收益不是很正相关的上面，可能会让你的性价比不是很高，但是正是由于这种自娱自乐的快乐，才更让人充实，而不是每天都去追求“外功”。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[哈夫曼树之构建]]></title>
      <url>http://www.myzwl.win/2017/07/30/huffman_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到哈夫曼树，就不得不说它在压缩与解压方面的应用太完美了，就是把一个大的文件，通过算法压缩成一个较小的文件，从而大大节约了空间</p>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>通俗的说就是给定n个权值作为n个叶子结点，构造一颗二叉树，若带权路径长度达到最小，称这样的树为哈夫曼树，也称为最优二叉树，同时，由定义可知，哈夫曼树是带权路径长度最短的树，所以权值较大的结点离根较近<br><img src="/images/imgs4/17.jpg" alt="Alt text"></p>
<h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><p><strong>路径长度</strong><br>结点路径长度：从树中一个结点到另一个结点之间的分支，构成两个结点之间路径，路径上的分支数目称为结点长度，如结点100到结点29的结点路径长度就是2</p>
<p>树的路径长度：从树根到每一个结点的路径长度之和</p>
<p><strong>权值</strong><br>所有叶子结点的date域，也就是当前叶子结点存放的数据域<br><strong>带权路径长度</strong><br>结点带权路径长度：从该节点到树根之间的路径长度与结点上权值的乘积<br>树的带权路径长度：树中所有结点的带权路径长度之和，并且几位WPL，如果WPL最小，则称该二叉树为哈夫曼树</p>
<p><strong>哈夫曼树构建过程</strong><br>它的构建思想其实很简单的，大概如下<br>1.根据给定的n个权值{w1,w2,..wn}构成n棵二叉树的集合F={T1,T2,..Tn};其中每棵二叉树Ti中只有一个带权为wi的根结点，器左右子树为空<br>2：在F中选取两颗根结点权值最小的树作为左右子树构造一颗新二叉树，并且新二叉树的根结点权值为左右子根结点的权值之和<br>3:在F中删除这两颗树，同时将新二叉树加入F中<br>4:重复2和3步骤，知道F中只含一棵树为止</p>
<h4 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h4><p>哈夫曼结点<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class HuffmNode &#123;</div><div class="line">	//构造HuffmNode类  </div><div class="line">    private int data;  </div><div class="line">    private HuffmNode left;  </div><div class="line">    private HuffmNode right;  </div><div class="line">    //HuffmNode类构造函数  </div><div class="line">    public  HuffmNode(int data) &#123;  </div><div class="line">        this.data=data;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //封装属性  </div><div class="line">    public int getData() &#123;  </div><div class="line">        return data;  </div><div class="line">    &#125;  </div><div class="line">    public void setData(int data) &#123;  </div><div class="line">        this.data = data;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getLeft() &#123;  </div><div class="line">        return left;  </div><div class="line">    &#125;  </div><div class="line">    public void setLeft(HuffmNode left) &#123;  </div><div class="line">        this.left = left;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getRight() &#123;  </div><div class="line">        return right;  </div><div class="line">    &#125;  </div><div class="line">    public void setRight(HuffmNode right) &#123;  </div><div class="line">        this.right = right;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造哈夫曼树<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class HuffmTree &#123;  </div><div class="line">      </div><div class="line">    public int [] datas =&#123;42,8,19,100,58,15,29&#125;;  </div><div class="line">    public LinkedList&lt;HuffmNode&gt; list = new LinkedList&lt;HuffmNode&gt;();  </div><div class="line">      </div><div class="line">    public HuffmNode createTree() &#123;  </div><div class="line">        //按照从小到大的将数据封装成节点  </div><div class="line">        for (int i = 0; i &lt; datas.length; i++) &#123;  </div><div class="line">            HuffmNode node = new HuffmNode(datas[i]);  </div><div class="line">            //得到需要插入的位置索引  </div><div class="line">            int index=getIndex(node);  </div><div class="line">            //将数据添加到容器中  </div><div class="line">            list.add(index, node);  </div><div class="line">        &#125;  </div><div class="line">        //构造哈夫曼树  </div><div class="line">        while(list.size()&gt;1)&#123;  </div><div class="line">            //移除容器中的第一个节点  </div><div class="line">            HuffmNode firstNode =list.removeFirst();  </div><div class="line">            //容器中原来的第二个节点变成新的第一个节点  </div><div class="line">            HuffmNode secondNode =list.removeFirst();  </div><div class="line">            //构造父节点数据域  </div><div class="line">            HuffmNode fatherNode = new HuffmNode(firstNode.getData()+secondNode.getData());  </div><div class="line">            //构造父节点左子叶  </div><div class="line">            fatherNode.setLeft(firstNode);  </div><div class="line">            //构造父节点右子叶  </div><div class="line">            fatherNode.setRight(secondNode);  </div><div class="line">            //得到构造好的父节点的索引  </div><div class="line">            int index=getIndex(fatherNode);  </div><div class="line">            //将父节点加入森林  </div><div class="line">            list.add(index, fatherNode);  </div><div class="line">        &#125;  </div><div class="line">        //返回根节点  </div><div class="line">        return list.getFirst();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //得到索引  </div><div class="line">    public int getIndex(HuffmNode node) &#123;  </div><div class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;  </div><div class="line">            if(node.getData()&gt;list.get(i).getData())&#123;  </div><div class="line">                continue;  </div><div class="line">            &#125;else &#123;  </div><div class="line">                return i;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        //如果比容器中的任何一个数大，则插入最后面  </div><div class="line">        return list.size();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //得到哈夫曼编码  </div><div class="line">    public void getHuffmCode(HuffmNode root,String code) &#123;  </div><div class="line">        if(root.getLeft()!=null)&#123;  </div><div class="line">            getHuffmCode(root.getLeft(),code+"0");  </div><div class="line">        &#125;  </div><div class="line">        if(root.getRight()!=null)&#123;  </div><div class="line">            getHuffmCode(root.getRight(),code+"1");  </div><div class="line">        &#125;  </div><div class="line">        if(root.getLeft()==null &amp;&amp; root.getRight()==null)&#123;  </div><div class="line">            System.out.println(root.getData()+":"+code);  </div><div class="line">        &#125;  </div><div class="line">    &#125;   </div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实这段代码就是上述四个步骤的实现，代码也很好理解，带权值为datas，将结点放到链表中，然后注意利用非正规的选择排序将链表集合里权值从小到大排好序，然后开始选择权值最小的两个构造一个新的权值结点，同时删除那两个，加入这个新的。。重复直到只剩一个根结点为止，很明显此时就是哈夫曼树了，最后通过后序遍历得到哈夫曼编码值，这里我们约定左子树一个路径为0，右子树一个路径为1，所以一定不存在像01与010这样前面是后面子串的编码值<br><strong>测试类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		 HuffmTree tree = new HuffmTree();  </div><div class="line">	        HuffmNode root = tree.createTree();</div><div class="line">	        tree.getHuffmCode(root, ""); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>8:000<br>11:001<br>23:01<br>14:100<br>7:1010<br>3:10110<br>5:10111<br>29:11</p>
</blockquote>
<p>注意这里的结果和图示有一个地方不一样，就是那个几点8，这里的结点8是合成的，可以根据结果画出哈夫曼树，比较就会看出不同</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络编程简单总结]]></title>
      <url>http://www.myzwl.win/2017/07/29/socket_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/images/imgs4/16.jpg" alt="Alt text"><br>在java网络编程中最主要的是tcp/ip协议，这个协议也是Internet最基本的协议，而其就是由网络层的ip协议和传输层的tcp协议组成，同时由于分层的思想，也就是每一层只能与它下面的层打交道，也就是说，应用层只跟传输层打交道，传输层只跟网络层打交道</p>
<h4 id="ip协议"><a href="#ip协议" class="headerlink" title="ip协议"></a>ip协议</h4><p><img src="/images/imgs4/27.gif" alt="Alt text"><br>关于底层协议的具体过程是在太复杂了，当初学习计算机网络的时候也是被各种细节弄得云里雾里的，总之ip层就是唯一确定了一台机器，就像我们住的房间地址一样，唯一确定了我们的住处<br>这里需要注意的是，ip地址由四位字节组成，每个字节由8位二进制组成，同时有a，b，c三类地址，如图由网络号和主机号组成，当然这是公网，如果是局域网的话，就需要配网关和子网掩码了，如192.168.1.1和255.255.0.0那么255.255就是确定了ip地址哪几位字节是网络号，如192.168就是网络号，当然其配置各种内网ip是很复杂的，具体参考计算机网络</p>
<h4 id="TCP与UDP协议"><a href="#TCP与UDP协议" class="headerlink" title="TCP与UDP协议"></a>TCP与UDP协议</h4><p><strong>tcp协议</strong></p>
<blockquote>
<p>它是专门设计用于在不可靠的因特网上提供端到端的字节流通信的协议，它是一种面向连接的协议，它连接的是字节流。<br>这里面有几个注意的地方：<br>可靠性：就是建立三次握手过程，就是说，我把信息传给你，等待，收到回复后，在确认。。最后在发送消息，它保证了数据一定发送给了对方，所以是一种可靠传输，但是遇到阻塞效率会很低<br>端口：ip地址唯一确定了这台机器，相当于一个房子，但是你消息总不能发给整个电脑吧，比如qq，而端口就相当于一间房间，具体发给那个，比如送到qq这间房间</p>
</blockquote>
<p><strong>端口分类</strong></p>
<blockquote>
<p>有65536个端口    0号是保留端口<br>1-1024是固定端口<br>又叫有名端口，即被某些程序固定使用，一般程序员不使用。<br>22：SSH远程登录协议    23：telnet使用    21：ftp使用<br>25：smtp服务使用    80：iis使用    7：echo服务<br>1025-65535是动态端口<br>这些端口，程序员可以使用<br>端口(port)–注意事项<br>1、在计算机(尤其是做服务器)要尽可能的少开端口；<br>2、一个端口只能被一个程序监听；<br>3、如果使用netstat -an可以查看本机有哪些端口在监听</p>
</blockquote>
<p><strong>UDP协议</strong><br>UDP向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接。<br>简单来说，就是只发一次数据，不管对方有没有接收到都不会再发了，但是有时候效率会很高，像网络拥堵时</p>
<p><strong>url</strong><br>统一资源定义符也被称为网页地址。Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL地址，这种地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是Internet上的站点，简单地说，URL就是Web地址，俗称“网址”，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法，如：<br><a href="http://www.sina.com:8080/index.html" target="_blank" rel="external">http://www.sina.com:8080/index.html</a><br>1、协议；2、ip地址(32位)；3、端口号(16位)0-65535；4、资源名称。</p>
<p><strong>单工、半双工和全双工</strong><br> 如果甲可以向乙发送数据，但是乙不能向甲发送数据，这样的通信就是单工通信(Simplex Communication)。<br>    单工数据传输只支持数据在一个方向上传输，就和传呼机一样。<br>    半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信，就和对讲机(步话机)一样；<br>全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力，就和电话一样</p>
<h4 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h4><p><img src="/images/imgs4/28.gif" alt="Alt text"><br>如模拟的客户端与服务端<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class MyServer &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new MyServer();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyServer()&#123;</div><div class="line">		try &#123;</div><div class="line">			//在9999号端口上监听</div><div class="line">			ServerSocket ss=new ServerSocket(9999);</div><div class="line">			System.out.println("9999端口监听...");</div><div class="line">			//等待某个客户端来连接，该函数会返回一个Socket连接</div><div class="line">			Socket s=ss.accept();</div><div class="line">			//要读取s中传递的数据</div><div class="line">			InputStreamReader isr=new InputStreamReader(s.getInputStream());</div><div class="line">			BufferedReader br=new BufferedReader(isr);</div><div class="line">			</div><div class="line">			String info=br.readLine();</div><div class="line">			System.out.println("服务器接收到:\t"+info);</div><div class="line">			</div><div class="line">			PrintWriter pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			pw.println("我是服务器，已收到你发送的信息!");</div><div class="line"></div><div class="line"></div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class MyClient &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new MyClient();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyClient()&#123;</div><div class="line">		try &#123;</div><div class="line">			//Socket()就是去连接某个服务器端 127.0.0.1表示服务器的ip</div><div class="line">			//9999是服务器的端口号</div><div class="line">			Socket s=new Socket("127.0.0.1",9999);</div><div class="line">			//如果s连接成功，就可以发送数据到服务器端</div><div class="line">			//我们通过pw向s写数据,true表示即时刷新</div><div class="line">			PrintWriter pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			pw.println("你好吗？我是客户端");</div><div class="line">			//要读取s中传递的数据</div><div class="line">			InputStreamReader isr=new InputStreamReader(s.getInputStream());</div><div class="line">			BufferedReader br=new BufferedReader(isr);</div><div class="line">			String info=br.readLine();</div><div class="line">			System.out.println("接收到服务器：\t"+info);</div><div class="line"></div><div class="line"></div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要注意的几个地方，必须是服务端先开启，然后accept（）等待客户端，没有客户端连接，它将处于阻塞状态，一旦有了客户端它将回应，其次这是理由tcp实现的，UDP实现用java提供的另外类，最后这里有一个问题，就是只能接受一次，需要改进，也就是不断循环接收客户端连接</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">			//在9999号端口上监听</div><div class="line">			ServerSocket ss=new ServerSocket(9999);</div><div class="line">			//等待客户端连接，该函数会返回一个Socket连接</div><div class="line">			Socket s=ss.accept();</div><div class="line">			//要读取s中传递的数据</div><div class="line">			isr=new InputStreamReader(s.getInputStream());</div><div class="line">			br=new BufferedReader(isr);</div><div class="line">			</div><div class="line">			pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			</div><div class="line">			//接收从控制台输入的信息</div><div class="line">			isr2=new InputStreamReader(System.in);</div><div class="line">			br2=new BufferedReader(isr2);</div><div class="line">			while(true)&#123;</div><div class="line">				//接收客户端信息</div><div class="line">				String infoFromClient=br.readLine();</div><div class="line">				System.out.println("服务器接收到:\t"+infoFromClient);</div><div class="line">				//接收从控制台输入的信息</div><div class="line">				System.out.println("请输入要发送到客户端的信息：");</div><div class="line">				String response=br2.readLine();</div><div class="line">				//服务器从控制台上接收bye服务器端退出</div><div class="line">				if(response.equals("bye"))&#123;</div><div class="line">					System.out.println("退出对话");</div><div class="line">					s.close();</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">				//把从控制台输入的信息，回送给客户端</div><div class="line">				pw.println(response);</div><div class="line">			&#125;</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;finally&#123;</div><div class="line">			try &#123;</div><div class="line">				if(br2!=null) br2.close();</div><div class="line">				if(isr2!=null) isr2.close();</div><div class="line">				if(pw!=null) pw.close();</div><div class="line">				if(br!=null) br.close();</div><div class="line">				if(isr!=null) isr.close();</div><div class="line">			&#125; catch (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>最后当然网络编程中也就是流的数据传送的应用，也不得不说网络底层协议其实很复杂的，只有当我们有精力了，再去细细研究它，才会有更多的收获</p>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AVL树]]></title>
      <url>http://www.myzwl.win/2017/07/28/balace_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AVL树，也叫平衡二叉树，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。同时，将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，还将距离插入结点最近的且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树<br><img src="/images/imgs4/25.gif" alt="Alt text"><br>如图：一为一个不平衡二叉排序树，显然时间复杂度较大，二为改进后的平衡二叉树，而在改进的过程中，最重要的就是通过平衡因子来判断是进行左旋还是右旋，如右旋，新增一个节点N后，平衡被打破，需要平衡因子2大于0，需要右旋，就是将其左子树作为根结点，左子树的右子树作为原根结点的左子树，这样做的原因就是根据二叉排序树的左右子树特点来的，很容易想明白</p>
<h4 id="模拟平衡二叉树"><a href="#模拟平衡二叉树" class="headerlink" title="模拟平衡二叉树"></a>模拟平衡二叉树</h4><p>不妨构造一个a[10]={3,2,1,4,5,6,7,10,9,8};<br><img src="/images/imgs4/26.gif" alt="Alt text"><br>大概过程如图所示，其中最重要的就是平衡因子的判断，如果是同号，且绝对值大于1的话，就要做相应的旋转操作，如果是不同号的话，就要通过旋转先转换成同号，在做操作</p>
<h4 id="左右旋操作"><a href="#左右旋操作" class="headerlink" title="左右旋操作"></a>左右旋操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">typedef struct BiTNode</div><div class="line">&#123;</div><div class="line">	int data;</div><div class="line">	int bf;</div><div class="line">	struct BiTNode *lchild,*rchild;</div><div class="line">&#125;BiTNode,*BiTree;</div><div class="line"></div><div class="line">//左旋处理</div><div class="line">void R_Rotate(BiTree *p)&#123;</div><div class="line">	BiTree L;</div><div class="line">	L=(*p)-&gt;lchild;   //L指向p的左子树根结点</div><div class="line">	(*p)-&gt;lchild=L-&gt;rchild; //L的右子树挂接为p的左子树</div><div class="line">	L-&gt;rchild=(*p);  </div><div class="line">	*p=L;           //p指向新的根结点</div><div class="line">&#125;</div><div class="line"></div><div class="line">//右旋处理</div><div class="line">void L_Ronate(BiTree *p)</div><div class="line">&#123;</div><div class="line">	BiTree R;</div><div class="line">	R=(*p)-&gt;rchild; //R指向p的右子树根结点</div><div class="line">	(*p)-&gt;rchild=R-&gt;lchild;  //R的左子树挂接为P的右子树</div><div class="line">	R-&gt;lchild=(*p);</div><div class="line">	*p=R;            //p指向新的根结点</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过之前的图来对比看，其实质也就是交互根结点位置和挂接新左右子树</p>
<h4 id="左右平衡旋转"><a href="#左右平衡旋转" class="headerlink" title="左右平衡旋转"></a>左右平衡旋转</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#define LH +1 /*  左高 */ </div><div class="line">#define EH 0  /*  等高 */ </div><div class="line">#define RH -1 /*  右高 */ </div><div class="line"></div><div class="line">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */</div><div class="line">/*  本算法结束时，指针T指向新的根结点 */</div><div class="line">void LeftBalance(BiTree *T)</div><div class="line">&#123; </div><div class="line">	BiTree L,Lr;</div><div class="line">	L=(*T)-&gt;lchild; /*  L指向T的左子树根结点 */ </div><div class="line">	switch(L-&gt;bf)</div><div class="line">	&#123; /*  检查T的左子树的平衡度，并作相应平衡处理 */ </div><div class="line">		 case LH: /*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */ </div><div class="line">			(*T)-&gt;bf=L-&gt;bf=EH;</div><div class="line">			R_Rotate(T);</div><div class="line">			break;</div><div class="line">		 case RH: /*  新结点插入在T的左孩子的右子树上，要作双旋处理 */ </div><div class="line">			Lr=L-&gt;rchild; /*  Lr指向T的左孩子的右子树根 */ </div><div class="line">			switch(Lr-&gt;bf)</div><div class="line">			&#123; /*  修改T及其左孩子的平衡因子 */ </div><div class="line">				case LH: (*T)-&gt;bf=RH;</div><div class="line">						 L-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case EH: (*T)-&gt;bf=L-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case RH: (*T)-&gt;bf=EH;</div><div class="line">						 L-&gt;bf=LH;</div><div class="line">						 break;</div><div class="line">			&#125;</div><div class="line">			Lr-&gt;bf=EH;</div><div class="line">			L_Rotate(&amp;(*T)-&gt;lchild); /*  对T的左子树作左旋平衡处理 */ </div><div class="line">			R_Rotate(T); /*  对T作右旋平衡处理 */ </div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */ </div><div class="line">/*  本算法结束时，指针T指向新的根结点 */ </div><div class="line">void RightBalance(BiTree *T)</div><div class="line">&#123; </div><div class="line">	BiTree R,Rl;</div><div class="line">	R=(*T)-&gt;rchild; /*  R指向T的右子树根结点 */ </div><div class="line">	switch(R-&gt;bf)</div><div class="line">	&#123; /*  检查T的右子树的平衡度，并作相应平衡处理 */ </div><div class="line">	 case RH: /*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */ </div><div class="line">			  (*T)-&gt;bf=R-&gt;bf=EH;</div><div class="line">			  L_Rotate(T);</div><div class="line">			  break;</div><div class="line">	 case LH: /*  新结点插入在T的右孩子的左子树上，要作双旋处理 */ </div><div class="line">			  Rl=R-&gt;lchild; /*  Rl指向T的右孩子的左子树根 */ </div><div class="line">			  switch(Rl-&gt;bf)</div><div class="line">			  &#123; /*  修改T及其右孩子的平衡因子 */ </div><div class="line">				case RH: (*T)-&gt;bf=LH;</div><div class="line">						 R-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case EH: (*T)-&gt;bf=R-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case LH: (*T)-&gt;bf=EH;</div><div class="line">						 R-&gt;bf=RH;</div><div class="line">						 break;</div><div class="line">			  &#125;</div><div class="line">			  Rl-&gt;bf=EH;</div><div class="line">			  R_Rotate(&amp;(*T)-&gt;rchild); /*  对T的右子树作右旋平衡处理 */ </div><div class="line">			  L_Rotate(T); /*  对T作左旋平衡处理 */ </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="插入与主函数"><a href="#插入与主函数" class="headerlink" title="插入与主函数"></a>插入与主函数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */ </div><div class="line">/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */ </div><div class="line">/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */</div><div class="line">Status InsertAVL(BiTree *T,int e,Status *taller)</div><div class="line">&#123;  </div><div class="line">	if(!*T)</div><div class="line">	&#123; /*  插入新结点，树“长高”，置taller为TRUE */ </div><div class="line">		 *T=(BiTree)malloc(sizeof(BiTNode));</div><div class="line">		 (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=NULL; (*T)-&gt;bf=EH;</div><div class="line">		 *taller=TRUE;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if (e==(*T)-&gt;data)</div><div class="line">		&#123; /*  树中已存在和e有相同关键字的结点则不再插入 */ </div><div class="line">			*taller=FALSE; return FALSE;</div><div class="line">		&#125;</div><div class="line">		if (e&lt;(*T)-&gt;data)</div><div class="line">		&#123; /*  应继续在T的左子树中进行搜索 */ </div><div class="line">			if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) /*  未插入 */ </div><div class="line">				return FALSE;</div><div class="line">			if(taller) /*   已插入到T的左子树中且左子树“长高” */ </div><div class="line">				switch((*T)-&gt;bf) /*  检查T的平衡度 */ </div><div class="line">				&#123;</div><div class="line">					case LH: /*  原本左子树比右子树高，需要作左平衡处理 */ </div><div class="line">							LeftBalance(T);	*taller=FALSE; break;</div><div class="line">					case EH: /*  原本左、右子树等高，现因左子树增高而使树增高 */ </div><div class="line">							(*T)-&gt;bf=LH; *taller=TRUE; break;</div><div class="line">					case RH: /*  原本右子树比左子树高，现左、右子树等高 */  </div><div class="line">							(*T)-&gt;bf=EH; *taller=FALSE; break;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123; /*  应继续在T的右子树中进行搜索 */ </div><div class="line">			if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) /*  未插入 */ </div><div class="line">				return FALSE;</div><div class="line">			if(*taller) /*  已插入到T的右子树且右子树“长高” */ </div><div class="line">				switch((*T)-&gt;bf) /*  检查T的平衡度 */ </div><div class="line">				&#123;</div><div class="line">					case LH: /*  原本左子树比右子树高，现左、右子树等高 */ </div><div class="line">							(*T)-&gt;bf=EH; *taller=FALSE;	break;</div><div class="line">					case EH: /*  原本左、右子树等高，现因右子树增高而使树增高  */</div><div class="line">							(*T)-&gt;bf=RH; *taller=TRUE; break;</div><div class="line">					case RH: /*  原本右子树比左子树高，需要作右平衡处理 */ </div><div class="line">							RightBalance(T); *taller=FALSE; break;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	int i;</div><div class="line">	int a[10]=&#123;3,2,1,4,5,6,7,10,9,8&#125;;</div><div class="line">	BiTree T=NULL;</div><div class="line">	Status taller;</div><div class="line">	for(i=0;i&lt;10;i++)</div><div class="line">	&#123;</div><div class="line">		InsertAVL(&amp;T,a[i],&amp;taller);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后不得不说，AVL树是在是太复杂了，但是其思想是在是太精妙了，它克服了二叉排序树在查找效率上的不足，通过在插入数据时，就将其变成一个平衡二叉树，从而使其时间复杂度为O(logn)</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉排序树]]></title>
      <url>http://www.myzwl.win/2017/07/27/BSTSort_1/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>二叉排序树，又称为二分查找树，它或者是一颗空树，或者具有如下性质<br>1.若它的左子树不为空，则左子树上所有结点的值均小于根结点值<br>2.若它的右子树不为空，则右子树上所有结点的值均小于根结点值<br>3.它的左右子树也分别为二叉排序树<br><img src="/images/imgs4/23.gif" alt="Alt text"></p>
<h4 id="二叉排序树查找操作"><a href="#二叉排序树查找操作" class="headerlink" title="二叉排序树查找操作"></a>二叉排序树查找操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">typedef struct BiTNode</div><div class="line">&#123;</div><div class="line">	int data;</div><div class="line">	struct BiTNode *lchild,*rchild;</div><div class="line">&#125;BiTNode,*BiTree;</div><div class="line"></div><div class="line"></div><div class="line">//递归查找二叉排序树中是否存在key</div><div class="line">//f指向T的双亲，初始值为NULL</div><div class="line">//若查找成功，则p指向该节点，并返回true</div><div class="line">//若查找失败，则p指向查找路径上访问的最后一个结点，并返回FALSE</div><div class="line">Status SearchBST(BiTree T,int key,BiTree f,BiTree *p)</div><div class="line">&#123;</div><div class="line">	if(!T)     //查找不成功</div><div class="line">	&#123;</div><div class="line">		*p=f;</div><div class="line">		return FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	else if(key==T-&gt;data) //查找成功</div><div class="line">	&#123;</div><div class="line">		*p=T;</div><div class="line">		return TRUE;</div><div class="line">	&#125;</div><div class="line">	else if(key&gt;T-&gt;data)&#123;         //在右子树中递归查找</div><div class="line">		return SearchBST(T-&gt;rchild,key,T,p);</div><div class="line">	&#125;</div><div class="line">	else if(key&lt;T-&gt;data)          //在左子树中递归查找</div><div class="line">		return SearchBST(T-&gt;lchild,key,T,p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看看它的过程是如何运行的，比如现在要查找93，显然初始化为SearchBST(T,93,NULL,p),因为93&gt;62，所以递归执行SearchBST(T-rchild,93,T,p),即SearchBST(88,93,62,P)这里用结点data值表示结点，又93&gt;88,继续SearchBST(99,93,88,P)，又93&lt;99，SearchBST(93,93,99,P)，所以93==93，得到最终p=T=93，f=99，查找成功。<br>可以发现二叉排序树的查找算法如此精妙而又优雅</p>
<h4 id="二叉排序树的插入操作"><a href="#二叉排序树的插入操作" class="headerlink" title="二叉排序树的插入操作"></a>二叉排序树的插入操作</h4><p>插入操作是基于查找操作的，也就是如果该二叉树为空，则新插入点为根结点，如果不为空，在先查找是否存在此元素，存在返回FALSE，否则在查找路径上的最后一个结点，通过比较插入到左孩子还是右孩子，最终返回TRUE<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Status InsertBST(BiTree *T,int key)</div><div class="line">&#123;</div><div class="line">	BiTree p,s;</div><div class="line">	if(!SearchBST(T,key,NULL,&amp;p)) //查找不成功</div><div class="line">	&#123;</div><div class="line">		s=(BiTree)malloc(sizeof(BiTNode));</div><div class="line">		 s-&gt;data=key;</div><div class="line">		 s-&gt;lchild=s-&gt;rchild=NULL;</div><div class="line">		 if(!p)                    //插入s为新的根结点</div><div class="line">		 	*T=s;</div><div class="line">		 else if(key&lt;s-data)      //插入s为左孩子</div><div class="line">		 	p-&gt;lchild=s;</div><div class="line">		 else                     //插入s为右孩子</div><div class="line">		 	p-&gt;rchild=s;</div><div class="line">		 return TRUE;</div><div class="line">	&#125;</div><div class="line">	else                       //树中已存在此关键字，则不插入</div><div class="line">		return FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="二叉排序树的删除操作"><a href="#二叉排序树的删除操作" class="headerlink" title="二叉排序树的删除操作"></a>二叉排序树的删除操作</h4><p>删除操作需要考虑三种情况，因为删除之后要保证还是一颗二叉排序树。如图<br><img src="/images/imgs4/24.gif" alt="Alt text"><br>一：删除叶子结点，这对这个二叉树来说并无影响，所以不移动其它元素<br>二：删除只含有左子树或者右子树的二叉排序树，因为根据二叉排序树的特点，很明显只要将它的左子树或右子树全部移动到它双亲的左子树或右子树就行了<br>三：删除既有左子树又有右子树的结点，我们可以通过它的中序遍历，也就是让它的直接前驱或者直接后继来替换它的位置，然后直接后继在分三种情况，直至只有一个孩子或者无孩子来替换<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">Status DeleteBST(BiTree *T,int key) //找到待删结点</div><div class="line">&#123;</div><div class="line">	if(!*T)</div><div class="line">		return FALSE;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if(key==(*T)-&gt;data)</div><div class="line">			return Delete(T);</div><div class="line">		else if(key&lt;(*T)-&gt;data)</div><div class="line">			return DeleteBST(&amp;(*T)-&gt;lchild,key);</div><div class="line">		else</div><div class="line">			return DeleteBST(&amp;(*T)-&gt;rchild,key);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//从二叉树中删除结点p，并重接它的左或右子树</div><div class="line">Status Delete(BiTree *p)</div><div class="line">&#123;</div><div class="line">	BiTree q,s;</div><div class="line">	if((*p)-&gt;rchild==NULL)  //右子树空则重接它的左子树</div><div class="line">	&#123;</div><div class="line">		q=*p;</div><div class="line">		*p=(*p)-&gt;lchild;</div><div class="line">		free(q);</div><div class="line">	&#125;</div><div class="line">	else if((*p)-&gt;lchild==NULL) //左子树空则重接它的右子树</div><div class="line">	&#123;</div><div class="line">		q=*p;</div><div class="line">		*p=(*p)-&gt;rchild;</div><div class="line">		free(q);</div><div class="line">	&#125;</div><div class="line">	else&#123;         //左右子树均不为空</div><div class="line">		q=*p;</div><div class="line">		s=(*p)-&gt;lchild;</div><div class="line">		while(s-&gt;lchild) //找到待删结点的前驱</div><div class="line">		&#123;</div><div class="line">			q=s;</div><div class="line">			s=s-&gt;rchild;</div><div class="line">		&#125;</div><div class="line">		(*p)-&gt;data=s-&gt;data;</div><div class="line">		if(q!=*p)        //重接q的右子树</div><div class="line">			q-&gt;rchild=s-&gt;lchild;</div><div class="line">		else             //重接q的左子树</div><div class="line">			q-&gt;lchild=s-&gt;lchild;</div><div class="line">		free(s);</div><div class="line">	&#125;</div><div class="line">	return TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>二叉排序树是以链式结构进行存储，所以在插入和删除元素上高效，，但是查找上走的是从根路径到结点的路径，其比较次数与数的层数有关如果该数是一颗斜数，那么查找就会比较很多次，如果该树是一颗完全二叉树，那么比较次数就最优，此时时间复杂度为O(logn),但是平均来说时间复杂度为O(n)</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[死锁和生产者消费者问题]]></title>
      <url>http://www.myzwl.win/2017/07/26/procos_1/</url>
      <content type="html"><![CDATA[<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>线程同步操作的是同一个线程对象，所以可能造成线程不安全，出现非数据的原子操作，所以，需要加锁，同时线程是程序的执行顺序，也就是cpu根据不同时间片选择某个时间执行某个线程，关于线程并发，在以前的总结中做过了几个简单的总结。<br>而死锁最经典的例子就是哲学家进餐问题，每个哲学家都左手拿着一只筷子，并且总共有五个哲学家，5个筷子，只有当哲学家左右手都有筷子时才能进餐，所以每个哲学家都在等右边哲学家方上筷子，处于僵持等待状态，称为死锁。<br>这里模仿两个线程死锁的情况<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class LockTest implements Runnable&#123;</div><div class="line"></div><div class="line">	public int flag=1;</div><div class="line">	 static Object o1=new Object(),o2=new Object();</div><div class="line">	   </div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println("flag="+flag);</div><div class="line">		 if(flag==1)&#123;</div><div class="line">		 synchronized (o1) &#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(5000);</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			synchronized (o2) &#123;</div><div class="line">				System.out.println("1");</div><div class="line">			&#125;</div><div class="line">		 &#125;	 </div><div class="line">		&#125;</div><div class="line">		if(flag==0)&#123;</div><div class="line">			 synchronized (o2) &#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(5000);</div><div class="line">					&#125; catch (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					synchronized (o1) &#123;</div><div class="line">						System.out.println("0");</div><div class="line">					&#125;</div><div class="line">				 &#125;	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LockTest lt1=new LockTest();</div><div class="line">		LockTest lt2=new LockTest();</div><div class="line">		 lt1.flag=1;</div><div class="line">		 lt2.flag=0;</div><div class="line">		  Thread t1=new Thread(lt1);</div><div class="line">		  Thread t2=new Thread(lt2);</div><div class="line">		  t1.start();</div><div class="line">		  t2.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>flag=1<br>flag=0</p>
</blockquote>
<p>大概分析一下，该类本身是一个线程类，flag用来控制执行哪个锁，O1和O2是两个被锁住对象，flag为1时先锁住o1，在锁住o2，flag为0则相反，而死锁发生就在此处两个线程启动了，o1被锁住了，另一个o2被锁住了，都在等待对方释放锁，显然处于僵持，产生死锁，<br>解决死锁的一个简单办法就是增大锁的粒度，扩大锁对象，比如讲前面的O1与O2改成this<br>结果：</p>
<blockquote>
<p>flag=1<br>flag=0<br>1<br>0</p>
</blockquote>
<h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><p>概述，模拟一个生产者利用生产食物放到篮子里，而一个消费者从篮子里消费食物<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">public class Food &#123; //食物类</div><div class="line"> int id;</div><div class="line"> public Food(int id)&#123;</div><div class="line">	 this.id=id;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class UtilStack &#123;//工具，用来放食物</div><div class="line"></div><div class="line">	int index=0; //食物计数变量</div><div class="line">	Food[] arrFD=new Food[4]; //最多工具能放食物容量</div><div class="line">	</div><div class="line">	public synchronized void push(Food fd)&#123; //生产食物，必须加锁，保证生产过程不被打断</div><div class="line">		while(index==arrFD.length)</div><div class="line">		&#123;</div><div class="line">			try &#123;</div><div class="line">				System.out.println("full");</div><div class="line">				this.wait();  //生产满了，就去休息区休息，等待被唤醒</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		this.notify();//唤醒当前在休息区的线程</div><div class="line">		arrFD[index]=fd;</div><div class="line">		index++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public synchronized Food pop()&#123; //消费</div><div class="line">		while(index==0) //消费完了，进休息区</div><div class="line">			try &#123;</div><div class="line">				System.out.println("empty");</div><div class="line">				this.wait();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		this.notify();</div><div class="line">		index--;</div><div class="line">		return arrFD[index];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Producer implements Runnable&#123;//生产者</div><div class="line"></div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Producer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=new Food(i);</div><div class="line">			ss.push(fd);</div><div class="line">			System.out.println("生产了"+fd.id);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(1000);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Consumer implements Runnable&#123;//消费者</div><div class="line"></div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Consumer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=ss.pop();</div><div class="line">			System.out.println("消费了"+fd.id);</div><div class="line">		 try &#123;</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>消费利用一对生产者和消费者模拟</p>
<blockquote>
<pre><code>UtilStack ss=new UtilStack();
    Producer p=new Producer(ss);
    Consumer c=new Consumer(ss);
    new Thread(p).start();
    new Thread(c).start();
</code></pre></blockquote>
<p>结果如下：</p>
<blockquote>
<p>生产了0<br>消费了0<br>生产了1<br>生产了2<br>消费了2<br>生产了3<br>生产了4<br>消费了4<br>生产了5<br>生产了6<br>消费了6<br>生产了7<br>full<br>消费了7<br>生产了8<br>full<br>消费了8<br>生产了9<br>full<br>消费了9<br>生产了10<br>full<br>消费了10<br>生产了11<br>full<br>消费了11<br>生产了12<br>full<br>消费了12<br>生产了13<br>full<br>消费了13<br>生产了14<br>full<br>消费了14<br>生产了15<br>full</p>
</blockquote>
<p>这里优于设置了消费者消费时间长，所以导致index不一样。可以发现当生产者满了，生产者不生产了，进入休息区，等待被唤醒，关于wait（）、notify（）、notifyAll（），在之前的多线程总结中已总结了</p>
<p><strong>结果分析</strong><br>从中我们可以看到生产者有满了的情况，但是消费者消费完了，index就不满了，然后就去叫醒了生产者继续生产，同样如果我们把消费者时间设置短一点看看，预测应该是empty的，在被生产者叫醒</p>
<blockquote>
<p>生产了0<br>消费了0<br>empty<br>消费了1<br>生产了1<br>empty<br>消费了2<br>生产了2<br>empty<br>消费了3<br>生产了3<br>empty<br>生产了4<br>消费了4<br>empty</p>
</blockquote>
<p>最后不得不说生产者与消费者问题可以解决平时在项目开发配置中不求甚解的一些问题，像缓冲区、连接池、消息队列、死锁、同步等等，</p>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>http://www.myzwl.win/2017/07/25/quick_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速排序被列为20世纪十大算法之一，正如其名一样，排序的速度非常快。<br>而它的基本思想就是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续排序，最终达到有序的目的<br><img src="/images/imgs4/22.gif" alt="Alt text"></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>采取同样的策略，从计算机的角度看看程序是怎么执行的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void QuickSort(SqList *L)&#123;</div><div class="line">  QSort(L,1,L-&gt;length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void QSort(SqList *L,int low,int high)&#123;</div><div class="line">  int pivot;</div><div class="line">   if(low&lt;high)&#123;</div><div class="line">    pivot=Partition(L,low,high);//将L-&gt;r[low..high]一分为二</div><div class="line">     QSort(L,low,pivor-1); //对低子表递归排序</div><div class="line">      QSort(L,pivot+1,high); //对高子表递归排序</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>里面有个函数Partition(L,low,high),和归并排序一样，暂时先不管它，初始化数组为{50,10,90,30,70,40,80,60,20}，初始low=1，high=9；<br>pivot为选择其中一个关键字，比pivot小的排到左边，比pivot大的排到右边，显然此时pivot=5，然后执行 QSort(L，1,4）直至排好序，同样右边也是递归调用QSort（L，6,9），这里的核心算法也就是Partition(L,low,high)如何排序的了<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int Partition(SqList *L,int low,int high)&#123;</div><div class="line">  int pivotkey;</div><div class="line">   pivotkey=L-&gt;[low]; //用子表的第一个记录做关键字</div><div class="line">    while(low&lt;high)</div><div class="line">    &#123;</div><div class="line">      while(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</div><div class="line">        high--;</div><div class="line">      swap(L,low,high);//交换low和high的记录</div><div class="line">      while(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</div><div class="line">         low++;</div><div class="line">       swap(L,low,high);</div><div class="line">    &#125;</div><div class="line">    return low;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样一行一行的看，这里默认选取子表的第一个记录作为关键字pivotkey=L-&gt;[low];接下来，由于low=1<high=9，执行内部程序，然后比较l->r[high]=L-&gt;r[9]=20与pivotkey=50大小，显然前者小于后者，不满足，将high与low交换，也就是说小的在左边，此时为{20,10,90.。。50},；然后明显20<50，所以low++；得low=2；并且10<50，在循环，得low=3，此时90>50,退出循环，在此交换位置，得{20,10,50.。。。90}；<br>最后low=3<9在循环，90>50,满足，high–，high=8，有L-&gt;high[8]=60&gt;50;high–;有80&gt;50;high–,有40&lt;50,退出循环，此时high=6，交换，依次类推，最终low=high=5，退出整个循环<br>最后在分别递归低和高的子表，最后我们发现他的规律如此只简单，遇到比关键字小的，依次递增比较，直到有比它大的，在换另一边比较，不得不说快速排序实在是太精妙了</9在循环，90></50，所以low++；得low=2；并且10<50，在循环，得low=3，此时90></high=9，执行内部程序，然后比较l-></p>
<p>最后再来看一下快速排序的时间复杂度，在最优的情况下为O（nlogn);</p>
<h4 id="排序算法间的比较"><a href="#排序算法间的比较" class="headerlink" title="排序算法间的比较"></a>排序算法间的比较</h4><p><img src="/images/imgs4/2.png" alt="Alt text"><br>分类<br><img src="/images/imgs4/15.jpg" alt="Alt text"></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[归并排序]]></title>
      <url>http://www.myzwl.win/2017/07/24/guibin_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>归并的意思就是将两个或者两个以上的有序数组合成一个有序表。而归并排序就是将含有n个记录的子序列，每个子序列长度为1，然后两两归并，得到[n/2]个长度为2或者1的有序子序列，在两两归并，。。。。，如此重复，直到得到一个长度为n的有序序列为止<br><img src="/images/imgs4/14.jpg" alt="Alt text"></p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>不妨先看代码，在从计算机角度去看看是如何执行代码过程的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void MergeSort(SqList *L)&#123;</div><div class="line">  MSort(L-&gt;r,L-&gt;r,1,L-&gt;length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//将SR[s..t]归并到TR1[s..t]</div><div class="line">void MSort(int SR[],int TR1[],int s,int t)&#123;</div><div class="line">  int m;</div><div class="line">  int TR2[MAXSIZE+1];</div><div class="line">  if(s==t)</div><div class="line">    TR1[s]=SR[s];</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    m=(s+t)/2;</div><div class="line">    MSort(SR,TR2,s,m);</div><div class="line">    MSort(SR,TR2,m+1,t);</div><div class="line">    Merge(TR2,TR1,s,m,t);//将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>里面有个递归 Merge(TR2,TR1,s,m,t);暂时先不管它，假设模拟的数组为{50,10,90,30,70,40,80,60,20}，所以知道初始化时SR和TR1都是该数组，s=1，t-9；由于s！=t，所以执行else中的语句。此时m=5，也就是正中间下标，所以开始先执行递归MSort(SR,TR2,1,5)，递归过程如下所示<br><img src="/images/imgs4/21.gif" alt="Alt text"><br>其核心部分就是最后都变成叶子结点，递归结束，然后执行if里语句，不过此时TR1[s]=SR[s]，注意这里s是元素下标，所以第一次TR2={50,10}，然后就要执行Merge(TR2,TR1,s,m,t);前面是50与10已结归并了，暂时我们知道它就是把无需归并为有序就行了，即TR2={10,50}后面在详细分析它，<br>接下来同理，依次向上归并，最后得到{10,30,50,70,90}，同理，根结点右子树也一样，最终完成了归并</p>
<p>再来看看Merge(TR2,TR1,s,m,t)函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void Merge(int SR[],int TR[],int i,int m,int n)</div><div class="line">&#123;</div><div class="line">  int j,k,l;</div><div class="line">   for(j=m+1,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++)</div><div class="line">   &#123;</div><div class="line">    if(SR[i]&lt;SR[j])</div><div class="line">      TR[k]=SR[i++];</div><div class="line">    else</div><div class="line">      TR[k]=SR[j++];</div><div class="line">   &#125;</div><div class="line">   if(i&lt;=m)&#123;  //将剩余元素归并</div><div class="line">    for(l=0;l&lt;=m-1;l++)</div><div class="line">      TR[k+1]=SR[i+1];</div><div class="line">  &#125;</div><div class="line"> if(j&lt;=n)</div><div class="line"> &#123;</div><div class="line">  for(l=0;l&lt;n-j;l++)</div><div class="line">    TR[k+1]=SR[j+1];</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就拿{10,30,50,70,90}和{20,40,60,80}归并为有序序列来说，此时i=1，m=5,n=9；进入for循环，此时j从6到9，i由1到5，k由1开始每次加1，并且k就是TR数组的下标，然后开始归并，左右子树的SR[i]=SR[1]=10与SR[j]=SR[6]=20开始比较，将较小数放入到一个初始化时空的TR[]中，比如是10，然后i++；否则j++，这样就可以得到有序序列了，但是最终当j=10时退出循环，而后面还有一些元素未归并，将执行后面if语句，将最后的90复制到最后，最终完成了归并</p>
<p>最后再来看看归并排序的时间复杂度，由于其与完全二叉树有关，最终得到其为O（nlogn)，而它也是比较占用内存但是很稳定的一种算法</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java IO简单总结]]></title>
      <url>http://www.myzwl.win/2017/07/23/IO_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在涉及IO流之前需要知道文件的概念。文件是数据源（保存数据的的地方）的一种，比如word文件、txt文件。他既可以保存一张图片，也可以保存视频、声音。。。等等<br><strong>文件流</strong><br><img src="/images/imgs4/19.gif" alt="Alt text"><br>文件在程序中是以流的形式来操作的<br>流：数据在数据源（文件）和程序（内存）之间经历的路径<br>输入流：数据从数据源到内存的路径<br>输出流：数据从内存到数据源的路径</p>
<h4 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h4><p>1.根据处理数据类型的不同分为：字符流和字节流<br>字节流：可以用于读写二进制文件及任何类型的byte，也就是一个字节一个的读<br>字符流：可以用于读写文本文件，不能操作二进制文件，也就是两个字节两个字节的读<br>2.根据数据流向不同分为：输入流和输出流<br>3。节点流和处理流<br>节点流：直接与数据源相连，读入或读出，可以发现使用该流过于频繁操作硬件，从而使读写很不方便<br>常用的结点流：</p>
<blockquote>
<p>父类：InputStream、OutputStream、Reader、Writer<br>文件 ：FileInputStream 、 FileOutputStrean 、FileReader、FileWriter 文件进行处理的节点流<br>数　组 ：ByteArrayInputStream、 ByteArrayOutputStream、 CharArrayReader 、CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）<br>字符串 ：StringReader、 StringWriter 对字符串进行处理的节点流<br>管　道 ：PipedInputStream 、PipedOutputStream 、PipedReader 、PipedWriter 对管道进行处理的节点流</p>
</blockquote>
<p>处理流：处理流和节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。<br><img src="/images/imgs4/20.gif" alt="Alt text"><br>常用的处理流：</p>
<blockquote>
<p>缓冲流：BufferedInputStrean 、BufferedOutputStream、 BufferedReader、 BufferedWriter 增加缓冲功能，避免频繁读写硬盘<br>转换流：InputStreamReader 、OutputStreamReader实现字节流和字符流之间的转换<br>数据流： DataInputStream 、DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来</p>
</blockquote>
<p><img src="/images/imgs4/13.jpg" alt="Alt text"></p>
<h4 id="文件File类"><a href="#文件File类" class="headerlink" title="文件File类"></a>文件File类</h4><p><strong>File常用方法</strong></p>
<blockquote>
<p>创建：<br>createNewFile()在指定位置创建一个空文件，成功就返回true，如果已存在就不创建，然后返回false。<br>mkdir()  在指定位置创建一个单级文件夹。<br>mkdirs()  在指定位置创建一个多级文件夹。<br>renameTo(File dest)如果目标文件与源文件是在同一个路径下，那么renameTo的作用是重命名， 如果目标文件与源文件不是在同一个路径下，那么renameTo的作用就是剪切，而且还不能操作文件夹。<br>删除：<br>delete()  删除文件或者一个空文件夹，不能删除非空文件夹，马上删除文件，返回一个布尔值。<br>deleteOnExit()jvm退出时删除文件或者文件夹，用于删除临时文件，无返回值。<br> 判断：<br>exists()  文件或文件夹是否存在。<br>isFile()  是否是一个文件，如果不存在，则始终为false。<br>isDirectory()  是否是一个目录，如果不存在，则始终为false。<br>isHidden()  是否是一个隐藏的文件或是否是隐藏的目录。<br>isAbsolute()  测试此抽象路径名是否为绝对路径名。<br> 获取：<br>getName()  获取文件或文件夹的名称，不包含上级路径。<br>getAbsolutePath()获取文件的绝对路径，与文件是否存在没关系<br>length()  获取文件的大小（字节数），如果文件不存在则返回0L，如果是文件夹也返回0L。<br>getParent()  返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回null。<br>lastModified()获取最后一次被修改的时间。<br>文件夹相关：<br>static File[] listRoots()列出所有的根目录（Window中就是所有系统的盘符）<br>list()  返回目录下的文件或者目录名，包含隐藏文件。对于文件这样操作会返回null。<br>listFiles()  返回目录下的文件或者目录对象（File类实例），包含隐藏文件。对于文件这样操作会返回null。<br>list(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。<br>listFiles(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> //创建一个文件对象</div><div class="line">  File f1=new File("e:\\aa.txt");</div><div class="line">  //得到文件的路径</div><div class="line">  System.out.println("文件路径"+f1.getAbsolutePath());</div><div class="line">//得到文件的大小,字节数</div><div class="line">  System.out.println("文件的大小"+f1.length());</div><div class="line">//创建文件夹</div><div class="line">		File f3=new File("e:\\ff");</div><div class="line">		//判断文件夹是否存在</div><div class="line">		if(f3.isDirectory())&#123;</div><div class="line">			System.out.println("文件夹存在，不能创建!");</div><div class="line">		&#125;else&#123;</div><div class="line">			//创建文件夹</div><div class="line">			f3.mkdir();</div><div class="line">		&#125;</div><div class="line">		//创建文件和创建文件夹</div><div class="line">		File f2=new File("e:\\ff\\zwl.txt");</div><div class="line">		//判断文件是否存在</div><div class="line">		if(!f2.exists())//可以创建</div><div class="line">			try &#123;</div><div class="line">				f2.createNewFile();//创建一个新文件</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		else&#123;</div><div class="line">			System.out.println("文件存在，不能创建!");</div><div class="line">		&#125;</div><div class="line">		//列出一个文件夹下面的所有文件</div><div class="line">		File f4=new File("e:\\ff");</div><div class="line">		//判断文件夹是事存在</div><div class="line">		if(f4.isDirectory())&#123;</div><div class="line">			//将文件夹的文件，传给lists数组</div><div class="line">			//将文件夹的文件，传给lists数组</div><div class="line">			File lists[]=f4.listFiles();</div><div class="line">			//遍历数组</div><div class="line">			for(int i=0;i&lt;lists.length;i++)&#123;</div><div class="line">				//输出文件夹下所有文件文件名</div><div class="line">				System.out.println("显示出文件名是"+lists[i].getName());</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>对应的结果：</p>
<blockquote>
<p>文件路径e:\aa.txt<br>文件的大小0<br>显示出文件名是zwl.txt</p>
</blockquote>
<h4 id="文件字节与字符流"><a href="#文件字节与字符流" class="headerlink" title="文件字节与字符流"></a>文件字节与字符流</h4><p><strong>InputStream常用方法</strong></p>
<blockquote>
<p>public abstract int read() throws IOException:从输入流中读取数据的下一个字节,到达末尾，返回-1；<br> public int read(byte[] b)throws IOException：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中<br> public int read(byte[] b,int off,int len)throws IOException：将输入流中最多 len 个数据字节读入 byte 数组<br> public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源</p>
</blockquote>
<p><strong>OutputStream常用方法</strong></p>
<blockquote>
<p>public void flush()throws IOException:刷新此输出流并强制写出所有缓冲的输出字节<br> public abstract void write(int b)throws IOException:将 b.length 个字节从指定的 byte 数组写入此输出流。<br> public void write(byte[] b, int off, int len)throws IOException:将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流<br> public void write(byte[] b)throws IOException:将指定的字节写入此输出流。</p>
</blockquote>
<p> Reader与Writer和上述方法基本类似，只不过它操作的是字符。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">int b=0;</div><div class="line">  //FileInputStream in=null;</div><div class="line">  FileReader in=null;</div><div class="line">   FileOutputStream out=null;</div><div class="line">    try &#123;</div><div class="line">		in=new FileReader("E:\\php练习\\readmeFirst.txt");</div><div class="line">		out=new FileOutputStream("E:\\php练习\\ttl.txt");</div><div class="line">	&#125; catch (Exception e) &#123;</div><div class="line">		System.out.println("not file");</div><div class="line">		 System.exit(-1);</div><div class="line">	&#125;</div><div class="line">    try &#123;</div><div class="line">		long num=0;</div><div class="line">		while((b=in.read())!=-1)&#123;</div><div class="line">			System.out.print((char)b);</div><div class="line">			//out.write(b);;</div><div class="line">			num++;</div><div class="line">		&#125;</div><div class="line">		in.close();</div><div class="line">		out.close();</div><div class="line">		System.out.println();</div><div class="line">		System.out.println("共读取了"+num+"个字符");</div><div class="line">	&#125; catch (Exception e) &#123;</div><div class="line">		System.out.println("error!");</div><div class="line">		 System.exit(-1);</div><div class="line">	&#125;</div><div class="line">    System.out.println("copy ok");</div></pre></td></tr></table></figure></p>
<p>上面程序是将已存在的一个文件复制到另一个文件中</p>
<p><strong>缓冲字节与字符流</strong><br>它是在原来节点流基础上增加了一根管道，用于缓存数据，用法基本类似，但是它的构造函数必须是结点流，同时在字符缓冲流中有一个可以读取或存取字符串的方法如：</p>
<blockquote>
<p>public String readLine()throws IOException:读取一个文本行</p>
</blockquote>
<p><strong>Object流</strong><br>Object流的意思将是像一根节点流插入一根Object流管道，专门操作Object，而它必须实现Serializable接口，该接口的意思是可序列化，就是说将一个对象流序列化成子节流写进网络或者文件，比如说游戏存盘，有各个游戏的记录，如果以面向对象来写进管道，它的各个成员变量，会在内存中被序列化成二进制写进去，而Serializable接口无方法，它只是个标记接口，编译器看到实现该接口的类就知道它应该被序列化，同样有一个transient关键字，是使可序列化的某个属性变成透明，也就是它不能变成字节写进去，那个属性只能为默认属性写进去<br>ok，接下来就来看看Object流相关常用方法</p>
<blockquote>
<p>ObjectOutput:有一个void writeObject(Object obj) throws IOException：将对象写入底层存储或流。<br>ObjectInput：Object readObject()throws ClassNotFoundException,IOException：读取并返回对象</p>
</blockquote>
<p>最后不得不说IO流是在太复杂，就是一根管道不断套接着另一根管道，但是IO流是非常有用的，不仅能帮助我们了解计算机底层，而且涉及到数据传输都离不开它。。</p>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[直接插入和希尔排序]]></title>
      <url>http://www.myzwl.win/2017/07/22/inserSort_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>直接插入在本质上改良了之前的冒泡和选择排序，而希尔排序更是超越O（n^2)的传统排序的改良算法</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>算法描述：直接插入排序就是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表<br>首先先定义数据结构</p>
<blockquote>
<p>#define MAXSIZE 10<br>typedef struct{<br>    int r[Maxsize+1]//用于存储要排序的数组，r[0]用作哨兵或者临时变量<br>    int length; //记录顺序表的长度<br>}SqList;</p>
</blockquote>
<p>接下来不妨以5个数模拟该算法执行过程</p>
<blockquote>
<p>初始化为{0,5,3,4,6,2}<br>从第二个数开始往前比较，如3比5小，那么，3赋值给哨兵，5后移到3位置，哨兵赋值给5位置，此时变成<br>{3,3,5,4,6,2}；<br>继续循环，哨兵初始化为0,4比5小，4给哨兵，5后移至4，在比较哨兵与3大小，如果比3小，3后移，在插入到该位置，否则直接插到5位置，ok这就是该算法的核心，在合适的位置直接插入</p>
</blockquote>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>下面在来看算法，一般理解算法的过程，就把自己当做计算机，自我调试，然后就会发现其中无穷的乐趣<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;    </div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;ctype.h&gt;      </div><div class="line">#include &lt;stdlib.h&gt;   </div><div class="line">#include &lt;io.h&gt;  </div><div class="line">#include &lt;math.h&gt;  </div><div class="line">#include &lt;time.h&gt;</div><div class="line"></div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define TRUE 1</div><div class="line">#define FALSE 0</div><div class="line"></div><div class="line"></div><div class="line">typedef int Status; </div><div class="line"></div><div class="line"></div><div class="line">#define MAXSIZE 10000  /* 用于要排序数组个数最大值，可根据需要修改 */</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	int r[MAXSIZE+1];	/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</div><div class="line">	int length;			/* 用于记录顺序表的长度 */</div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line">void InsertSort(SqList *L)</div><div class="line">&#123;</div><div class="line">	int i,j; //i用来控制外层循环，也就是r[i]中每个数，j用来控制r[i]与前面的数大小，并插到合适的位置</div><div class="line">for(i=2;i&lt;=L-&gt;length;i++)&#123;</div><div class="line">   if(L-&gt;r[i]&lt;L-&gt;r[i-1]) //要插的数比前一个数大</div><div class="line">   &#123;</div><div class="line">   	L-&gt;r[0]=L-&gt;r[i];    //要插入的数先放到哨兵</div><div class="line">   	 for(j=i-1;L-&gt;r[j]&gt;L-&gt;r[0];j--) //依次比较插入的数前面的数，放到合适的位置</div><div class="line">   	 	L-&gt;r[j+1]=L-&gt;r[j]; //记录后移</div><div class="line">   	 L-&gt;r[j+1]=L-&gt;r[0];  //插入合适的位置</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void print(SqList L) //打印元素</div><div class="line">&#123;</div><div class="line">	int i;</div><div class="line">	for(i=1;i&lt;L.length;i++)</div><div class="line">		printf("%d,",L.r[i]);</div><div class="line">	printf("%d",L.r[i]);</div><div class="line">	printf("\n");</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	int i;</div><div class="line">      int d[5]=&#123;5,3,4,6,2&#125;;</div><div class="line">        SqList L;</div><div class="line">          for(i=0;i&lt;5;i++)</div><div class="line">          	L.r[i+1]=d[i];</div><div class="line">             L.r[0]=0;</div><div class="line">             L.length=5;</div><div class="line">            printf("直接插入排序:\n");</div><div class="line">             InsertSort(&amp;L);</div><div class="line">              print(L);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面在看看它的时间复杂度，最好的情况就是{2,3,4,5,6}，也就是说其本身已经是一个有序的，很显然只需要L-&gt;r[i]与L-&gt;r[r-1]大小，所以此时时间复杂度为O(n);最坏的情况就是{6,5,4,3,2}，即2+3+。。+n为（n+2)(n-1)/2<br>所以最后根据平局原则，知道直接插入排序的时间复杂度为O(n^2);</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>基本有序</strong><br>首先需要了解一下基本有序的概念，就是指小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，如{2,1,3,6,4,7,5,8,9}，但如{1,5,9,3,7,8,2,4,6}这种9在第三位，2在倒数第三位就不叫基本有序</p>
<p>希尔排序的关键就是将相隔某个”增量”的记录组成一个子序列，实现跳跃式的移动</p>
<blockquote>
<p>初始一个数组{0,9,1,5,8,3,7,4,6,2}，其中0为哨兵<br>并且初始化增量为数组长度（哨兵不算），所以为9，并约定一个循环，当且仅当增量小于等于1退出循环，并且每次增量都执行增量=增量/3+1（也可以是其他增量原则），第一次就是4了<br>然后一个循环变量i从增量+1开始直到小于等于数组长度，然后比较该i值与i-增量值，也就是第一个值大小，后面就是直接插入算法思想了，有一点不一样，就是循环变量j控制不太一样</p>
</blockquote>
<p>然后看看上述数组怎么比较的</p>
<blockquote>
<p>第一次：i=增量+1=5开始，也就是3与9比较，明显满足3&lt;9,然后交换（直接插入思想），依次7与1，不交换，4与5交换，6与8交换，2与9交换这里那个j条件也满足并且2&lt;3在交换，ok得到一个交换后的数组<br>{2,1,4,6,3,7,5,8,9}可以发现经过第一轮后，该数组基本有序了<br>紧接着开始进行第二轮，即增量=增量/3+1=2，即从第三个2与4不交换，1与6不交换，4与3交换，6与7不交换，4与5不交换，7与8不交换，5与9不交换，即得到{2,1,3,6,4,7,5,,8,9};<br>最后一轮：增量为1,2与1交换，2与4不交换，然后依次比较，由于目前已经基本有序，所以交换的比较少，<br>最后得到{1,2,3,4,5,6,7,8,9}</p>
</blockquote>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>通过上面的例子，大概就是希尔排序的模拟过程，可以发现增量值是一个很巧妙的地方<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">void ShellSort(SqList *L)</div><div class="line">&#123;</div><div class="line">  int i,j;</div><div class="line">  int increment=L-&gt;length; //初始化增量为数组长度</div><div class="line">  do&#123;</div><div class="line">    increment=increment/3+1; //增量序列</div><div class="line">    for(i=increment+1;i&lt;=L-&gt;length;i++) //从增量序列后一位开始</div><div class="line">    &#123;</div><div class="line">      if(L-&gt;r[i]&lt;L-&gt;r[i-increment]) //该位置与第一位比较，是否交换</div><div class="line">      &#123;</div><div class="line">        L-&gt;r[0]=L-&gt;r[i]; //若交换，先放到哨兵位置</div><div class="line">         for(j=i-increment;j&gt;0&amp;&amp;L-&gt;r[0]&lt;L-&gt;r[j];j-=increment)</div><div class="line">           L-&gt;r[j+increment]=L-&gt;r[j]; //记录后移</div><div class="line">            L-&gt;r[j+increment]=L-&gt;r[0];//插入到正确位置</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;while(increment&gt;1);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	int i;</div><div class="line">      int d[5]=&#123;5,3,4,6,2&#125;;</div><div class="line">        SqList L;</div><div class="line">          for(i=0;i&lt;5;i++)</div><div class="line">          	L.r[i+1]=d[i];</div><div class="line">             L.r[0]=0;</div><div class="line">             L.length=5;</div><div class="line">            printf("希尔排序:\n");</div><div class="line">           ShellSort(&amp;L);</div><div class="line">               print(L);</div><div class="line">              print(L);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现希尔排序的关键就是增量的选择，而它的时间复杂度是O(n^(3/2)),显然比传统的算法O(n^2)时间复杂度要小很多</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用集合类简单总结]]></title>
      <url>http://www.myzwl.win/2017/07/21/jihes_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在没有集合之前我们都是直接用数组存放对象，但是这样操作会很不方便，于是利用数据结构封装了一些列集合，而集合中不存放输几局的基本类型，只存放对象的引用，如图（部分集合源码分析在之前的总结中已经简单研究过）<br><img src="/images/imgs4/1.png" alt="Alt text"><br>java集合主要分为以下三种类型：<br>Set(集)：集合中的对象不按特定方式排序，且没有重复对象。它的有些实现类能对集合中的对象按照特地方式排序。<br>List(列表)：集合中的对象按照索引位置排序，可以有重复对象，允许使用索引检索对象。<br>Map(映射)：集合中的每一个元素都包含一对键对象和值对象（key-value），集合中的键对象是不能重复的,它的一些实现类能对集合中的键对象进行排序。</p>
<p>注意这里的不能重复与比较hashcode和equals有关</p>
<h4 id="集合底层概述"><a href="#集合底层概述" class="headerlink" title="集合底层概述"></a>集合底层概述</h4><p><strong>Collection接口</strong><br>Collection接口是Set、List、Queue接口的父接口，提供了多数集合常用的方法声明，包括 add()、remove()、contains() 、size() 、iterator() 等</p>
<p><strong>List接口</strong><br>它的特点是有序可重复，使用此接口能够精确的控制每个元素插入的位置用户能够使用索引来访问List中的元素并且允许有可重复的元素</p>
<p><strong>ArrayList</strong><br>底层实现是一个动态的数组，查询快，增删慢，线程不安全，效率高</p>
<p><strong>LinkedList</strong><br>底层实现是一个双向循环链表，查询慢，增删快，线程不安全，效率较高</p>
<p><strong>Vector</strong><br>是ArrlyList的线程安全版，底层同它基本一致，但是效率低，现在基本很少用</p>
<p><strong>Set接口</strong><br>它的特点就是唯一性并且不允许出现重复元素和是无序的</p>
<p><strong>hashSet</strong><br>底层是基于哈希表实现的，而其核心就是先比较hashCode（）值是否相同（相当于索引），然后在用equals比较是否相同，从而确定元素是否重复，所以当不希望集合中有重复值，并且不关心元素之间的顺序时可以使用此类</p>
<p><strong>LinkedHashSet</strong><br>底层实现是使用链表和哈希表，它由链表保证元素有序，哈希表保证元素唯一，因此当不希望集合中有重复值，并且希望按照元素的插入顺序进行迭代遍历时可采用此类</p>
<p><strong>TreeSet</strong><br>底层实现是红黑树，也就是一种平衡AVL树，通过比较返回值是否是0来保证元素唯一性，并且通过自然排序来保证元素的排序（自然排序也就是让元素所属的类实现Comparable接口，比如abc排在abd前面，总之就是和插入顺序无关，只和元素本身的内容和特质有关）</p>
<p><strong>Queue接口</strong><br>它的特点就是队列，即用于保存将要执行的任务列表</p>
<p><strong>LinkedList</strong><br>实现了该接口，可以实现先进先出的队列</p>
<p><strong>PriorityQueue</strong><br>底层采用某种排序的单链表存储队列元素，用来创建自然排序的优先级队列</p>
<p><strong>Map接口</strong><br>Map关心的是唯一的标识符，也就是将唯一的键映射到某个元素，以键值对形式存储，键唯一，值可重复</p>
<p><strong>HashMap</strong><br>底层实现是基于哈希表依赖于hashCode（）和equals（）方法，线程不安全，允许key和value为NULL，效率高</p>
<p><strong>Hashtable</strong><br>HashMap的线程安全版，效率低，不允许key和value为NULL</p>
<p><strong>LinkedHashMap</strong><br>底层是由链表和哈希表组成，链表保证元素有序，哈希表保证元素唯一，所以当需要键值对，并且关心插入顺序时可采用它</p>
<p><strong>TreeMap</strong><br>底层是由红黑树实现，当需要键值对，并关心元素的自然排序时可采用它</p>
<p><strong>Collections</strong><br>内置了一些常见的集合算法，像排序，查找算法等</p>
<h4 id="如何选择哪种集合"><a href="#如何选择哪种集合" class="headerlink" title="如何选择哪种集合"></a>如何选择哪种集合</h4><p>1 首先看是否是键值对形式<br>  是的话就选择Map<br>   然后再看是否需要排序：<br>     是的话就是TreeMap<br>     不是的话就是HashMap<br>     一般情况下都使用HashMap<br>   不是键值对的话就选择Collection<br>     再看元素是否唯一：<br>       是的话就选set<br>         元素是否需要排序<br>           是的话就选TreeSet<br>           反之选择HashSet<br>          一般情况选择HashSet<br>        不是元素唯一就选List<br>          再看是否是否需要线程安全：<br>           是的话就选Vector<br>            不是的话就选择ArrayList或者LinkedList<br>             增删选择：LinkedList<br>              查询选择ArrayList<br>              一般情况下都选择ArrayList</p>
<h4 id="集合常见方法"><a href="#集合常见方法" class="headerlink" title="集合常见方法"></a>集合常见方法</h4><p><strong>Collection的常见方法</strong></p>
<blockquote>
<p>1，添加。<br>    boolean add(Object obj):<br>    boolean addAll(Collection coll):<br>2，删除。<br>    boolean remove(object obj):<br>    boolean removeAll(Collection coll);<br>    void clear();<br>3，判断：<br>    boolean contains(object obj):<br>    boolean containsAll(Colllection coll);<br>    boolean isEmpty():判断集合中是否有元素。<br>4，获取：<br>    int size():<br>    Iterator iterator():取出元素的方式：迭代器。<br> 5，其他：<br>    boolean retainAll(Collection coll);取交集。<br>    Object[] toArray():将集合转成数组。 </p>
</blockquote>
<p><strong>Map的常见方法</strong></p>
<blockquote>
<p> 1，添加。<br>          value put(key,value):返回前一个和key关联的值，如果没有返回null.<br> 2，删除。<br>            void  clear():清空map集合。<br>            value remove(key):根据指定的key翻出这个键值对。<br> 3，判断。<br>                boolean containsKey(key):<br>                boolean containsValue(value):<br>                boolean isEmpty();<br> 4，获取。<br>                value get(key):通过键获取值，如果没有该键返回null。                        当然可以通过返回null，来判断是否包含指定键。<br>                int size(): 获取键值对的个数。<br>5.特殊方法： Collection<v> values() 包含的值的 Collection 视图。<br>             Set<map.entry<k,v>&gt; entrySet()方法：返回一个set集合，里面装的是Map.Entry接口类型的键值对象</map.entry<k,v></v></p>
</blockquote>
<p><strong>Map遍历方法</strong></p>
<blockquote>
<p>  第一种遍历的方法<br>  Set<k> keySet()：返回键的set集合<br> 取出map中的所有元素。<br> 原理，通过keySet方法获取map中所有的键所在的Set集合，在通过Set的迭代器获取到每一个键，<br>  在对每一个键通过map集合的get方法获取其对应的值即可。<br>    Set<integer> keySet = map.keySet();<br>        System.out.println(keySet);//键的set集合<br>        Iterator<integer> it = keySet.iterator();//迭代keySet<br>        while(it.hasNext()){<br>            Integer key = it.next();<br>            String value = map.get(key);<br>            System.out.println(key+”:”+value);<br>        }</integer></integer></k></p>
<p>第二种遍历map的方式：通过看API:Set<map.entry<k,v>&gt; entrySet()：Map.Entry<k,v>接口类型，<br>  里面有K getKey() 返回与此项对应的键。 V getValue()  返回与此项对应的值。<br>  Set<map.entry<integer, string="">&gt;entrySet = map.entrySet();<br>        System.out.println(entrySet);//键值对对象<br>        Iterator<map.entry<integer, string="">&gt;it = entrySet.iterator();<br>        while(it.hasNext()){<br>            Map.Entry<integer, string=""> entryMap = it.next();<br>            Integer key = entryMap.getKey();//获取键<br>            String value = entryMap.getValue();//获取值<br>            System.out.println(key+”:”+value);<br>  }</integer,></map.entry<integer,></map.entry<integer,></k,v></map.entry<k,v></p>
</blockquote>
<h4 id="collections常用方法"><a href="#collections常用方法" class="headerlink" title="collections常用方法"></a>collections常用方法</h4><p>由于该集合工具类方法太多，只总结出部分<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">sort</span><span class="params">(Collection)</span></span>：对集合进行自然排序</div><div class="line"><span class="function"><span class="title">reverse</span><span class="params">()</span></span>：反转集合中元素的顺序</div><div class="line"><span class="function"><span class="title">shuffle</span><span class="params">(Collection)</span></span>：对集合进行随机排序</div><div class="line"><span class="function"><span class="title">fill</span><span class="params">(List list,Object o)</span></span>：用对象o替换集合list中的所有元素</div><div class="line"><span class="function"><span class="title">copy</span><span class="params">(List m,List n)</span></span>：将集合n中的元素全部复制到m中,并且覆盖相应索引的元素</div><div class="line"><span class="function"><span class="title">min</span><span class="params">(Collection)</span></span>,min(Collection,Comparator)：前者采用Collection内含自然比较法，后者采用Comparator进行比较</div><div class="line"><span class="function"><span class="title">max</span><span class="params">(Collection)</span></span>,max(Collection,Comparator)：同上</div><div class="line"><span class="function"><span class="title">indexOfSubList</span><span class="params">(List list,List subList)</span></span>：查找subList在list中首次出现位置的索引</div><div class="line"><span class="function"><span class="title">swap</span><span class="params">(List list,int i,int j)</span></span>：交换集合中指定元素索引的位置</div><div class="line">.binarySearch(Collection,Object)：查找指定集合中的元素，返回所查找元素的索引</div><div class="line"><span class="function"><span class="title">replaceAll</span><span class="params">(List list,Object old,Object new)</span></span>：替换批定元素为某元素,若要替换的值存在刚返回true,反之返回false</div></pre></td></tr></table></figure></p>
<p>最后不得不说集合容器是在太复杂了，它包装了许许多多的数据结构和算法，也正是因为如此，才大大简化了难度，但同时也说明了数据结构与算法的重要性，只有我们真正理解了算法和数据结构，才能更好的驾驭集合类</p>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[String与StringBuffer常用方法总结]]></title>
      <url>http://www.myzwl.win/2017/07/20/StringBuf_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>String与StringBuffer的区别，简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。</p>
<h4 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h4><p>在之前的数据结构与算法中已经模拟了部分String常用的方法</p>
<blockquote>
<p>public final class Stringextends Objectimplements Serializable, Comparable<string>, CharSequence</string></p>
</blockquote>
<p><strong>构造方法</strong></p>
<blockquote>
<p>public String()：初始化一个新创建的 String 对象，使其表示一个空字符序列。注意，由于 String 是不可变的，所以无需使用此构造方法。<br> public String(String original）：创建一个String对象为original的拷贝<br> public String(char[] value)：用一个字符数组创建一个String对象<br> public String(char[] value, int offset,int count)：用一个字符数组从offset项开始的count个字符序列创建一个String对象</p>
</blockquote>
<p><strong>普通方法</strong></p>
<blockquote>
<p>public char charAt(int index):返回字符串中第index个字符<br> public int length():返回字符串的长度<br> public int indexOf(String str):返回字符串中出现str的第一个位置<br> public int indexOf(String str,int fromIndex):返回字符串中从fromIndex开始起出现str的第一个位置<br> public boolean equalsIgnoreCase(String another):比较字符串与another是否一样（忽略大小写）<br> public String replace(char oldChar,char newChar):在字符串中用newChar替换oldChar<br> public boolean startWith(String prefix):判断字符串是否以prefix字符串开头<br> public boolean endsWith(String suffix):判断字符串是否以suffix为结尾<br> public String toLowerCase():返回一个字符串为该字符串的小写形式<br> public String substring(int beginIndex):返回该字符串从beginIndex开始到结尾的字符串<br> public String substring(int beginIndex,int endIndex):返回该字符串从beginIndex开始到endIndex结尾的字符串<br> public String trim():返回将该字符串去掉开头和结尾空格后的字符串</p>
</blockquote>
<p><strong>静态重载方法</strong></p>
<blockquote>
<p>public static String valueOf(..):将基本类型数据转化为字符串，如<br> public static String valueOf(double d)</p>
</blockquote>
<p><strong>其它常用方法</strong></p>
<blockquote>
<p>public String[] split(String regix):可以将一个字符串按照指定的分隔符分隔，返回分隔后的字符串数组<br>public String concat(String str)//将参数中的字符串str连接到当前字符串的后面，效果等价于”+”；<br>contains(String str)//判断参数s是否被包含在字符串中，并返回一个布尔类型的值。<br>字符串转换为基本类型<br>java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：<br>1)public static byte parseByte(String s)<br>2)public static short parseShort(String s)<br>3)public static short parseInt(String s)<br>4)public static long parseLong(String s)<br>5)public static float parseFloat(String s)<br>6)public static double parseDouble(String s)</p>
</blockquote>
<p><strong>字符串比较</strong></p>
<blockquote>
<p>1)public int compareTo(String anotherString)//该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。<br>2)public int compareToIgnore(String anotherString)//与compareTo方法相似，但忽略大小写。<br>3)public boolean equals(Object anotherObject)//比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。<br>4)public boolean equalsIgnoreCase(String anotherString)//与equals方法相似，但忽略大小写。</p>
</blockquote>
<h4 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h4><p><strong>构造方法</strong></p>
<blockquote>
<p>StringBuffer() ：构造一个没有任何字符的StringBuffer类。<br>StringBuffer(int length) ：：构造一个没有任何字符的StringBuffer类，并且，其长度为length。<br>StringBuffer(String str) ：以str为初始值构造一个StringBuffer类。</p>
</blockquote>
<p><strong>append方法</strong><br>为该对象添加字符序列，返回添加后的该对象引用，同时是调用了toString方法转化为字符串</p>
<blockquote>
<ol>
<li>StringBuffer append(boolean b)</li>
<li>StringBuffer append(char c)</li>
<li>StringBuffer append(char[] str)</li>
<li>StringBuffer append(char[] str, int offset, int len)</li>
<li>StringBuffer append(double d)</li>
<li>StringBuffer append(float f)</li>
<li>StringBuffer append(int i)</li>
<li>StringBuffer append(long l)</li>
<li>StringBuffer append(Object obj)</li>
<li>StringBuffer append(String str)</li>
<li>StringBuffer append(StringBuffer sb)</li>
</ol>
</blockquote>
<p><strong>其他方法</strong></p>
<blockquote>
<p>12.int capacity() ：返回当前StringBuffer对象（字符串缓冲区）的总空间，而非字符号串的长度。</p>
<ol>
<li>char charAt(int index) ：在当前StringBuffer对象中取索引号为index的字符。第一个字符的索引为“0”</li>
<li>StringBuffer delete(int start, int end) ：删除当前StringBuffer对象中以索引号start开始，到end结束的子串。</li>
<li>StringBuffer deleteCharAt(int index) ：删除当前StringBuffer对象中索引号为index的字符。</li>
<li>void ensureCapacity(int minimumCapacity) ：重新设置字符号串缓冲区的总空间。如果minimumCapacity大于当前的总空间，则新的空间被设置：一种结果是minimumCapacity；另一种结果是{“老空间”乘2加2}<br>17.void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) ：从当前StringBuffer对象的索引号srcBegin开始，到srcEnd结束的子串，赋值到字符数组dst中，并且从dst的索引号dstBegin开始</li>
<li>int indexOf(String str) ：返回当前StringBuffer对象中，第一个满足str子串的位置。</li>
<li>int indexOf(String str, int fromIndex) ：从当前StringBuffer对象的fromIndex开始查找，返回第一个满足str子串的位置。</li>
<li>StringBuffer insert(int offset, boolean b)</li>
<li>StringBuffer insert(int offset, char c)</li>
<li>StringBuffer insert(int offset, char[] str)</li>
<li>StringBuffer insert(int index, char[] str, int offset, int len)</li>
<li>StringBuffer insert(int offset, double d)</li>
<li>StringBuffer insert(int offset, float f)</li>
<li>StringBuffer insert(int offset, int i)</li>
<li>StringBuffer insert(int offset, long l)</li>
<li>StringBuffer insert(int offset, Object obj)</li>
<li>StringBuffer insert(int offset, String str)</li>
<li>int lastIndexOf(String str) ：返回当前StringBuffer对象中，最后一个满足str子串的位置。</li>
<li>int lastIndexOf(String str, int fromIndex) ：从当前StringBuffer对象的fromIndex开始查找，返回最后一个满足str子串的位置。</li>
<li>int length() ：返回当前StringBuffer对象（字符缓冲区）中，字符串的长度。注意：此方法与capacity() 不同。</li>
<li>StringBuffer replace(int start, int end, String str) ：替换当前StringBuffer对象的字符串。从start开始，到end结束的位置替换成str。</li>
<li>StringBuffer reverse() ：将字符串翻转。</li>
<li>void setCharAt(int index, char ch) ：设置索引号index的字符为ch。</li>
<li>void setLength(int newLength) ：重新设置字符串缓冲区中字符串的长度，如果newLength小于当前的字符串长度，将截去多余的字符。</li>
<li>String substring(int start) ：取当前StringBuffer对象中，从start开始到结尾的子串。</li>
<li>String substring(int start, int end) ：取当前StringBuffer对象中，从start开始到end的子串。</li>
<li>String toString() ：将当前StringBuffer对象转换成String对象。</li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Brute-Force与KMP算法]]></title>
      <url>http://www.myzwl.win/2017/07/19/suanfa_2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设有两个串：目标串target和模式串pattern，在目标串中查找与模式串pattern相等得一个子串并确定孩子串位置的操作称为串的模式匹配。而匹配的结果有两种，如果target中存在等于pattern的子串，则匹配成功，给出孩子串在target中的位置，否则匹配失败</p>
<h4 id="Brute-Force算法"><a href="#Brute-Force算法" class="headerlink" title="Brute-Force算法"></a>Brute-Force算法</h4><p><img src="/images/imgs4/16.gif" alt="Alt text"><br>算法描述：如图，该算法的核心就是在target中从begin位置，这里begin=0开始，比较ti与pi是否相等，如果有一个不相等，则begin开始从之前的下一个字符开始匹配，同时pattern中退回到第一个字符，在依次比较，知道存在相等字符，返回相应位置，可以发现该算法是一个回溯算法。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//模式匹配，pattern为待匹配子串，begin为起始匹配位置</div><div class="line">public int indexOf(MyString pattern,int begin)&#123;</div><div class="line">	//待匹配子串不为空并且长度大于0和目标串大于等于带匹配子串</div><div class="line">	if(pattern!=null&amp;&amp;pattern.length()&gt;0&amp;&amp;this.length()&gt;=pattern.length())</div><div class="line">	&#123;</div><div class="line">		int i=begin,j=0; //记录i为开始位置，j为待匹配子串计数器</div><div class="line">		while(i&gt;this.length())&#123; //目标串全部匹配完，退出</div><div class="line">			if(this.charAt(i)==pattern.charAt(j))//如果，有字符相等</div><div class="line">			&#123;</div><div class="line">				i++; //计数器都加1，并且开始比较后一个字符</div><div class="line">				j++;</div><div class="line">			&#125;</div><div class="line">			else&#123;</div><div class="line">				i=i+j+1; //i回溯，变成上一个目标串匹配字符的下一个字符</div><div class="line">				j=0;    //待匹配字符，回溯为0</div><div class="line">			&#125;</div><div class="line">			if(j==pattern.length())</div><div class="line">				return i-j; //返回匹配到的位置</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	           return -1; //匹配失败</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回当前目标串的首次位置，从第一个位置开始</div><div class="line">public int indexOf(MyString pattern)&#123;</div><div class="line">	return this.indexOf(pattern, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="模式匹配应用"><a href="#模式匹配应用" class="headerlink" title="模式匹配应用"></a>模式匹配应用</h4><p>一般我们要替换或者删除相关子串时，首先就是查找是否存在此串，然后在进行相关操作<br>首先是替换操作<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//返回当前串替换之后的串</div><div class="line">public MyString replaceFirst(MyString pattern,MyString replacement)&#123;</div><div class="line">	int i=this.indexOf(pattern, 0);//找到要替换串的下标</div><div class="line">	 if(i==-1)</div><div class="line">		 return this; //不存在要替换的部分，返回当前串</div><div class="line">	 //连接三个串</div><div class="line">	 return this.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length()));		 </div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyString replaceAll(MyString pattern,MyString replacement)&#123;</div><div class="line">	MyString temp=new MyString(this);</div><div class="line">	 int i=this.indexOf(pattern, 0);</div><div class="line">	  while(1!=-1)</div><div class="line">	  &#123;</div><div class="line">		  temp=temp.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length()));</div><div class="line">		  i=temp.indexOf(pattern, i+replacement.length());//从下一个字符开始继续寻找匹配</div><div class="line">	  &#125;</div><div class="line">	  return temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，String是不变类型，也就是一个新的字符串是在堆栈上又开辟了一个新空间，不是原来的对象<br>下面是删除操作<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public MyString deleteFirst(MyString target,MyString pattern)&#123;</div><div class="line">	int i=target.indexOf(pattern);</div><div class="line">	 if(i==-1)</div><div class="line">		 return target;</div><div class="line">	  return target.substring(0, i)+target.substring(i+pattern.length());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyString deleteAll(MyString target,MyString pattern)&#123;</div><div class="line">	int i=target.indexOf(pattern);</div><div class="line">	 while(i!=-1)</div><div class="line">	 &#123;</div><div class="line">		 target=target.substring(0, i)+target.substring(i+pattern.length());</div><div class="line">		  i=target.indexOf(pattern, i);</div><div class="line">	 &#125;</div><div class="line">	 return target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心思想就是先模式匹配，然后在构造一个新的串</p>
<p>最后分析一下该模式匹配算法，假设模式串长度为m，可以发现他的时间复杂度为O(m);并且匹配中存在很多重复，所以算法效率是很低的</p>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>由之前的算法我们知道，它存在重复匹配，如之前的pattern=abc，此时p的各个字符都不相等，而在匹配时target=ababdabcd中，第一次从a匹配，到第三位不等，开始从第二位匹配，但由于第一次已经知道pi各位不等，所以第二位就不用匹配了，他肯定与第一位不等，所以可省略，而这恰恰是KMP算法的核心</p>
<p><strong>next数组</strong><br>next数组的作用就是研究pattern串，依次确定如果不匹配下一次target串从哪一位开始匹配。并且这样定义next数组</p>
<blockquote>
<p>next[J]=-1，当j=0；<br>next[j]=k 当0&lt;=k&lt;f时且使p_0..p_k-1=p_j-k..p_j-1的最大整数</p>
</blockquote>
<p><img src="/images/imgs4/17.gif" alt="Alt text"><br>如图：pattern=”abcabc”，当j=0时，next[0]=-1；当j=1,2,3时，”a”,”ab”,”abc”都没有相同前缀子串和后缀子串next[j]=k=0；当j=4时，”abca”钟相同的前缀子串和后缀子串是”a”，所以k=1；当j=5时，为”ab”，所以k=2，依次类推<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private int[] getNext(String pattern)&#123;  //求next</div><div class="line">		int j=0,k=-1;                   //初始化j，k，next</div><div class="line">		int[] next=new int[pattern.length()];</div><div class="line">		next[0]=-1;</div><div class="line">		while(j&lt;pattern.length()-1)    //当j遍历完pattern字符串，结束</div><div class="line">		&#123;</div><div class="line">			if(k==-1||pattern.charAt(j)==pattern.charAt(k)) //k为初始值或者pattern的后缀字符与前缀相同</div><div class="line">			&#123; </div><div class="line">				j++;           //j后移，k加一，同时第j个字符的next值为k</div><div class="line">				k++;</div><div class="line">				next[j]=k;</div><div class="line">			&#125; </div><div class="line">			else              //否则，k重新回到前缀值，继续比较</div><div class="line">				k=next[k];</div><div class="line">			return next;</div><div class="line">		&#125;</div><div class="line">		return next;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下面是KMP的算法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int indexOf(String target,String pattern,int begin)&#123;</div><div class="line">		if(pattern!=null&amp;&amp;pattern.length()&gt;0&amp;&amp;this.length()&gt;=pattern.length())</div><div class="line">		&#123;</div><div class="line">		int i=begin,j=0;</div><div class="line">		int[] next=getNext(pattern); //求得next数组，这样就可以避免一些重复比较了</div><div class="line">		while(i&lt;target.length())&#123;</div><div class="line">			if(j==-1||target.charAt(i)==pattern.charAt(j))</div><div class="line">			&#123;</div><div class="line">				i++;</div><div class="line">				j++;</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">				j=next[j]; //退回到next[J]个字符开始比较</div><div class="line">			if(j==pattern.length())</div><div class="line">				return i-j;</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		return -1;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h4 id="改进的KMP算法"><a href="#改进的KMP算法" class="headerlink" title="改进的KMP算法"></a>改进的KMP算法</h4><p>当target=”aaaabcde”时，pattern=”aaaax”时，发现，a重复了，按照之前的算法，当i=5时，有重复比较四个a，所以可改进<br><img src="/images/imgs4/18.gif" alt="Alt text"><br>如图：改进的nextval是在next数组基础上，这里约定的next初始值为-1，所以如j=3，与next[j]+1比较，如果相等，则其值等于next[j]+1的next值，否则，保持原next值不变<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private int[] getNext(String pattern)&#123;</div><div class="line">		int j=0,k=-1;</div><div class="line">		int[] next=new int[pattern.length()];</div><div class="line">		next[0]=-1;</div><div class="line">		while(j&lt;pattern.length()-1)</div><div class="line">		&#123;</div><div class="line">			if(k==-1||pattern.charAt(j)==pattern.charAt(k))</div><div class="line">			&#123;</div><div class="line">				j++;</div><div class="line">				k++;</div><div class="line">				if(pattern.charAt(j)!=pattern.charAt(k))//改进之处</div><div class="line">				next[j]=k;</div><div class="line">				else</div><div class="line">					next[j]=next[k];</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">				k=next[k];</div><div class="line">			return next;</div><div class="line">		&#125;</div><div class="line">		return next;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>由此发现KMP算法的时间复杂度为O(n);</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[冒泡与选择排序]]></title>
      <url>http://www.myzwl.win/2017/07/18/suanfa_1/</url>
      <content type="html"><![CDATA[<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>算法描述：冒泡排序是一种交换排序，它的基本思想就是两两比较相邻的关键字，如果反序则交换，直到没有反序的记录为止<br><img src="/images/imgs4/14.gif" alt="Alt text"><br>就像冒泡一样，第一次先把最大的选出来冒到最后，依次类推，从下个继续冒最大的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int a[])&#123;</div><div class="line">		int temp;  //临时变量，用于交换</div><div class="line">		for(int i=a.length-1;i&gt;0;i--) //外层循环，用于控制需要冒泡的个数</div><div class="line">			for(int j=0;j&lt;=i-1;j++) //内存循环</div><div class="line">				if(a[j]&gt;a[j+1]) //如果需要交换，则交换</div><div class="line">				&#123;</div><div class="line">					temp=a[j+1];</div><div class="line">					a[j+1]=a[j];</div><div class="line">					a[j]=temp;</div><div class="line">				&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出这个冒泡的实现是很简单的，但是效率上存在严重问题，比如有序数列2,1,3,4,5这个除了第一个，其余都已经是有序了，但是根据算法还是不断循环，比较增加了冗余，所以需要改进<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int a[])&#123;</div><div class="line">	int temp;</div><div class="line">	boolean flag=true; //用来作为标记</div><div class="line">	for(int i=a.length-1;i&gt;0&amp;&amp;flag;i--)&#123; //如果flag为false，也就是已经有序了，退出</div><div class="line">		flag=false;  //初始化为false</div><div class="line">		for(int j=0;j&lt;=i-1;j++)</div><div class="line">			if(a[j]&gt;a[j+1])</div><div class="line">			&#123;</div><div class="line">				temp=a[j+1];</div><div class="line">				a[j+1]=a[j];</div><div class="line">				a[j]=temp;</div><div class="line">				flag=true;  //如果有数据交换，则设为true</div><div class="line">			&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>显然从效率上提高了许多，由内外循环次数可以得出其时间复杂度为o(n^2)</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>算法描述：选择排序就是通过n-i此关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换<br><img src="/images/imgs4/15.gif" alt="Alt text"><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void ChooseSort(int[] a)&#123;</div><div class="line">	int min,temp;  //分别为每一次循环的当前最小变量和临时变量</div><div class="line">	for(int i=0;i&lt;a.length;i++)&#123;</div><div class="line">		 min=i; //初始化最小变量，为当前循环的第一个变量</div><div class="line">	 for(int j=i+1;j&lt;a.length;j++)</div><div class="line">	 &#123;</div><div class="line">		 if(a[j]&lt;a[i])  //找到比当前循环的最小变量小的记录，并记录下标</div><div class="line">			 min=j;</div><div class="line">	 &#125;</div><div class="line">	 if(min!=i) //如果有比当前最小变量小，则交换记录</div><div class="line">	 &#123;</div><div class="line">		 temp=a[min];</div><div class="line">		 a[min]=a[i];</div><div class="line">		 a[i]=temp;			 </div><div class="line">	 &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出它的时间复杂度仍然是O(n^2)</p>
<h4 id="约瑟夫环的另一种解法"><a href="#约瑟夫环的另一种解法" class="headerlink" title="约瑟夫环的另一种解法"></a>约瑟夫环的另一种解法</h4><p>至于问题描述就不描述了，在之前的数据结构总结中已经有了这个问题的描述<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public static void Count3Quit()&#123;</div><div class="line">		boolean[] arr=new boolean[500]; //初始化500个人围成圈</div><div class="line">		 for(int i=0;i&lt;arr.length;i++) //假设每个人值都为true</div><div class="line">	      arr[i]=true;</div><div class="line">		    int len=arr.length; //记录总人数</div><div class="line">		    int index=0;  //记录每个人的索引</div><div class="line">		    int count=0;  //记录数数变量，这里是数三退一</div><div class="line">		     while(len&gt;1)//直到只剩最后一个人为止</div><div class="line">		     &#123;</div><div class="line">		    	 if(arr[index]==true) //人还在圈内</div><div class="line">		    	 &#123;</div><div class="line">		    		 count++; //数数加一</div><div class="line">		    		 if(count==3) //数到三时，退一个人</div><div class="line">		    		 &#123;</div><div class="line">		    			 count=0; //计数重置为0</div><div class="line">		    			  arr[index]=false; //该人退出</div><div class="line">		    			   len--; //总人数减一</div><div class="line">		    		 &#125;</div><div class="line">		    	 &#125;</div><div class="line">		    	 index++; //索引加一</div><div class="line">		    	 if(index==arr.length)//索引超出人数长度，循环从0开始</div><div class="line">		    		 index=0;</div><div class="line">		     &#125;</div><div class="line">		     for(int i=0;i&lt;arr.length;i++)//输出最后一个人</div><div class="line">		    	 if(arr[i]==true)</div><div class="line">		    		 System.out.println(i);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java异常处理二]]></title>
      <url>http://www.myzwl.win/2017/07/17/yc_2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过一已经初步了解了异常的一些原理和相关性质，当然在平时写程序时被各种各样的异常类型弄得叫苦不堪<br><img src="/images/imgs4/12.gif" alt="Alt text"></p>
<h4 id="java常见异常"><a href="#java常见异常" class="headerlink" title="java常见异常"></a>java常见异常</h4><p>从api文档中可以看出，java已经为我们内置了很多异常<br><img src="/images/imgs4/13.gif" alt="Alt text"><br>先来看看RuntimeException中常见异常</p>
<blockquote>
<p>  1java.lang.ArrayIndexOutOfBoundsException<br>    数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。<br>    2、java.lang.ArithmeticException<br>    算术条件异常。譬如：整数除零等。<br>    3、java.lang.NullPointerException<br>    空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等<br>    4、java.lang.ClassNotFoundException<br>    找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。<br>   5、java.lang.NegativeArraySizeException  数组长度为负异常<br>   6、java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常<br>   7、java.lang.SecurityException 安全性异常<br>   8、java.lang.IllegalArgumentException 非法参数异常</p>
</blockquote>
<p><strong>IOException</strong></p>
<blockquote>
<p>IOException：操作输入流和输出流时可能出现的异常。<br>  EOFException   文件已结束异常<br>  FileNotFoundException   文件未找到异常</p>
</blockquote>
<p><strong>其他异常</strong></p>
<blockquote>
<p> ClassCastException    类型转换异常类<br>   ArrayStoreException  数组中包含不兼容的值抛出的异常<br>    SQLException   操作数据库异常类<br>    NoSuchFieldException   字段未找到异常<br>    NoSuchMethodException   方法未找到抛出的异常<br>    NumberFormatException    字符串转换为数字抛出的异常<br>    StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常<br>    IllegalAccessException  不允许访问某类异常<br>    InstantiationException  当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</p>
</blockquote>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>在Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。<br> 所有异常都必须是 Throwable 的子类。<br> 如果希望写一个检查性异常类，则需要继承 Exception 类。<br> 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。<br> 如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class MyException extends Exception&#123;</div><div class="line"></div><div class="line">	private int id;</div><div class="line">	</div><div class="line">	public MyException()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyException(String msg,int id)&#123;</div><div class="line">		super(msg);</div><div class="line">		this.id=id;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int getId()&#123;</div><div class="line">		return this.id;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Ttest &#123;</div><div class="line">  public void regist(int num) throws MyException&#123;</div><div class="line">	  if(num&lt;0)&#123;</div><div class="line">		  throw new MyException("不能为负数",404);</div><div class="line">	  &#125;</div><div class="line">	  System.out.println("it is"+num);		  </div><div class="line">  &#125;</div><div class="line">  public void manager()&#123;</div><div class="line">	  try &#123;</div><div class="line">		regist(-10);</div><div class="line">	&#125; catch (MyException e) &#123;</div><div class="line">		System.out.println("Error Code"+e.getId());</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">	  System.out.println("over");</div><div class="line">  &#125;</div><div class="line">  public static void main(String args[])&#123;</div><div class="line">	  Ttest t=new Ttest();</div><div class="line">	  t.manager();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果有异常时运行结果如下：</p>
<blockquote>
<p>com.test.QQ.MyException: 不能为负数<br>    at com.test.QQ.Ttest.regist(Ttest.java:6)<br>    at com.test.QQ.Ttest.manager(Ttest.java:12)<br>    at com.test.QQ.Ttest.main(Ttest.java:21)<br>Error Code404<br>over</p>
</blockquote>
<p>将regist（-10）改为regist（10），如下</p>
<blockquote>
<p>it is10<br>over</p>
</blockquote>
<h4 id="spring异常处理"><a href="#spring异常处理" class="headerlink" title="spring异常处理"></a>spring异常处理</h4><p>前面我们都是用try..catch来捕获异常，造成业务逻辑较多，而spring通过注解式使捕获异常更方便。核心如下：</p>
<blockquote>
<p>  @ExceptionHandler：统一处理某一类异常，从而能够减少代码重复率和复杂度<br>    @ControllerAdvice：异常集中处理，更好的使业务逻辑与异常处理剥离开<br>    @ResponseStatus：可以将某种异常映射为HTTP状态码</p>
</blockquote>
<p>@ExceptionHandler源码如下：</p>
<blockquote>
<p>@Target({ElementType.METHOD})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface ExceptionHandler {<br>    Class&lt;? extends Throwable&gt;[] value() default {};<br> }</p>
</blockquote>
<p> 首先是注解的说明：<br> @Retention: 定义注解的保留策略<br>@Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在class字节码文件中不包含<br>@Retention(RetentionPolicy.CLASS)     // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，<br>@Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到</p>
<p>@Target：定义注解的作用目标<br>@Target(ElementType.TYPE)   //接口、类、枚举、注解<br>@Target(ElementType.FIELD) //字段、枚举的常量<br>@Target(ElementType.METHOD) //方法<br>@Target(ElementType.PARAMETER) //方法参数<br>@Target(ElementType.CONSTRUCTOR)  //构造函数<br>@Target(ElementType.LOCAL_VARIABLE)//局部变量<br>@Target(ElementType.ANNOTATION_TYPE)//注解<br>@Target(ElementType.PACKAGE) ///包    </p>
<p>@Document：说明该注解将被包含在javadoc中<br>@Inherited：说明子类可以继承父类中的该注解</p>
<p>该注解作用对象为方法，并且在运行时有效，value()可以指定异常类<br>方法返回值可以为：<br>    ModelAndView对象<br>    Model对象<br>    Map对象<br>    View对象<br>    String对象<br>    还有@ResponseBody、HttpEntity&lt;?&gt;或ResponseEntity&lt;?&gt;，以及void</p>
<p>如</p>
<blockquote>
<p>@ControllerAdvice //在所有的controller中执行该异常<br>public class DefaultExceptionHandler {<br>    /**</p>
<pre><code> * 没有权限 异常
 * &lt;p/&gt;
 * 后续根据不同的需求定制即可
 */
@ExceptionHandler({UnauthorizedException.class}) //不同的异常处理
@ResponseStatus(HttpStatus.UNAUTHORIZED)
public String processUnauthenticatedException(NativeWebRequest request, UnauthorizedException e) {
    System.out.println(&quot;un&quot;);
    return null;
</code></pre><p>}</p>
</blockquote>
<pre><code>@ExceptionHandler(RuntimeException.class)
@ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)  
public String handleUnexpectedServerError(RuntimeException ex) { 
    System.out.println(&quot;500&quot;);
    return null;
}

@ExceptionHandler(ServletException.class)
@ResponseStatus(value = HttpStatus.NOT_FOUND)  
public String handleNotFoundError() {     
       System.out.println(&quot;404&quot;);
      return null;       
}
</code></pre><p>}</p>
<p>如上的500和404错误，先给出错误的异常，在给出错误的状态码并且异常与状态码必须是对应的，该类的源码在org.springframework.http下，如</p>
<blockquote>
<p>public enum HttpStatus {<br>成功<br>   OK(200, “OK”),<br>   创建<br>   CREATED(201, “Created”),<br>   /接受<br>   ACCEPTED(202, “Accepted”),<br>   BAD_REQUEST(400, “Bad Request”),<br>   没有认证权限<br>   UNAUTHORIZED(401, “Unauthorized”),</p>
</blockquote>
<p>   PAYMENT_REQUIRED(402, “Payment Required”),<br>   禁止<br>   FORBIDDEN(403, “Forbidden”),</p>
<p>   NOT_FOUND(404, “Not Found”),</p>
<p>   有了上述全局处理的异常，就不许要在每个类里面重复写了，同时如果我们是在页面中需要捕获异常，如页面的404和500，只需在web.xml中配置一下（在spring配置文件中注入无效，也不知道怎么回事），如下：</p>
<blockquote>
<p><error-page><br>        <error-code>404</error-code><br>        <location>/404.jsp</location><br>    </error-page><br>    <error-page><br>    <error-code>500</error-code><br>     <location>/500.jsp</location><br> </error-page></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java异常处理一]]></title>
      <url>http://www.myzwl.win/2017/07/16/yc_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不得不说，我们平时在写程序时遇到最多的情形或者最头疼的事情就是遇到异常，然后各种调试，各种方法用尽最后才解决它，那么异常主要分为几类，每个类又有什么特征了（如图）<br><img src="/images/imgs4/11.gif" alt="Alt text"><br>从大的角度说主要分成两类：Error类代表了编译和系统的错误，不允许捕获，也就是我们自己无法主动去处理它；Exception类代表了我们可捕获并且可自己可处理异常，而Exception有包括两类，一个是你必须要处理的异常，如某个类有throws异常了，在未进入运行期就必须处理，另一类就是Runtime Exception（运行期异常），就是只有在运行时（也就是编译成class文件）时才知道，这个异常可处理或不处理</p>
<h4 id="处理异常机制"><a href="#处理异常机制" class="headerlink" title="处理异常机制"></a>处理异常机制</h4><p>在java应用程序中，异常处理机制主要为两种:抛出异常和捕获异常<br><strong>抛出异常</strong><br>简单的说，就是不处理异常，将异常不断抛给上一级，直至某一级有有处理异常措施，一般用throws、throw如</p>
<blockquote>
<p>public readFile() throws IOException{<br>    throw new xxx();<br>}</p>
</blockquote>
<p><strong>捕获异常</strong><br>定义是这样说的，在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。<br>一般有try..catch语句块，其语法格式如下：</p>
<blockquote>
<p>   try {<br>        // 可能会发生异常的程序代码<br>    } catch (Type1 id1){<br>        // 捕获并处置try抛出的异常类型Type1<br>    }<br>    catch (Type2 id2){<br>         //捕获并处置try抛出的异常类型Type2<br>    }  </p>
</blockquote>
<pre><code>如果，不管异常有没有捕获，都要执行某段代码，如数据库查询后都要关闭等等，就可以用finally，上面修改
</code></pre><blockquote>
<p>   try {<br>        // 可能会发生异常的程序代码<br>    } catch (Type1 id1){<br>        // 捕获并处置try抛出的异常类型Type1<br>    }<br>    catch (Type2 id2){<br>         //捕获并处置try抛出的异常类型Type2<br>    }  finally{<br>        //必须执行的代码<br>    }</p>
</blockquote>
<h4 id="try-catch-finally-规则"><a href="#try-catch-finally-规则" class="headerlink" title="try-catch-finally 规则"></a>try-catch-finally 规则</h4><pre><code>try块：用于捕获异常。其后可接0个或多个catch块，如果没有catch块，则必须跟一个finally块
catch块：用于处理try捕获到的异常。
finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行：
</code></pre><p>1）在finally语句块中发生了异常。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）关闭CPU。</p>
<p>try..catch..拥有执行顺序，即第一个catch之后，后面不在执行catch，所以一般将较详细的catch放在最前面，如先捕获IOException在捕获Exception</p>
<h4 id="throws规则"><a href="#throws规则" class="headerlink" title="throws规则"></a>throws规则</h4><p>1) 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</p>
<p>2）必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</p>
<p>3)仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出</p>
<p>4）调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。<br>如下</p>
<blockquote>
<pre><code>void method1() throws IOException{}  //合法    
</code></pre></blockquote>
<pre><code>//编译错误，必须捕获或声明抛出IOException    
void method2(){    
  method1();    
}    

//合法，声明抛出IOException    
void method3()throws IOException {    
  method1();    
}    

//合法，声明抛出Exception，IOException是Exception的子类    
void method4()throws Exception {    
  method1();    
}    

//合法，捕获IOException    
void method5(){    
 try{    
    method1();    
 }catch(IOException e){…}    
}    

//编译错误，必须捕获或声明抛出Exception    
void method6(){    
  try{    
    method1();    
  }catch(IOException e){throw new Exception();}    
}    

//合法，声明抛出Exception    
void method7()throws Exception{    
 try{    
  method1();    
 }catch(IOException e){throw new Exception();}    
}   

这里需要注意的是throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象
</code></pre><p><strong>Throwable类源码分析</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div></pre></td><td class="code"><pre><div class="line">/**  </div><div class="line">    *   </div><div class="line">    * Throwable是所有Error和Exceptiong的父类  </div><div class="line">    * 注意它有四个构造函数:  </div><div class="line">    * Throwable()  </div><div class="line">    * Throwable(String message)  </div><div class="line">    * Throwable(Throwable cause)  </div><div class="line">    * Throwable(String message, Throwable cause)  </div><div class="line">    *   </div><div class="line">    */    </div><div class="line">    public class Throwable implements Serializable &#123;    </div><div class="line">          private static final long serialVersionUID = -3042686055658047285L;    </div><div class="line">        </div><div class="line">          /**  </div><div class="line">           * Native code saves some indication of the stack backtrace in this slot.  </div><div class="line">           */    </div><div class="line">          private transient Object backtrace;     </div><div class="line">          /** </div><div class="line">       * 描述此异常的信息 </div><div class="line">       */  </div><div class="line">      private String detailMessage;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 表示当前异常由那个Throwable引起 </div><div class="line">        * 如果为null表示此异常不是由其他Throwable引起的 </div><div class="line">        * 如果此对象与自己相同,表明此异常的起因对象还没有被初始化 </div><div class="line">       */  </div><div class="line">      private Throwable cause = this;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 描述异常轨迹的数组 </div><div class="line">       */  </div><div class="line">      private StackTraceElement[] stackTrace;  </div><div class="line">      /** </div><div class="line">       * 构造函数,起因对象没有被初始化可以在以后使用initCause进行初始化 </div><div class="line">        * fillInStackTrace可以用来初始化它的异常轨迹的数组 </div><div class="line">       */  </div><div class="line">      public Throwable() &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数 </div><div class="line">       */  </div><div class="line">      public Throwable(String message) &#123;  </div><div class="line">         //填充异常轨迹数组  </div><div class="line">          fillInStackTrace();  </div><div class="line">         //初始化异常描述信息  </div><div class="line">          detailMessage = message;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数,cause表示起因对象 </div><div class="line">       */  </div><div class="line">      public Throwable(String message, Throwable cause) &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">          detailMessage = message;  </div><div class="line">          this.cause = cause;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数 </div><div class="line">       */  </div><div class="line">      public Throwable(Throwable cause) &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">          detailMessage = (cause==null ? null : cause.toString());  </div><div class="line">          this.cause = cause;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 获取详细信息 </div><div class="line">       */  </div><div class="line">      public String getMessage() &#123;  </div><div class="line">          return detailMessage;  </div><div class="line">      &#125;  </div><div class="line"></div><div class="line">      /** </div><div class="line">       * 获取详细信息 </div><div class="line">       */  </div><div class="line">      public String getLocalizedMessage() &#123;  </div><div class="line">          return getMessage();  </div><div class="line">      &#125;  </div><div class="line">       /** </div><div class="line">       * 获取起因对象 </div><div class="line">       */  </div><div class="line">      public Throwable getCause() &#123;  </div><div class="line">          return (cause==this ? null : cause);  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 初始化起因对象,这个方法只能在未被初始化的情况下调用一次 </div><div class="line">       */  </div><div class="line">      public synchronized Throwable initCause(Throwable cause) &#123;  </div><div class="line">         //如果不是未初始化状态则抛出异常  </div><div class="line">          if (this.cause != this)  </div><div class="line">              throw new IllegalStateException("Can't overwrite cause");  </div><div class="line">          </div><div class="line">         //要设置的起因对象与自身相等则抛出异常  </div><div class="line">          if (cause == this)  </div><div class="line">              throw new IllegalArgumentException("Self-causation not permitted");  </div><div class="line">          </div><div class="line">         //设置起因对象  </div><div class="line">          this.cause = cause;  </div><div class="line">         //返回设置的起因的对象  </div><div class="line">          return this;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 字符串表示形式 </div><div class="line">       */  </div><div class="line">      public String toString() &#123;       </div><div class="line">          String s = getClass().getName();          </div><div class="line">          String message = getLocalizedMessage();        </div><div class="line">          return (message != null) ? (s + ": " + message) : s;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace() &#123;   </div><div class="line">          printStackTrace(System.err);  </div><div class="line">      &#125;  </div><div class="line"></div><div class="line">       /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace(PrintStream s) &#123;  </div><div class="line">          synchronized (s) &#123;  </div><div class="line">            //调用当前对象的toString方法  </div><div class="line">              s.println(this);  </div><div class="line">            //获取异常轨迹数组  </div><div class="line">              StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">              </div><div class="line">            //打印出每个元素的字符串表示  </div><div class="line">              for (int i=0; i &lt; trace.length; i++)  </div><div class="line">                s.println("\tat " + trace[i]);  </div><div class="line">  </div><div class="line">            //获取起因对象  </div><div class="line">              Throwable ourCause = getCause();  </div><div class="line">              </div><div class="line">            //递归的打印出起因对象的信息  </div><div class="line">              if (ourCause != null)  </div><div class="line">                ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">       /** </div><div class="line">       * 打印起因对象的信息 </div><div class="line">       * @param s 打印的流 </div><div class="line">        * @param causedTrace 有此对象引起的异常的异常轨迹  </div><div class="line">       */  </div><div class="line">      private void printStackTraceAsCause(PrintStream s,  </div><div class="line">                                          StackTraceElement[] causedTrace)  </div><div class="line">      &#123;  </div><div class="line">         //获得当前的异常轨迹  </div><div class="line">          StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">         //m为当前异常轨迹数组的最后一个元素位置,   </div><div class="line">         //n为当前对象引起的异常的异常轨迹数组的最后一个元素  </div><div class="line">          int m = trace.length-1, n = causedTrace.length-1;  </div><div class="line">         //分别从两个数组的后面做循环,如果相等则一直循环,直到不等或数组到头  </div><div class="line">          while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(causedTrace[n])) &#123;  </div><div class="line">              m--; n--;  </div><div class="line">         &#125;  </div><div class="line">          </div><div class="line">         //相同的个数  </div><div class="line">          int framesInCommon = trace.length - 1 - m;  </div><div class="line">          </div><div class="line">         //打印出不同的错误轨迹  </div><div class="line">          s.println("Caused by: " + this);  </div><div class="line">          for (int i=0; i &lt;= m; i++)  </div><div class="line">              s.println("\tat " + trace[i]);  </div><div class="line">          //如果有相同的则打印出相同的个数  </div><div class="line">          if (framesInCommon != 0)  </div><div class="line">              s.println("\t... " + framesInCommon + " more");  </div><div class="line">  </div><div class="line">         //获得此对象的起因对象,并递归打印出信息  </div><div class="line">          Throwable ourCause = getCause();  </div><div class="line">          if (ourCause != null)  </div><div class="line">              ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace(PrintWriter s) &#123;   </div><div class="line">          synchronized (s) &#123;  </div><div class="line">              s.println(this);  </div><div class="line">              StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">              for (int i=0; i &lt; trace.length; i++)  </div><div class="line">                  s.println("\tat " + trace[i]);  </div><div class="line">  </div><div class="line">              Throwable ourCause = getCause();  </div><div class="line">              if (ourCause != null)  </div><div class="line">                  ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 打印起因对象的信息 </div><div class="line">        */  </div><div class="line">      private void printStackTraceAsCause(PrintWriter s,  </div><div class="line">                                          StackTraceElement[] causedTrace)  </div><div class="line">      &#123;  </div><div class="line">          // assert Thread.holdsLock(s);  </div><div class="line">  </div><div class="line">          // Compute number of frames in common between this and caused  </div><div class="line">          StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">          int m = trace.length-1, n = causedTrace.length-1;  </div><div class="line">          while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(causedTrace[n])) &#123;  </div><div class="line">              m--; n--;  </div><div class="line">          &#125;  </div><div class="line">          int framesInCommon = trace.length - 1 - m;  </div><div class="line">  </div><div class="line">          s.println("Caused by: " + this);  </div><div class="line">          for (int i=0; i &lt;= m; i++)  </div><div class="line">              s.println("\tat " + trace[i]);  </div><div class="line">          if (framesInCommon != 0)  </div><div class="line">              s.println("\t... " + framesInCommon + " more");  </div><div class="line">  </div><div class="line">          // Recurse if we have a cause  </div><div class="line">          Throwable ourCause = getCause();  </div><div class="line">          if (ourCause != null)  </div><div class="line">              ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 填充异常轨迹 </div><div class="line">       */  </div><div class="line">      public synchronized native Throwable fillInStackTrace();  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 返回当前的异常轨迹的拷贝 </div><div class="line">       */  </div><div class="line">      public StackTraceElement[] getStackTrace() &#123;  </div><div class="line">          return (StackTraceElement[]) getOurStackTrace().clone();  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      </div><div class="line">      /** </div><div class="line">       * 获取当前的异常轨迹 </div><div class="line">        */  </div><div class="line">      private synchronized StackTraceElement[] getOurStackTrace() &#123;  </div><div class="line">         //如果第一次调用此方法则初始化异常轨迹数组  </div><div class="line">          if (stackTrace == null) &#123;  </div><div class="line">            //获得异常轨迹深度  </div><div class="line">              int depth = getStackTraceDepth();  </div><div class="line">            //创建新的异常轨迹数组,并填充它  </div><div class="line">              stackTrace = new StackTraceElement[depth];  </div><div class="line">              </div><div class="line">            for (int i=0; i &lt; depth; i++)  </div><div class="line">                stackTrace[i] = getStackTraceElement(i);//获取指定位标的异常轨迹  </div><div class="line">          &#125;  </div><div class="line">          </div><div class="line">          return stackTrace;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 设置异常轨迹 </div><div class="line">       */  </div><div class="line">      public void setStackTrace(StackTraceElement[] stackTrace) &#123;  </div><div class="line">         //拷贝设置参数  </div><div class="line">          StackTraceElement[] defensiveCopy =  </div><div class="line">              (StackTraceElement[]) stackTrace.clone();  </div><div class="line">          </div><div class="line">         //如果设置参数有空元素则抛出异常  </div><div class="line">          for (int i = 0; i &lt; defensiveCopy.length; i++)  </div><div class="line">              if (defensiveCopy[i] == null)  </div><div class="line">                  throw new NullPointerException("stackTrace[" + i + "]");  </div><div class="line">  </div><div class="line">         //设置当前对象的异常轨迹  </div><div class="line">          this.stackTrace = defensiveCopy;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 异常轨迹的深度,0表示无法获得 </div><div class="line">       */  </div><div class="line">      private native int getStackTraceDepth();  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 获取指定位标的异常轨迹 </div><div class="line">       */  </div><div class="line">      private native StackTraceElement getStackTraceElement(int index);  </div><div class="line">  </div><div class="line">      </div><div class="line">      private synchronized void writeObject(java.io.ObjectOutputStream s)  </div><div class="line">          throws IOException  </div><div class="line">      &#123;  </div><div class="line">          getOurStackTrace();  </div><div class="line">          s.defaultWriteObject();  </div><div class="line">      &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上源码分析来自于互联网，同时由于目前是jdk1.8和这个源码有一小部分不一样，但不影响整体分析。当然，我们真正关心的是他的下面几个方法</p>
<blockquote>
<p>e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息:<br>   getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。<br>　 getMeage()：返回异常的消息信息。<br>　 printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。<br>而当我们出现异常时，就形成一条异常链，一个一个堆栈的打印出相关信息和异常</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二分查找]]></title>
      <url>http://www.myzwl.win/2017/07/15/sjjg_10/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>查找操作，通俗的讲，就是给定一个值key，在一个数据结构中找出关键字为key的元素。而基于线性表的查找算法有顺序查找（O（n）），二分查找和分块查找</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>主要用于已排序的顺序表<br>算法描述：假定顺序表已按照升序排列，从表的中间位置开始比较，如果当前元素的关键字等于给定值，则查找成功，否则，若给定的值小于当前元素关键字，则在表的前半段继续查找，反之，在后半段查找，以此重复，直到获得查找结果<br><img src="/images/imgs4/10.gif" alt="Alt text"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class BSArray &#123;</div><div class="line"></div><div class="line">	//在升序排列的数组中，若找到关键字，则返回相应下标，否则返回-1</div><div class="line">	public static&lt;T&gt; int binarySearch(Comparable&lt;T&gt;[] value,T key)&#123;</div><div class="line">		return binarySearch(value,0,value.length-1,key);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static&lt;T&gt; int binarySearch(Comparable&lt;T&gt;[] value,int begin,int end,T key)&#123;</div><div class="line">		if(key!=null)</div><div class="line">			while(begin&lt;=end)&#123;    //边界有效</div><div class="line">				int mid=(begin+end)/2;  //中间位置，当前比较元素位置</div><div class="line">		System.out.println(value[mid]+"?");</div><div class="line">		if(value[mid].compareTo(key)==0) //对象比较大小</div><div class="line">			return mid;                  //查找成功</div><div class="line">		if(value[mid].compareTo(key)&gt;0)  </div><div class="line">			end=mid-1;                    //缩小到前半段</div><div class="line">		else</div><div class="line">			begin=mid+1;                 //缩小到后半段</div><div class="line">	&#125; </div><div class="line">	return -1;                           //查找不成功</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hash散列表]]></title>
      <url>http://www.myzwl.win/2017/07/14/sjjg_9/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>散列（hash）表是一种支持高效的查找、插入和删除操作的数据结构，它是针对查找效率接近O（1）而专门设计的。它根据元素的关键字确定元素的存储位置，而其中主要解决两个问题，设计散列函数和处理冲突</p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>在数据元素的关键字和该元素的存储位置之间建立一种对应关系，称为散列函数，而由散列函数决定元素存储位置的存储结构称为散列表，散列函数声明为</p>
<blockquote>
<p>public int hash(int key) //散列函数，确定关键字为key元素的散列地址</p>
</blockquote>
<p>散列函数实质上是关键字集合到地址集合的映射，如果这种映射是一一对应的，则查找效率是O（1），但是由于散列表是一个压缩映射，即存储容量有限，即映射关系是多对一的映射，所以会产生冲突<br><img src="/images/imgs4/9.gif" alt="Alt text"></p>
<h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>设两个关键字k1和k2（k1！=k2），如果有hash（k1）=hash（k2），即它们的散列值相同，表示不同关键字的多个元素映射到同一个存储位置，称为冲突，如图，所设的关键字序列是（1,4,3,11,12,6,14,74,16,96），元素个数是10，关键字范围是0~99，如果散列值的容量是100，很明显是一对一不会产生冲突，但是空间利用率此时只有10%，如果容量是10或者20，冲突差生的频率会减少</p>
<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>该散列函数定义为hash（k）=k%p，函数结果范围为0~p-1，图示就是采用这种方法，而p取值为小于散列表长度的最大素数，如散列表长度分别为8,16,128，则对应的p（最大素数）分别为7,13,127</p>
<h4 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h4><p><strong>开放定址法</strong><br>当产生冲突时，开放定址法在散列表内寻找另一个位置存储冲突的元素，如利用线性探查发实现，即设一个元素关键字为k，其散列地址为i=hash（k），若散列表中i位置已存储元素，则产生冲突，探测下一个位置i+1是否为空，。。直到找到一个空位置，但是它的缺陷就是在散列表内处理冲突，使得一个存储地址i可被任意一个元素抢占，这样就破坏了散列函数i=hash（k）的规则</p>
<p><strong>链地址法</strong><br><img src="/images/imgs4/12.jpg" alt="Alt text"><br>该方法是将多个冲突的元素存储在一条单链表中（称为同义词单链表），如图示<br>而对链地址法表进行插入、删除、查找等操作主要分两步完成<br>1.计算元素的散列函数值<br>2.根据元素的散列函数值，对某一条同义词单链表进行插入、删除和查找操作<br>规定查找成功的平均查找长度为（根据图示）ASL=(9<em>1+3</em>2)/12<br>并且有如下结论：<br>1.查找操作的时间复杂度为O（m），其中m为一条痛一次单链表的长度，插入操作为O(1),删除操作为O(m)</p>
<h4 id="模拟HashSet类"><a href="#模拟HashSet类" class="headerlink" title="模拟HashSet类"></a>模拟HashSet类</h4><p>这里同义词单链表采用单链表<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class HashSet&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	private SinglyLinkenList&lt;T&gt;[] table;    //散列表，同义词单链表对象数组</div><div class="line">	public HashSet(int size)&#123;               //构造指定容量的散列表</div><div class="line">		this.table=new SinglyLinkenList[Math.abs(size)];</div><div class="line">		for(int i=0;i&lt;table.length;i++)</div><div class="line">			table[i]=new SinglyLinkenList&lt;T&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public HashSet()&#123; //构造最大质数为97的容量</div><div class="line">		this(97);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private int hash(T x)&#123;  //散列函数，确定关键字为key元素的散列地址</div><div class="line">		int key=Math.abs(x.hashCode()); //每个对象的hashcode（）方法返回散列码，并且每个对象不同</div><div class="line">		return key%table.length; //出留余数法，除数是散列表长度</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void insert(T x)&#123;//插入x元素</div><div class="line">		table[hash(x)].insert(0, x);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void remove(T x)&#123; //删除x元素</div><div class="line">		table[hash(x)].remove((Integer) x);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public T search(T key)&#123; //返回查找到的关键字为key元素，查找不成功返回null</div><div class="line">		return table[hash(key)].search(key);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean contain(T key)&#123; //判断散列表是否包含关键字为key元素</div><div class="line">		return this.search(key)!=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String toString()&#123;</div><div class="line">		String str="";</div><div class="line">		for(int i=0;i&lt;table.length;i++)  //遍历各同义词单链表</div><div class="line">			if(!table[i].isEmpty())</div><div class="line">				str+=table[i].toString()+"\n";</div><div class="line">		return str;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[树和二叉树]]></title>
      <url>http://www.myzwl.win/2017/07/13/sjjg_8/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>树是数据元素（结点）之间具有层次关系的非线性结构。在树结构中，除根以外的结点只有一个前驱结点，可以有零至多个后继结点，根结点没有前驱结点</p>
<h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><p><img src="/images/imgs4/7.jpg" alt="Alt text"><br>1.父母、孩子、兄弟结点<br>2.度（结点所拥有的子树数目），如A的度为3<br>3.结点的层次（结点处于树中的位置，约定根结点层次为1），树的高度（树中结点的最大层次数）如图中树高度为3<br>4.边（设X结点是y结点的父母结点，有序对（X，y）称为这两个结点的边，路径如A到E结点，表示为（A，B，E），路径长度（路径上的边数）为2<br>5.无序数与有序树（区别子树之间有没有次序）<br>6.森林（删除根结点）</p>
<h4 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h4><p><img src="/images/imgs4/8.jpg" alt="Alt text"><br>二叉树最多有两颗子树，分别为左右子树<br>性质1：若根结点的层次为1，则二叉树第i层最多有2^(i-1)(i&gt;1)个结点<br>性质2：在高度为h的二叉树中，最多有2^h-1个结点（h&gt;=0)<br>性质3：设一棵二叉树的叶子结点数为n0,2度结点数为n2，则n0=n2+1<br>性质4：一颗具有n个结点的完全二叉树，其高度为h=[log以2为底数n为参数]+1；其中[]是高斯取整函数<br>性质5：一颗具有n个结点的完全二叉树，对序号为i（0&lt;=i<n)的结点，有 1.若i="0，则i为根结点，无父母结点：若i">0，则i的父母结点序号为[(i+1)/2]<br>2.若2<em>i+1&lt;n，则i的左孩子结点序号为2</em>i+1；否则无左孩子<br>3.若2<em>i+2&lt;n，则i的右孩子结点序号为2</em>i+2，否则i无右孩子</n)的结点，有></p>
<h4 id="二叉树的遍历规则"><a href="#二叉树的遍历规则" class="headerlink" title="二叉树的遍历规则"></a>二叉树的遍历规则</h4><p><strong>孩子优先遍历</strong><br>二叉树的遍历是按照一定规则和次序访问二叉树中的所有结点，并且每个结点仅被访问一次，同时遍历二叉树访问结点的次序是线性的。<br>1.先根次序：访问根结点，遍历左子树，遍历右子树（124536）<br>2.中根次序：遍历左子树，访问根结点，遍历右子树（425136）<br>3.后根次序：遍历左子树，遍历右子树，访问根结点（452631）</p>
<p><strong>兄弟优先遍历</strong><br>该遍历是按照层次进行的，遍历历程是从根结点开始，逐层深入，从左至右依次访问完当前层的所有结点，在访问下一层</p>
<h4 id="二叉树抽象数据类型和存储结构"><a href="#二叉树抽象数据类型和存储结构" class="headerlink" title="二叉树抽象数据类型和存储结构"></a>二叉树抽象数据类型和存储结构</h4><p><strong>顺序存储结构</strong><br><img src="/images/imgs4/9.jpg" alt="Alt text"><br>二叉树的顺序存储结构仅适用于完全二叉树和满二叉树，如图所示。根据之前的性质，可以实现对应关系一一对应个。<br>而对于非完全二叉树，如果采取顺序存储，可以将其补成一个完全二叉树，对于空结点利用特殊符号代替，但是会造成空间浪费，并且线性映射关系不明确</p>
<p><strong>链式存储结构</strong><br><img src="/images/imgs4/11.jpg" alt="Alt text"><br>二叉链表采用两条链分别连接左右孩子结点，每个结点有三个域：data存储数据元素，left、right分别指向左右孩子结点<br>三叉链表在二叉链表基础上增加一条链parent连接父母结点<br><img src="/images/imgs4/10.jpg" alt="Alt text"></p>
<p><strong>二叉链表结点</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class BinaryNode&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	public T data;                 //数据域，存储数据元素</div><div class="line">	public BinaryNode&lt;T&gt; left,right;   //链域，分别指向左、右孩子结点</div><div class="line">	</div><div class="line">	public BinaryNode(T data,BinaryNode&lt;T&gt; left,BinaryNode&lt;T&gt; right)&#123;</div><div class="line">		this.data=data;</div><div class="line">		this.left=left;</div><div class="line">		this.right=right;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode(T data)&#123;</div><div class="line">		this(data,null,null);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode()&#123;</div><div class="line">		this(null,null,null);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>抽象数据类型</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface BinaryTTree&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	boolean isEmpty();           //判断二叉树是否为空</div><div class="line">	int count();                 //返回二叉树的结点个数</div><div class="line">	int height();                //返回二叉树的高度</div><div class="line">	void preOrder();             //先根次序遍历二叉树</div><div class="line">	void inOrder();              //中根次序遍历二叉树</div><div class="line">	void postOrder();            //后根次序遍历二叉树</div><div class="line">	void levelOrder();           //按层次遍历二叉树</div><div class="line">	BinaryNode&lt;T&gt; search(T key);   //查找并返回首次出现关键字为key元素结点</div><div class="line">	BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; node);      //返回node的父母结点</div><div class="line">	void insertRoot(T x);            //插入元素x作为根结点</div><div class="line">	BinaryNode&lt;T&gt; insertChild(BinaryNode&lt;T&gt; p,T x,boolean leftChild); //插入孩子节点</div><div class="line">	void removeChild(BinaryNode&lt;T&gt; p,boolean leftChild); //删除p结点的左或右子树</div><div class="line">	void removeAll();  //删除二叉树</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是其实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line">public class BinaryTree&lt;T&gt; implements BinaryTTree&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	public BinaryNode&lt;T&gt; root;   //根结点，结点结构为二叉链表</div><div class="line">	public BinaryTree()&#123;         //构造空二叉树</div><div class="line">		this.root=null;</div><div class="line">	&#125;</div><div class="line">	public boolean isEmpty() &#123;  //判断二叉树是否为空</div><div class="line">		return this.root==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int count() &#123;</div><div class="line">		return count(root);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int count(BinaryNode&lt;T&gt; p)&#123; //返回以p结点为根的子树的结点个数</div><div class="line">		if(p==null)</div><div class="line">			return 0;</div><div class="line">		return 1+count(p.left)+count(p.right);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int height() &#123;</div><div class="line">		return height(root);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int height(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p==null)</div><div class="line">			return 0;</div><div class="line">		int lh=height(p.left); //返回左子树高度</div><div class="line">		int rh=height(p.right); //返回右子树高度</div><div class="line">		return (lh&gt;=rh)?lh+1:rh+1; //当前子树高度为较高子树高度加1</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void preOrder() &#123;</div><div class="line">		System.out.println("先根次序遍历二叉树:  ");</div><div class="line">		preOrder(root);</div><div class="line">		System.out.println();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void preOrder(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p!=null)</div><div class="line">		&#123;</div><div class="line">			System.out.println(p.data.toString()+" ");//访问当前结点</div><div class="line">			preOrder(p.left); //按先根次序遍历当前结点左子树，递归调用</div><div class="line">			preOrder(p.right); //按先根次序遍历当前结点右子树，递归调用</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void inOrder() &#123;</div><div class="line">		System.out.println("中根次序遍历二叉树 :   ");</div><div class="line">		inOrder(root);</div><div class="line">		System.out.println();	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void inOrder(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p!=null)</div><div class="line">		&#123;</div><div class="line">			inOrder(p.left);</div><div class="line">			System.out.println(p.data.toString()+" ");</div><div class="line">			inOrder(p.right);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void postOrder() &#123;</div><div class="line">	</div><div class="line">		System.out.println("后根次序遍历二叉树 :   ");</div><div class="line">		inOrder(root);</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void postOrder(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p!=null)&#123;</div><div class="line">			postOrder(p.left);</div><div class="line">			postOrder(p.right);</div><div class="line">			System.out.println(p.data.toString()+" ");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void levelOrder() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public BinaryNode&lt;T&gt; search(T key) &#123;</div><div class="line">		return search(root,key);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode&lt;T&gt; search(BinaryNode&lt;T&gt; p,T key) &#123;</div><div class="line">		if(p==null||key==null)</div><div class="line">			return null;</div><div class="line">		if(p.data.equals(key))  //查找成功，返回找到结点</div><div class="line">			return p;</div><div class="line">		BinaryNode&lt;T&gt; find=search(p.left,key);//在左子树中查找，递归调用</div><div class="line">		if(find==null)</div><div class="line">			find=search(p.right,key);//左子树中未找到，在右子树中继续递归查找</div><div class="line">		return find;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; node) &#123;</div><div class="line">	if(root==null||node==null||node==root)</div><div class="line">		return null;</div><div class="line">	 return getParent(root,node);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; p,BinaryNode&lt;T&gt; node) &#123;</div><div class="line">	if(p==null)</div><div class="line">		return null;</div><div class="line">	if(p.left==node||p.right==node)</div><div class="line">		return p;</div><div class="line">	BinaryNode&lt;T&gt; find=getParent(p.left,node);</div><div class="line">	if(find==null)</div><div class="line">		find=getParent(p.right,node);</div><div class="line">		return find;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void insertRoot(T x) &#123;</div><div class="line">		root=new BinaryNode&lt;T&gt;(x, root, null);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	//插入元素x作为p结点的孩子，若leftChild为true,插入结点作为左孩子，否则作为右孩子</div><div class="line">	public BinaryNode&lt;T&gt; insertChild(BinaryNode&lt;T&gt; p,T x,boolean leftChild)&#123;</div><div class="line">		if(p==null||x==null)</div><div class="line">			return null;</div><div class="line">		if(leftChild)</div><div class="line">		&#123;</div><div class="line">			p.left=new BinaryNode&lt;T&gt;(x, p.left, null);//插入x作为p的左孩子，p原左孩子变为x左孩子</div><div class="line">			return p.left;</div><div class="line">		&#125;</div><div class="line">		p.right=new BinaryNode&lt;T&gt;(x,null,p.right); //插入x结点作为p的右孩子</div><div class="line">		return p.right;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line">	public void removeChild(BinaryNode&lt;T&gt; p, boolean leftChild) &#123;</div><div class="line">	if(p!=null)</div><div class="line">		if(leftChild)</div><div class="line">			p.left=null;</div><div class="line">		else</div><div class="line">			p.right=null;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">		this.root=null;</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[优先队列与递归]]></title>
      <url>http://www.myzwl.win/2017/07/12/sjjg_7/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果按照队列的特点，即先来先服务原则，在很多情况下不能实现相关设计，比如操作系统中的进程调度管理，就是按照优先级大小来进行调度</p>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>若一个队列中的每个元素都有一个优先级，每次出队的是具有优先级最高的元素，则称该队列为优先队列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class PriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; implements QQueue&#123;</div><div class="line"></div><div class="line">	private SortedSinglyLinkedList&lt;T&gt; list; //使用排序单链表存储队列元素</div><div class="line">	</div><div class="line">	public PriorityQueue()&#123;   //构造空队列</div><div class="line">		this.list=new SortedSinglyLinkedList&lt;T&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123; //判断队列是否为空</div><div class="line">		return list.isEmpty();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(Object x) &#123; //元素x入队，根据元素大小插入在单链表适当位置</div><div class="line">		list.insert(x);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object dequeue() &#123;//出队，返回对头元素</div><div class="line"></div><div class="line">		return list.remove(0);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String toString()&#123;</div><div class="line">		return list.toString();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进程按优先级调度管理<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Process implements Comparable&lt;Process&gt;&#123;</div><div class="line"></div><div class="line">	private String name;   //进程名</div><div class="line">	private int priority;  //优先级</div><div class="line"></div><div class="line"></div><div class="line">	public Process(String name, int priority) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.priority = priority;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	public int compareTo(Process o) &#123;//比较两个进程的大小，约定进程排队次序的规则</div><div class="line"></div><div class="line">		return this.priority-o.priority;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>从形式上，递归的定义可如下所示<br><img src="/images/imgs4/6.jpg" alt="Alt text"><br>同时递归定义必须满足以下两个条件<br>1.边界条件：至少有一条初始定义是非递归的。<br>2.递归通式： 由已知函数值逐步递推计算出未知函数值</p>
<p>递归算法是指直接或者间接调用自身的算法<br>如用递归算法求fibonacci数列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Factorial &#123;</div><div class="line"></div><div class="line">	public static int factorial(int n)</div><div class="line">	&#123;</div><div class="line">		if(n&lt;0)</div><div class="line">			throw new IllegalArgumentException("n="+n);</div><div class="line">		if(n==0||n==1)</div><div class="line">			return n;</div><div class="line">		return factorial(n-1)+factorial(n-2);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String args[])&#123;</div><div class="line">		for(int i=0;i&lt;=24;i++)</div><div class="line">			System.out.print(factorial(i)+" ");</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<blockquote>
<p>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 </p>
</blockquote>
<p>再如将之前的SinglyLinkenList类增加一个复制方法，采用递归法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private Node&lt;T&gt; copy(Node&lt;T&gt; p)&#123;</div><div class="line">	Node&lt;T&gt; q=null; //新结点</div><div class="line">	if(p!=null)  //要复制的结点非空</div><div class="line">	&#123;</div><div class="line">		q=new Node&lt;T&gt;(p.data,null); //相当于q.data=p.data，q.next=null</div><div class="line">		q.next=copy(p.next);//递归，q1.data=p.next.data，q1.next=null，先返回q1，q.next=q1</div><div class="line">		//可以看成一棵二叉树</div><div class="line">	&#125;</div><div class="line">	return q;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[顺序与链式队列]]></title>
      <url>http://www.myzwl.win/2017/07/11/sjjg_6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行。特点是先进先出。</p>
<h4 id="队列抽象数据类型"><a href="#队列抽象数据类型" class="headerlink" title="队列抽象数据类型"></a>队列抽象数据类型</h4><p><img src="/images/imgs4/5.jpg" alt="Alt text"><br>其中，像队列中插入元素的过程称为入队（enqueue），删除元素的过程称为出队（dequeue），允许入队的一端称为队尾（rear），允许出队的一头称为对头（front），没有元素的队列称为空队列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface QQueue&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	boolean isEmpty();          //判断队列是否为空</div><div class="line">	void enqueue(T x);          //元素x入队</div><div class="line">	T dequeue();                //出队，返回对头元素</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>顺序队列使用数组存储数据元素<br>1.当队列空时，设置队头、队尾下标front=rear=-1，<br>2.当第一个元素入队时，front=rear=0，同时改变两个下标<br>3.进行入队、出队操作，front、rear随之变化<br>4.当入队的元素个数（包括已出队元素）超出数组容量时，rear下标越界，数据溢出，但是，由于之前已有若干元素出队，数组前部以空出许多存储单元，所以这种溢出并不是因为存储空间不够而产生的，称为假溢出</p>
<p>所以顺序队列有两个缺点：假溢出和存储单元没有重复使用机制</p>
<h4 id="顺序循环队列"><a href="#顺序循环队列" class="headerlink" title="顺序循环队列"></a>顺序循环队列</h4><p>相比较顺序队列，有如下不同<br>1.队头、队尾元素按照如下循环规律变化，其中length表示数组长度<br>front=（front+1)%length;<br>rear=(rear+1)%length;<br>所以可以看出front和rear的取值范围为0~length-1；</p>
<p>2.约定rear是下一个入队元素位置，队列空条件是front==rear，即入队只改变rear，出队只改变front<br>3.约定队列满条件是队列中仍然有一个空位置，即front==（rear+1）%length，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class SeqQueue&lt;T&gt; implements QQueue&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Object element[];  //存储队列数据元素的数组</div><div class="line">	private int front,rear;    //分别为对头和队尾元素</div><div class="line">	</div><div class="line">	public SeqQueue(int length)&#123;        //构造容量为length的空队列</div><div class="line">		if(length&lt;64)</div><div class="line">			length=64;</div><div class="line">		this.element=new Object[Math.abs(length)];</div><div class="line">		this.front=this.rear=0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public SeqQueue()&#123;       //构造默认容量空队列</div><div class="line">		this(64);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;     //判断队列是否为空</div><div class="line">		return this.front==this.rear;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(T x) &#123;   //元素x入队，空对象不能入队</div><div class="line">	if(x==null)</div><div class="line">		return;</div><div class="line">	if(this.front==(this.rear+1)%this.element.length) //当队满时，扩充容量</div><div class="line">	&#123;</div><div class="line">		Object[] temp=this.element;</div><div class="line">		this.element=new Object[temp.length*2];</div><div class="line">		int i=this.front,j=0;</div><div class="line">		while(i!=this.rear)&#123;        //按照队列元素次序复制数组元素</div><div class="line">			this.element[j]=temp[i];</div><div class="line">			i=(i+1)%temp.length;</div><div class="line">			j++;</div><div class="line">		&#125;</div><div class="line">		this.front=0;</div><div class="line">		this.rear=j;</div><div class="line">	&#125;</div><div class="line">		this.element[this.rear]=x;</div><div class="line">		this.rear=(this.rear+1)%this.element.length;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T dequeue() &#123;         //出队，返回队头元素，若队列空则返回null</div><div class="line">   if(isEmpty())</div><div class="line">		return null;</div><div class="line">    T temp=(T)this.element[this.front];</div><div class="line">      this.front=(this.front+1)%this.element.length;  //取得队头元素</div><div class="line">     return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p>以不带头结点的单链表实现链式队列，设指针front和rear分别指向队头和队尾结点，初始空队列的状态设置为front=rear=null；队列空条件是front==null&amp;&amp;rear==null</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class LinkedQueue&lt;T&gt; implements QQueue&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Node&lt;T&gt; front,rear;        //分别指向队头和队尾</div><div class="line">	</div><div class="line">	public LinkedQueue()&#123;             //构造空队列</div><div class="line">		this.front=this.rear=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;        //判断队列是否为空</div><div class="line">		return this.front==null&amp;&amp;this.rear==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(T x) &#123;       //元素x入队，空对象入队</div><div class="line">		if(x==null)  </div><div class="line">			return;</div><div class="line">		Node&lt;T&gt; q=new Node&lt;T&gt;(x,null);  </div><div class="line">		 if(this.front==null)</div><div class="line">			 this.front=q;   //空队入队</div><div class="line">		 else</div><div class="line">			 this.rear.next=q; //插入在队尾之后</div><div class="line">		 this.rear=q;		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T dequeue() &#123;  //出队，返回对头元素，若队列元素为空，返回null</div><div class="line">		if(isEmpty())</div><div class="line">			return null;</div><div class="line">		T temp=this.front.data;    //取得队头元素</div><div class="line">		this.front=this.front.next;    //删除队头结点</div><div class="line">		if(this.front==null)</div><div class="line">			this.rear=null;</div><div class="line">		return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[栈]]></title>
      <url>http://www.myzwl.win/2017/07/10/sjjg_5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈是一种特殊的线性表，其特殊之处在于插入和删除操作的位置受到限制，而且插入和删除只允许在线性表的一端进行，特点是后进先出</p>
<h4 id="栈抽象数据类型"><a href="#栈抽象数据类型" class="headerlink" title="栈抽象数据类型"></a>栈抽象数据类型</h4><p><img src="/images/imgs4/8.gif" alt="Alt text"><br>其中允许操作的一端为栈顶（top），不允许操作的一端为栈底（bottom），栈中插入元素的操作称为入栈（push），删除元素的操作为出栈（pop），没有元素的栈称为空栈</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface SStack&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	boolean isEmpty();  //判断是否为空栈</div><div class="line">	void push(T x);     //元素x入栈</div><div class="line">	T pop();            //出栈，返回当前栈顶元素</div><div class="line">	T get();            //取栈顶元素，未出栈</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>采用顺序存储结构的栈称为顺序栈<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class SeqStack&lt;T&gt; implements SStack&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Object element[];    //存取栈数据元素的数组</div><div class="line">	private int top;             //栈顶元素下标</div><div class="line">	</div><div class="line">	public SeqStack(int size)&#123;    //构造容量为size的空栈</div><div class="line">		this.element=new Object[Math.abs(size)];</div><div class="line">		this.top=-1;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public SeqStack()&#123;         //构造默认容量的空栈</div><div class="line">		this(64);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123; //判断栈是否为空</div><div class="line">		</div><div class="line">		return this.top==-1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void push(T x) &#123;    //元素x入栈，空对象不能入栈</div><div class="line">		if(x==null)</div><div class="line">			return;</div><div class="line">		if(this.top==element.length-1)   //栈满，扩充栈容量</div><div class="line">		&#123;</div><div class="line">			Object[] temp=this.element;</div><div class="line">			this.element=new Object[temp.length*2];</div><div class="line">			for(int i=0;i&lt;temp.length;i++)</div><div class="line">				this.element[i]=temp[i];</div><div class="line">		&#125;</div><div class="line">		this.top++;</div><div class="line">		this.element[this.top]=x;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T pop() &#123;  //出栈</div><div class="line">		</div><div class="line">		return this.top==-1?null:(T)this.element[this.top--];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get() &#123;		//取栈顶元素</div><div class="line">		return this.top==-1?null:(T)this.element[this.top];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上，push（），pop（），get（）方法的时间复杂度为O（1），而需要扩充容量时，复杂度为O（n）；</p>
<h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>采用链式存储结构的栈称为链式栈，这里采用单链表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class LinkedStack&lt;T&gt; implements SStack&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Node&lt;T&gt; top;         //栈顶结点</div><div class="line">	</div><div class="line">	public LinkedStack()&#123;        //构造空栈</div><div class="line">		this.top=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;     //判断栈是否为空</div><div class="line">		return this.top==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void push(T x) &#123;</div><div class="line">		if(x!=null)</div><div class="line">			this.top=new Node(x, this.top);  //头插入，x结点作为新的栈顶结点</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T pop() &#123;         //出栈，返回栈顶元素</div><div class="line">		if(this.top==null)</div><div class="line">			return null;</div><div class="line">		T temp=this.top.data;</div><div class="line">		this.top=this.top.next;</div><div class="line">		return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get() &#123;</div><div class="line">		return this.top==null?null:this.top.data;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[串之字符串]]></title>
      <url>http://www.myzwl.win/2017/07/09/sjjg_4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>串是由n(n&gt;=0)个字符组成的有限序列，它是一种特殊的线性表。而子串是指串s中任意连续字符组成的一个子序列组成的串。同时，串的比较通常由其字符编码的相关规则比较</p>
<h4 id="常量字符串String"><a href="#常量字符串String" class="headerlink" title="常量字符串String"></a>常量字符串String</h4><p>字符串采用字符数组作为存储结构，并且采用顺序存储结构，不过String类一次性申请了固定的空间，同时由于其存储结构为最终型，所以string不提供删除，插入子串<br>如下是模仿String类的部分<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public final class MyString implements Comparable&lt;MyString&gt;,Serializable&#123;</div><div class="line"></div><div class="line">	private final char[] value;         //字符数组，只能赋值一次</div><div class="line">	</div><div class="line">	public MyString()&#123;  //构造一个空串</div><div class="line">		this.value=new char[0];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyString(String original)&#123; //将字符串常量变成字符数组</div><div class="line">		this.value=original.toCharArray();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//以value数组中构造从begin开始的count个字符的字符串对象</div><div class="line">	public MyString(char[] value,int begin,int count)&#123;</div><div class="line">		this.value=new char[count];</div><div class="line">		 for(int i=begin;i&lt;begin+count;i++)</div><div class="line">			 this.value[i]=value[i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//以value数组中字符构造字符串</div><div class="line">	public MyString(char[] value)&#123;</div><div class="line">		this(value,0,value.length);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyString(MyString str)&#123;//复制对象</div><div class="line">		this(str.value);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int length()&#123;  //返回字符串长度</div><div class="line">		return this.value.length;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public char charAt(int i)&#123; //返回第i个字符</div><div class="line">		if(i&lt;0||i&gt;=this.value.length)</div><div class="line">			 throw new StringIndexOutOfBoundsException(i);</div><div class="line">		return this.value[i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String toString()&#123;</div><div class="line">		return new String(this.value);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">		public MyString concat(MyString str)&#123; //返回当前串与指定串str连接生成的新串</div><div class="line">		if(str==null||str.length()==0)     //要连接的串为空时，返回当前串</div><div class="line">			return this;</div><div class="line">		  char[] buffer=new char[this.value.length+str.length()];</div><div class="line">		   int i;</div><div class="line">		    for(i=0;i&lt;this.value.length;i++)  //复制当前串</div><div class="line">		    buffer[i]=this.value[i];</div><div class="line">		     for(int j=0;j&lt;str.value.length;j++)  //复制指定串</div><div class="line">		    	 buffer[i+j]=str.value[j];</div><div class="line">		       return new MyString(buffer); //以字符数组构造串</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int compareTo(MyString o) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由上述模拟过程知道，有四种构造方法构造串对象</p>
<blockquote>
<p>MyString s1=new MyString();<br> MyString s2=new MyString(“abc”);<br> char[] letters={a,b,c,d}<br> MyString s3=new MyString(“letters);<br> MyString s4=new MyString(s3);</p>
</blockquote>
<p> 此外在数组复制时，java提供了两种方法</p>
<blockquote>
<p>java.lang.System.arraycopy(value,0,this.value,0,value.length);<br> this.value=java.util.Arrays.copyOf(value,value.length)</p>
</blockquote>
<h4 id="求字串"><a href="#求字串" class="headerlink" title="求字串"></a>求字串</h4> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public MyString substring(int begin,int end)&#123;//返回传中从begin到end-1的子串</div><div class="line">	if(begin&lt;0)</div><div class="line">		begin=0;</div><div class="line">	if(end&gt;this.value.length)</div><div class="line">		end=this.value.length;</div><div class="line">	if(begin&gt;end)</div><div class="line">		throw new StringIndexOutOfBoundsException(end-begin);</div><div class="line">	if(begin==0&amp;&amp;end==this.value.length)</div><div class="line">		return this;</div><div class="line">	char[] buffer=new char[end-begin];</div><div class="line">	 for(int i=0;i&lt;buffer.length;i++)</div><div class="line">		 buffer[i]=this.value[i+begin];</div><div class="line">	   return new MyString(buffer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyString substring (int begin)&#123;//返回串中序号从begin到末尾的子串</div><div class="line">	return substring(begin,this.value.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="比较串相等与大小"><a href="#比较串相等与大小" class="headerlink" title="比较串相等与大小"></a>比较串相等与大小</h4> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object obj)&#123;</div><div class="line">	if(this==obj)</div><div class="line">		return true;</div><div class="line">	if(obj instanceof MyString)</div><div class="line">		&#123;MyString str=(MyString)obj;</div><div class="line">	if(this.value.length==str.value.length)&#123;</div><div class="line">		for(int i=0;i&lt;this.value.length;i++)</div><div class="line">			if(this.value[i]!=str.value[i])</div><div class="line">				return false;</div><div class="line">	      return true;&#125;</div><div class="line">&#125;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//返回两个字符串之间的差值，返回0表示相等</div><div class="line">public int compareTo(MyString o) &#123;</div><div class="line">	for(int i=0;i&lt;this.value.length&amp;&amp;i&lt;o.value.length;i++)</div><div class="line">		if(this.value[i]!=o.value[i])</div><div class="line">			 return this.value[i]-o.value[i]; //返回两串第一个不同字符的差值</div><div class="line">	return this.value.length-o.value.length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="变量字符串StringBuffer"><a href="#变量字符串StringBuffer" class="headerlink" title="变量字符串StringBuffer"></a>变量字符串StringBuffer</h4><p>该字符数组的容量总是大于串长，并且能够修改<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public class MyStringBuffer implements Serializable&#123;</div><div class="line">    </div><div class="line">	   private char[] value;     //字符数组</div><div class="line">	    private int len;         //串长度</div><div class="line">	     </div><div class="line">	    public MyStringBuffer(int size)&#123;    //构造指定容量的空串</div><div class="line">	    	this.value=new char[size&lt;16?16:size];</div><div class="line">	    	this.len=0;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public MyStringBuffer()&#123;      //以默认容量构造空串</div><div class="line">	    	this(16);</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public MyStringBuffer(String str)&#123;  //以字符串常量构造对象</div><div class="line">	    	this(str.length()+16);</div><div class="line">	    	 </div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public int length()&#123;</div><div class="line">	    	return this.len;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public synchronized char charAt(int i)&#123;</div><div class="line">	    	if(i&lt;0||i&gt;=this.len)</div><div class="line">	    		throw new StringIndexOutOfBoundsException(i);</div><div class="line">	    	return this.value[i];</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public void setCharAt(int i,char ch)&#123;</div><div class="line">	    	if(i&lt;0||i&gt;=this.len)</div><div class="line">	    		throw new StringIndexOutOfBoundsException(i);</div><div class="line">	    	this.value[i]=ch;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public synchronized MyStringBuffer insert(int i,MyStringBuffer str)&#123;</div><div class="line">	    	if(i&lt;0) i=0;</div><div class="line">	    	if(i&gt;this.len) i=this.len;</div><div class="line">	    	if(str==null) return this;</div><div class="line">	    	char temp[]=this.value;</div><div class="line">	    	if(this.value.length-this.len&lt;str.len) //当前容量不足，自动扩充</div><div class="line">	    	&#123;</div><div class="line">	    		this.value=new char[this.value.length+str.len*2];</div><div class="line">	    		for(int j=0;j&lt;i;j++)  //复制当前串前i-1个字符</div><div class="line">	    			this.value[j]=temp[j];</div><div class="line">	    	&#125;</div><div class="line">	    		for(int j=i;j&lt;this.len;j++)</div><div class="line">	    			this.value[str.len+j]=temp[j];//从i开始向后移动j个字符</div><div class="line">	    		for(int j=0;j&lt;str.len;j++)     //复制字符串str</div><div class="line">	    			this.value[i+j]=str.value[j];</div><div class="line">	    		this.len+=str.len;</div><div class="line">	    		return this;</div><div class="line">	    	&#125;</div><div class="line">	   </div><div class="line">	    public synchronized MyStringBuffer delete(int begin,int end)&#123;</div><div class="line">	    	if(begin&gt;0)</div><div class="line">	    		begin=0;</div><div class="line">	    	if(end&gt;this.len)</div><div class="line">	    		end=this.len;</div><div class="line">	    	if(begin&gt;end)</div><div class="line">	    		throw new StringIndexOutOfBoundsException(end-begin);</div><div class="line">	    	for(int i=0;i&lt;this.len-end;i++) //从end开始至串尾的子串向前移动</div><div class="line">	    		this.value[begin+1]=this.value[end+i];</div><div class="line">	    	this.len=end-begin;</div><div class="line">	    	return this;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public synchronized String toString()&#123;</div><div class="line">	    	return new String(this.value,0,this.len);</div><div class="line">	    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线性表之双链表]]></title>
      <url>http://www.myzwl.win/2017/07/08/sjjg_3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>双链表的每个结点有两个地址域，分别指向它的前驱结点和后继结点<br><img src="/images/imgs4/4.jpg" alt="Alt text"></p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>双链表的结点声明如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class DLinkNode&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	public T data;  //数据元素</div><div class="line">	public DLinkNode&lt;T&gt; prev,next; //prev指向前驱结点，next指向后继结点</div><div class="line">	</div><div class="line">	public DLinkNode(T data, DLinkNode&lt;T&gt; prev, DLinkNode&lt;T&gt; next) &#123;</div><div class="line">		super();</div><div class="line">		this.data = data;</div><div class="line">		this.prev = prev;</div><div class="line">		this.next = next;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public DLinkNode()&#123;</div><div class="line">		this(null,null,null);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若带头结点的双链表为空双链表，则有head.next=null&amp;&amp;head.prev=null;</p>
<p>若p指向双链表中非两端的某个结点，则有p=p.next.prev=p.prev.next;</p>
<h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>如果双链表的最后一个结点的next链指向头结点，头结点的prev链指向最后一个结点，则称为循环双链表，<br>对于空双链表有head.next=head&amp;&amp;head.prev=head<br>下面是循环双链表CirDoublyLinkedList的实现类<br>只有插入和删除和单链表不一样<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class CirDoublyLinkedList&lt;T&gt; implements LList&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	public DLinkNode&lt;T&gt; head;</div><div class="line">	</div><div class="line">	public CirDoublyLinkedList()&#123;</div><div class="line">		this.head=new DLinkNode&lt;T&gt;();</div><div class="line">		this.head.prev=head;</div><div class="line">		this.head.next=head;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void insert(int i, T x) &#123;//将x对象插入在序号为i的结点</div><div class="line">	if(x==null)</div><div class="line">		return;</div><div class="line">	DLinkNode&lt;T&gt; p=this.head;</div><div class="line">	for(int j=0;p.next!=this.head&amp;&amp;j&lt;i;j++) //寻找插入位置</div><div class="line">		p=p.next;                           //循环停止时，p指向第i-1个结点</div><div class="line">	 DLinkNode&lt;T&gt; q=new DLinkNode&lt;T&gt;(x,p,p.next);//插入在p结点之后</div><div class="line">	 p.next.prev=q;</div><div class="line">	 p.next=q;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void append(T x) &#123;</div><div class="line">	 if(x==null)</div><div class="line">		 return;</div><div class="line">	 DLinkNode&lt;T&gt; q=new DLinkNode&lt;T&gt;(x,head.prev,head);</div><div class="line">	 head.prev.next=q; //插入在头结点之前，相当于尾插入</div><div class="line">	 head.prev=q;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T remove(int i) &#123;</div><div class="line">	if(i&gt;0)</div><div class="line">	&#123;</div><div class="line">		DLinkNode&lt;T&gt; p=this.head.next;</div><div class="line">		for(int j=0;p!=head&amp;&amp;j&lt;i;j++)  //定位到待删除结点</div><div class="line">			p=p.next;</div><div class="line">		if(p!=head)</div><div class="line">		&#123; </div><div class="line">			T old=p.data;     //获得原对象</div><div class="line">			p.prev.next=p.next;  //删除p结点自己</div><div class="line">			p.next.prev=p.prev;</div><div class="line">			return old;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">		this.head.prev=head;</div><div class="line">		this.head.next=head;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	。。。其余方法和单链表一样</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线性表之单链表]]></title>
      <url>http://www.myzwl.win/2017/07/07/sjjg_2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线性表的链式存储是用若干地址分散的存储单元存储数据元素，逻辑上相连的数据元素在物理位置上不一定相连，必须采用附加信息表示数据元素之间的关系，并且存储单元至少包含两部分-数据域和地址域<br><img src="/images/imgs4/2.jpg" alt="Alt text"></p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表中结点只有一个地址并且指向后继结点<br><img src="/images/imgs4/3.jpg" alt="Alt text"></p>
<p>单链表结点类Node声明如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Node&lt;T&gt; &#123;  //单链表结点类</div><div class="line"></div><div class="line">	public T data;            //数据域，保存数据元素</div><div class="line">	public Node&lt;T&gt; next;      //地址域，引用后继结点</div><div class="line">	</div><div class="line">	public Node(T data,Node&lt;T&gt; next)&#123;</div><div class="line">		this.data=data;</div><div class="line">		this.next=next;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Node()&#123;</div><div class="line">		this(null,null);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于java不支持指针类型，但提供引用方式保存包括地址在内的结构化信息<br>通常通过node结点建立两个结点之间的链接，如p结点的下一个结点是q结点</p>
<blockquote>
<p>Node<string> p=new Node<string>(‘A’,null);<br>  Node<string> q=new Node<string>(‘B’,null);<br>  p.next=q;</string></string></string></string></p>
</blockquote>
<p>  单链表的头指针head也是一个结点引用</p>
<blockquote>
<p>Node<t> head=null;</t></p>
</blockquote>
<p>  当head==null时，为空单链表</p>
<p><strong>单链表的遍历操作 </strong><br>  遍历单链表是指从第一个结点开始，沿着结点的next链，依次访问单链表中的每个结点，并且每个结点只访问一次</p>
<blockquote>
<p>Node<t> p=head;<br>while(p!=null){<br>    p=p.next;<br>}</t></p>
</blockquote>
<p><strong>单链表的插入操作 </strong><br>对单链表进行插入操作，只要该表节点间的链接关系，不需要移动数据元素<br><strong>空表插入/头插入 </strong></p>
<blockquote>
<p>if(head==null)<br> head=new Node<t>(x,null);  //空表插入<br> else{<br> Node<t> q=new Node<t>(x,null); //头插入<br> q.next=head;<br> }</t></t></t></p>
</blockquote>
<p><strong>中间插入 </strong><br>若p指向非空单链表的某个结点，在p结点之后插入q结点</p>
<p>&lt; Node<t> q=new Node<t>(x,null);<br>q.next=p.next;             //q的后继结点应是p的原后继结点<br>p.next=q;                  //q作为p的后继结点</t></t></p>
<p><strong>尾插入 </strong></p>
<p><strong>单链表的删除操作 </strong><br>删除单链表的指定结点，只需改变结点的next域</p>
<p><strong>头删除 </strong></p>
<blockquote>
<p>head=head.next;</p>
</blockquote>
<p><strong>中间/尾删除 </strong></p>
<blockquote>
<p>if(p.next!=null)<br> p.next=p.next.next;</p>
</blockquote>
<h4 id="单链表实现类"><a href="#单链表实现类" class="headerlink" title="单链表实现类"></a>单链表实现类</h4> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line">public class SinglyLinkenList&lt;T&gt; implements LList&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	public Node&lt;T&gt; head;  //头指针</div><div class="line">	</div><div class="line">	public SinglyLinkenList()&#123; //构造空链表</div><div class="line">		this.head=new Node&lt;T&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public SinglyLinkenList(T[] element)&#123;//尾插入构造单链表</div><div class="line">		this();</div><div class="line">		Node&lt;T&gt; rear=this.head; //指向单链表最后一个结点</div><div class="line">		for(int i=0;i&lt;element.length;i++)&#123;</div><div class="line">			rear.next=new Node&lt;T&gt;(element[i],null); //尾插入</div><div class="line">			rear=rear.next;     //指向新的链尾结点</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;</div><div class="line">		</div><div class="line">		return this.head.next==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int length() &#123;</div><div class="line">		</div><div class="line">		int i=0;</div><div class="line">		Node&lt;T&gt; p=this.head.next;  //p从单链表第一个结点开始</div><div class="line">		while(p!=null)&#123;            //若单链表未结束</div><div class="line">			i++;</div><div class="line">			p=p.next;             //p的后继结点</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		return i;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String toString()&#123;</div><div class="line">		String str="(";</div><div class="line">		Node&lt;T&gt; p=this.head.next;</div><div class="line">		while(p!=null)&#123;</div><div class="line">			str+=p.data.toString();</div><div class="line">			if(p.next!=null)</div><div class="line">				str+=",";  //不是最后一个结点时加分隔符</div><div class="line">			p=p.next;</div><div class="line">		&#125;</div><div class="line">		return str+")";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get(int i) &#123;  //返回第i个元素，若i指定序号无效，则返回null</div><div class="line">	  if(i&gt;=0)</div><div class="line">	  &#123;</div><div class="line">		  Node&lt;T&gt; p=this.head.next;</div><div class="line">		   for(int j=0;p!=null&amp;&amp;j&lt;i;j++)</div><div class="line">			   p=p.next;</div><div class="line">		    if(p!=null)</div><div class="line">		    	return p.data;</div><div class="line">	  &#125;</div><div class="line">		</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//设置第i个元素值为x，若i指定序号无效则抛出序号越界异常</div><div class="line">	public void set(int i, T x) &#123;</div><div class="line">		if(x==null)</div><div class="line">			return;            //不能设置空对象</div><div class="line">		if(i&gt;=0)</div><div class="line">		&#123;</div><div class="line">			Node&lt;T&gt; p=this.head.next;</div><div class="line">			 for(int j=0;p!=null&amp;&amp;j&lt;i;j++)</div><div class="line">				 p=p.next;</div><div class="line">			 if(p!=null)</div><div class="line">				 p.data=x;        //p指向第i个节点</div><div class="line">		&#125;</div><div class="line">		else throw new IndexOutOfBoundsException(i+"");</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void insert(int i, T x) &#123;//将x对象插入在序号为i的结点前</div><div class="line"></div><div class="line">		if(x==null)</div><div class="line">			return;</div><div class="line">		Node&lt;T&gt; p=this.head;  //p指向头结点</div><div class="line">		for(int j=0;p.next!=null&amp;&amp;j&lt;i;j++) //寻找插入位置</div><div class="line">			p=p.next;  //循环停止时，p指向第i-1结点或最后一个结点</div><div class="line">		p.next=new Node&lt;T&gt;(x,p.next);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//单链表最后添加对象</div><div class="line">	public void append(T x) &#123;</div><div class="line">		insert(Integer.MAX_VALUE,x);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	public T remove(int i) &#123;</div><div class="line">		if(i&gt;=0)</div><div class="line">		&#123;</div><div class="line">			Node&lt;T&gt; p=this.head;</div><div class="line">			 for(int j=0;p.next!=null&amp;&amp;j&lt;i;j++)//找到待删除的结点i的前驱结点i-1</div><div class="line">				 p=p.next;</div><div class="line">			 if(p.next!=null)</div><div class="line">			 &#123;</div><div class="line">				 T old=p.next.data;     //获取原对象</div><div class="line">				  p.next=p.next.next;    //删除p的后继结点</div><div class="line">				   return old;</div><div class="line">			 &#125;</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">	this.head.next=null;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int indexOf(T key) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public boolean contain(T key) &#123;</div><div class="line">		</div><div class="line">		return this.search(key)!=null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T search(T key) &#123;</div><div class="line">	 if(key==null)</div><div class="line">		 return null;</div><div class="line">	 Node&lt;T&gt; p=this.head.next;</div><div class="line">	 while(p!=null)</div><div class="line">	 &#123;</div><div class="line">		 if(p.data.equals(key))</div><div class="line">			 return p.data;</div><div class="line">		 p=p.next;</div><div class="line">	 &#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单链表求解约瑟夫环"><a href="#单链表求解约瑟夫环" class="headerlink" title="单链表求解约瑟夫环"></a>单链表求解约瑟夫环</h4><p>只需更改一处</p>
<blockquote>
<p>//LList<string> list=new seqList<string>(number);<br>  LList<string> list=new SinglyLinkenList<string>();</string></string></string></string></p>
</blockquote>
<p> 得到如下结果</p>
<blockquote>
<p>初始化约瑟夫环:(5,0,2)<br>删除B(A,C,D,E)<br>删除D(A,C,E)<br>删除A(C,E)<br>删除E(C)<br>最后的被赦免者是:C</p>
</blockquote>
<p>此外单链表相比较于顺序表在插入和删除时只要改变少量结点的链，不需要移动数据元素，也避免了顺序表因存在空间不足扩充空间和复制元素的过程，提高了运行效率和空间利用率</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线性表之顺序表]]></title>
      <url>http://www.myzwl.win/2017/07/06/sjjg_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据结构是指数据间存在的关系，通常包含三个方面。数据的逻辑结构（线性结构、树、图），数据的存储结构（顺序存储和链式存储），数据操作（对数据结构中的元素进行各种运算和处理），而通常所说的算法是建立在数据结构之上，读数据结构的操作需要用算法来描述。而算法的分析又主要包括时间代价和空间代价两方面</p>
<h4 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h4><p><img src="/images/imgs4/1.jpg" alt="Alt text"></p>
<p>数组是顺序存储的随机存取结构，占用一组连续的存储单元，通过下标识别元素，元素地址是下标的线性函数，一个下标能唯一确定一个元素<br> 不妨构造一个顺序表接口类来模仿顺序表<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface LList&lt;T&gt; &#123;</div><div class="line">	boolean isEmpty();       //判断线性表是否为空</div><div class="line">	int length();            //返回线性表长度</div><div class="line">	T get(int i);            //返回第i(i&gt;=0)个元素</div><div class="line">	void set(int i,T x);     //设置第i个元素值为x</div><div class="line">	void insert(int i,T x);  //插入x作为第i个元素</div><div class="line">	void append(T x);        //在线性表最后插入第i个元素</div><div class="line">	T remove(int i);         //删除第i个元素并返回被删除对象</div><div class="line">	void removeAll();        //删除线性表所有元素</div><div class="line">	int indexOf(T key);      //顺序查找关键字为key的元素，返回首次出现的位置</div><div class="line">	boolean contain(T key);  //是否包含关键字</div><div class="line">	T search(T key);         //顺序查找关键字为key的元素，返回首次出现的元素</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是其实现类<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">public class seqList&lt;T&gt; implements LList&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Object[] element; //存放线性表元素的一维数组</div><div class="line">	private int len;       //顺序表长度，记载元素个数</div><div class="line">	</div><div class="line">	public seqList(int size)&#123;            //创建容量为size的空表</div><div class="line">		//若size&lt;0，java将抛出负数组长度异常</div><div class="line">		this.element=new Object[size];</div><div class="line">		this.len=0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public seqList()&#123;     //创建默认容量的空表，这里是64</div><div class="line">		this(64);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;</div><div class="line">		</div><div class="line">		return this.len==0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int length() &#123;</div><div class="line">	</div><div class="line">		return this.len;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get(int i) &#123; //返回第i个元素（i&gt;=0),若i指定元素无效，则返回null</div><div class="line">	if(i&gt;=0&amp;&amp;i&lt;this.len)</div><div class="line">		return (T)this.element[i];</div><div class="line">    return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//设置第i(i&gt;=0)个元素的值为x，若i指定序号无效则抛出序号越界异常</div><div class="line">	public void set(int i, T x) &#123;</div><div class="line">		if(x==null)</div><div class="line">			return;</div><div class="line">		if(i&gt;=0&amp;&amp;i&lt;this.len)</div><div class="line">			this.element[i]=x;</div><div class="line">		else</div><div class="line">			throw new IndexOutOfBoundsException(i+"");</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">/**</div><div class="line"> * 在顺序表元素ai位置插入元素x，首选必须将i到n个元素后移，空出一个位置，然后插入元素x</div><div class="line"> */</div><div class="line">	public void insert(int i, T x) &#123;</div><div class="line">		if(x==null)</div><div class="line">			return ;           //不能添加null</div><div class="line">		if(this.len==element.length)	 //若数组满，则扩充顺序表容量</div><div class="line">		&#123; </div><div class="line">			Object[] temp=this.element;</div><div class="line">			this.element=new Object[temp.length*2]; //容量扩充2倍</div><div class="line">			for(int j=0;j&lt;temp.length;j++)&#123; </div><div class="line">				this.element[i]=temp[i];  //复制数组元素</div><div class="line">			&#125;</div><div class="line">			if(i&lt;0)                      //下标容错</div><div class="line">				i=0;</div><div class="line">			if(i&gt;this.len)</div><div class="line">				i=this.len;</div><div class="line">			for(int j=this.len-1;j&gt;=i;j--)       //元素后移，平均移动len/2</div><div class="line">				this.element[j+1]=this.element[j];</div><div class="line">			this.element[i]=x;</div><div class="line">			this.len++;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void append(T x) &#123;</div><div class="line">		insert(this.len,x);	   //在顺序表最后插入x对象</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 删除元素ai，必须将元素i+1到n向前移动</div><div class="line">	 */</div><div class="line">	public T remove(int i) &#123; //删除成功返回被删除对象，否则返回null</div><div class="line">		if(this.len==0||i&lt;0||i&gt;this.len)</div><div class="line">			return null;</div><div class="line">		T old=(T)this.element[i];</div><div class="line">		 for(int j=i;j&lt;this.len-1;j++)     //元素前移，平均移动len/2</div><div class="line">			 this.element[j]=this.element[j+1];</div><div class="line">		 this.element[this.len-1]=null;</div><div class="line">		 this.len--;</div><div class="line">		return old;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">		</div><div class="line">		this.len=0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//顺序查找关键字为key的元素，返回首次出现的位置，若查找不成功返回-1</div><div class="line">	public int indexOf(T key) &#123;</div><div class="line">		if(key!=null)</div><div class="line">			for(int i=0;i&lt;this.len;i++)</div><div class="line">				if(this.element[i].equals(key))</div><div class="line">					return i;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//判断线性表是否包含关键字为key元素</div><div class="line">	public boolean contain(T key) &#123;</div><div class="line">		</div><div class="line">		return this.indexOf(key)&gt;=0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//查找，返回首次出现的关键字为key的元素</div><div class="line">	public T search(T key) &#123;</div><div class="line">	 int find=this.indexOf(key);</div><div class="line">		return find==-1?null:(T)this.element[find];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h4><p> 问题描述：古代某法官要判决n个犯人的死刑，他有一条荒唐的法律：将犯人站成一个圆圈，从第s个人开始数起，每数到第d个犯人，就拉出来处决，在从下一个开始数d个，数到的人在处决。。。直到数到最后一个人就开始赦免</p>
<p><img src="/images/imgs4/7.gif" alt="Alt text"><br>上面是假设n=5，s=1，d=2，并且起始位置是从第一个人开始数起，因为该圆圈可以看成顺序表进行模拟<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Josephus &#123;</div><div class="line"></div><div class="line">	public Josephus(int number,int start,int distance)&#123;</div><div class="line">		seqList&lt;String&gt; list=new seqList&lt;String&gt;(number); //初始化顺序表</div><div class="line">		for(int i=0;i&lt;number;i++)                      </div><div class="line">		//依次添加犯人，这里记为A,B.C,D,E</div><div class="line">			list.append((char)('A'+i)+"");</div><div class="line">		System.out.println("初始化约瑟夫环:"+'('+number+','+start+','+distance+')');</div><div class="line">		int i=start;            //起始数起的人</div><div class="line">		while(list.length()&gt;1)&#123;        //多于一个犯人时数起</div><div class="line">			i=(i+distance-1)%list.length(); </div><div class="line">			System.out.print("删除"+list.remove(i).toString()+"");</div><div class="line">			System.out.println(list.toString());</div><div class="line">		&#125;</div><div class="line">		System.out.println("最后的被赦免者是:"+list.get(0).toString());	</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String args[])&#123;</div><div class="line">		new Josephus(5,0,2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果</p>
<blockquote>
<p>初始化约瑟夫环:(5,0,2)<br>删除B(A,C,D,E)<br>删除D(A,C,E)<br>删除A(C,E)<br>删除E(C)<br>最后的被赦免者是:C</p>
</blockquote>
<h4 id="顺序表的效率分析"><a href="#顺序表的效率分析" class="headerlink" title="顺序表的效率分析"></a>顺序表的效率分析</h4><p>由之前的源码易看出，存取任何一个元素，即set（）、get（）方法的时间复杂度为O（1），而插入或者删除很耗时，不妨假设在第i个位置插入元素，并且概率为p<em>{i},表长度为n；则平均移动次数为\sum</em>{i=0}^n{(n-i)}*{p_i};<br>如果插入元素的概率相同，即都是1/(n+1);最后求得时间复杂度为O(n);同理删除的时间复杂度也为O(n);<br>所以得出一个结论:顺序表的动态操作效率极低</p>
<h4 id="顺序表比较相等"><a href="#顺序表比较相等" class="headerlink" title="顺序表比较相等"></a>顺序表比较相等</h4><p>首先简单说一下深拷贝和浅拷贝，浅拷贝类似于只引用某个对象，和原对象指向相同的空间，而深拷贝是开辟了新空间并且复制原来对象的数据<br>而两个顺序表的相等是指，他们对应的元素相等并且长度也相同<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object obj)&#123;</div><div class="line">		if(this==obj)</div><div class="line">			return true;</div><div class="line">		if(obj instanceof seqList)&#123;</div><div class="line">			seqList&lt;T&gt; list=(seqList&lt;T&gt;)obj;</div><div class="line">			if(this.length()==list.length())&#123;</div><div class="line">				for(int i=0;i&lt;this.length();i++)</div><div class="line">					if(!(this.get(i).equals(list.get(i))))</div><div class="line">						return false;</div><div class="line">				return true;</div><div class="line">			&#125;</div><div class="line">				</div><div class="line">		&#125;</div><div class="line">			return true;</div><div class="line">	</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shiro之会话管理]]></title>
      <url>http://www.myzwl.win/2017/07/05/shiro_5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shiro提供了完整的会话功能，不依赖于底层容器，即直接使用shiro的会话管理可以直接替换掉web容器的会话管理</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。</p>
<p><strong>获取会话</strong></p>
<blockquote>
<p>Subject subject = SecurityUtils.getSubject();<br>Session session = subject.getSession();  </p>
</blockquote>
<p><strong>获取当前会话的唯一标识</strong></p>
<blockquote>
<p>session.getId(); </p>
</blockquote>
<p><strong>获取当前Subject的主机地址</strong></p>
<blockquote>
<p>session.getHost();</p>
</blockquote>
<p><strong>获取/设置当前Session的过期时间</strong></p>
<blockquote>
<p>session.getTimeout();<br>session.setTimeout(毫秒); </p>
</blockquote>
<p><strong>获取会话的启动时间及最后访问时间</strong></p>
<blockquote>
<p>session.getStartTimestamp();<br>session.getLastAccessTime();</p>
</blockquote>
<p><strong>更新会话最后访问时间及销毁会话</strong></p>
<blockquote>
<p>session.touch();<br>session.stop();</p>
</blockquote>
<p>当Subject.logout()时会自动调用stop方法来销毁会话</p>
<p><strong>设置/获取/删除会话属性</strong></p>
<blockquote>
<p>session.setAttribute(“key”, “WORD”);<br>session.getAttribute(“key”);<br>session.removeAttribute(“key”); </p>
</blockquote>
<h4 id="会话管理器"><a href="#会话管理器" class="headerlink" title="会话管理器"></a>会话管理器</h4><p>会话管理器管理着应用中所有subject的会话的创建、维护、删除、失效、验证等工作。它是shiro的核心，顶层组件SecurityManager直接继承了SessionManager，且提供了SessionsSecurityManager实现直接把会话管理委托给相应的SessionManager，DefaultSecurityManager及DefaultWebSecurityManager默认SecurityManager都继承了SessionsSecurityManager。</p>
<p><strong>SecurityManager</strong></p>
<blockquote>
<p>Session start(SessionContext context); //启动会话<br>Session getSession(SessionKey key) throws SessionException; //根据会话Key获取会话 </p>
</blockquote>
<p><strong>WebSessionManager</strong></p>
<blockquote>
<p>boolean isServletContainerSessions();//是否使用Servlet容器的会话  </p>
</blockquote>
<p><strong>ValidatingSessionManager</strong></p>
<blockquote>
<p>void validateSessions();//验证所有会话是否过期 </p>
</blockquote>
<p><img src="/images/imgs4/5.gif" alt="Alt text"></p>
<p>Shiro提供了三个默认实现：</p>
<p>DefaultSessionManager：DefaultSecurityManager使用的默认实现，用于JavaSE环境；</p>
<p>ServletContainerSessionManager：DefaultWebSecurityManager使用的默认实现，用于Web环境，其直接使用Servlet容器的会话；</p>
<p>DefaultWebSessionManager：用于Web环境的实现，可以替代ServletContainerSessionManager，自己维护着会话，直接废弃了Servlet容器的会话管理。</p>
<p><strong>全局会话时间</strong><br>在web.xml中设置(单位：分钟)</p>
<blockquote>
<p><session-config><br>  <session-timeout>30</session-timeout><br></session-config> </p>
</blockquote>
<h4 id="会话监听器"><a href="#会话监听器" class="headerlink" title="会话监听器"></a>会话监听器</h4><p>会话监听器用于监听会话创建、过期及停止事件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MySessionListener1 implements SessionListener &#123;  </div><div class="line">     @Override  </div><div class="line">     public void onStart(Session session) &#123;//会话创建时触发  </div><div class="line">         System.out.println("会话创建：" + session.getId());  </div><div class="line">     &#125;  </div><div class="line">     @Override  </div><div class="line">     public void onExpiration(Session session) &#123;//会话过期时触发  </div><div class="line">         System.out.println("会话过期：" + session.getId());  </div><div class="line">     &#125;  </div><div class="line">     @Override  </div><div class="line">     public void onStop(Session session) &#123;//退出/会话过期时触发  </div><div class="line">         System.out.println("会话停止：" + session.getId());  </div><div class="line">     &#125;    </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>如果只想监听某一个事件，可以继承SessionListenerAdapter实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class MySessionListener2 extends SessionListenerAdapter &#123;  </div><div class="line">    @Override  </div><div class="line">    public void onStart(Session session) &#123;  </div><div class="line">        System.out.println("会话创建：" + session.getId());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="会话存储-持久化"><a href="#会话存储-持久化" class="headerlink" title="会话存储/持久化"></a>会话存储/持久化</h4><p>Shiro提供SessionDAO用于会话的CRUD</p>
<blockquote>
<pre><code>//如DefaultSessionManager在创建完session后会调用该方法；如保存到关系数据库/文件系统/NoSQL数据库；即可以实现会话的持久化；返回会话ID；主要此处返回的ID.equals(session.getId())；  
Serializable create(Session session);  
//根据会话ID获取会话  
Session readSession(Serializable sessionId) throws UnknownSessionException;  
//更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用  
void update(Session session) throws UnknownSessionException;  
//删除会话；当会话过期/会话停止（如用户退出时）会调用  
void delete(Session session);  
//获取当前所有活跃用户，如果用户量多此方法影响性能  
Collection&lt;Session&gt; getActiveSessions();   
</code></pre></blockquote>
<p><img src="/images/imgs4/6.gif" alt="Alt text"></p>
<p>AbstractSessionDAO提供了SessionDAO的基础实现，如生成会话ID等；CachingSessionDAO提供了对开发者透明的会话缓存的功能，只需要设置相应的CacheManager即可；MemorySessionDAO直接在内存中进行会话维护；而EnterpriseCacheSessionDAO提供了缓存功能的会话维护，默认情况下使用MapCache实现，内部使用ConcurrentHashMap保存缓存的会话。</p>
<pre><code>如果自定义实现SessionDAO，继承CachingSessionDAO即可
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class MySessionDAO extends CachingSessionDAO &#123;  </div><div class="line">    private JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate();  </div><div class="line">     protected Serializable doCreate(Session session) &#123;  </div><div class="line">        Serializable sessionId = generateSessionId(session);  </div><div class="line">        assignSessionId(session, sessionId);  </div><div class="line">        String sql = "insert into sessions(id, session) values(?,?)";  </div><div class="line">        jdbcTemplate.update(sql, sessionId, SerializableUtils.serialize(session));  </div><div class="line">        return session.getId();  </div><div class="line">    &#125;  </div><div class="line">protected void doUpdate(Session session) &#123;  </div><div class="line">    if(session instanceof ValidatingSession &amp;&amp; !((ValidatingSession)session).isValid()) &#123;  </div><div class="line">        return; //如果会话过期/停止 没必要再更新了  </div><div class="line">    &#125;  </div><div class="line">        String sql = "update sessions set session=? where id=?";  </div><div class="line">        jdbcTemplate.update(sql, SerializableUtils.serialize(session), session.getId());  </div><div class="line">    &#125;  </div><div class="line">    protected void doDelete(Session session) &#123;  </div><div class="line">        String sql = "delete from sessions where id=?";  </div><div class="line">        jdbcTemplate.update(sql, session.getId());  </div><div class="line">    &#125;  </div><div class="line">    protected Session doReadSession(Serializable sessionId) &#123;  </div><div class="line">        String sql = "select session from sessions where id=?";  </div><div class="line">        List&lt;String&gt; sessionStrList = jdbcTemplate.queryForList(sql, String.class, sessionId);  </div><div class="line">        if(sessionStrList.size() == 0) return null;  </div><div class="line">        return SerializableUtils.deserialize(sessionStrList.get(0));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h4><p>Shiro提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话，Shiro提供了会话验证调度器SessionValidationScheduler来验证</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//分页获取会话并验证  </div><div class="line">String sql = "select session from sessions limit ?,?";  </div><div class="line">int start = 0; //起始记录  </div><div class="line">int size = 20; //每页大小  </div><div class="line">List&lt;String&gt; sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);  </div><div class="line">while(sessionList.size() &gt; 0) &#123;  </div><div class="line">  for(String sessionStr : sessionList) &#123;  </div><div class="line">    try &#123;  </div><div class="line">      Session session = SerializableUtils.deserialize(sessionStr);  </div><div class="line">      Method validateMethod =   </div><div class="line">        ReflectionUtils.findMethod(AbstractValidatingSessionManager.class,   </div><div class="line">            "validate", Session.class, SessionKey.class);  </div><div class="line">      validateMethod.setAccessible(true);  </div><div class="line">      ReflectionUtils.invokeMethod(validateMethod,   </div><div class="line">        sessionManager, session, new DefaultSessionKey(session.getId()));  </div><div class="line">    &#125; catch (Exception e) &#123;  </div><div class="line">        //ignore  </div><div class="line">    &#125;  </div><div class="line">  &#125;  </div><div class="line"> start = start + size;  </div><div class="line">  sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>sessionFactory</strong><br>sessionFactory是创建会话的工厂，根据相应的Subject上下文信息来创建会话；默认提供了SimpleSessionFactory用来创建SimpleSession会话。<br>自定义一个session</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class OnlineSession extends SimpleSession &#123;  </div><div class="line">    public static enum OnlineStatus &#123;  </div><div class="line">        on_line("在线"), hidden("隐身"), force_logout("强制退出");  </div><div class="line">        private final String info;  </div><div class="line">        private OnlineStatus(String info) &#123;  </div><div class="line">            this.info = info;  </div><div class="line">        &#125;  </div><div class="line">        public String getInfo() &#123;  </div><div class="line">            return info;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    private String userAgent; //用户浏览器类型  </div><div class="line">    private OnlineStatus status = OnlineStatus.on_line; //在线状态  </div><div class="line">    private String systemHost; //用户登录时系统IP   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义SessionFactory<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class OnlineSessionFactory implements SessionFactory &#123;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public Session createSession(SessionContext initData) &#123;  </div><div class="line">        OnlineSession session = new OnlineSession();  </div><div class="line">        if (initData != null &amp;&amp; initData instanceof WebSessionContext) &#123;  </div><div class="line">            WebSessionContext sessionContext = (WebSessionContext) initData;  </div><div class="line">            HttpServletRequest request = (HttpServletRequest) sessionContext.getServletRequest();  </div><div class="line">            if (request != null) &#123;  </div><div class="line">                session.setHost(IpUtils.getIpAddr(request));  </div><div class="line">                session.setUserAgent(request.getHeader("User-Agent"));  </div><div class="line">                session.setSystemHost(request.getLocalAddr() + ":" + request.getLocalPort());  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return session;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 安全框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shiro之jstl标签]]></title>
      <url>http://www.myzwl.win/2017/07/04/shiro_4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shiro提供了JSTL标签用于在页面进行权限控制</p>
<h4 id="导入标签库"><a href="#导入标签库" class="headerlink" title="导入标签库"></a>导入标签库</h4><blockquote>
<p>&lt;%@taglib prefix=”shiro” uri=”<a href="http://shiro.apache.org/tags" target="_blank" rel="external">http://shiro.apache.org/tags</a>“ %&gt; </p>
</blockquote>
<h4 id="各类标签"><a href="#各类标签" class="headerlink" title="各类标签"></a>各类标签</h4><p><strong>guest标签</strong></p>
<blockquote>
<p><shiro:guest><br>欢迎游客访问，<br></shiro:guest></p>
</blockquote>
<p>用户没有身份验证时显示相应信息，即游客访问信息</p>
<p><strong>user标签 </strong></p>
<blockquote>
<p>   <shiro:user><br>    欢迎[<shiro:principal>]登录<br>    </shiro:principal></shiro:user>   </p>
</blockquote>
<p>用户已经身份验证/记住我登录后显示相应的信息。</p>
<p><strong>authenticated标签 </strong></p>
<blockquote>
<p> shiro:authenticated&gt;<br>     </p>
</blockquote>
<p> 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。</p>
<p><strong>notAuthenticated标签</strong></p>
<blockquote>
<p>  <shiro:notauthenticated><br>     </shiro:notauthenticated></p>
</blockquote>
<p> 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证</p>
<p><strong>principal标签</strong></p>
<blockquote>
<shiro: principal="">

</shiro:></blockquote>
<p> 显示用户身份信息，默认调用Subject.getPrincipal()获取，即Primary Principal。</p>
<p><strong>hasRole标签</strong></p>
<blockquote>
<p> <shiro:hasrole name="admin"><br>    用户[<shiro:principal>]拥有角色admin<br><br>    </shiro:principal></shiro:hasrole></p>
</blockquote>
<p> 如果当前Subject有角色将显示body体内容</p>
<p><strong>hasAnyRoles标签</strong></p>
<blockquote>
<pre><code>&lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;    
   &lt;/shiro:hasAnyRoles&gt;   
</code></pre></blockquote>
<p> 如果当前Subject有任意一个角色（或的关系）将显示body体内容</p>
<p><strong>lacksRole标签</strong></p>
<blockquote>
<p>  <shiro:lacksrole name="abc"><br>     </shiro:lacksrole></p>
</blockquote>
<p> 如果当前Subject没有角色将显示body体内容</p>
<p><strong>hasPermission标签</strong></p>
<blockquote>
<p><shiro:haspermission name="user:create"><br>    </shiro:haspermission></p>
</blockquote>
<p> 如果当前Subject有权限将显示body体内容。</p>
<p><strong>lacksPermission标签</strong></p>
<blockquote>
<p> <shiro:lackspermission name="sss:create"><br>     </shiro:lackspermission> </p>
</blockquote>
<p> 如果当前Subject没有权限将显示body体内容。</p>
]]></content>
      
        <categories>
            
            <category> 安全框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shiro之拦截器机制]]></title>
      <url>http://www.myzwl.win/2017/07/03/shiro_3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Shiro使用了与Servlet一样的Filter接口进行扩展，还有拦截器是基于java的反射机制，如利用动态代理实现，而平时说的过滤器是基于回调函数的实现，在实现原理上有着本质的区别<br><img src="/images/imgs4/2.gif" alt="Alt text"></p>
<h4 id="拦截器介绍"><a href="#拦截器介绍" class="headerlink" title="拦截器介绍"></a>拦截器介绍</h4><p><strong>NameableFilter</strong><br>顾名思义，就是根据相应拦截器链组装拦截器的名字找到相应的拦截器实例</p>
<p><strong>OncePerRequestFilter</strong><br>该拦截器用于控制一次请求只能走一次拦截器链，默认是开启拦截的</p>
<p><strong>ShiroFilter</strong><br>是整个shiro的入口点，用于拦截需要安全控制的请求进行处理</p>
<p><strong>AdviceFilter</strong><br>该拦截器非常类似于struct中拦截器，同时支持AOP拦截</p>
<blockquote>
<p>boolean preHandle(ServletRequest request, ServletResponse response) throws Exception<br>void postHandle(ServletRequest request, ServletResponse response) throws Exception<br>void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception;  </p>
</blockquote>
<p>preHandler：类似于AOP中的前置增强；在拦截器链执行之前执行；如果返回true则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权）</p>
<p>postHandle：类似于AOP中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）；</p>
<p>afterCompletion：类似于AOP中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源（如解除Subject与线程的绑定之类的）；</p>
<p><strong>PathMatchingFilter</strong><br>提供了基于Ant风格的请求路径匹配功能及拦截器参数解析的功能，如“roles[admin,user]”自动根据“，”分割解析到一个路径参数配置并绑定到相应的路径：</p>
<blockquote>
<p>boolean pathsMatch(String path, ServletRequest request)<br>boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception </p>
</blockquote>
<p>pathsMatch：该方法用于path与请求路径进行匹配的方法；如果匹配返回true；</p>
<p>onPreHandle：在preHandle中，当pathsMatch匹配一个路径后，会调用opPreHandler方法并将路径绑定参数配置传给mappedValue；然后可以在这个方法中进行一些验证（如角色授权），如果验证失败可以返回false中断流程；默认返回true；也就是说子类可以只实现onPreHandle即可，无须实现preHandle。如果没有path与请求路径匹配，默认是通过的（即preHandle返回true）。</p>
<p><strong>AccessControlFilter</strong><br>提供了访问控制的基础功能</p>
<blockquote>
<pre><code>abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;  
boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;  
abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception;   
</code></pre></blockquote>
<pre><code>isAccessAllowed：表示是否允许访问；mappedValue就是[urls]配置中拦截器参数部分，如果允许访问返回true，否则false；
</code></pre><p>onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；如果返回false表示该拦截器实例已经处理了，将直接返回即可。</p>
<p>同时它还有一些扩展的功能</p>
<blockquote>
<p>void setLoginUrl(String loginUrl) //身份验证时使用，默认/login.jsp<br>String getLoginUrl()<br>Subject getSubject(ServletRequest request, ServletResponse response) //获取Subject实例<br>boolean isLoginRequest(ServletRequest request, ServletResponse response)//当前请求是否是登录请求<br>void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException //将当前请求保存起来并重定向到登录页面<br>void saveRequest(ServletRequest request) //将请求保存起来，如登录成功后再重定向回该请求<br>void redirectToLogin(ServletRequest request, ServletResponse response) //重定向到登录页面 </p>
</blockquote>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h4><p>在web容器中，先执行shiro的filter链，再执行servlet容器的filter链，同时shiro的ProxiedFilterChain对Servlet容器的FilterChain进行了代理</p>
<blockquote>
<p>FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain);</p>
</blockquote>
<h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><p>通过自定义拦截器可以扩展一些功能，如动态url-角色/权限访问控制，根据Subject身份信息获取用户信息绑定到Request（即设置通用数据）、验证码验证、在线用户信息的保存等等</p>
<p><strong>扩展OncePerRequestFilter</strong><br>OncePerRequestFilter保证一次请求只调用一次doFilterInternal<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MyOncePerRequestFilter extends OncePerRequestFilter&#123;</div><div class="line">	@Override</div><div class="line">	protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)</div><div class="line">			throws ServletException, IOException &#123;	</div><div class="line">		  System.out.println("once");</div><div class="line">		  chain.doFilter(request, response);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的ini配置文件中</p>
<blockquote>
<p>[filters]<br>myFilter1=com.shiro.web.MyOncePerRequestFilter<br>[urls]<br>/**=myFilter1</p>
</blockquote>
<p>其中[filters]声明拦截器，[urls]执行拦截器</p>
<p><strong>扩展AdviceFilter</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MyAdviceFilter extends AdviceFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">		System.out.println("pre");</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void postHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">	  System.out.println("postHandle");</div><div class="line">		super.postHandle(request, response);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception)</div><div class="line">			throws Exception &#123;</div><div class="line">		System.out.println("afterCompletion");</div><div class="line">		super.afterCompletion(request, response, exception);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>preHandle：进行请求的预处理，然后根据返回值决定是否继续处理（true：继续过滤器链）；可以通过它实现权限控制；</p>
<p>postHandle：执行完拦截器链之后正常返回后执行；</p>
<p>afterCompletion：不管最后有没有异常，afterCompletion都会执行，完成如清理资源功能。</p>
<p><strong>扩展PathMatchingFilter</strong><br>提供了url模式过滤的功能<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyPathMatchingFilter extends PathMatchingFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue)</div><div class="line">			throws Exception &#123;</div><div class="line">		</div><div class="line">		   System.out.println("url matches,config is " + Arrays.toString((String[])mappedValue));  </div><div class="line">	       return true;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>preHandle：会进行url模式与请求url进行匹配，如果匹配会调用onPreHandle；如果没有配置url模式/没有url模式匹配，默认直接返回true；</p>
<p>onPreHandle：如果url模式与请求url匹配，那么会执行onPreHandle，并把该拦截器配置的参数传入。默认什么不处理直接返回true。</p>
<p><strong>扩展AccessControlFilter</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MyAccessControlFilter extends AccessControlFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)</div><div class="line">			throws Exception &#123;</div><div class="line">		System.out.println("isAccessAllowed");  </div><div class="line">        return false;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">		 System.out.println("访问拒绝也不自己处理，继续拦截器链的执行");  </div><div class="line">	        return true;  </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>isAccessAllowed：即是否允许访问，返回true表示允许；</p>
<p>onAccessDenied：表示访问拒绝时是否自己处理，如果返回true表示自己不处理且继续拦截器链执行，返回false表示自己已经处理了（比如重定向到另一个页面）</p>
<p>其中如果isAccessAllowed返回true，onAccessDenied将不执行，反之执行</p>
<h4 id="默认拦截器"><a href="#默认拦截器" class="headerlink" title="默认拦截器"></a>默认拦截器</h4><p>Shiro内置了很多默认的拦截器，比如身份验证、授权等相关的<br><img src="/images/imgs4/3.gif" alt="Alt text"><br><img src="/images/imgs4/4.gif" alt="Alt text"></p>
]]></content>
      
        <categories>
            
            <category> 安全框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shiro之编码加密]]></title>
      <url>http://www.myzwl.win/2017/07/02/shiro_2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在涉及数据在网络上的传输时，都要将明文数据加密传输，并且通常情况下的加密都是不可逆的</p>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>shiro内部提供了base64和16进制字符串编码/解码的API支持，如下<br><strong>base64编码/解码</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     String str="123456";	</div><div class="line">String base64Encoded=Base64.encodeToString(str.getBytes());//加密</div><div class="line"> System.out.println(base64Encoded);</div><div class="line">  String str2=Base64.decodeToString(base64Encoded); //解密</div><div class="line">   System.out.println(str2);</div><div class="line">    System.out.println(str.equals(str2));</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>MTIzNDU2<br>123456<br>true</p>
</blockquote>
<p><strong>16进制字符串编码/解码</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     String str="123456";	</div><div class="line">String base64Encoded = Hex.encodeToString(str.getBytes());//加密</div><div class="line"> System.out.println(base64Encoded);</div><div class="line"> String str2 = new String(Hex.decode(base64Encoded.getBytes())); //解密</div><div class="line">   System.out.println(str2);</div><div class="line">    System.out.println(str.equals(str2));</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>313233343536<br>123456<br>true</p>
</blockquote>
<p><strong>byte与string编码/解码</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     String str="123456";</div><div class="line">     byte[] str3=CodecSupport.toBytes(str, "utf-8");  //变成byte数组</div><div class="line">System.out.println(str3);</div><div class="line">String str4=CodecSupport.toString(str3, "utf-8"); //编程String</div><div class="line">System.out.println(str4);</div></pre></td></tr></table></figure></p>
<p>输出结果</p>
<blockquote>
<p>[B@cd51c3<br>123456</p>
</blockquote>
<h4 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h4><p>该算法是一种不可逆的算法，如MD5，SHA等，一般该算法最好需要提供一个salt（盐）来增加破解难度，一般情况下的盐被设置为 密码+用户名+盐，这样只有系统知道盐值，更难被破解</p>
<p><strong>MD5散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  String str = "hello";  </div><div class="line">String salt = "world";  </div><div class="line">String md5 = new Md5Hash(str, salt,2).toString();</div><div class="line">System.out.println(md5);</div></pre></td></tr></table></figure></p>
<p>这里的2是散列次数，即迭代多少次，这里是2次</p>
<blockquote>
<p>556b1a232d4d63a2f3ab87c9535abe25</p>
</blockquote>
<p><strong>其它散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    String str = "hello";  </div><div class="line">String salt = "world";  </div><div class="line">String sha1 = new Sha256Hash(str, salt).toString(); </div><div class="line">String SHA1=new Sha1Hash(str, salt).toString();</div><div class="line">String SHA512=new Sha512Hash(str, salt).toString();</div><div class="line">System.out.println(sha1);</div><div class="line">System.out.println(SHA1);</div><div class="line">System.out.println(SHA512);</div></pre></td></tr></table></figure></p>
<p>相应的输入结果：</p>
<blockquote>
<p>5715790a892990382d98858c4aa38d0617151575<br>3e64afa1cb7d643aa36f63b8d092ad76b1f04ff557abbb3d05f5b9037abf68a6606a8885d51bec8f6f39ee7d0badd504241c3704e777a51c21a9723e285fb9b8</p>
</blockquote>
<p><strong>通用散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String simpleHash = new SimpleHash("SHA-1", str, salt).toString();</div></pre></td></tr></table></figure></p>
<p>其中第一个参数指定采用哪种算法<br>输出结果：</p>
<blockquote>
<p>5715790a892990382d98858c4aa38d0617151575</p>
</blockquote>
<p><strong>默认匹配</strong><br>Shiro提供了HashService，默认提供了DefaultHashService实现。<br>先来看下它的构造函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public DefaultHashService() &#123;</div><div class="line">        this.algorithmName = "SHA-512";//默认算法SHA-512</div><div class="line">        this.iterations = 1; //生成Hash值的迭代次数，默认1</div><div class="line">        this.generatePublicSalt = false; //是否生成公盐，默认false</div><div class="line">        this.rng = new SecureRandomNumberGenerator();//用于生成公盐</div><div class="line">    &#125;</div><div class="line">    String hex = randomNumberGenerator.nextBytes().toHex();//随机生成一个盐</div></pre></td></tr></table></figure></p>
<h4 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h4><p>Shiro还提供对称式加密/解密算法的支持，如AES、Blowfish等<br><strong>AES算法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">AesCipherService aesCipherService = new AesCipherService();</div><div class="line">      aesCipherService.setKeySize(128);//设置key长度</div><div class="line">      //生成key</div><div class="line">      Key key = aesCipherService.generateNewKey();</div><div class="line">      String text = "zwl";</div><div class="line">      //加密</div><div class="line">      String encrptText = aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();</div><div class="line">      //解密</div><div class="line">      String text2 = new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());</div><div class="line">        System.out.println(key.toString());</div><div class="line">      System.out.println(encrptText);</div><div class="line">    System.out.println(text2);</div></pre></td></tr></table></figure></p>
<p>而上面的key就相当于一把钥匙，只有了这把钥匙，就能解密<br>输出结果：</p>
<blockquote>
<p>javax.crypto.spec.SecretKeySpec@176a4<br>a316645482dff96d9c86c64adabc51dee5170232365a3c15dab941dc6b73c2ec<br>zwl</p>
</blockquote>
<p><strong>Blowfish算法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BlowfishCipherService blowfishCipherService = new BlowfishCipherService();</div><div class="line">        blowfishCipherService.setKeySize(128);</div><div class="line">        //生成key</div><div class="line">        Key key = blowfishCipherService.generateNewKey();</div><div class="line">        String text = "zwl";</div><div class="line">        //加密</div><div class="line">        String encrptText = blowfishCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();</div><div class="line">        //解密</div><div class="line">        String text2 = new String(blowfishCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes()); </div><div class="line">        System.out.println(key.toString());</div><div class="line">       System.out.println(encrptText);</div><div class="line">      System.out.println(text2);</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>javax.crypto.spec.SecretKeySpec@d97afa5c<br>8e7f6626884b7b429a1000286f4990a4<br>zwl</p>
</blockquote>
<h4 id="PasswordService-CredentialsMatcher"><a href="#PasswordService-CredentialsMatcher" class="headerlink" title="PasswordService/CredentialsMatcher"></a>PasswordService/CredentialsMatcher</h4><p>在用户输入明文密码时，shiro默认的实现方式如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public interface PasswordService &#123;  </div><div class="line">    //输入明文密码得到密文密码  </div><div class="line">    String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">    public interface CredentialsMatcher &#123;  </div><div class="line">    //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）  </div><div class="line">    boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Shiro默认提供了PasswordService实现DefaultPasswordService；CredentialsMatcher实现PasswordMatcher及HashedCredentialsMatcher</p>
<p>关于shiro的编码\加密是在是丰富多多彩，一般是学习中遇到采取查询相关的</p>
<h4 id="一个对称加密的算法"><a href="#一个对称加密的算法" class="headerlink" title="一个对称加密的算法"></a>一个对称加密的算法</h4><p>下面是在一个项目中使用到的工具类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div></pre></td><td class="code"><pre><div class="line">public class DesUtils &#123;</div><div class="line">	/** 字符串默认键值     */</div><div class="line">	  private static String strDefaultKey = "national";</div><div class="line"></div><div class="line">	  /** 加密工具     */</div><div class="line">	  private Cipher encryptCipher = null;</div><div class="line"></div><div class="line">	  /** 解密工具     */</div><div class="line">	  private Cipher decryptCipher = null;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 将byte数组转换为表示16进制值的字符串， 如：byte[]&#123;8,18&#125;转换为：0813， 和public static byte[]  </div><div class="line">	   * hexStr2ByteArr(String strIn) 互为可逆的转换过程  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需要转换的byte数组  </div><div class="line">	   * @return 转换后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   *             本方法不处理任何异常，所有异常全部抛出  </div><div class="line">	   */</div><div class="line">	  public static String byteArr2HexStr(byte[] arrB) throws Exception &#123;</div><div class="line">	    int iLen = arrB.length;</div><div class="line">	    // 每个byte用两个字符才能表示，所以字符串的长度是数组长度的两倍   </div><div class="line">	    StringBuffer sb = new StringBuffer(iLen * 2);</div><div class="line">	    for (int i = 0; i &lt; iLen; i++) &#123;</div><div class="line">	      int intTmp = arrB[i];</div><div class="line">	      // 把负数转换为正数   </div><div class="line">	      while (intTmp &lt; 0) &#123;</div><div class="line">	        intTmp = intTmp + 256;</div><div class="line">	      &#125;</div><div class="line">	      // 小于0F的数需要在前面补0   </div><div class="line">	      if (intTmp &lt; 16) &#123;</div><div class="line">	        sb.append("0");</div><div class="line">	      &#125;</div><div class="line">	      sb.append(Integer.toString(intTmp, 16));</div><div class="line">	    &#125;</div><div class="line">	    return sb.toString();</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 将表示16进制值的字符串转换为byte数组， 和public static String byteArr2HexStr(byte[] arrB)  </div><div class="line">	   * 互为可逆的转换过程  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需要转换的字符串  </div><div class="line">	   * @return 转换后的byte数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   *             本方法不处理任何异常，所有异常全部抛出  </div><div class="line">	   *  </div><div class="line">	   */</div><div class="line">	  public static byte[] hexStr2ByteArr(String strIn) throws Exception &#123;</div><div class="line">	    byte[] arrB = strIn.getBytes();</div><div class="line">	    int iLen = arrB.length;</div><div class="line"></div><div class="line">	    // 两个字符表示一个字节，所以字节数组长度是字符串长度除以2   </div><div class="line">	    byte[] arrOut = new byte[iLen / 2];</div><div class="line">	    for (int i = 0; i &lt; iLen; i = i + 2) &#123;</div><div class="line">	      String strTmp = new String(arrB, i, 2);</div><div class="line">	      arrOut[i / 2] = (byte) Integer.parseInt(strTmp, 16);</div><div class="line">	    &#125;</div><div class="line">	    return arrOut;</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 默认构造方法，使用默认密钥  </div><div class="line">	   *   </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public DesUtils() throws Exception &#123;</div><div class="line">	    this(strDefaultKey);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 指定密钥构造方法  </div><div class="line">	   *   </div><div class="line">	   * @param strKey  </div><div class="line">	   *            指定的密钥  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public DesUtils(String strKey) throws Exception &#123;</div><div class="line">	    //Security.addProvider(new com.sun.crypto.provider.SunJCE());</div><div class="line">	    Key key = getKey(strKey.getBytes());</div><div class="line"></div><div class="line">	    encryptCipher = Cipher.getInstance("DES");</div><div class="line">	    encryptCipher.init(Cipher.ENCRYPT_MODE, key);</div><div class="line"></div><div class="line">	    decryptCipher = Cipher.getInstance("DES");</div><div class="line">	    decryptCipher.init(Cipher.DECRYPT_MODE, key);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 加密字节数组  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需加密的字节数组  </div><div class="line">	   * @return 加密后的字节数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public byte[] encrypt(byte[] arrB) throws Exception &#123;</div><div class="line">	    return encryptCipher.doFinal(arrB);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 加密字符串  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需加密的字符串  </div><div class="line">	   * @return 加密后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public String encrypt(String strIn) throws Exception &#123;</div><div class="line">	    return byteArr2HexStr(encrypt(strIn.getBytes()));</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 解密字节数组  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需解密的字节数组  </div><div class="line">	   * @return 解密后的字节数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public byte[] decrypt(byte[] arrB) throws Exception &#123;</div><div class="line">	    return decryptCipher.doFinal(arrB);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 解密字符串  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需解密的字符串  </div><div class="line">	   * @return 解密后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public String decrypt(String strIn) throws Exception &#123;</div><div class="line">	    return new String(decrypt(hexStr2ByteArr(strIn)));</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 从指定字符串生成密钥，密钥所需的字节数组长度为8位 不足8位时后面补0，超出8位只取前8位  </div><div class="line">	   *   </div><div class="line">	   * @param arrBTmp  </div><div class="line">	   *            构成该字符串的字节数组  </div><div class="line">	   * @return 生成的密钥  </div><div class="line">	   * @throws java.lang.Exception  </div><div class="line">	   */</div><div class="line">	  private Key getKey(byte[] arrBTmp) throws Exception &#123;</div><div class="line">	    // 创建一个空的8位字节数组（默认值为0）   </div><div class="line">	    byte[] arrB = new byte[8];</div><div class="line"></div><div class="line">	    // 将原始字节数组转换为8位   </div><div class="line">	    for (int i = 0; i &lt; arrBTmp.length &amp;&amp; i &lt; arrB.length; i++) &#123;</div><div class="line">	      arrB[i] = arrBTmp[i];</div><div class="line">	    &#125;</div><div class="line"></div><div class="line">	    // 生成密钥   </div><div class="line">	    Key key = new javax.crypto.spec.SecretKeySpec(arrB, "DES");</div><div class="line"></div><div class="line">	    return key;</div><div class="line">	  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 安全框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识shiro]]></title>
      <url>http://www.myzwl.win/2017/07/01/shiro_1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考百度上说的<a href="http://shiro.apache.org/download.html" target="_blank" rel="external">Apache Shiro</a>是一个强大易用的java安全框架，提供了认证、授权、加密和会话管理功能，可以为任何应用提供安全保障，而其主要为解决以下四个问题：<br>1、 认证-用户身份识别，常被称为用户登录<br>2、 授权-访问控制<br>3、 密码加密-保护或隐藏数据防止被偷窥<br>4、 会话管理-每用户相关的时间敏感的状态</p>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>以下是从其官网上截取的原理图<br><img src="/images/imgs3/14.gif" alt="Alt text"></p>
<p>可以看出shiro的设计非常精妙，同时它不依赖于任何容器，即在java se和java ee中都可以使用，如果把shiro看做一个不透明的黑盒的话，即认证主体subject提供认证给security manager，其内部封装一些列细节方法去执行认证，这里的验证数据源可以是数据库的或者其他</p>
<p>下面将以用户的登录过程来模拟shiro的执行过程</p>
<p><img src="/images/imgs4/1.gif" alt="Alt text"></p>
<h4 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h4><p><strong>token令牌</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">   @RequestMapping("login")</div><div class="line">public ModelAndView login(@RequestParam("username") String username, @RequestParam("password") String password) &#123;</div><div class="line">	 UsernamePasswordToken token = new UsernamePasswordToken(username, password);</div><div class="line">        Subject subject = SecurityUtils.getSubject();</div><div class="line">        try &#123;</div><div class="line">            subject.login(token);</div><div class="line">        &#125; catch (IncorrectCredentialsException ice) &#123;</div><div class="line">            // 捕获密码错误异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "password error!");</div><div class="line">            return mv;</div><div class="line">        &#125; catch (UnknownAccountException uae) &#123;</div><div class="line">            // 捕获未知用户名异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "username error!");</div><div class="line">            return mv;</div><div class="line">        &#125; catch (ExcessiveAttemptsException eae) &#123;</div><div class="line">            // 捕获错误登录过多的异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "times error");</div><div class="line">            return mv;</div><div class="line">        &#125;</div><div class="line">        catch (AuthenticationException eae) &#123;</div><div class="line">            // 捕获错误登录过多的异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "times error");</div><div class="line">            return mv;</div><div class="line">        &#125;</div><div class="line">        TUserEntity user=tUserService.queryObject(username);</div><div class="line">        subject.getSession().setAttribute("user", user);   </div><div class="line">         return new ModelAndView("index");	 </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这里该方法接收到前台传递过来的username和password信息，类比身份证，姓名是认证，但是身份证号码是作为认证的唯一凭证，只有身份证号码正确了，这个认证也就通过了，而这里的token可以理解为用户登录的令牌，里面记录着认证信息，然后交给shiro去验证<br> 接下来就是执行登录动作了</p>
<blockquote>
<p>SecurityUtils.setSecurityManager(securityManager); // 注入SecurityManager<br>Subject subject = SecurityUtils.getSubject(); // 获取Subject单例对象<br>subject.login(token); // 登陆</p>
</blockquote>
<p>其中SecurityManager是一个单例对象，即全局变量，接着SecurityUtils会自动绑定当前线程，获得subject主体，关于subject可以这样理解其包含两个信息:<br>Principals： 身份，可以是用户名，邮件，手机号码等等，用来标识一个登陆主体身份；<br>Credentials： 凭证，常见有密码，数字证书等等；<br>最后就是登陆了，最后通过验证token是否合法返回不同结果</p>
<h4 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h4><p>根据流程图，接下来security manager开始执行一系列的认证手段了，其中最主要的就是<br>AuthorizationInfo（角色权限认证），AuthenticationInfo（身份认证），可以简单这样理解，身份认证只是验证了这个subject的存在性，如果约定subject有某些权限，如管理员有删除或者访问某些url地址权限，而这个管理员就可以抽象为角色，也就是说权限是访问资源的权利集合，而角色是权限的集合</p>
<p>最后的realm域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色，权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源</p>
<p>一般情况下realm需要我们自定义去实现，因为shiro不知道哪些token是合法的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">  public class OAuth2Realm extends AuthorizingRealm&#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	private TUserService tUserService;</div><div class="line">	</div><div class="line">	/**</div><div class="line">     * 提供用户信息返回权限信息</div><div class="line">     */</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</div><div class="line">	</div><div class="line">		String username = (String) principals.getPrimaryPrincipal();</div><div class="line">		 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();</div><div class="line">		   TUserEntity user=tUserService.queryObject(username);</div><div class="line">	        // 根据id查询当前用户拥有的角色</div><div class="line">		  List&lt;TUserRoleEntity&gt; ture=tUserService.queryRole(user.getId());</div><div class="line">		   Set&lt;TRoleEntity&gt; roles=new HashSet&lt;TRoleEntity&gt;();</div><div class="line">		        for(TUserRoleEntity Tures:ture)&#123;</div><div class="line">		        	roles.add(tUserService.queryObject(Tures.getRoleId()));</div><div class="line">		        &#125;</div><div class="line">		        Set&lt;String&gt; roleNames=new HashSet&lt;String&gt;();</div><div class="line">		         for(TRoleEntity rolename : roles)&#123;</div><div class="line">		    	   roleNames.add(rolename.getRolename());</div><div class="line">		         &#125;</div><div class="line">		      // 将角色名称提供给info</div><div class="line">		      authorizationInfo.setRoles(roleNames);</div><div class="line">		return authorizationInfo;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">     * 提供账户信息返回认证信息</div><div class="line">     */</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</div><div class="line">		</div><div class="line">		String username=(String)token.getPrincipal();   // 获取用户名</div><div class="line">// String password = new String((char[])token.getCredentials()); 得到密码</div><div class="line"></div><div class="line">	UsernamePasswordToken t = (UsernamePasswordToken) token; //得到密码</div><div class="line">		String newPassword=new String(t.getPassword());</div><div class="line">		//根据用户名从数据库取出用户完整信息</div><div class="line">		 TUserEntity tuserEntity=tUserService.queryObject(username);</div><div class="line">		  if(tuserEntity!=null)&#123;</div><div class="line">			  //若存在，将此用户存放到登录认证info中    </div><div class="line">	            return new SimpleAuthenticationInfo(tuserEntity.getUsername(),tuserEntity.getPassword(), ByteSource.Util.bytes("zwl"), getName());  </div><div class="line">		  &#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>该realm类的结果就是根据token的合法性验证返回不同结果给相应的controller，目前只是从宏观上看了一个全过程，shiro是非常强大的，它的功能远不止如此</p>
<h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>缓存的本质就是将原本只能存储在内存中的数据通过算法保存到硬盘上，再根据需求依次取出。可以把缓存理解为一个Map对象，通过put保存对象，再通过get取回对象。这里使用的是Ehcache缓存框架。具体代码如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;ehcache name="es"&gt;</div><div class="line"></div><div class="line">    &lt;diskStore path="java.io.tmpdir"/&gt;</div><div class="line"></div><div class="line">    &lt;!--</div><div class="line">       name:缓存名称。</div><div class="line">       maxElementsInMemory：缓存最大个数。</div><div class="line">       eternal:对象是否永久有效，一但设置了，timeout将不起作用。</div><div class="line">       timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</div><div class="line">       timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</div><div class="line">       overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。</div><div class="line">       diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</div><div class="line">       maxElementsOnDisk：硬盘最大缓存个数。</div><div class="line">       diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</div><div class="line">       diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</div><div class="line">       memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</div><div class="line">       clearOnFlush：内存数量最大时是否清除。</div><div class="line">    --&gt;</div><div class="line"></div><div class="line">    &lt;defaultCache</div><div class="line">            maxEntriesLocalHeap="1000"</div><div class="line">            eternal="false"</div><div class="line">            timeToIdleSeconds="3600"</div><div class="line">            timeToLiveSeconds="3600"</div><div class="line">            overflowToDisk="false"&gt;</div><div class="line">    &lt;/defaultCache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-authenticationCache"</div><div class="line">           maxEntriesLocalHeap="1000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-authorizationCache"</div><div class="line">           maxEntriesLocalHeap="2000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-userCache"</div><div class="line">           maxEntriesLocalHeap="2000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">&lt;/ehcache&gt;</div></pre></td></tr></table></figure></p>
<p>其中<diskstore path="java.io.tmpdir">可以指定缓存的路径，这里是临时路径</diskstore></p>
<h4 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h4><p>通常情况下散列和加密本质上都是一样的，即将一个Object变成一串无意义的字符串，不同点是经过散列的对象无法复原，是一个单向的过程，而加密是可以双向的，即加密与解密，所以如果忘记密码，只能进行修改密码操作，下面是在项目中用到的散列算法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private RandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator();</div><div class="line">private String algorithmName = "md5";</div><div class="line">private final int hashIterations = 2;</div><div class="line"></div><div class="line">public void encryptPassword(TUserEntity user) &#123;</div><div class="line">    // User对象包含最基本的字段Username和Password</div><div class="line">	String salt="zwl";</div><div class="line">    // 将用户的注册密码经过散列算法替换成一个不可逆的新密码保存进数据，散列过程使用了盐</div><div class="line">    String newPassword = new SimpleHash(algorithmName, user.getPassword(),</div><div class="line">            ByteSource.Util.bytes("zwl"), hashIterations).toHex();</div><div class="line">    user.setPassword(newPassword);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中algorithmName为指定运用何种算法，hashIterations为散列次数，也就是数学中的迭代，将前一个结果作为参数在运算一次，salt盐可以理解为有了盐，并且每个盐唯一确定一个散列值，最后产生的newPassword是经过如下类</p>
<blockquote>
<p>public SimpleHash(String algorithmName, Object source, Object salt, int hashIterations) </p>
</blockquote>
<p>四个参数分别标识算法名称，散列对象，散列使用的salt值，散列次数。</p>
<h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>匹配的功能就是用来匹配用户登录使用的令牌和数据库中保存的用户信息是否匹配。它的原始接口是CredentialsMatcher，一般情况下如果不自定义的话就会使用默认的实现类HashedCredentialsMatcher，如下是自定义的匹配<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher&#123;</div><div class="line"></div><div class="line">	// 声明一个缓存接口，这个接口是Shiro缓存管理的一部分，它的具体实现可以通过外部容器注入</div><div class="line">	 private Cache&lt;String, AtomicInteger&gt; passwordRetryCache;</div><div class="line">	 </div><div class="line">	 public RetryLimitHashedCredentialsMatcher(CacheManager cacheManager) &#123;</div><div class="line">	        passwordRetryCache = cacheManager.getCache("passwordRetryCache");</div><div class="line">	    &#125;</div><div class="line">	 </div><div class="line">	 @Override</div><div class="line">	    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123;</div><div class="line">		 String username = (String) token.getPrincipal();</div><div class="line">	        AtomicInteger retryCount = passwordRetryCache.get(username);</div><div class="line">	        if (retryCount == null) &#123;</div><div class="line">	            retryCount = new AtomicInteger(0);</div><div class="line">	            passwordRetryCache.put(username, retryCount);</div><div class="line">	        &#125;</div><div class="line">	        // 自定义一个验证过程：当用户连续输入密码错误5次以上禁止用户登录一段时间</div><div class="line">	        if (retryCount.incrementAndGet() &gt; 5) &#123;</div><div class="line">	            throw new ExcessiveAttemptsException();</div><div class="line">	        &#125;</div><div class="line">	        boolean match = super.doCredentialsMatch(token, info);</div><div class="line">	        if (match) &#123;</div><div class="line">	            passwordRetryCache.remove(username);</div><div class="line">	        &#125;</div><div class="line">	        return match;</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般情况下，匹配的异常的结果都会抛出相应的异常，如 DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等</p>
<p>而针对获得realm数据源的情况，会设置五张表，分别是用户表（存储用户名，密码，盐等）、角色表（角色名称，相关描述等）、权限表（权限名称，相关描述等）、用户-角色对应中间表（以用户ID和角色ID作为联合主键）、角色-权限对应中间表（以角色ID和权限ID作为联合主键），其中用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>用户的一次登录即为一次会话，即session，Shiro也可以代替Tomcat等容器管理会话。而针对会话，可以处理的情况太多了，如记录用户信息和行为等等，比如保存用户信息</p>
<blockquote>
<p>TUserEntity user=tUserService.queryObject(username);<br>    subject.getSession().setAttribute(“user”, user); </p>
</blockquote>
<h4 id="ssm-shiro集成"><a href="#ssm-shiro集成" class="headerlink" title="ssm+shiro集成"></a>ssm+shiro集成</h4><p>web.xml中的配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"</div><div class="line">         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee</div><div class="line">                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</div><div class="line">         version="3.0"&gt;</div><div class="line"></div><div class="line">    &lt;!-- 修改 Servlet 版本--&gt;</div><div class="line">    &lt;!-- 配置 DispatcherServlet--&gt;</div><div class="line">    &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</div><div class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">        &lt;init-param&gt;</div><div class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">            &lt;param-value&gt;</div><div class="line">                classpath:spring/spring-web.xml</div><div class="line">            &lt;/param-value&gt;</div><div class="line">        &lt;/init-param&gt;</div><div class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">        &lt;async-supported&gt;true&lt;/async-supported&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">    &lt;context-param&gt;</div><div class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;</div><div class="line">            classpath:spring/spring-service.xml,</div><div class="line">            classpath:spring/spring-dao.xml,</div><div class="line">            classpath:spring/spring-shiro.xml</div><div class="line">        &lt;/param-value&gt;</div><div class="line">    &lt;/context-param&gt;</div><div class="line"></div><div class="line">    &lt;listener&gt;</div><div class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</div><div class="line">    &lt;/listener&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;!-- 添加 Shiro 相关配置(应该去官网查询相应的配置信息) --&gt;</div><div class="line"></div><div class="line">    &lt;!-- The filter-name matches name of a 'shiroFilter' bean inside applicationContext.xml --&gt;</div><div class="line">    &lt;filter&gt;</div><div class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</div><div class="line">        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</div><div class="line">        &lt;init-param&gt;</div><div class="line">            &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;</div><div class="line">            &lt;param-value&gt;true&lt;/param-value&gt;</div><div class="line">        &lt;/init-param&gt;</div><div class="line">    &lt;/filter&gt;</div><div class="line"></div><div class="line">    &lt;filter-mapping&gt;</div><div class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</div><div class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">    &lt;/filter-mapping&gt;</div><div class="line"></div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>其中主要关心的是web容器将将Shiro的配置文件交给Spring监听器初始化以及配置了shiro的过滤等<br>这里shiro的配置都在spring-shiro.xml中配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">       xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">       xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">       xsi:schemaLocation="</div><div class="line">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</div><div class="line">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</div><div class="line">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;!-- 声明一个密码匹配器 --&gt;</div><div class="line">    &lt;bean id="credentialsMatcher" class="com.hfsf.sys.oauth2.RetryLimitHashedCredentialsMatcher"&gt;</div><div class="line">        &lt;!-- 设置该密码匹配器使用的算法是 md5 --&gt;</div><div class="line">      &lt;property name="hashAlgorithmName" value="md5"/&gt;</div><div class="line">     &lt;property name="hashIterations" value="2" /&gt;</div><div class="line">      &lt;property name="storedCredentialsHexEncoded" value="true" /&gt; </div><div class="line">      &lt;constructor-arg ref="ehCacheManager" /&gt; </div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 声明一个自定义的 Realm --&gt;</div><div class="line">    &lt;bean id="myRealm" class="com.hfsf.sys.oauth2.OAuth2Realm"&gt;</div><div class="line">        &lt;!-- 将上面声明的密码匹配器注入到自定义 Realm 的属性中去 --&gt;</div><div class="line">        &lt;property name="credentialsMatcher" ref="credentialsMatcher"/&gt;</div><div class="line">        &lt;!-- 将自定义的权限匹配器注入到自定义 Realm 中 --&gt;</div><div class="line">        &lt;property name="permissionResolver" ref="permissionResolver"/&gt;</div><div class="line"></div><div class="line">        &lt;!-- 配置缓存相关 --&gt;</div><div class="line">        &lt;!-- 启用缓存 --&gt;</div><div class="line">        &lt;property name="cachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 开启认证缓存--&gt;</div><div class="line">        &lt;property name="authenticationCachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 指定认证缓存的名字(与 ehcache.xml 中声明的相同) --&gt;</div><div class="line">        &lt;property name="authenticationCacheName" value="shiro-authenticationCache"/&gt;</div><div class="line">        &lt;!--开启授权缓存--&gt;</div><div class="line">        &lt;property name="authorizationCachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 指定授权缓存的名字(与 ehcache.xml 中声明的相同) --&gt;</div><div class="line">        &lt;property name="authorizationCacheName" value="shiro-authorizationCache"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 自定义一个权限匹配器 --&gt;</div><div class="line">    &lt;bean id="permissionResolver" class="com.hfsf.sys.oauth2.UrlPermissionResolver"/&gt;</div><div class="line"></div><div class="line">    &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt;</div><div class="line">        &lt;property name="securityManager" ref="securityManager"/&gt;</div><div class="line">        &lt;!-- 如果认证不通过,浏览器通过 Get 方式请求到 /login 上 --&gt;</div><div class="line">        &lt;property name="loginUrl" value="/login.jsp"/&gt;</div><div class="line"></div><div class="line">        &lt;!-- override these for application-specific URLs if you like:</div><div class="line"></div><div class="line">        &lt;property name="successUrl" value="/home.jsp"/&gt;</div><div class="line">        &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; --&gt;</div><div class="line"> </div><div class="line">        &lt;!-- defined will be automatically acquired and available via its beanName in chain        --&gt;</div><div class="line">       </div><div class="line">        &lt;property name="filterChainDefinitions"&gt;</div><div class="line">            &lt;value&gt;</div><div class="line"></div><div class="line">               /authc/admin = roles[admin]</div><div class="line">                /authc/** = authc</div><div class="line">                /** = anon</div><div class="line">            &lt;/value&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 声明一个自定义的过滤器 --&gt;</div><div class="line">    &lt;bean id="resourceCheckFilter" class="com.hfsf.common.xss.ResourceCheckFilter"&gt;</div><div class="line">        &lt;!-- 为上面声明的自定义过滤器注入属性值 --&gt;</div><div class="line">        &lt;property name="errorUrl" value="/unAuthorization"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt;</div><div class="line">        &lt;!-- Single realm app.  If you have multiple realms, use the 'realms' property instead. --&gt;</div><div class="line">        &lt;!-- 设置安全管理器的安全数据源为自定义的 Realm --&gt;</div><div class="line">        &lt;property name="realm" ref="myRealm"/&gt;</div><div class="line">        &lt;!-- By default the servlet container sessions will be used.  Uncomment this line</div><div class="line">             to use shiro's native sessions (see the JavaDoc for more): --&gt;</div><div class="line">        &lt;!-- &lt;property name="sessionMode" value="native"/&gt; --&gt;</div><div class="line">        &lt;property name="cacheManager" ref="ehCacheManager"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    </div><div class="line">  </div><div class="line">   </div><div class="line">    &lt;!-- 配置 shiro 的 ehcache 缓存相关,这个缓存只和 Realm 相关 --&gt;</div><div class="line">    &lt;bean id="ehCacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 配置 Spring 的 EhCacheManagerFactoryBean ,须要 spring-context-support 的支持 --&gt;</div><div class="line">    &lt;bean id="ehCacheManagerFactoryBean" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt;</div><div class="line">        &lt;property name="configLocation" value="classpath:ehcache.xml"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 配置 Spring 的 EhCacheCacheManager,须要 spring-context-support 的支持 --&gt;</div><div class="line">    &lt;bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager"&gt;</div><div class="line">        &lt;property name="cacheManager" ref="ehCacheManagerFactoryBean"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>其中最主要的是filterChainDefinitions，这里声明了权限控制用户访问哪些url，而且访问是有顺序的，即执行了前者后者将不再执行，其中anon为匿名访问，authc为需要身份认证通过才可以访问，这里的内容较多，具体参考官方文档</p>
<p>最后只要通过前台页面提交数据，经过一系列流程，最终就可以完成权限控制了，事实上shiro的内容很多，而且很丰富，只有不断在实践中踩坑，学习，总结才能更好的认识和运用它</p>
]]></content>
      
        <categories>
            
            <category> 安全框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式原则笔记]]></title>
      <url>http://www.myzwl.win/2017/05/11/jd1/</url>
      <content type="html"><![CDATA[<p>在编程语言中除了各种不同的设计模式外，它们也可以被抽出一些共性</p>
<p>开闭原则：一个软件实体应当对开展开放，对修改关闭（玉帝招安美猴王）</p>
<p>面向对象解释： 不予以更改的是抽象层，但是可以扩展的是实现层</p>
<p>对可变性的封装原则： 找到一个系统的可变因素，将之封装起来</p>
<p>继承应当是看做封装的方法，而不应该被认为是从一般对象方法到特殊对象的生成方法</p>
<p>里氏代换原则： 任何基类可以出现的地方，子类一定可以出现</p>
<p>两个类共同行为抽象到一个c类<br>B继承A改为聚合B（白马与黑马，正方形与长方形）</p>
<p>依赖倒转原则： 要依赖于抽象，不要依赖于实现<br>抽象类仅提供一个类型的部分实现，可以同时有抽象方法和具体方法<br>具体类不是用来继承的<br>如果两个具体类存在继承关系，要引入第三个类作为他们的共同的接口<br>抽象类应该拥有尽可能多共同代码<br>抽象类应当拥有尽可能少的数据</p>
<p>接口隔离原则： 应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</p>
<p>角色的合理划分<br>定制服务<br>接口污染</p>
<p>合成/聚合复用原则： 要尽量使用合成/聚合，而不是继承关系达到复用的目的<br>合成是值得聚合，聚合是引用的聚合<br>Is-A 代表一个类是另一个类的一种，Has-A代表一个类是另一个类的角色，而不是另一个类的特殊类（人与角色）</p>
<p>迪米特法则： 一个软件实体应当尽可能少的与其他实体发生相互作用</p>
<p>java接口： 一些方法特征的集合<br>没有接口会造成硬代码问题直接导致可插入性没有保证<br>java接口用来声明一个新的类型<br>单方法接口（如Runnable）<br>标识接口（serialzable）<br>常量接口</p>
]]></content>
      
        <categories>
            
            <category> java与设计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java与设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[连续子数组的最大和]]></title>
      <url>http://www.myzwl.win/2017/05/08/offer_29/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>对于一个数A，若是A的左边累计数非负，那么加上A能使得值不小于A，认为累计值对整体和是有贡献的。如果前几项累计值负数，则认为有害于总和，total记录当前值。此时 若和大于maxSum 则用maxSum记录下来</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int FindGreatestSumOfSubArray(int[] array) &#123;</div><div class="line">        if(array.length==0)</div><div class="line">            return 0;</div><div class="line">        else&#123;</div><div class="line">            int total=array[0],maxSum=array[0];</div><div class="line">            for(int i=1;i&lt;array.length;i++)&#123;</div><div class="line">                if(total&gt;=0)</div><div class="line">                    total+=array[i];</div><div class="line">                else&#123;</div><div class="line">                    total=array[i];</div><div class="line">                &#125;</div><div class="line">                if(total&gt;maxSum)</div><div class="line">                    maxSum=total;</div><div class="line">            &#125;</div><div class="line">            return maxSum;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一个只出现一次的字符]]></title>
      <url>http://www.myzwl.win/2017/05/07/offer_28/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>可以先将字符串转换为字符数组，然后放在一张哈希表中，而其索引就为字符，然后判断该字符是否为第一次，第一次则键值为1，否则累加，最后遍历该数组，取出第一个键值为1的字符就能确定该位置</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public int FirstNotRepeatingChar(String str) &#123;</div><div class="line">            if(str==null||str.equals(" "))return -1;</div><div class="line">            char[] ch=str.toCharArray();</div><div class="line">            HashMap&lt;Character, Integer&gt; hash=new HashMap&lt;Character, Integer&gt;();</div><div class="line">            for(char c:ch)&#123;</div><div class="line">                if(hash.get(c)!=null)&#123;</div><div class="line">                    hash.put(c, hash.get(c)+1);</div><div class="line">                &#125;else&#123;</div><div class="line">                    hash.put(c, 1);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            for(int i=0;i&lt;ch.length;i++)&#123;</div><div class="line">                if(hash.get(ch[i])==1)</div><div class="line">                    return i;</div><div class="line">            &#125;</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[整数中1出现的次数（从1到n整数中1出现的次数）]]></title>
      <url>http://www.myzwl.win/2017/05/06/offer_27/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>可以通过对每一个整数先对10取余数，这样可以得到最低位的余数，然后在对除以10，这样不断降位，最后即可得到1的总数</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public int NumberOf1Between1AndN_Solution(int n) &#123;</div><div class="line">      if(n==0) return 0;</div><div class="line">       if(n&lt;=9)return 1;</div><div class="line">       int number=0;</div><div class="line">       for(int i=1;i&lt;=n;i++)</div><div class="line">           number+=NumberOf1(i);</div><div class="line">       return number;</div><div class="line">       </div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private int NumberOf1(int n)&#123;</div><div class="line">       int number=0;</div><div class="line">       while(n&gt;0)&#123;</div><div class="line">           if(n%10==1)number++;</div><div class="line">           n=n/10;</div><div class="line">       &#125;</div><div class="line">       return number;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数组中出现次数超过一半的数字]]></title>
      <url>http://www.myzwl.win/2017/05/05/offer_26/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>通过双重循环，先将第一个数开始，通过计数器，如果后面的书和计数的数一样，则计数器加一，直至计数器满足条件退出，然后依次从第二个数开始，因为到中位数时肯定后面不满足，所以可在这里终止</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int MoreThanHalfNum_Solution(int [] array) &#123;</div><div class="line">        int count=0;</div><div class="line">        int temp=0;</div><div class="line">        for(int j=0;j&lt;array.length;j++)&#123;</div><div class="line">        for(int i=j;i&lt;array.length;i++)&#123;</div><div class="line">            temp=array[j];</div><div class="line">            if(temp==array[i])&#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            if(count&gt;array.length/2)&#123;</div><div class="line">                return temp;</div><div class="line">            &#125;</div><div class="line">            if(j&gt;array.length/2)</div><div class="line">                return 0;</div><div class="line">        &#125;</div><div class="line">                count=0;</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最小的K个数]]></title>
      <url>http://www.myzwl.win/2017/05/05/offer_25/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h4 id="思路分析-解法一"><a href="#思路分析-解法一" class="headerlink" title="思路分析(解法一)"></a>思路分析(解法一)</h4><p>可先将整数数组进行排序，利用快排（nlogn）为从小到大，然后取出前k项</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123;</div><div class="line">        ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();</div><div class="line">        if(k&lt;0||k&gt;input.length)</div><div class="line">            return list;      </div><div class="line">        Arrays.sort(input);</div><div class="line">        for(int i=0;i&lt;k;i++)</div><div class="line">            list.add(input[i]);</div><div class="line">        return list;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="思路分析-解法二"><a href="#思路分析-解法二" class="headerlink" title="思路分析(解法二)"></a>思路分析(解法二)</h4><p>这里可进行海量数据的处理，先将前k个数据放在treeset中，这里数据不能重复，并且是按照红黑树从小到大存储，然后依次比较k之后的元素，如果小于最大的，就替换掉，最后遍历完成后就是所求的</p>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123;</div><div class="line">              ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();</div><div class="line">            if(k&lt;=0||k&gt;input.length||input.length==0||input==null)</div><div class="line">                return list; </div><div class="line">            TreeSet&lt;Integer&gt; s=new TreeSet&lt;Integer&gt;();</div><div class="line">            for(int i=0;i&lt;input.length;i++)&#123;</div><div class="line">                if(s.size()&lt;k)&#123;</div><div class="line">                    s.add(input[i]);</div><div class="line">                &#125;else&#123;</div><div class="line">                    if(input[i]&lt;s.last())&#123;</div><div class="line">                        s.remove(s.last());</div><div class="line">                        s.add(input[i]);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;Integer&gt; it=s.iterator();</div><div class="line">            while(it.hasNext())&#123;</div><div class="line">                list.add(it.next());</div><div class="line">            &#125;</div><div class="line">            return list;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[把数组排成最小的数]]></title>
      <url>http://www.myzwl.win/2017/05/04/offer_24/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>将整数数组转化为字符串数组，然后通过对字符串排序，这里利用自定义比较器，通过每两个字符比较自然顺序，将最小的排到前面，然后放到一个可变字符数组中即可</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public String PrintMinNumber(int [] numbers) &#123;</div><div class="line">      if(numbers==null||numbers.length&lt;=0)return "";</div><div class="line">        String[] strs=new String[numbers.length];</div><div class="line">        for(int i=0;i&lt;numbers.length;i++)</div><div class="line">            strs[i]=numbers[i]+"";</div><div class="line">        StringBuilder sb=new StringBuilder();</div><div class="line">        Arrays.sort(strs,new Comparator&lt;String&gt;()&#123;</div><div class="line">            public int compare(String o1,String o2)&#123;</div><div class="line">                return (o1+o2).compareTo(o2+o1);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        for(int i=0;i&lt;strs.length;i++)</div><div class="line">            sb.append(strs[i]);</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[输出字符串的全排列]]></title>
      <url>http://www.myzwl.win/2017/05/03/offer_23/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如：输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab,cba</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>回想字符串的模式匹配思想，我们可以将该字符串分成两部分，一部分是第一个字符串，第二部分是剩余的字符，然后保持第一个字符不变，从剩余字符遍历，同时交换遍历的位置，很显然这是一个递归的过程，最后在回溯，交换第一个字符和剩余字符的位置，依次类推</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class StringSort &#123;</div><div class="line">	</div><div class="line">	public ArrayList&lt;String&gt; permitution(String str)&#123;</div><div class="line">		ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;();</div><div class="line">		 if(str==null||str.length()&lt;0)</div><div class="line">			 return list;</div><div class="line">		 list=permitution(list,str.toCharArray(),0,str.length());</div><div class="line">		  Collections.sort(list);</div><div class="line">		  return list;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private ArrayList&lt;String&gt; permitution(ArrayList&lt;String&gt; list,char[] str,int begin,int length)</div><div class="line">	&#123;</div><div class="line">		if(begin==length-1)</div><div class="line">		&#123;</div><div class="line">			if(!list.contains(str))</div><div class="line">				list.add(String.valueOf(str));</div><div class="line">		&#125;</div><div class="line">		else&#123;</div><div class="line">			for(int i=begin;i&lt;length;i++)&#123;</div><div class="line">				if(i==begin||str[i]!=str[begin])&#123;</div><div class="line">					swap(str,begin,i);</div><div class="line">					permitution(list,str,begin+1,length);</div><div class="line">					swap(str,begin,i);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return list;</div><div class="line">	&#125;</div><div class="line">	public void swap(char[] str,int begin,int i)&#123;</div><div class="line">		char temp=str[i];</div><div class="line">		str[i]=str[begin];</div><div class="line">		str[begin]=temp;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ArrayList&lt;String&gt; list=new StringSort().permitution("abcc");</div><div class="line">         for(String s:list)&#123;</div><div class="line">        	 System.out.print(s+" ");</div><div class="line">         &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[序列化二叉树]]></title>
      <url>http://www.myzwl.win/2017/05/02/offer_22/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树。其中序列化的意思返回一个带有逗号和特殊符号的字符串，而反序列化就是根据带有特殊符号和逗号的字符串返回一个二叉树</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>对应序列化二叉树来说，因为每次都是将根结点序列化，所以可用前序遍历，即如果结点有孩子，先保存结点值，在继续，当遇到孩子为空时，就用特殊符号输出代替<br>反序列化，同样用递归实现，即先利用一个索引，用于取出每次遍历的字符串中的值，同时把字符串变成一个字符数组，然后比较是否是特殊符号，如果是特殊符号，不做处理，反之，变成根结点的孩子</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">static class TreeNode&#123;</div><div class="line">		int data;</div><div class="line">		TreeNode left;</div><div class="line">		TreeNode right;</div><div class="line">		</div><div class="line">		public TreeNode(int data)&#123;</div><div class="line">			this.data=data;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String serialize(TreeNode root)&#123;</div><div class="line">	StringBuilder sb=new StringBuilder();</div><div class="line">		if(root==null)</div><div class="line">		&#123;</div><div class="line">		  sb.append("$"+",");</div><div class="line">			 return sb.toString();</div><div class="line">		&#125;</div><div class="line">		       sb.append(root.data+",");</div><div class="line">		        sb.append(serialize(root.left));</div><div class="line">		         sb.append(serialize(root.right));</div><div class="line">		        return sb.toString();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	int n=-1;</div><div class="line">	public TreeNode deSerialize(String str)&#123;</div><div class="line">		 n++;</div><div class="line">		if(n&gt;=str.length())</div><div class="line">			return null;</div><div class="line">		  TreeNode node=null;</div><div class="line">		 String[] s=str.split(",");</div><div class="line">		if(!s[n].equals("$"))&#123;</div><div class="line">			node=new TreeNode(Integer.parseInt(s[n]));</div><div class="line">			  node.left=deSerialize(str);</div><div class="line">			  node.right=deSerialize(str);</div><div class="line">		&#125;</div><div class="line">		 return node;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	void preTraver(TreeNode root)&#123;</div><div class="line">		if(root!=null)&#123;</div><div class="line">		System.out.print(root.data+" ");</div><div class="line">		 preTraver(root.left);</div><div class="line">		  preTraver(root.right);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<blockquote>
<p>TreeNode root=new TreeNode(10);<br>        TreeNode a=new TreeNode(6);<br>        TreeNode b=new TreeNode(14);<br>        TreeNode c=new TreeNode(4);<br>        TreeNode d=new TreeNode(8);<br>        TreeNode e=new TreeNode(12);<br>        TreeNode f=new TreeNode(16);<br>         root.left=a;<br>         root.right=b;<br>         a.left=c;<br>         a.right=d;<br>         b.left=e;<br>         b.right=f;<br>         String s=new ConvertTreeToDLinkList().serialize(root);<br>          System.out.println(s);<br>           TreeNode head=new ConvertTreeToDLinkList().deSerialize(s);<br>            System.out.println();<br>            new ConvertTreeToDLinkList().preTraver(head);</p>
</blockquote>
<p>测试结果</p>
<blockquote>
<p>10,6,4,$,$,8,$,$,14,12,$,$,16,$,$,<br>10 6 4 8 14 12 16 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉搜索树与双向链表]]></title>
      <url>http://www.myzwl.win/2017/05/01/offer_21/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一颗二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>由于是二叉排序树，其左子树结点值小于根结点，右子树大于根节点，可以利用中序遍历，即先左孩子递归，找到树中最小的节点，然后作为头结点，然后遍历到该左子树最后一个结点，在其后继追加根结点，同样，遍历右子树，得到右子树中的第一个结点，然后将根结点追加到其前继结点即可</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class ConvertTreeToDLinkList &#123;</div><div class="line"></div><div class="line">	static class TreeNode&#123;</div><div class="line">		int data;</div><div class="line">		TreeNode left;</div><div class="line">		TreeNode right;</div><div class="line">		</div><div class="line">		public TreeNode(int data)&#123;</div><div class="line">			this.data=data;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public TreeNode Convert(TreeNode root)&#123;</div><div class="line">		if(root==null) return null;</div><div class="line">		if(root.left==null&amp;&amp;root.right==null)</div><div class="line">			return root;</div><div class="line">		TreeNode LastOfLeftTreeNode=Convert(root.left);</div><div class="line">		  TreeNode  p=LastOfLeftTreeNode;</div><div class="line">		 //定位到左子树的最后一个结点</div><div class="line">		    while(p!=null&amp;&amp;p.right!=null)&#123;</div><div class="line">		    	p=p.right;</div><div class="line">		    &#125;</div><div class="line">		    //将根结点追加到左子树最后一个结点</div><div class="line">		    if(LastOfLeftTreeNode!=null)&#123;</div><div class="line">		    	p.right=root;</div><div class="line">		    	root.left=p;</div><div class="line">		    &#125;</div><div class="line">		    TreeNode LastOfRightTreeNode=Convert(root.right);</div><div class="line">		      if(LastOfRightTreeNode!=null)&#123;</div><div class="line">		    	  LastOfRightTreeNode.left=root;</div><div class="line">		    	   root.right=LastOfRightTreeNode;</div><div class="line">		      &#125;</div><div class="line">		      </div><div class="line">		      if(LastOfLeftTreeNode!=null)</div><div class="line">		    	  return LastOfLeftTreeNode;</div><div class="line">		return root;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		TreeNode root=new TreeNode(10);</div><div class="line">		TreeNode a=new TreeNode(6);</div><div class="line">		TreeNode b=new TreeNode(14);</div><div class="line">		TreeNode c=new TreeNode(4);</div><div class="line">		TreeNode d=new TreeNode(8);</div><div class="line">		TreeNode e=new TreeNode(12);</div><div class="line">		TreeNode f=new TreeNode(16);</div><div class="line">		</div><div class="line">		 root.left=a;</div><div class="line">		 root.right=b;</div><div class="line">		 a.left=c;</div><div class="line">		 a.right=d;</div><div class="line">		 b.left=e;</div><div class="line">		 b.right=f;</div><div class="line">		 </div><div class="line">		 TreeNode node=new ConvertTreeToDLinkList().Convert(root);</div><div class="line">		 while(node!=null)&#123;</div><div class="line">			 System.out.println(node.data);</div><div class="line">			  node=node.right;</div><div class="line">		 &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[复杂链表的复制]]></title>
      <url>http://www.myzwl.win/2017/04/30/offer_20/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个复杂链表（每个节点中有结点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点）</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>很自然的第一个想法就是采取分治法，首先复制原来链表的结点，把每个复制的结点都链在原结点后面，接下来，设置复制节点的特殊指针，并且如果原来节点指向特殊指针N，则原结点复制后的结点指向N的复制指针，最后，需要抽取出复制的结点，由于原结点与复制节点都是间隔的，所以可间接处理</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">public class CopyCompLicateLinkedList &#123;</div><div class="line"></div><div class="line">	static class RandomListNode&#123;</div><div class="line">		int label;</div><div class="line">		 RandomListNode next=null;</div><div class="line">		  RandomListNode random=null;</div><div class="line">		   </div><div class="line">		  RandomListNode(int label)&#123;</div><div class="line">			  this.label=label;</div><div class="line">		  &#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//复制链表结点</div><div class="line">	private void CloneNodes(RandomListNode pHead)&#123;</div><div class="line">		RandomListNode node=pHead;</div><div class="line">		 while(pHead!=null)</div><div class="line">		 &#123;</div><div class="line">			 RandomListNode cloneNode=new RandomListNode(node.label);</div><div class="line">			   cloneNode.next=node.next;</div><div class="line">			    cloneNode.random=null;</div><div class="line">			     cloneNode.random=null;</div><div class="line">			       node.next=cloneNode;</div><div class="line">			         node=cloneNode.next;</div><div class="line">		 &#125;</div><div class="line">	&#125;</div><div class="line">		//设置每个节点的随机指针</div><div class="line">		private void ConnectSibLingNodes(RandomListNode pHead)&#123;</div><div class="line">			 RandomListNode node=pHead;</div><div class="line">			  while(node!=null)</div><div class="line">			  &#123;</div><div class="line">				  RandomListNode clone=node.next;</div><div class="line">				   if(node.random!=null)</div><div class="line">				   &#123;</div><div class="line">					   clone.random=node.random.next;</div><div class="line">				   &#125;</div><div class="line">				   node=clone.next;</div><div class="line">			  &#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	 //组合复制的结点</div><div class="line">	private RandomListNode ConnectFinalListNodes(RandomListNode pHead)&#123;</div><div class="line">		RandomListNode node=null;</div><div class="line">		RandomListNode cloneHead=null;</div><div class="line">		RandomListNode cloneNode=null;</div><div class="line">		</div><div class="line">		if(node!=null)&#123;</div><div class="line">			cloneHead=node.next;</div><div class="line">			 cloneNode=node.next;</div><div class="line">			  node.next=cloneNode.next;</div><div class="line">			 node=node.next;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		while(node!=null)&#123;</div><div class="line">			cloneNode.next=node.next;</div><div class="line">			 cloneNode=cloneNode.next;</div><div class="line">			  node.next=cloneNode.next;</div><div class="line">			  node=node.next;</div><div class="line">		&#125;</div><div class="line">		return cloneHead;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public RandomListNode Clone(RandomListNode pHead)&#123;</div><div class="line">		this.CloneNodes(pHead);</div><div class="line">		 this.ConnectSibLingNodes(pHead);</div><div class="line">		  return this.ConnectFinalListNodes(pHead);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树中和为某一值的所有路径]]></title>
      <url>http://www.myzwl.win/2017/04/29/offer_19/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为整数的所有路径。路径定义为从树的根结点开始往下一直到叶子结点所经过的结点形成一条路径</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>从问题描述知道，前序遍历符合从根结点遍历，所有可用此方法遍历，同时可以设置两个集合，一个用来保存每次遍历的结点，一个用来记录每次访问过的结点路径，如果等于和的话，就将结点路径加入，如果不等于，则看是否有左右孩子，在递归遍历，最后如果，返回上层，每一次都要删掉保存的结点</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode root,int target)&#123;</div><div class="line">		  int currentSum=0;</div><div class="line">		  ArrayList&lt;Integer&gt; nodes=new ArrayList&lt;Integer&gt;();</div><div class="line">		   ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathNodes=new ArrayList&lt;&gt;();</div><div class="line">		    if(root==null)</div><div class="line">		    	return pathNodes;</div><div class="line">		      return findPath(pathNodes,nodes,root,target,currentSum);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathNodes, ArrayList&lt;Integer&gt; nodes,</div><div class="line">			TreeNode root, int target, int currentSum) &#123;</div><div class="line">	         currentSum+=root.data;</div><div class="line">	          nodes.add(currentSum);</div><div class="line">	         </div><div class="line">	        boolean isLeafNode=(root.left==null)&amp;&amp;(root.right==null);</div><div class="line">	          if(target==currentSum&amp;&amp;isLeafNode)&#123;</div><div class="line">	        	 ArrayList&lt;Integer&gt; path=new ArrayList&lt;Integer&gt;();</div><div class="line">	        	  for(Integer val:nodes)</div><div class="line">	        	  &#123;</div><div class="line">	        		  path.add(val);</div><div class="line">	        	  &#125;</div><div class="line">	        	  pathNodes.add(path);</div><div class="line">	         &#125;</div><div class="line">	         if(root.left!=null)&#123;</div><div class="line">	        	 this.findPath(pathNodes, nodes, root.left, target, currentSum);</div><div class="line">	         &#125;</div><div class="line">	         if(root.right!=null)&#123;</div><div class="line">	        	 this.findPath(pathNodes, nodes, root.right, target, currentSum);</div><div class="line">	         &#125;</div><div class="line">	         Integer value=nodes.remove(pathNodes.size()-1);</div><div class="line">	          currentSum-=value;</div><div class="line">	           return pathNodes;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"> class TreeNode&#123;</div><div class="line">	int data;</div><div class="line">	TreeNode left;</div><div class="line">	TreeNode right;</div><div class="line">	</div><div class="line">	TreeNode(int data)&#123;</div><div class="line">		this.data=data;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<blockquote>
<p>TreeNode a=new TreeNode(10);<br>       TreeNode b=new TreeNode(5);<br>       TreeNode c=new TreeNode(12);<br>       TreeNode d=new TreeNode(4);<br>       TreeNode e=new TreeNode(7);<br>       a.left=b;<br>       a.right=c;<br>       b.left=d;<br>       b.right=e;<br>       ArrayList<arraylist<integer>&gt; pathNodes=new ConstructBinaryTree().findPath(a, 19);<br>        for(ArrayList<integer> list:pathNodes)<br>            for(Integer val:list){<br>                System.out.println(val+” “);<br>            }</integer></arraylist<integer></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树的后续遍历序列]]></title>
      <url>http://www.myzwl.win/2017/04/28/offer_18/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历的结果。如果是，则输出true，否则返回false</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>如{5,7,6,9,11,10,8}，根据二叉排序树的后续遍历特点，首先知道最后一个数是根结点，然后让前面的数与它比较，当到某一个数大于他时，那门这个数的前面就是左子树，右边就是右子树，比如{5,7,6}为左子树，{9,11,10}为右子树，接着判断如果右子树中有存在某个数小于根结点8，也就是返回false，如果不是，在将左子树和右子树依次递归</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class BinaryOfOut &#123;</div><div class="line"></div><div class="line">	public boolean IsBianry(int[] ids)&#123;</div><div class="line">		if(ids.length&lt;0)</div><div class="line">			return false;</div><div class="line">		 int root=ids[ids.length-1];</div><div class="line">		    int i=0;</div><div class="line">		     for(;i&lt;ids.length-1;i++)</div><div class="line">		     &#123;</div><div class="line">		    	 if(ids[i]&gt;root)</div><div class="line">		    		 break;</div><div class="line">		     &#125;</div><div class="line">		     int[] leftTree=new int[i];</div><div class="line">               System.arraycopy(ids, 0, leftTree, 0,i);</div><div class="line">               int j=i;</div><div class="line">               for(;j&lt;ids.length-1;j++)</div><div class="line">               &#123;</div><div class="line">            	   if(root&gt;ids[j])</div><div class="line">            		   return false;</div><div class="line">               &#125;</div><div class="line">               int[] rightTree=new int[ids.length-1-i];</div><div class="line">                System.arraycopy(ids, i, rightTree, 0,ids.length-1-i);</div><div class="line">               boolean leftFlag=true;</div><div class="line">                if(i&gt;0)&#123;</div><div class="line">                	leftFlag=IsBianry(leftTree);</div><div class="line">                &#125;</div><div class="line">                boolean rightFlag=true;</div><div class="line">                if(i&lt;ids.length-1)&#123;</div><div class="line">                	rightFlag=IsBianry(rightTree);</div><div class="line">                &#125;</div><div class="line">                return leftFlag&amp;&amp;rightFlag;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		System.out.println(new BinaryOfOut().IsBianry(new int[]&#123;5,7,6,9,11,10,8&#125;));</div><div class="line">		System.out.println(new BinaryOfOut().IsBianry(new int[]&#123;7,4,6,5&#125;));</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[包含min函数的栈]]></title>
      <url>http://www.myzwl.win/2017/04/27/offer_17/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。调用min、push、pop的时间复杂度都是O(1)</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>可以构造一个辅助栈，该栈里只放每次的最小栈顶元素集合，比如刚开始往栈里放3,4；则辅助栈里存放的是3,3；即每次比较新加的元素和原辅助栈栈顶最小元素的大小</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class StackWithMin &#123;</div><div class="line"></div><div class="line">	Stack&lt;Integer&gt; m_data=new Stack&lt;&gt;();</div><div class="line">	   Stack&lt;Integer&gt; m_min=new Stack&lt;&gt;();</div><div class="line">	   </div><div class="line">	   public void push(Integer value)&#123;</div><div class="line">		   m_data.push(value);</div><div class="line">		   </div><div class="line">		    if(m_min.size()==0||value&lt;m_min.peek())</div><div class="line">		    	m_min.push(value);</div><div class="line">		    else&#123;</div><div class="line">		    	m_min.push(m_min.peek());</div><div class="line">		    &#125;</div><div class="line">	   &#125;</div><div class="line">	   </div><div class="line">	   public void pop()&#123;</div><div class="line">		   if(m_data.size()&gt;0&amp;&amp;m_min.size()&gt;0)</div><div class="line">		   &#123;</div><div class="line">			   m_data.pop();</div><div class="line">			   m_min.pop();</div><div class="line">		   &#125;</div><div class="line">	   &#125;</div><div class="line">	</div><div class="line">	   public Integer min()&#123;</div><div class="line">		   if(m_data.size()&gt;0&amp;&amp;m_min.size()&gt;0)</div><div class="line">			   return m_min.peek();</div><div class="line">		   return null;</div><div class="line">	   &#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		StackWithMin sta=new StackWithMin();</div><div class="line">		 sta.push(3);</div><div class="line">		  sta.push(4);</div><div class="line">		   sta.push(2);</div><div class="line">		    System.out.println(sta.min());</div><div class="line">		      sta.pop();</div><div class="line">		        System.out.println(sta.min());</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>2,3</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从上到下打印二叉树]]></title>
      <url>http://www.myzwl.win/2017/04/26/offer_16/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>不分行的从上到下打印二叉树的每个节点，同一层的结点按照从左到右的顺序打印</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>其实也就是树的层次遍历，而层次遍历的通法就是构造一个队列或者其他容器集合，按照从上到下依次加进结点，每次删除一个结点，就把它的左右孩子结点加入队列，依次类推，这里使用list模拟层序遍历</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">class TreeNode&#123;</div><div class="line">	int data;</div><div class="line">	TreeNode left;</div><div class="line">	TreeNode right;</div><div class="line">	</div><div class="line">	TreeNode(int data)&#123;</div><div class="line">		this.data=data;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public List&lt;Integer&gt; printFromToptoButtom(TreeNode root)&#123;</div><div class="line">		List&lt;TreeNode&gt; node=new ArrayList&lt;TreeNode&gt;();</div><div class="line">		 List&lt;Integer&gt; treeDate=new ArrayList&lt;Integer&gt;();</div><div class="line">		  int index=1;</div><div class="line">		   if(root==null)</div><div class="line">			   return null;</div><div class="line">		      node.add(root);</div><div class="line">		     while(node.size()&gt;0)&#123;</div><div class="line">		    	 TreeNode front=node.remove(0);</div><div class="line">		    	   index--;</div><div class="line">		    	   treeDate.add(front.data);</div><div class="line">		    	   if(front.left!=null)</div><div class="line">		    	   &#123;</div><div class="line">		    		   node.add(index++,front.left);</div><div class="line">		    		  </div><div class="line">		    	   &#125;</div><div class="line">		    	   if(front.right!=null)&#123;</div><div class="line">		    		   node.add(index++,front.right);		  </div><div class="line">		    	   &#125;</div><div class="line">		     &#125;</div><div class="line">		     return treeDate;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">       TreeNode a=new TreeNode(1);</div><div class="line">       TreeNode b=new TreeNode(2);</div><div class="line">       TreeNode c=new TreeNode(3);</div><div class="line">       TreeNode d=new TreeNode(4);</div><div class="line">       TreeNode e=new TreeNode(5);</div><div class="line">       a.left=b;</div><div class="line">       a.right=c;</div><div class="line">       b.left=e;</div><div class="line">       b.right=null;</div><div class="line">       c.right=d;</div><div class="line">       c.left=null;</div><div class="line">       d.left=null;</div><div class="line">       d.right=null;</div><div class="line">       e.left=null;</div><div class="line">       e.right=null;</div><div class="line">      List&lt;Integer&gt; data= new ConstructBinaryTree().printFromToptoButtom(a);</div><div class="line">       for(Integer h:data)&#123;</div><div class="line">    	   System.out.print(h+" ");</div><div class="line">       &#125;</div><div class="line">   </div><div class="line">	&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树的镜像]]></title>
      <url>http://www.myzwl.win/2017/04/25/offer_15/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>请完成一个函数，输入一颗二叉树，该函数输出它的镜像。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>镜像也就是将每个子节点的左右子节点交换，可以先判断根结点是否有左右子树，然后依次交换，然后在利用递归的思想继续交换</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class TreeNode&#123;</div><div class="line">		int data;</div><div class="line">		TreeNode left;</div><div class="line">		TreeNode right;</div><div class="line">		</div><div class="line">		TreeNode(int data)&#123;</div><div class="line">			this.data=data;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">public void Mirror(TreeNode root)&#123;</div><div class="line">		if(root==null||(root.left==null&amp;&amp;root.right==null))</div><div class="line">			return;</div><div class="line">		TreeNode temp=root.left;</div><div class="line">		root.left=root.right;</div><div class="line">		root.right=temp;</div><div class="line">		if(root.left!=null)</div><div class="line">			Mirror(root.left);</div><div class="line">		if(root.right!=null)</div><div class="line">			Mirror(root.right);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[树的子结构]]></title>
      <url>http://www.myzwl.win/2017/04/24/offer_14/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入两颗二叉树A，B，判断B是不是A的子结构</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>要在原二叉树中查找是否具有某棵子树，只需要判断每个节点是否都在二叉树中是否出现即可。所以需要先判断头结点，只有头结点符合要求才继续比较其子树是否符合，然后在从左右子树依次比较，如果都符合，则说明B是A的子树</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class TreeNode&#123;</div><div class="line">		int data;</div><div class="line">		TreeNode left;</div><div class="line">		TreeNode right;</div><div class="line">		</div><div class="line">		TreeNode(int data)&#123;</div><div class="line">			this.data=data;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean HasSubtree(TreeNode root1,TreeNode root2)&#123;</div><div class="line">		boolean hasSubTree=false;</div><div class="line">		if(root1!=null&amp;&amp;root2!=null)</div><div class="line">		&#123;</div><div class="line">			if(root1.data==root2.data)</div><div class="line">			&#123;</div><div class="line">				hasSubTree=nodesValEqual(root1,root2);</div><div class="line">			&#125;</div><div class="line">			if(!hasSubTree)</div><div class="line">			&#123;</div><div class="line">				hasSubTree=HasSubtree(root1.left,root2.left);</div><div class="line">			&#125;</div><div class="line">			if(!hasSubTree)</div><div class="line">			&#123;</div><div class="line">				hasSubTree=HasSubtree(root1.right,root2.right);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return hasSubTree;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private boolean nodesValEqual(TreeNode root1,TreeNode root2)&#123;</div><div class="line">		if(root2==null)</div><div class="line">			return true;</div><div class="line">		if(root1==null)</div><div class="line">			return false;</div><div class="line">		if(root1.data!=root2.data)</div><div class="line">			return false;</div><div class="line">		return nodesValEqual(root1.left,root2.left)&amp;&amp;nodesValEqual(root1.right,root2.right);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[合并两个排序的链表]]></title>
      <url>http://www.myzwl.win/2017/04/23/offer_13/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入两个单调递增的链表，输出两个链表合成后的链表，并且合并后的链表仍然是单调递增的</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>由于两个链表都是排序的，所以可先比较两个链表的头结点，从而确定合并后的第一个结点，之后在依次比较第二个结点，作为新的第二个结点，依次类推</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public LinkNodes sortLink(LinkNodes l1,LinkNodes l2)&#123;</div><div class="line">		if(l1==null)return l2;</div><div class="line">		if(l2==null)return l1;</div><div class="line">		</div><div class="line">		LinkNodes phead=null;</div><div class="line">		if(l1.data&lt;l2.data)</div><div class="line">		&#123;</div><div class="line">			phead=l1;</div><div class="line">			phead.next=sortLink(l1.next,l2);</div><div class="line">		&#125;else&#123;</div><div class="line">			phead=l2;</div><div class="line">			phead.next=sortLink(l1,l2.next);</div><div class="line">		&#125;</div><div class="line">		return phead;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[反转链表]]></title>
      <url>http://www.myzwl.win/2017/04/22/offer_12/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个链表，反转链表后，输出链表的头结点</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>当我们遍历一次后，也就是遍历到尾节点时，其实也就完成了反转，在此过程中需要三个指针，一个指向当前遍历的前驱，由于反转，另一个是当前指针，还有一个是当前遍历的下一个指针，通过不断改变他们之间的关系来更改前后继关系</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public LinkNodes reserve(LinkNodes head)&#123;</div><div class="line">		LinkNodes reserveHead=null;</div><div class="line">		LinkNodes curNode=head;</div><div class="line">		LinkNodes pre=null;</div><div class="line">		while(curNode!=null)</div><div class="line">		&#123;</div><div class="line">			LinkNodes nextNode=curNode.next;</div><div class="line">			if(nextNode==null)</div><div class="line">				reserveHead=curNode;</div><div class="line">			curNode.next=pre;</div><div class="line">			pre=curNode;</div><div class="line">			curNode=nextNode;</div><div class="line">		&#125;</div><div class="line">		return reserveHead;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<blockquote>
<p>public static void main(String[] args) {<br>        RefindNum rf=new RefindNum();<br>        LinkNodes node1=new LinkNodes(1);<br>        LinkNodes node2=new LinkNodes(2);<br>        LinkNodes node3=new LinkNodes(3);<br>        LinkNodes node4=new LinkNodes(4);<br>        node1.next=node2;<br>        node2.next=node3;<br>        node3.next=node4;<br>        node4.next=null;<br>        LinkNodes phead=rf.reserve(node1);<br>        while(phead!=null){<br>            System.out.println(phead.data);<br>            phead=phead.next;<br>        }</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[链表中倒数第K个节点]]></title>
      <url>http://www.myzwl.win/2017/04/22/offer_11/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个链表，输出该链表中倒数第K个节点。同时，从1开始计数，即链表的尾节点是倒数第一个节点。例如：一个链表有6个节点，从头节点开始，他们的值依次是1、2、3、4、5、6.这个链表的倒数第三个节点是值为4的结点</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先想到的思路是，首先遍历该链表一次，就得到了该链表的长度，然后在遍历该链表一次，也就是倒数第k个节点就是顺数第总长度-k+1个位置的结点，但是从效率上说，遍历两次的时间复杂度为O（n*2);</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class RefindNum &#123;</div><div class="line"></div><div class="line"> </div><div class="line">	</div><div class="line">	public LinkNodes getReserve(LinkNodes head,int k)&#123;</div><div class="line">		int count=1;</div><div class="line">		LinkNodes node=head;</div><div class="line">		if(node==null)</div><div class="line">			return null;</div><div class="line">		while(node.next!=null)&#123;</div><div class="line">			count++;</div><div class="line">			node=node.next;</div><div class="line">		&#125;</div><div class="line">		int i=1;</div><div class="line">		node=head;</div><div class="line">		while(k&lt;count&amp;&amp;i!=count-k+1)&#123;</div><div class="line">			i++;</div><div class="line">			node=node.next;</div><div class="line">		&#125;</div><div class="line">		if(k&lt;=count)</div><div class="line">			return node;</div><div class="line">		return null;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		RefindNum rf=new RefindNum();</div><div class="line">		LinkNodes node1=new LinkNodes(1);</div><div class="line">		LinkNodes node2=new LinkNodes(2);</div><div class="line">		LinkNodes node3=new LinkNodes(3);</div><div class="line">		LinkNodes node4=new LinkNodes(4);</div><div class="line">		node1.next=node2;</div><div class="line">		node2.next=node3;</div><div class="line">		node3.next=node4;</div><div class="line">		node4.next=null;</div><div class="line">		System.out.println(rf.getReserve(node1, 2).data);</div><div class="line">		</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class LinkNodes&#123;</div><div class="line">	int data;</div><div class="line">	LinkNodes next;</div><div class="line">	public LinkNodes(int data)&#123;</div><div class="line">		this.data=data;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="两个指针解法"><a href="#两个指针解法" class="headerlink" title="两个指针解法"></a>两个指针解法</h4><p>这种解法的思路，就是构造两个指针pre和behind，第一次使pre遍历到k-1位置，也就是第k个节点，此时在让behind指针从头开始遍历，由于pre和behind始终都相差k个位置，也就是说pre遍历到尾节点时，behind正好是倒数第k个节点，而此时的效率是很高的</p>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public LinkNodes get(LinkNodes head,int k)&#123;</div><div class="line">		LinkNodes pre=head;</div><div class="line">		LinkNodes behind=null;</div><div class="line">		if(pre==null||k&lt;0)</div><div class="line">			return null;</div><div class="line">		for(int i=0;i&lt;k-1;i++)</div><div class="line">		&#123;</div><div class="line">			if(pre.next!=null)</div><div class="line">				pre=pre.next;</div><div class="line">			else</div><div class="line">				return null;</div><div class="line">		&#125;</div><div class="line">		behind=head;</div><div class="line">		while(pre.next!=null)</div><div class="line">		&#123;</div><div class="line">			pre=pre.next;</div><div class="line">			behind=behind.next;</div><div class="line">		&#125;</div><div class="line">		return behind;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[调整数组顺序是奇数位于偶数前面]]></title>
      <url>http://www.myzwl.win/2017/04/21/offer_10/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数和偶数与偶数之间的基本相对位置不变</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先想到的思路是从头开始遍历这个数组，如果遇到偶数就把这个数之后的所有数往前移动一位，这样数组就会流出一个空位，移动完毕后就把该偶数放到该空位，但是由于一次是遍历，一次是移位，所以导致时间复杂度为O（n*2)</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public int[] reOrderArray2(int[] array)&#123;</div><div class="line">		if(array==null||array.length==0)</div><div class="line">			return null;</div><div class="line">		int i,j;</div><div class="line">		for(i=1;i&lt;array.length;i++)&#123;</div><div class="line">			int temp=array[i];</div><div class="line">		if(!isEven(array[i]))&#123;</div><div class="line">			for(j=i-1;j&gt;=0&amp;&amp;isEven(array[j]);j--)</div><div class="line">			&#123;</div><div class="line">				array[j+1]=array[j];</div><div class="line">			&#125;</div><div class="line">			array[j+1]=temp;</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		return array;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEven(int i)&#123;</div><div class="line">		if((i&amp;0x1)==0)</div><div class="line">			return true;</div><div class="line">		return false;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<blockquote>
<p>Fib fib=new Fib();<br>        int[] arr=fib.reOrderArray2(new int[]{3,5,6,7,8,9});<br>        for(int i=0;i&lt;arr.length;i++)<br>        System.out.println(arr[i]);</p>
</blockquote>
<h4 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h4><p>如果说不改变相对位置的话，就可以用两个指针操作，第一个指针指向偶数，第二个指针指向奇数，并且让第一个指针在第二个指针前面，就交换两个元素。当第一个指针在第二个指针后面就说明所有的奇数都移动到所有偶数前面了<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void reOrderArr(int[] array)&#123;</div><div class="line">		if(array==null||array.length==0)</div><div class="line">			return;</div><div class="line">		int evenIndex=0;</div><div class="line">		int oddIndex=array.length-1;</div><div class="line">		while(evenIndex&lt;oddIndex)</div><div class="line">		&#123;</div><div class="line">			while(evenIndex&lt;oddIndex&amp;&amp;(array[evenIndex]&amp;0x1)!=0)</div><div class="line">				evenIndex++;</div><div class="line">			while(evenIndex&lt;oddIndex&amp;&amp;(array[oddIndex]&amp;0x1)==0)</div><div class="line">				oddIndex--;</div><div class="line">			if(evenIndex&lt;oddIndex)</div><div class="line">				swap(array,evenIndex,oddIndex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数值的整数次方]]></title>
      <url>http://www.myzwl.win/2017/04/21/offer_9/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>这里主要的问题就是幂的符号问题，共有三种情况，即正数，0，负数，当幂为0的时候直接返回1，当为正数的时候直接按正常的计算来，当为负数的时候要先把其转化为正数，然后返回结果的倒数就可以了</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public double powOfdouble(double base,int exp)&#123;</div><div class="line">		double result=base;</div><div class="line">		if(exp==0)</div><div class="line">			return 1;</div><div class="line">		if(exp&gt;0)</div><div class="line">		&#123;</div><div class="line">			for(int i=1;i&lt;exp;i++)&#123;</div><div class="line">				result*=base;</div><div class="line">			&#125;</div><div class="line">			return result;</div><div class="line">		&#125;</div><div class="line">		else&#123;</div><div class="line">			int absexp=-exp;</div><div class="line">			for(int i=1;i&lt;absexp;i++)</div><div class="line">			&#123;</div><div class="line">				result*=base;</div><div class="line">			&#125;</div><div class="line">			System.out.println(result);</div><div class="line">			return 1/result;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试</p>
<blockquote>
<p>Fib fib=new Fib();<br>double a=fib.powOfdouble(0.5, -2);<br>System.out.println(a);</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二进制中1的个数]]></title>
      <url>http://www.myzwl.win/2017/04/20/offer_8/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。比如输入9，,9的二进制表示是1001,1的个数是2，所以输出2</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>如果一个数与该数减一的结果进行与运算，会把该数低位第一个1变成0，而高位不变，比如1100（12），减一后就变成1011（11），也就是说建议后，也就右边位1变0,0变1，与位操作后就是少了一个1，如1100&amp;1011，变成1000，一次类推，最终得到结果</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public int Number(int n)&#123;</div><div class="line">		int sum=0;</div><div class="line">		while(n!=0)</div><div class="line">		&#123;</div><div class="line">			sum++;</div><div class="line">			n=n&amp;(n-1);</div><div class="line">		&#125;</div><div class="line">		return sum;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用两个栈实现队列]]></title>
      <url>http://www.myzwl.win/2017/04/19/offer_5/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>根据栈先进后出的特点，一个栈push元素后，另一个栈可push进它出栈的元素，这样存储的不就是原先顺序的元素吗，也就是原先栈顶元素现在在栈底</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class CQueue&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	private Stack&lt;T&gt; stack1=new Stack&lt;&gt;();</div><div class="line">	 private Stack&lt;T&gt; stack2=new Stack&lt;&gt;();</div><div class="line">	 </div><div class="line">	 public void appendTail(T t)&#123;</div><div class="line">		 stack1.push(t);</div><div class="line">	 &#125;</div><div class="line">	 </div><div class="line">	 public T deleteHead() throws Exception&#123;</div><div class="line">		 if(stack2.isEmpty())</div><div class="line">		 &#123;</div><div class="line">			 while(!stack1.isEmpty())&#123;</div><div class="line">				 stack2.push(stack1.pop());</div><div class="line">			 &#125;</div><div class="line">		 &#125;</div><div class="line">		 if(stack2.isEmpty())&#123;</div><div class="line">			 throw new Exception("队列为空！不能删除");</div><div class="line">		 &#125;</div><div class="line">		 return stack2.pop();</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	public static void main(String[] args) throws Exception &#123;</div><div class="line">		CQueue queue=new CQueue&lt;&gt;();</div><div class="line">		queue.appendTail(1);</div><div class="line">		queue.appendTail(2);</div><div class="line">		queue.appendTail(3);</div><div class="line">		System.out.println(queue.deleteHead());</div><div class="line">		System.out.println(queue.deleteHead());</div><div class="line">		System.out.println(queue.deleteHead());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="两个队列实现一个栈"><a href="#两个队列实现一个栈" class="headerlink" title="两个队列实现一个栈"></a>两个队列实现一个栈</h4><p>有了上面的经验，我们发现，可以用同样的思想去实现两个队列实现一个栈，当然还是有点不一样的<br>它的核心思想就是将一个队列的元素除队尾元素都放到另一个队列中，轮流操作就是栈了</p>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">private Queue&lt;T&gt; queue1=new ArrayBlockingQueue(10);</div><div class="line">   private Queue&lt;T&gt; queue2=new ArrayBlockingQueue(10);</div><div class="line">    private boolean flag=false;</div><div class="line"> </div><div class="line">   public void push(T t)&#123;</div><div class="line">	   if(queue2.isEmpty())</div><div class="line">	     queue1.add(t);</div><div class="line">	   else if(queue1.isEmpty())</div><div class="line">		   queue2.add(t);</div><div class="line">	   else&#123;</div><div class="line">		   return;</div><div class="line">	   &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public Queue pop()throws Exception&#123;</div><div class="line">	   int len;</div><div class="line">	   int count=1;</div><div class="line">	   if(queue2.isEmpty())</div><div class="line">	   &#123;</div><div class="line">		   len=queue1.size();</div><div class="line">		   while(!flag&amp;&amp;count&lt;len)&#123;</div><div class="line">			   queue2.add(queue1.poll());</div><div class="line">			   count++;</div><div class="line">		   &#125;</div><div class="line">		   flag=true;</div><div class="line">		   queue1.poll();</div><div class="line">		   count=1;</div><div class="line">		   return  queue2;</div><div class="line">	   &#125;</div><div class="line">	   else if(queue1.isEmpty())&#123;</div><div class="line">		   len=queue2.size();</div><div class="line">		   while(flag&amp;&amp;count&lt;len)&#123;</div><div class="line">			   queue1.add(queue2.poll());</div><div class="line">			   count++;</div><div class="line">		   &#125;</div><div class="line">		   flag=false;</div><div class="line">		   queue2.poll();</div><div class="line">		   count++;</div><div class="line">		   return  queue1;</div><div class="line">	   &#125;</div><div class="line">	   else if(queue1.isEmpty()&amp;&amp;queue2.isEmpty())&#123;</div><div class="line">		   System.out.println("error");</div><div class="line">		   return null;</div><div class="line">	   &#125;</div><div class="line">	   else&#123;</div><div class="line">		   </div><div class="line">	   &#125;</div><div class="line">	return null;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<blockquote>
<p>queue.push(“a”);<br>        queue.push(“b”);<br>        queue.push(“c”);<br>        System.out.println(queue.pop().toString());<br>        System.out.println(queue.pop().toString());<br>        queue.push(“d”);<br>        System.out.println(queue.pop().toString());</p>
</blockquote>
<p>结果：</p>
<blockquote>
<p>[a, b]<br>[a]<br>[a]</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[斐波那契数列]]></title>
      <url>http://www.myzwl.win/2017/04/19/offer_7/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>写一个函数，输入n，求斐波那契数列的第n项</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>这个数列是一个迭代的数列，所以用递归很容易求出来，但是会存在效率问题</p>
<p>码上有戏<br><strong>低效率解法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public long method1(int n)&#123;</div><div class="line">		if(n==0)</div><div class="line">			return 0;</div><div class="line">		else if(n==1)</div><div class="line">			return 1;</div><div class="line">		else</div><div class="line">			return method1(n-1)+method1(n-2);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>此时利用递归会发现，最终会有很多重复的计算</p>
<p><strong>非递归解法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public long method2(int n)&#123;</div><div class="line">		long result=0;</div><div class="line">		long preOne=0;</div><div class="line">		long preTwo=1;</div><div class="line">		if(n==0)&#123;</div><div class="line">			return preOne;</div><div class="line">		&#125;</div><div class="line">		if(n==1)&#123;</div><div class="line">			return preTwo;</div><div class="line">		&#125;</div><div class="line">		for(int i=2;i&lt;=n;i++)</div><div class="line">		&#123;</div><div class="line">			preOne=preTwo;</div><div class="line">			preTwo=result;</div><div class="line">			result=preOne+preTwo;</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>该算法核心就是把每次数列的结果缓存，这样就不用重复计算了</p>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[旋转数组的最小值]]></title>
      <url>http://www.myzwl.win/2017/04/19/offer_6/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减序列的一个旋转，输出旋转数组的一个最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>这里有一个条件，就是观察发现，它是将原本有序的数组划分成两块，左边有序快依次递增并且总是大于右边有序块，所以很自然想到二分查找法，就是利用low，mid，high引用依次比较，mid值到底比左边还是右边大，也就是说不断缩小最小值的查找范围，然而还有一种情况就是low、mid。high三者值相等得情况，例如{1,0,1,1,1}，很显然mid不好确定范围，这属于特殊情况，可以采用顺序查找，找到数组中较小者，然后返回</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class Findmin &#123;</div><div class="line"></div><div class="line">	public int min(int[] arr)&#123;</div><div class="line">		if(arr==null||arr.length-1&lt;0)</div><div class="line">			return 0;</div><div class="line">		 int low=0;</div><div class="line">		  int high=arr.length-1;</div><div class="line">		    int mid=low;</div><div class="line">		      while(arr[low]&gt;=arr[high])&#123;</div><div class="line">		    	  mid=(low+high)/2;</div><div class="line">		    	   if(high-low==1)&#123;</div><div class="line">		    		   return arr[high];</div><div class="line">		    	   &#125;</div><div class="line">		    	   if(arr[low]==arr[mid]&amp;&amp;arr[mid]==arr[high])</div><div class="line">		    	   &#123;</div><div class="line">		    		   return search(arr,low,high);</div><div class="line">		    	   &#125;</div><div class="line">		    	   if(arr[mid]&gt;arr[low])</div><div class="line">		    		   low=mid;</div><div class="line">		    	   else if(arr[mid]&lt;arr[high])</div><div class="line">		    		   high=mid; 		   </div><div class="line">		      &#125;</div><div class="line">		      return arr[mid];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	private int search(int[] arr, int low, int high) &#123;</div><div class="line">		int result=arr[high];</div><div class="line">		for(int i=low+1;i&lt;=high;i++)</div><div class="line">			if(result&gt;arr[i])</div><div class="line">			&#123;</div><div class="line">				result=arr[i];</div><div class="line">			&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int minNumber=new Findmin().min(new int[]&#123;1,0,1,1,1&#125;);</div><div class="line">		System.out.println(minNumber);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[重建二叉树]]></title>
      <url>http://www.myzwl.win/2017/04/18/offer_4/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果都不含重复的数字。例如输入前序遍历{1,2,4,7,3,5,6,8}和中序遍历{4,7,2,1,5,3,8,6}，则重建二叉树并返回</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>由前序遍历很容易知道根结点是1，然后根据中序遍历知道左子树包含节点是4、7、2,右子树结点是5、3、8、6;又由前序遍历为2,4,7知道2是这三个节点的根结点，又中序为4,7,2知道4是2的左孩子，7是4的右孩子，右子树同理可判断</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">public class ConstructBinaryTree &#123;</div><div class="line"></div><div class="line">	public class TreeNode&#123;</div><div class="line">		int data;</div><div class="line">		TreeNode left;</div><div class="line">		TreeNode right;</div><div class="line">		</div><div class="line">		TreeNode(int data)&#123;</div><div class="line">			this.data=data;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public TreeNode reConstructBinaryTree(int[] pre,int[] in)&#123;</div><div class="line">		TreeNode root=constructCore(pre,0,pre.length-1,in,0,in.length-1);</div><div class="line">		return root;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private TreeNode constructCore(int[] pre,int startPreOrder,int endPreOrder,int[] in,int startInOrder,int endInOrder)</div><div class="line">	&#123;</div><div class="line">		//根据前序遍历找到根结点的值</div><div class="line">		int rootValue=pre[startPreOrder];</div><div class="line">		TreeNode rootNode=new TreeNode(rootValue);</div><div class="line">		rootNode.left=null;</div><div class="line">		rootNode.right=null;</div><div class="line">		</div><div class="line">		//只有一个结点，那么该节点就是根结点，直接返回</div><div class="line">		if(startPreOrder==endPreOrder)&#123;</div><div class="line">			if(startInOrder==endInOrder&amp;&amp;pre[startPreOrder]==in[startInOrder])&#123;</div><div class="line">				return rootNode;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		//根据中序遍历的结果找到根结点</div><div class="line">		int rootOfInOrder=startInOrder;</div><div class="line">		while(rootOfInOrder&lt;=endInOrder&amp;&amp;in[rootOfInOrder]!=rootValue)&#123;</div><div class="line">			rootOfInOrder++;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//异常处理</div><div class="line">		if(rootOfInOrder==endInOrder&amp;&amp;in[rootOfInOrder]!=rootValue)&#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//计算左子树的长度</div><div class="line">		int leftSubTreeLen=rootOfInOrder-startInOrder;</div><div class="line">		//根据左子树的长度计算前序的遍历结果中左子树的最后一个结点的下标</div><div class="line">		int leftIndexOfPreOrderEnd=startPreOrder+leftSubTreeLen;</div><div class="line">		//重建左子树</div><div class="line">		if(leftSubTreeLen&gt;0)&#123;</div><div class="line">			rootNode.left=constructCore(pre,startPreOrder+1,leftIndexOfPreOrderEnd,in,startInOrder,rootOfInOrder-1);	</div><div class="line">		&#125;</div><div class="line">		//重接右子树</div><div class="line">		if(leftSubTreeLen&lt;endPreOrder-startPreOrder)&#123;</div><div class="line">			rootNode.right=constructCore(pre,leftIndexOfPreOrderEnd+1,endPreOrder,in,rootOfInOrder+1,endInOrder);		</div><div class="line">		&#125;</div><div class="line">		return rootNode;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void outTraver(TreeNode root)&#123;</div><div class="line">		if(root!=null)&#123;</div><div class="line">		outTraver(root.left);</div><div class="line">		outTraver(root.right);</div><div class="line">		System.out.print(root.data+" ");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] pre=&#123;1,2,4,7,3,5,6,8&#125;;</div><div class="line">		int[] in=&#123;4,7,2,1,5,3,8,6&#125;;</div><div class="line">		TreeNode root=new ConstructBinaryTree().reConstructBinaryTree(pre, in);</div><div class="line">		new ConstructBinaryTree().outTraver(root);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后拿到根结点然后输出后续遍历如下</p>
<blockquote>
<p>7 4 2 5 8 6 3 1</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二维数组中的查找]]></title>
      <url>http://www.myzwl.win/2017/04/17/offer_3/</url>
      <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排列。请完成一个函数，输入这样的一个一维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>查找的过程从二维数组的角上选取一个值判断，如右上角那个数，显然它是当前所在列的最小值，当前所在行的最大值，如果比它相等，那是最好的情况，如果比它大，那就说从的所在列下方寻找，可以排除那一行，依次类推，如果说比它小，那就排除那一列，从它的左边以此类推，直到找到或者不存在完成</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Find &#123;</div><div class="line"></div><div class="line">	public static boolean find(int arr[][],int target)&#123;</div><div class="line">		boolean found=false;</div><div class="line">		int rows=arr.length;</div><div class="line">		int columns=arr[0].length;</div><div class="line">		int row=0;</div><div class="line">		int column=columns-1;</div><div class="line">		while(row&lt;rows&amp;&amp;column&gt;=0)&#123;</div><div class="line">			if(arr[row][column]==target)&#123;</div><div class="line">				found=true;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			else if(arr[row][column]&gt;target)&#123;</div><div class="line">				column--;</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">				row++;</div><div class="line">		&#125;</div><div class="line">		return found;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[][] arr=new int[4][4];</div><div class="line">		arr[0]=new int[]&#123;1,2,8,9&#125;;</div><div class="line">		arr[1]=new int[]&#123;2,4,9,12&#125;;</div><div class="line">		arr[2]=new int[]&#123;4,7,10,13&#125;;</div><div class="line">		arr[3]=new int[]&#123;6,8,11,15&#125;;</div><div class="line">		boolean flag=Find.find(arr, 16);</div><div class="line">		System.out.println(flag);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字符串空格替换]]></title>
      <url>http://www.myzwl.win/2017/04/16/offer_2/</url>
      <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，将一个字符串中的空格替换成”20%”,例如，当字符串为we are happy，则经过替换之后的字符串为we%20are%20happy；</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>这个首先让人想到的是java中不是有replaceAll（）方法（源码模拟在之前的数据结构中已总结），如果直接调用那就没意思了，或者使用stringBuffer的append（）方法，遇到空格在后面插入，这样做也可以，但是是不是也是体现不出我们的思考过程。另一种做法就是<br><img src="/images/imgs4/36.gif" alt="Alt text"><br>大概意思就是构造一个缓存数组temp，首先计算出原字符数组中的空格数，而temp的大小就是原数组长度加上空格数*2，同时先将原数组拷贝到新数组，多出的空间刚开始是空值，然后有两个索引，分别指向原数组末尾和新数组末尾，最后通过原数组末尾一个一个字符的从后向前比较，如果是空值的话，替换，否则将原数组的内容在新数组中向后移动至末尾，依次，知道原数组索引小于0为止，代码如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class Buffer &#123;</div><div class="line"></div><div class="line">	public String replaceSpace(StringBuffer s)&#123;</div><div class="line">		String str=s.toString();</div><div class="line">		 int blankCount=this.getBlankCount(str);</div><div class="line">		  int originLen=str.toCharArray().length;</div><div class="line">		    int newStrlen=blankCount*2+originLen;</div><div class="line">		     char[] newStr=new char[newStrlen];</div><div class="line">		      System.arraycopy(str.toCharArray(), 0, newStr, 0, originLen);</div><div class="line">		      int strIndex=originLen-1;</div><div class="line">		       int newstrIndex=newStrlen-1;</div><div class="line">		        while(strIndex&gt;0&amp;&amp;strIndex!=newstrIndex)</div><div class="line">		        &#123;</div><div class="line">		        	if(str.charAt(strIndex)==' ')&#123;</div><div class="line">		        		newStr[newstrIndex--]='0';</div><div class="line">		        		newStr[newstrIndex--]='2';</div><div class="line">		        		newStr[newstrIndex--]='%';</div><div class="line">		        	&#125;</div><div class="line">		        	else&#123;</div><div class="line">		        		newStr[newstrIndex--]=newStr[strIndex];</div><div class="line">		        	&#125;</div><div class="line">		        	strIndex--;</div><div class="line">		        &#125;</div><div class="line">		        return new String(newStr);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line"></div><div class="line">	public int getBlankCount(String s)&#123;</div><div class="line">		int count=0;</div><div class="line">		 for(int i=0;i&lt;s.length();i++)&#123;</div><div class="line">			 if(s.charAt(i)==' ')</div><div class="line">				 count++;</div><div class="line">		 &#125;</div><div class="line">		 return count;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：</p>
<blockquote>
<p>String s=”we are happy”;<br>StringBuffer sb=new StringBuffer(s);<br>String str=new Buffer().replaceSpace(sb);<br>System.out.println(str);</p>
</blockquote>
<p>可以发现整个过程都是一层循环，所以它的时间复杂度为O(n);</p>
<h4 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h4><p><strong>replaceAll方法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str=s.replaceAll("\\s", "20%");</div><div class="line">	System.out.println(str);</div></pre></td></tr></table></figure></p>
<p>其中此方法需要传正则表达式，而\s表示空格，当然结果也能完成目的，但是考虑到String是不变字符串，也就是说它不能在原来字符数组上进行修改，需要另开内存空间，所以每次插入，都要向后移动n此，同时也要查找比较n词，显然时间复杂度就是O（n*2），来看看之前模拟的replaceAll方法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public MyString replaceAll(MyString pattern,MyString replacement)&#123;</div><div class="line">		MyString temp=new MyString(this);</div><div class="line">		 int i=this.indexOf(pattern, 0);</div><div class="line">		  while(1!=-1)</div><div class="line">		  &#123;</div><div class="line">			  temp=temp.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length()));</div><div class="line">			  i=temp.indexOf(pattern, i+replacement.length());//从下一个字符开始继续寻找匹配</div><div class="line">		  &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>显然此方法效率不高</p>
<p><strong>stringBuffer方法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public String replace(String input)&#123;</div><div class="line">		if(input==null)&#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">		StringBuffer str=new StringBuffer();</div><div class="line">		 for(int i=0;i&lt;input.length();i++)&#123;</div><div class="line">			 if(input.charAt(i)==' ')</div><div class="line">			 &#123;</div><div class="line">				 str.append("%");</div><div class="line">				 str.append("2");</div><div class="line">				 str.append("0");</div><div class="line">			 &#125;</div><div class="line">			 else&#123;</div><div class="line">				 str.append(String.valueOf(input.charAt(i)));</div><div class="line">			 &#125;</div><div class="line">		 &#125;</div><div class="line">		</div><div class="line">		 return new String(str);</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>主要利用stringBuffer的可变性，同样只有一层循环，时间复杂度为O（n）；</p>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从尾到头打印链表]]></title>
      <url>http://www.myzwl.win/2017/04/15/offer_1/</url>
      <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个链表，从尾部到头部打印输出链表的值。</p>
<h4 id="栈方式"><a href="#栈方式" class="headerlink" title="栈方式"></a>栈方式</h4><p>很自然，想到的第一个方法就是后进先出，那就是直接可用栈来模拟<br>当然，因为题目要求使用链表，所以首先可确定结点结构，如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Node&lt;T extends Object&gt; &#123;</div><div class="line"></div><div class="line">	T data;</div><div class="line">	 public Node next;</div><div class="line">	</div><div class="line">	public Node(Node next)&#123;</div><div class="line">		this.next=next;</div><div class="line">	&#125;</div><div class="line">	public Node(T data)&#123;</div><div class="line">		this.data=data;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public T getData()&#123;</div><div class="line">		return this.data;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是栈方式<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class LinkNode&#123;</div><div class="line">	 </div><div class="line">	 void Resver(Stack&lt;Node&gt; stack)&#123;</div><div class="line">		 while(!stack.isEmpty())&#123;</div><div class="line">		 System.out.println((stack.pop()).data);</div><div class="line">		 &#125;</div><div class="line">	 &#125;</div><div class="line"></div><div class="line">	 public static void main(String args[])&#123;</div><div class="line">		Node A=new Node(1);</div><div class="line">		Node B=new Node(2);</div><div class="line">		Node C=new Node(3);</div><div class="line">	    A.next=B;</div><div class="line">	    B.next=C;</div><div class="line">	    C.next=null;</div><div class="line">	    LinkNode link=new LinkNode();</div><div class="line">	    Stack stack=new Stack&lt;&gt;();</div><div class="line">	    stack.push(A);</div><div class="line">	    stack.push(B);</div><div class="line">	    stack.push(C);</div><div class="line">	    link.Resver(stack);</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>会发现用利用栈的特点可以很快的非递归实现此功能</p>
<h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><p>另一种想法就是利用递归树的特点，也就是说如果你有后继结点，就递归寻找后继结点，直到找到最后一个后继结点，然后打印结点值，就是想象成一棵斜数，然后后续遍历<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Node TraverserHeadToTail(Node node)&#123;</div><div class="line">	 if(node!=null)&#123;</div><div class="line">		if(node.next!=null)&#123;</div><div class="line">			 TraverserHeadToTail(node.next);</div><div class="line">		 &#125;</div><div class="line">		System.out.println(node.data);</div><div class="line">	 return node;</div><div class="line">	 &#125;</div><div class="line">	 else &#123;</div><div class="line">		 System.out.println("null");</div><div class="line">		 return null;</div><div class="line">	 &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public static void main(String args[])&#123;</div><div class="line">	Node A=new Node(1);</div><div class="line">	Node B=new Node(2);</div><div class="line">	Node C=new Node(3);</div><div class="line">    A.next=B;</div><div class="line">    B.next=C;</div><div class="line">    C.next=null;</div><div class="line">    LinkNode link=new LinkNode();</div><div class="line">    link.TraverserHeadToTail(A);	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现递归的方式如此简便，注意这里的node返回的是根结点，因为它是后续遍历的最后一个结点啊</p>
<h4 id="顺序表方式"><a href="#顺序表方式" class="headerlink" title="顺序表方式"></a>顺序表方式</h4><p>能不能把链表转换成顺序表了，大体思路是这样的，对链表做三次遍历，第一次遍历确定链表的长度，第二次遍历将每个结点的值按照结点顺序放到一个缓存中，第三次遍历，对该缓存遍历，然后将到放到另一个缓存数组中，不过是将前一个缓存按照倒序放到该数组中，最后将该倒序缓存放到集合中就可以了，代码如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;Integer&gt; ChangeToList(Node node)&#123;</div><div class="line">		 int len = 0,i=0;</div><div class="line">		 Node temp=node;</div><div class="line">		 while(node!=null)&#123;</div><div class="line">			 ++len;</div><div class="line">			 node=node.next;</div><div class="line">		 &#125;</div><div class="line">		 Integer[] nodes=new Integer[len];</div><div class="line">		 while(temp!=null)</div><div class="line">		 &#123;</div><div class="line">			 nodes[i++]=(Integer) temp.data;</div><div class="line">			 temp=temp.next;</div><div class="line">		 &#125;</div><div class="line">		</div><div class="line">		 Integer[] nodesTemp=new Integer[len];</div><div class="line">		 for(int j=0;j&lt;nodes.length;j++)</div><div class="line">			 nodesTemp[len-j-1]=nodes[j];</div><div class="line">		 ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();</div><div class="line">		 for(int k=0;k&lt;nodes.length;k++)</div><div class="line">			 list.add(k, nodesTemp[k]);</div><div class="line">		 return list;	 </div><div class="line">	 &#125;</div><div class="line"></div><div class="line"></div><div class="line">	 public static void main(String args[])&#123;</div><div class="line">		Node A=new Node(1);</div><div class="line">		Node B=new Node(2);</div><div class="line">		Node C=new Node(3);</div><div class="line">	    A.next=B;</div><div class="line">	    B.next=C;</div><div class="line">	    C.next=null;</div><div class="line">	    LinkNode link=new LinkNode();</div><div class="line">	    List&lt;Integer&gt; list=link.ChangeToList(A);</div><div class="line">	    for(Integer val:list)</div><div class="line">	    	System.out.println(val);</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Shiro之通过数据库验证身份]]></title>
      <url>http://www.myzwl.win/2017/04/14/shiro1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考百度上说的<a href="http://shiro.apache.org/download.html" target="_blank" rel="external">Apache Shiro</a>是一个强大易用的java安全框架，提供了认证、授权、加密和会话管理功能，可以为任何应用提供安全保障，而其主要为解决以下四个问题：<br>1、 认证-用户身份识别，常被称为用户登录<br>2、 授权-访问控制<br>3、 密码加密-保护或隐藏数据防止被偷窥<br>4、 会话管理-每用户相关的时间敏感的状态</p>
<h4 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h4><p>以下是从其官网上截取的原理图<br><img src="/images/imgs3/14.gif" alt="Alt text"></p>
<h4 id="Subject认证主体"><a href="#Subject认证主体" class="headerlink" title="Subject认证主体"></a>Subject认证主体</h4><p>其中认证主体包含两个信息:<br>Principals： 身份，可以是用户名，邮件，手机号码等等，用来标识一个登陆主体身份；<br>Credentials： 凭证，常见有密码，数字证书等等；</p>
<h4 id="Realm-amp-JDBC-amp-Reaml"><a href="#Realm-amp-JDBC-amp-Reaml" class="headerlink" title="Realm&amp;JDBC&amp;Reaml"></a>Realm&amp;JDBC&amp;Reaml</h4><p>Realm：意思是域，Shiro从Reaml中获取验证数据；<br>Realm有很多种类，例如常见的jdbc realm</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>1.在eclipse中新建一个maven工程，并且配置pom.xml<br>主要配置如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;dependencies&gt;</div><div class="line"></div><div class="line">  	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span>&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">1.2</span>.<span class="number">4</span>&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    </div><div class="line">    &lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">1.7</span>.<span class="number">12</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;c3p0&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;c3p0&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">0.9</span>.<span class="number">1.2</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;commons-logging&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">1.2</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">5.1</span>.<span class="number">37</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line"></div><div class="line">  &lt;/dependencies&gt;</div></pre></td></tr></table></figure></p>
<p>主要有shiro的核心包、日志包，数据源及数据库连接包</p>
<ol>
<li>在resource包下新建jdbc_realm.ini用于配置从数据库中获取验证数据<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[main]   <span class="comment">//声明以下是代码片段</span></div><div class="line"><span class="comment">//相当于new了一个jdbcRealm类</span></div><div class="line">jdbcRealm=org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.realm</span><span class="selector-class">.jdbc</span><span class="selector-class">.JdbcRealm</span></div><div class="line"><span class="comment">//声明一个数据源，这里用了c3p0</span></div><div class="line">dataSource=com<span class="selector-class">.mchange</span><span class="selector-class">.v2</span><span class="selector-class">.c3p0</span><span class="selector-class">.ComboPooledDataSource</span></div><div class="line"><span class="comment">//声明驱动</span></div><div class="line">dataSource.driverClass=com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span></div><div class="line"><span class="comment">//声明url，其中localhost可更改为ip地址</span></div><div class="line">dataSource.jdbcUrl=jdbc:mysql:<span class="comment">//localhost:9806/db_shiro</span></div><div class="line"><span class="comment">//配置数据库用户名、密码</span></div><div class="line">dataSource.user=root</div><div class="line">dataSource.password=root</div><div class="line"><span class="comment">//添加数据源</span></div><div class="line">jdbcRealm.dataSource=<span class="variable">$dataSource</span></div><div class="line"><span class="comment">//添加数据域</span></div><div class="line">securityManager.realms=<span class="variable">$jdbcRealm</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里数据库中需要注意的是，数据库中的表名必须为users，并且字段必须为userName和password</p>
<ol>
<li>在src/main/java文件下新建一个HelloWorld类，目前数据这里手动构造一个<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package com.zwl.shiro;</div><div class="line"></div><div class="line">import org.apache.shiro.SecurityUtils;</div><div class="line">import org.apache.shiro.authc.AuthenticationException;</div><div class="line">import org.apache.shiro.authc.UsernamePasswordToken;</div><div class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</div><div class="line">import org.apache.shiro.mgt.SecurityManager;</div><div class="line">import org.apache.shiro.subject.Subject;</div><div class="line">import org.apache.shiro.util.Factory;</div><div class="line"></div><div class="line">public class HelloWorld &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//读取配置文件，初始化SecurityManager工厂</div><div class="line">	   Factory&lt;SecurityManager&gt; factory=new IniSecurityManagerFactory("classpath:jdbc_realm.ini");</div><div class="line">	    //获取SecurityManager实例</div><div class="line">	   SecurityManager securityManager=factory.getInstance();</div><div class="line">	   //把SecurityManager实例绑定到SecurityUtils</div><div class="line">	   SecurityUtils.setSecurityManager(securityManager);</div><div class="line">	   //得到当前执行的用户</div><div class="line">	   Subject currentUser=SecurityUtils.getSubject();</div><div class="line">	   //创建token令牌，用户名/密码</div><div class="line">	   UsernamePasswordToken token=new UsernamePasswordToken("admin", "123456");</div><div class="line">	   try &#123;</div><div class="line">		//身份认证</div><div class="line">		  currentUser.login(token);</div><div class="line">		  System.out.println("身份认证成功！");</div><div class="line">	&#125; catch (AuthenticationException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		System.out.println("身份认证失败！");</div><div class="line">	&#125;</div><div class="line">	        // 退出</div><div class="line">			currentUser.logout();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里通过更改token来模拟验证数据是否正确</p>
<p>相关源代码，已放在<a href="https://github.com/slycmiaoxi/slycmx.github.io/tree/b" target="_blank" rel="external">github</a></p>
]]></content>
      
        <categories>
            
            <category> 安全框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发系列之四Guarded Suspension]]></title>
      <url>http://www.myzwl.win/2017/04/13/thrd4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Guarded Suspension是指当现在并不适合马上执行某个操作时，就要求想要执行该操作的线程等待</p>
<h4 id="Guarded-Suspension"><a href="#Guarded-Suspension" class="headerlink" title="Guarded Suspension"></a>Guarded Suspension</h4><p>首先模拟一个案例<br>首先是表示请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public class Request &#123;</div><div class="line">private final String name;</div><div class="line"></div><div class="line">public Request(String name)&#123;</div><div class="line">	this.name=name;</div><div class="line">&#125;</div><div class="line">public String getName()&#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String toString()&#123;</div><div class="line">	return "[ Request"+name+"]";</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一次存放请求以待使用的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.LinkedList;</div><div class="line"></div><div class="line">public class RequestQueue &#123;</div><div class="line"></div><div class="line">  //构造链表，用来保存请求</div><div class="line">	private final LinkedList queue=new LinkedList&lt;&gt;();</div><div class="line">//有请求将最早的请求取出，没有则等待</div><div class="line">	public synchronized Request getRequest()&#123;</div><div class="line">		while(queue.size()&lt;=0)&#123;</div><div class="line">			try&#123;</div><div class="line">				wait();</div><div class="line">			&#125;catch(Exception e)&#123;</div><div class="line">				</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return (Request) queue.removeFirst();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//增加一个请求</div><div class="line">	public synchronized void putRequest(Request request)&#123;</div><div class="line">		queue.addLast(request);</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>送出请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class ClientThread extends Thread &#123;</div><div class="line">  //构造随机数，用来线程等待时间</div><div class="line">	private Random random;</div><div class="line">	//存放请求</div><div class="line">	private RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	public ClientThread(RequestQueue requestQueue,String name,long seed)&#123;</div><div class="line">		super(name);</div><div class="line">		this.requestQueue=requestQueue;</div><div class="line">		this.random=new Random(seed);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">//不断调用putrequest（），并且打印相关信息</div><div class="line">		for(int i=0;i&lt;10000;i++)&#123;</div><div class="line">			Request request=new Request("No ."+i);</div><div class="line">			System.out.println(Thread.currentThread().getName()+" Request:"+request);</div><div class="line">			requestQueue.putRequest(request);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(random.nextInt(1000));</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO: handle exception</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接收请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class ServerThread extends Thread &#123;</div><div class="line">	private Random random;</div><div class="line">	private RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	public ServerThread(RequestQueue requestQueue,String name,long seed)&#123;</div><div class="line">		super(name);</div><div class="line">		this.requestQueue=requestQueue;</div><div class="line">		this.random=new Random(seed);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">	//不断调用getrequest（）</div><div class="line">		for(int i=0;i&lt;10000;i++)&#123;</div><div class="line">			Request request=requestQueue.getRequest();</div><div class="line">			System.out.println(Thread.currentThread().getName()+" Handlet:"+request);</div><div class="line">			</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(random.nextInt(1000));</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO: handle exception</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后是测试<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RequestQueue requestQueue=new RequestQueue();</div><div class="line">		new ClientThread(requestQueue, "A", 1314520l).start();</div><div class="line">		new ServerThread(requestQueue, "B", 5201314l).start();</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>A Request:[ RequestNo .0]<br>B Handlet:[ RequestNo .0]<br>A Request:[ RequestNo .1]<br>B Handlet:[ RequestNo .1]<br>A Request:[ RequestNo .2]<br>B Handlet:[ RequestNo .2]<br>……</p>
</blockquote>
<p>从测试结果可以看出，当发送请求时，接受并处理<br>而其中的关键方法是getRequest（）中，当满足while里条件时，则调用wait，处于等待，直到收到通知，才从休息区出来，而这种一定要满足的条件，就称为Guarded Suspension的警戒条件</p>
<p>所以可将该模式抽象为如下<br>GuardedObject（被防伪的对象）参与者：当线程执行guardMethod时，只要满足警戒条件，就马上执行，当不成立时，就开始等待，而条件的成立与否，是与参与者的状态变化有关<br>guardMethod：防伪的方法<br>stateChangingMethod：状态改变的方法</p>
]]></content>
      
        <categories>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发系列之三Immutable]]></title>
      <url>http://www.myzwl.win/2017/04/12/thrd3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>immutable是指永恒，不会改变的意思，就像java.lang.String类中，并没有提供任何改变字符串属性的方法</p>
<h4 id="immutable-Pattern"><a href="#immutable-Pattern" class="headerlink" title="immutable Pattern"></a>immutable Pattern</h4><p>首先模拟一个案例<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public final class Person &#123;</div><div class="line">//不允许修改的地址</div><div class="line">private final String address;</div><div class="line">//不允许修改的姓名</div><div class="line">private final String name;</div><div class="line">public Person(String name, String address) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.address = address;</div><div class="line">&#125;</div><div class="line">//有final就不会有set方法，控制外部对其的修改</div><div class="line">public String getAddress() &#123;</div><div class="line">	return address;</div><div class="line">&#125;</div><div class="line">public String getName() &#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String toString()&#123;</div><div class="line">	return "[ Person: name="+name+ ",address="+address+"]";</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是人的线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public class PersonThread extends Thread &#123;</div><div class="line"></div><div class="line">	private Person person;</div><div class="line"></div><div class="line">	public PersonThread(Person person) &#123;</div><div class="line">		this.person = person;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">		while(true)&#123;</div><div class="line">		//得到线程的名并打印出人的信息</div><div class="line">			System.out.println(Thread.currentThread().getName()+"prints"+person);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person person=new Person("A1","AA");</div><div class="line">	new PersonThread(person).start();</div><div class="line">	new PersonThread(person).start();</div><div class="line">	new PersonThread(person).start();</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>以下一直重复</p>
</blockquote>
<p>可以发现上面的字段都是final并且没有修改该字段的方法<br>正因为如此，所以就不需要使用synchronized来限制，这在性能上就大大提高了</p>
<h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><p>1.当实例产生后，状态不再变化时<br>2.实例需要共享，而且访问很频繁时</p>
<p>当然，有时也需要变与不变的转换，就像StringBuffer是一个线程不安全的类，在它的构造器中有String作为参数，而在String类中也有StringBuffer作为参数<br>另外像java中的基本类型boolean、int、long等都是immutable模式<br>该模式最大的优点就是实例的状态不会改变，所以没必要进行保护</p>
]]></content>
      
        <categories>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发系列之二Single Threaded Execution]]></title>
      <url>http://www.myzwl.win/2017/04/11/thrd2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Single Threaded Execution是指以一个线程执行，简单来说就是在多线程中限制同时只让一个线程运行</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>首先来模拟一个线程不安全的例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class Gate &#123;</div><div class="line"></div><div class="line">    //记录走过门的人数，默认为0</div><div class="line">	private int count=0;</div><div class="line">	//记录通过门的人的名字</div><div class="line">	private String name="nobody";</div><div class="line">	//记录通过门的人的地址</div><div class="line">	private String address="noplace";</div><div class="line">	</div><div class="line">	//穿越这道门使用的方法</div><div class="line">	public  void pass(String name,String address)&#123;</div><div class="line">		this.name=name;</div><div class="line">		this.address=address;</div><div class="line">		count++;</div><div class="line">		check();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//检查通过门的人的合法性，即人的名字和地址首字母是否相同</div><div class="line">	public void check()&#123;</div><div class="line">		if(name.charAt(0)!=address.charAt(0))&#123;</div><div class="line">			System.out.println("***broken***"+this.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//打印出人数、姓名、地址</div><div class="line">	public  String toString()&#123;</div><div class="line">		return "No."+count+":"+name+" ,"+address;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>目前上面的Gate类是线程不安全的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">//不断穿越门的行人</div><div class="line">public class UserThread extends Thread &#123;</div><div class="line">//用final限制门，姓名，地址不能重复</div><div class="line">private final Gate gate;</div><div class="line">private final String myaddress;</div><div class="line">private final String myname;</div><div class="line">public UserThread(Gate gate, String myname, String myaddress) &#123;</div><div class="line">	super();</div><div class="line">	this.gate = gate;</div><div class="line">	this.myname = myname;</div><div class="line">	this.myaddress = myaddress;</div><div class="line">&#125;</div><div class="line">//发生错误，即行人不合法，则处于死循环，并且执行toString方法</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">	System.out.println(myname+" BEGIN");</div><div class="line">while(true)&#123;</div><div class="line">	gate.pass(myname, myaddress);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">System.out.println("test begin:");</div><div class="line">	Gate gate=new Gate();</div><div class="line">	//构造三个行人</div><div class="line">	new UserThread(gate, "A1", "A2").start();</div><div class="line">	new UserThread(gate, "B1", "B2").start();</div><div class="line">	new UserThread(gate, "C1", "C2").start();</div></pre></td></tr></table></figure></p>
<p>测试结果（截取部分）</p>
<blockquote>
<p>test begin:<br>B1 BEGIN<br>A1 BEGIN<br><strong><em>broken</em></strong>No.1305356:A1 ,A2<br><strong><em>broken</em></strong>No.1347999:B1 ,B2<br><strong><em>broken</em></strong>No.1357011:A1 ,A2<br><strong><em>broken</em></strong>No.1370176:B1 ,B2<br><strong><em>broken</em></strong>No.1377075:B1 ,B2</p>
</blockquote>
<p>从结果来看，明显发生了错误，即出现了线程不安全，但是也有点不对劲</p>
<h4 id="为什么会出错了"><a href="#为什么会出错了" class="headerlink" title="为什么会出错了"></a>为什么会出错了</h4><blockquote>
<p>问题的出错地方就在Gate类中，因为其是线程不安全的，打个比方<br>    线程A1                  线程A2           this.name值            this.address值<br>   count++                  count++            之前的值                  之前的值<br> this.name=name                                  A1                     之前的值<br>                           this.name=name        A2                     之前的值<br>                           this.address=address  A2                       B2<br> this.address=address                            A1                       B2<br>  check（）                  check（）           A1                        B2</p>
</blockquote>
<p>  发生错误</p>
<p>  以上只是发生错误的一种情况，事实上只有当数据量非常大时，极有可能发生错误，所以才会出现错误的结果，并且是在count达到大数量的时候出现的<br>  那么如何修改了？<br>  因为发生在Gate类的pass和toString方法中，所以只要把这个两个方法声明为同步就可以了</p>
<blockquote>
<p>public synchronized void pass(String name,String address){}<br>  public synchronized String toString(){}</p>
</blockquote>
<p>  对应的测试结果</p>
<blockquote>
<p>test begin:<br>A1 BEGIN<br>B1 BEGIN<br>C1 BEGIN</p>
</blockquote>
<h4 id="归纳single-Threaded"><a href="#归纳single-Threaded" class="headerlink" title="归纳single Threaded"></a>归纳single Threaded</h4><p>上面例子的解决方案就是该模式的一种应用，可以将其抽象为以下几个参与者<br>SharedResource（共享资源）参与者：可有多个线程访问的类，如Gate<br>SafeMethod：从多个线程同时调用也不会发生问题<br>UnsafeMethod：从多个线程同时调用会发生问题，需要防范的方法<br>所以必须将上述不安全的方法加以同步锁，当时如果通过其他方法改变不安全方法中数据也会发生错误，就像大门上锁，但是窗户开着一样，所以有时也是一个隐患的问题</p>
<p>那么此种模式何时适用了？<br>多线程时、数据可被多个线程访问的时候、状态可能变化的时候、需要确保安全性的时候</p>
<h4 id="生命线与死锁"><a href="#生命线与死锁" class="headerlink" title="生命线与死锁"></a>生命线与死锁</h4><p>使用该模式，可能会发生死锁的危险<br>而死锁是指：两个线程分别获取了锁定，互相等待另一个线程解除锁定的线程。发生死锁时，哪个线程都无法继续执行下去，所以程序会失去生命线<br>最经典的死锁问题就是汤勺与叉子模型，问题大概是这样的<br>假设A与B同吃一碗面，盘子旁有一支汤勺与一支叉子，而吃面必须同时需要汤勺和叉子<br>而现在叉子被其中一人假设是A拿走，而汤勺被B拿走，就会造成如下现象：<br>A和B一直等待对方放下叉子（或者汤勺），即一直处于等待，僵持阶段，从而程序无法继续运行，故称为死锁现象</p>
<p>而只要上述模式达到下面的条件，就会出现死锁<br>1.具有多个SharedResource参与者<br>2.线程锁定一个SharedResource时，还没接触前就去锁定另一个SharedResource<br>3.获取SharedResource参与者的顺序不固定</p>
<p>当然只要破坏上述三个条件之一就可以避免死锁的发生</p>
<p>下面就开始模拟死锁<br>首先是表示餐具的类(这里只有叉子和汤勺)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class Tool &#123;</div><div class="line"></div><div class="line">	private final String name;</div><div class="line">	public Tool(String  name)&#123;</div><div class="line">		this.name=name;</div><div class="line">	&#125;</div><div class="line">	public String toString()&#123;</div><div class="line">		return "["+name+"]";</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>开始用餐的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class EaterThread extends Thread &#123;</div><div class="line">    </div><div class="line">    //用餐者名字</div><div class="line">	private String name;</div><div class="line">	//左手拿餐具</div><div class="line">	private final Tool lefthand;</div><div class="line">	//右手拿餐具</div><div class="line">	private final Tool righthand;</div><div class="line">	public EaterThread(String name, Tool lefthand, Tool righthand) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.lefthand = lefthand;</div><div class="line">		this.righthand = righthand;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">	  //不断吃</div><div class="line">		while(true)&#123;</div><div class="line">			eat();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void eat()&#123;</div><div class="line">		 //锁定左手获取餐具</div><div class="line">		synchronized (lefthand) &#123;</div><div class="line">		 //左手拿餐具</div><div class="line">			System.out.println(name+"takes up"+lefthand+"left.");</div><div class="line">		 //锁定右手拿餐具</div><div class="line">			synchronized (righthand) &#123;</div><div class="line">		 //右手拿餐具</div><div class="line">				System.out.println(name+" takes up"+righthand+"right.");</div><div class="line">		 //开吃</div><div class="line">				System.out.println(name+" is eating");</div><div class="line">		 //右手放下餐具</div><div class="line">				System.out.println(name+" puts down"+righthand+"right.");</div><div class="line">			&#125;</div><div class="line">		 //解除右手锁定锁，并且左手放下餐具</div><div class="line">			System.out.println(name+"puts down"+lefthand+"left.");</div><div class="line">		&#125;</div><div class="line">		//解除左手餐具的锁定</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   System.out.println("test begin:");</div><div class="line">Tool spoon=new Tool("Spoon");</div><div class="line">Tool fork=new Tool("Fork");</div><div class="line">new EaterThread("A", spoon, fork).start();</div><div class="line">new EaterThread("B", fork, spoon).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>test begin:<br>Atakes up[Spoon]left.<br>A takes up[Fork]right.<br>A is eating<br>A puts down[Fork]right.<br>Aputs down[Spoon]left.<br>Atakes up[Spoon]left.<br>A takes up[Fork]right.<br>A is eating<br>A puts down[Fork]right.<br>Aputs down[Spoon]left.<br>重复。。直到<br>Atakes up[Spoon]left.<br>Btakes up[Fork]left.<br>该处程序停止不动了，也就是a和b分别拿着汤勺和叉子，即处于死锁状态了。</p>
</blockquote>
<p>一种最简单的方法就是改变顺序，即以相同顺序拿餐具<br>即：</p>
<blockquote>
<p>Tool spoon=new Tool(“Spoon”);<br>    Tool fork=new Tool(“Fork”);<br>    new EaterThread(“A”, spoon, fork).start();<br>    new EaterThread(“B”, spoon,fork).start();</p>
</blockquote>
<p>最后程序就会一直进行下去，不过这样的话，前面的共享资源就不存在了！</p>
]]></content>
      
        <categories>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发系列一之初识java线程]]></title>
      <url>http://www.myzwl.win/2017/04/10/thrd1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>曾在论坛中看过这样一句话，如果连多线程都不懂，别说自己学过java，可见多线程的重要性！</p>
<h4 id="何谓线程"><a href="#何谓线程" class="headerlink" title="何谓线程"></a>何谓线程</h4><p>简单来说，就像我们在执行一个程序时，他总按照顺序执行，如果从头到尾都没有分叉，也就是说总是一个流程，那么就可以看做单线程，并且程序执行的主体只有一个，所以，我们把正在执行程序的主体称为线程</p>
<p>当然，平时我们说的最多的就是多线程，顾名思义就是由一个以上的线程所构成的程序，比如文件处理，io请求处理及网络客户端发出的请求等等都可以看做多线程</p>
<h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>先看一个简单的例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest1;</div><div class="line"></div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">public class Mythread extends Thread &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;700;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mythread m=new Mythread();</div><div class="line">	  m.start();</div><div class="line">	  for(int i=0;i&lt;900;i++)&#123;</div><div class="line">	  System.out.print("lol!");</div><div class="line">	  &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>lol!lol!lol!lol!lol!lol!。。hello!hello!hello!hello!hello!。。lol!lol!lol!lol!lol!lol!</p>
</blockquote>
<p>然后在去认识上面程序，其中start方法会启动新的线程，然后再由这个新线程调用run方法，<br>当然也可以直接调用run方法</p>
<p>那么两者有什么区别了？<br>调用start方法会出现字符串交错，也就是并发，而run方法，就是等run方法执行完，在执行其它，显然不会出现交错现象<br>当然数据量小的话，出现的结果很难有说服力，所以并发模拟尽量使用大数量</p>
<h4 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h4><ol>
<li>利用thread的子类的实例，启动线程<br>正如前面模拟的程序，不过下面测试用两个线程<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new Mythread().start（）;</div><div class="line">new Mythread().start（）;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>显然两个线程操作两个对象，所以thread是线程安全的</p>
<ol>
<li>利用Runnable接口<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Mythread implements Runnable</div><div class="line">&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;700;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      Mythread m=new Mythread();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>这里主要向Runnable接口实现的实例作为参数传递给Thread，再启动线程，这里就有一个问题，因为不同线程操作一个对象，所以会造成线程不安全的问题，也就是脏数据</p>
<h4 id="线程的暂时停止"><a href="#线程的暂时停止" class="headerlink" title="线程的暂时停止"></a>线程的暂时停止</h4><p>利用Thread的sleep方法可暂时停止线程当前的操作，如<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">      public class Mythread implements Runnable</div><div class="line">&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;5;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>这里的参数是ms，所以1000就是1s了</p>
<h4 id="线程的共享互斥"><a href="#线程的共享互斥" class="headerlink" title="线程的共享互斥"></a>线程的共享互斥</h4><p>在程序里，多个线程可自由操作，就会造成一个线程还在执行，另一个线程就插进来执行，就会造成一些脏数据的产生<br>如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">       private int count=1000;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">	for(int i=0;i&lt;100;i++)&#123;</div><div class="line">		count--;</div><div class="line">		System.out.println("mythread"+(count));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     Mythread m=new Mythread();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：（取部分）</p>
<blockquote>
<p>mythread999<br>mythread997<br>mythread996<br>mythread995<br>mythread994</p>
</blockquote>
<p>显然出现了脏数据<br>要想使数据正确，一种方法是加同步锁，即一个线程在执行该操作时，其余线程无锁，则必须等待，直到该线程执行结束或者被挂起，才释放锁，然后在门外等待的线程依次执行，加锁，重复上述步骤<br>显然，就不会出现多个线程操作同一个对象了</p>
<p>java中通过声明synchronized关键字实现同步锁<br>如：</p>
<blockquote>
<p>public synchronized void run()</p>
</blockquote>
<p>则在执行run方法前加同步锁，控制线程，当然该关键字可以声明在任何方法前，包括静态方法<br>另外，它还有另外一种声明方式</p>
<blockquote>
<p>public  void run() {<br>        synchronized (xx.class) {<br>        }</p>
</blockquote>
<p>注意这里xx.class是操作该方法的那个类实现同步比如这里可以将</p>
<blockquote>
<p>synchronized (this) {}</p>
</blockquote>
<p>就是对本身这个类加锁控制了等同于上述的另一种写法</p>
<h4 id="线程的协调"><a href="#线程的协调" class="headerlink" title="线程的协调"></a>线程的协调</h4><p>如果有一个线程正在执行同步锁，而其他线程则要等待，这是典型的线程互斥现象<br>假如当该空间有空余时则写入数据，无空闲时间则等待（等待）<br>当该空间有空闲时，则通知等待的线程（通知）</p>
<p>这里是根据空间是否空闲为条件进行线程处理，java中通过wait（让线程等待），notify与notifyAll（启动等候中的线程）</p>
<p>我们可以把线程处于等待的地方形象的看做wait set（线程的休息室）</p>
<h4 id="wait-把线程放入休息室"><a href="#wait-把线程放入休息室" class="headerlink" title="wait-把线程放入休息室"></a>wait-把线程放入休息室</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">	private static int count=90;</div><div class="line">	</div><div class="line">public synchronized int s() throws InterruptedException&#123;</div><div class="line">	count--;</div><div class="line">	System.out.println("ok:"+count);</div><div class="line">	this.wait();</div><div class="line">	System.out.println("lockover");</div><div class="line">	return count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">	public  void run() &#123;	</div><div class="line">				try &#123;</div><div class="line">					s();</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>然后在测试中启动几个线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     Count m=new Count();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>ok:89<br>ok:88<br>ok:87</p>
</blockquote>
<p>一般为obj.wait（），而obj是某个对象的实例，也就是说该线程在obj的休息区<br>之后会自动释放锁，等待的线程开始执行</p>
<p>当然也有obj.wait（1000）；也可以设置在休息区等待的秒数，然后继续执行</p>
<p>测试结果：</p>
<blockquote>
<p>ok:89<br>ok:88<br>ok:87<br>lockover<br>lockover<br>lockover</p>
</blockquote>
<h4 id="notify方法-从休息区拿出线程"><a href="#notify方法-从休息区拿出线程" class="headerlink" title="notify方法-从休息区拿出线程"></a>notify方法-从休息区拿出线程</h4><p>一般为obj.notify（），即从obj的wait set里的线程中挑选一个，唤醒一个线程并退出该休息区<br>当然，这里有一个顺序，召唤该线程的那个线程执行完，释放锁后，那个在休息区的线程在执行</p>
<p>obj.notifyAll（），即从线程区中拿出所有线程</p>
<p>最后需要说一下的是wait、notify、notifyAll是Object的类方法，也就是所有类都能使用</p>
<p>由此可看出多线程的确是一个复杂而且很重要的东西！！</p>
]]></content>
      
        <categories>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[集合中的线程安全问题]]></title>
      <url>http://www.myzwl.win/2017/04/07/thread2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早在刚开始学习java se的时候，就遇到过这样问题，xxx是线程安全的，xxxx是线程不安全的，当时也是一脸蒙，只记住了结论。后来接触了单例才有一点了解</p>
<p>线程安全的：<br>vector、hashtable、stringbuffer等</p>
<p>非线程安全的：<br>arraylist、linkedlist、hashmap、StringBuilder等等</p>
<p>首先来模拟一个案例</p>
<p>测试集合类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static void test()  &#123;</div><div class="line">// 用来测试的List  </div><div class="line">   List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();  </div><div class="line">   </div><div class="line">   // 线程数量(1000)  </div><div class="line">   int threadCount = 1000;  </div><div class="line">   </div><div class="line">// 用来让主线程等待threadCount个子线程执行完毕  </div><div class="line">   CountDownLatch countDownLatch = new CountDownLatch(threadCount);  </div><div class="line">   </div><div class="line">    // 启动threadCount个子线程  </div><div class="line">   for(int i = 0; i &lt; threadCount; i++)  </div><div class="line">   &#123;  </div><div class="line">       Thread thread = new Thread(new Mythread(list,countDownLatch));  </div><div class="line">       thread.start();  </div><div class="line">   &#125;  </div><div class="line">   try  </div><div class="line">   &#123;  </div><div class="line">       // 主线程等待所有子线程执行完成，再向下执行  </div><div class="line">       countDownLatch.await();  </div><div class="line">   &#125;  </div><div class="line">   catch (InterruptedException e)  </div><div class="line">   &#123;  </div><div class="line">       e.printStackTrace();  </div><div class="line">   &#125;  </div><div class="line">   // List的size  </div><div class="line">   System.out.println(list.size());  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>自定义线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line">import java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line">public class Mythread implements Runnable &#123;</div><div class="line">	private List&lt;Object&gt; list;  </div><div class="line">	</div><div class="line">	private CountDownLatch countDownLatch; </div><div class="line">	public Mythread(List&lt;Object&gt; list,CountDownLatch countDownLatch)&#123;</div><div class="line">		  this.list = list; </div><div class="line">		  this.countDownLatch = countDownLatch;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		// 每个线程向List中添加100个元素  </div><div class="line">        for(int i = 0; i &lt; 100; i++)  </div><div class="line">        &#123;  </div><div class="line">            list.add(new Object());  </div><div class="line">        &#125;  </div><div class="line">     // 完成一个子线程  </div><div class="line">        countDownLatch.countDown();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">	 </div><div class="line">	 // 进行10次测试  </div><div class="line">        for(int i = 0; i &lt; 10; i++)  </div><div class="line">        &#123;  </div><div class="line">            test();  </div><div class="line">        &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>99873<br>99968<br>99955<br>100000<br>100000<br>100000<br>100000<br>Exception in thread “Thread-7516” java.lang.ArrayIndexOutOfBoundsException: 76327<br>    at java.util.ArrayList.add(ArrayList.java:441)<br>    at com.zwl.test.Mythread.run(Mythread.java:20)<br>    at java.lang.Thread.run(Thread.java:744)</p>
</blockquote>
<p>有时不会出现异常，但是list的长度不是最终期望的那样，显然是线程不安全的，<br>这里是arraylist，同样将其换成linkedlist，也可以改变list，变成其它，得到同样线程不安全结果</p>
<p>测试结果：</p>
<blockquote>
<p>100000<br>99783<br>100000<br>99945<br>99897<br>99996<br>99879<br>99971<br>100000<br>99899</p>
</blockquote>
<p>将其换成线程安全的，如</p>
<blockquote>
<p>List<object> list = new Vector<object>(); </object></object></p>
</blockquote>
<p>测试结果：</p>
<blockquote>
<p>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000</p>
</blockquote>
<p>当然集合中的线程不安全是多线程同时操作同一个对象，如果是不同类，就不存在线程安全问题</p>
<p>对于线程安全，一般通过线程同步来实现，即通过申明synchronized关键字</p>
<p>如，改一下之前的线程安全的例子number类</p>
<p>修改后的number类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class number &#123;</div><div class="line"></div><div class="line">	private int num=0; </div><div class="line"></div><div class="line">	public  void count()&#123;</div><div class="line">	</div><div class="line">		num++;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int getnumber()&#123;</div><div class="line">		return num;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是自定义线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Mythread implements Runnable &#123;</div><div class="line">	private number num;</div><div class="line">	</div><div class="line">	private CountDownLatch countDownLatch; </div><div class="line">	public Mythread(number num,CountDownLatch countDownLatch)&#123;</div><div class="line">		  this.num = num; </div><div class="line">		  this.countDownLatch = countDownLatch;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123; </div><div class="line">        for(int i = 0; i &lt; 100; i++)  </div><div class="line">        &#123;  </div><div class="line"> </div><div class="line">        	num.count();</div><div class="line">        	</div><div class="line">        &#125;  </div><div class="line">     // 完成一个子线程  </div><div class="line">        countDownLatch.countDown();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> public static void test()  &#123;</div><div class="line"></div><div class="line">   </div><div class="line">   number num=new number();</div><div class="line">   // 线程数量(1000)  </div><div class="line">   int threadCount = 1000;  </div><div class="line">   </div><div class="line">// 用来让主线程等待threadCount个子线程执行完毕  </div><div class="line">   CountDownLatch countDownLatch = new CountDownLatch(threadCount);  </div><div class="line">   </div><div class="line">   for(int i = 0; i &lt; threadCount; i++)  </div><div class="line">   &#123;  </div><div class="line">       Thread thread = new Thread(new Mythread(num,countDownLatch));  </div><div class="line">       thread.start();  </div><div class="line">   &#125;  </div><div class="line">   try  </div><div class="line">   &#123;  </div><div class="line">       // 主线程等待所有子线程执行完成，再向下执行  </div><div class="line">       countDownLatch.await();  </div><div class="line">   &#125;  </div><div class="line">   catch (InterruptedException e)  </div><div class="line">   &#123;  </div><div class="line">       e.printStackTrace();  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line">   System.out.println(num.getnumber());  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		 </div><div class="line">		 // 进行10次测试  </div><div class="line">	        for(int i = 0; i &lt; 10; i++)  </div><div class="line">	        &#123;  </div><div class="line">	            test();  </div><div class="line">	        &#125;  </div><div class="line">	 &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>100000<br>100000<br>100000<br>100000<br>99940<br>99300<br>100000<br>100000<br>100000<br>100000</p>
</blockquote>
<p>出现了线程不安全<br>可以通过对方法声明同步</p>
<blockquote>
<p>public synchronized void count(){}</p>
</blockquote>
<p>最后输出的书都是同一个数</p>
<p>最后不得不说，线程安全是一个很复杂的问题，有时候不注意就会出现数据上的各种问题！！！</p>
]]></content>
      
        <categories>
            
            <category> 学习进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识线程安全与线程不安全]]></title>
      <url>http://www.myzwl.win/2017/04/06/thread1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于线程问题基本上贯穿学习的整个过程，像集合，servlet，structs，hibernate，spring等等，其都涉及到线程问题</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>什么是线程安全？<br>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>线程安全问题都是由全局变量及静态变量引起的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全</p>
<p>不妨来一个实例<br>首先是number类，里面有一个计数的全局和静态变量<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class number &#123;</div><div class="line"></div><div class="line">	private int num;</div><div class="line">	private static int count;</div><div class="line">	</div><div class="line">	public void count()&#123;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			num+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+num);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void countstatic()&#123;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			count+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+count);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然我们希望每个线程都能输出的结果是55就是线程安全</p>
<p>线面是测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class test &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	</div><div class="line">		Runnable runner=new Runnable() &#123;</div><div class="line">			number num=new number();</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				num.count();</div><div class="line">				System.out.println("statis:");</div><div class="line">				num.countstatic();</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			new Thread(runner).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里启动十个线程，依次通过run方法输出全局和静态变量的累加和，如果是线程安全的，则应该都是55</p>
<p>结果如下所示</p>
<blockquote>
<p>Thread-0:55<br>statis:<br>Thread-0:55<br>Thread-1:110<br>statis:<br>Thread-1:110<br>Thread-2:165<br>statis:<br>Thread-2:165<br>Thread-6:275<br>statis:<br>Thread-6:220<br>Thread-3:385<br>statis:<br>Thread-4:220<br>statis:<br>Thread-3:275<br>Thread-8:385<br>statis:<br>Thread-8:385<br>Thread-4:330<br>Thread-5:440<br>statis:<br>Thread-5:440<br>Thread-7:495<br>statis:<br>Thread-7:495<br>Thread-9:550<br>statis:<br>Thread-9:550</p>
</blockquote>
<p>发现不是线程安全的</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
<p>对于上面的线程不安全可以进行如下修改</p>
<p>解决方法：将全局变量变成局部变量（静态变量暂时不讨论）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void count()&#123;</div><div class="line">		int num = 0;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			num+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+num);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>最后所有的线程都输出了55</p>
<p>或者将new 的number放到run里面，变成局部的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">			public void run() &#123;</div><div class="line">				number num=new number();</div><div class="line">				num.count();</div><div class="line">				System.out.println("statis:");</div><div class="line">				num.countstatic();</div><div class="line">			&#125;</div><div class="line">		&#125;;</div></pre></td></tr></table></figure></p>
<p>最后也能保证了线程安全了</p>
]]></content>
      
        <categories>
            
            <category> 学习进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Linkedlist底层]]></title>
      <url>http://www.myzwl.win/2017/04/05/linkedlist/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LinkedList底层是基于双端链表实现的，也就是说它具有指向其前驱与后继的引用，而且，在插入与删除数据时效率极高</p>
<p>至于它继承谁和实现什么接口，直接看源码</p>
<blockquote>
<p>public class LinkedList<e> extends AbstractSequentialList<e><br> implements List<e>, Deque<e>, Cloneable, java.io.Serializable</e></e></e></e></p>
</blockquote>
<p> 和ArrayList一样，从源码分析其add、get以及remove方法</p>
<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p> 首先通过MyEclipse进入LinkedList的源码</p>
<p> 找到add（）方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line"> //把e放在链表的最后一个位置</div><div class="line">       linkLast(e);</div><div class="line">       return true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到linkLast（）方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line">    * Pointer to last node.</div><div class="line">    * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line">    *            (last.next == null &amp;&amp; last.item != null)</div><div class="line">    */</div><div class="line">   transient Node&lt;E&gt; last; //链表最后一个结点的引用</div><div class="line"></div><div class="line">   transient Node&lt;E&gt; first; //链表第一个结点的引用</div><div class="line"></div><div class="line"></div><div class="line">void linkLast(E e) &#123;</div><div class="line">       //将l也指向最后一个结点</div><div class="line">       final Node&lt;E&gt; l = last;</div><div class="line"></div><div class="line">       //调用Node（Node&lt;E&gt; prev，E element，Node&lt;e&gt; next）构造方法</div><div class="line">       //其中prev为前驱结点，element为对象元素，next为后继结点</div><div class="line">       //这里构造新节点，并且是作为尾节点</div><div class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line"></div><div class="line">       //last结点指向newNode</div><div class="line">       last = newNode;</div><div class="line"></div><div class="line">       //如果l为空，则表示链表为空，直接把newNode作为首节点，否则放在l结点之后</div><div class="line">       if (l == null)</div><div class="line">           first = newNode;</div><div class="line">       else</div><div class="line">           l.next = newNode;</div><div class="line"></div><div class="line">        //链表的元素个数加一</div><div class="line">       size++;</div><div class="line"></div><div class="line">       //链表发生结构性修改的次数，这里主要指添加及删除操作</div><div class="line">       modCount++;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>以上便是add方法的源码，主要通过改变链表的前驱及后继引用来完成插入，可想而知，使用链表，使插入数据的速度异常快，相对顺序查找</p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>找到get方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line"></div><div class="line">     //检查index是否合法</div><div class="line">       checkElementIndex(index);</div><div class="line"></div><div class="line">     //如果合法就返回该节点位置的值</div><div class="line">       return node(index).item;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到checkElementIndex(int index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void checkElementIndex(int index) &#123;</div><div class="line">    //检查index是否合法</div><div class="line">       if (!isElementIndex(index))</div><div class="line">           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到isElementIndex(index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//判断index是否存在于链表中</div><div class="line">private boolean isElementIndex(int index) &#123;</div><div class="line">       return index &gt;= 0 &amp;&amp; index &lt; size;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到node(int index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Node&lt;E&gt; node(int index) &#123;</div><div class="line">    //index已在链表中</div><div class="line">    // assert isElementIndex(index);</div><div class="line">    //从第一个位置开始寻找，知道找到index的位置，最后返回该节点的位置</div><div class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        for (int i = 0; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        return x;</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    //从最后一个位置开始往前寻找该节点</div><div class="line">    else &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        for (int i = size - 1; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>linkedlist在查找时的效率非常低，就是因为它是从头或从尾部遍历链表，所以当数据量大时，造成效率低下</p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><p>找到remove方法</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public E remove(int index) &#123;</div><div class="line">      //检查index是否合法</div><div class="line">        checkElementIndex(index);</div><div class="line"></div><div class="line"></div><div class="line">        return unlink(node(index));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>找到unlink(node(index))方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> E unlink(Node&lt;E&gt; x) &#123;</div><div class="line">        // assert x != null;</div><div class="line">        //保存x节点的值</div><div class="line">        final E element = x.item;</div><div class="line">        //保存x节点的后继</div><div class="line">        final Node&lt;E&gt; next = x.next;</div><div class="line">        //保存x节点的前驱</div><div class="line">        final Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">       //如果前驱为空，则表明要移除的是第一个结点，在把first指向下一个节点</div><div class="line">        if (prev == null) &#123;</div><div class="line">            first = next;</div><div class="line">        &#125; else &#123;</div><div class="line">        	//否则把x前驱的后继指向x的后继，并把x前驱设置为null</div><div class="line">            prev.next = next;</div><div class="line">            x.prev = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"> //如果后继为空，则表明要移除的是最后一个结点，在把last引用指向x的前驱</div><div class="line">        if (next == null) &#123;</div><div class="line">            last = prev;</div><div class="line">        &#125; else &#123;</div><div class="line">            next.prev = prev;</div><div class="line">            x.next = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">//把x结点的值设置为null，保证x没有任何引用了</div><div class="line">        x.item = null;</div><div class="line"></div><div class="line"> //链表的size减一</div><div class="line">        size--;</div><div class="line"></div><div class="line">   //链表的结构性修改次数加一</div><div class="line">        modCount++;</div><div class="line"></div><div class="line">   //这里该节点移除之前以保存在element中，然后返回该节点</div><div class="line">        return element;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>至此，简单把上面三个方法的源码简单过了一遍<br>当然，还有一点不得不提的是LinkedList可以当做stack（栈），queue（队列）处理，因为它是双端链表，另外，在遍历时，有index &lt; (size &gt;&gt; 1)，即判断index与size/2比较，这样可以缩小范围，选择是从前遍历还是从后遍历，从而大大增加查找效率</p>
]]></content>
      
        <categories>
            
            <category> 学习进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hibernate之四:反向工程]]></title>
      <url>http://www.myzwl.win/2017/04/04/hbm4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在运用持久层框架时，先前我们都是先通过建立对象—映射文件—数据库的方法，倘若数据库中的表非常多和复杂时，我们可以改变下开发顺序，即从数据库自动生成映射文件和对象，这样涉及表之间的关系，级联或者主外键约束就自动生成，更方便。一般我们用hibernate的反向工程达到此目的。</p>
<p>不多说，先模拟一个案例。<br>首先建立三张表user，picture，addr表，分别如下<br>User表<br><img src="/images/imgs3/1.gif" alt="Alt text"></p>
<p>Picture表<br><img src="/images/imgs3/2.gif" alt="Alt text"></p>
<p>外键<br><img src="/images/imgs3/3.gif" alt="Alt text"></p>
<p>这里的uid是外键对应user表的主键，并且只有当user的id删除时，对应uid相应的记录删除</p>
<p>Addr表<br><img src="/images/imgs3/4.gif" alt="Alt text"></p>
<p>外键<br><img src="/images/imgs3/5.gif" alt="Alt text"></p>
<p>通过myeclipse 提供 数据库浏览器连接到我们的mysql数据库<br><img src="/images/imgs3/6.gif" alt="Alt text"></p>
<p>然后点击右键，选择new，出现如下界面<br><img src="/images/imgs3/7.gif" alt="Alt text"></p>
<p>首先选择数据库，然后填写相关配置信息，其中Driver name随便取，添加jar包，然后点击test Driver，如股票成功，则表示与数据库连接成功，此外，可以选择保存密码，不然，后续操作一次，就要输入密码<br>直接点击finish，</p>
<p>接下来在MyEclipse中创建一个web工程，通过工具自身引入hibernate，具体步骤如下<br><img src="/images/imgs3/8.gif" alt="Alt text"></p>
<p><img src="/images/imgs3/9.gif" alt="Alt text"></p>
<p>选择之前配置好的sshe</p>
<p><img src="/images/imgs3/10.gif" alt="Alt text"></p>
<p>直接点结束，这样hibernate就引入了。</p>
<p>下面我们使用myeclipse提供的逆向工程，自动的创建对象类和对象关系映射文件<br>选中要反向的表<br><img src="/images/imgs3/11.gif" alt="Alt text"></p>
<p>注意我们可以事先在项目中新建一个包，用来存放映射对象和文件<br><img src="/images/imgs3/12.gif" alt="Alt text"></p>
<p>最后点击finish，则自动生成了。<br><img src="/images/imgs3/13.gif" alt="Alt text"></p>
<p>最后值得注意的是，这里只是模拟了三张表，有一对多和多对一关系，主外键及级联，这样就省得我们自己去配置了，因为hibernate的关系配置真的很麻烦！！</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hibernate之三:浅谈HQL和映射文件]]></title>
      <url>http://www.myzwl.win/2017/04/03/hbm3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们想要精确的查找某一个数据库中的信息时，最理想的方法就是通过sql语句查询，一般hibernate中可以通过query接口来写语句进行查询，这个语句可以使sql，hql，当然推荐的是hql，事实上我认为hql和sql基本差不多</p>
<p>一：Query接口<br>    Query接口类型的对象可以对数据库操作,它可以使用Hql和原生SQL(native Sql)对数据库操作.官方推荐使用Hql语句<br>先来看一个例子</p>
<p>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">	public void selectone()&#123;</div><div class="line">	User u=(User)session.createQuery(" from User where id=1").uniqueResult();</div><div class="line">	System.out.println(u.getName());&#125;</div></pre></td></tr></table></figure></p>
<p>分析：这里用了uniqueResult()方法 ，如果我们检索一个对象，明确知道最多只有一个对象，则建议使用该方法:</p>
<p>如果是取出集合对象，则使用如下方法：<br>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void selectone()&#123;		</div><div class="line">List&lt;User&gt; list=session.createQuery("from User").list();</div><div class="line">     for(User user : list)&#123;</div><div class="line">	System.out.println(user.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此我们可以发现，使用list可以取出集合对象，同时方法里面写想要的hql语句</p>
<p>二：HQL简单语法<br>  HQL是面向对象的查询语言，与SQL不同，HQL中的对象名是区分大小写的；HQL中查的是对象而不是表，并且支持多态；HQL主要通过Query来操作，Query的创建方式：</p>
<blockquote>
<p>Query q = session.createQuery(hql);</p>
</blockquote>
<p>1：between.. and..<br>  测试代码：</p>
<blockquote>
<p>List<user> list=session.createQuery(“from User where id between 0 and 2”).list();</user></p>
</blockquote>
<p>2：in /not in</p>
<blockquote>
<p>List<user> list=session.createQuery(“from User where id in (1,2)”).list();</user></p>
</blockquote>
<p>其他如group by，having，聚集函数等都类似于sql语句，换汤不换药。</p>
<p>参数绑定：<br> 先看例子：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">org.hibernate.Query query= session.createQuery("from User where id between ? and ?");</div><div class="line">	      query.setInteger(0, 1);</div><div class="line">	      query.setInteger(1,2);</div><div class="line">	      List&lt;User&gt; list=query.list();</div><div class="line">	      for(User user : list)&#123;</div><div class="line">	  		System.out.println(user.getName());</div><div class="line">	  	&#125;</div></pre></td></tr></table></figure>
<p>主要通过set与？的形式来注入参数，注意这里第一个？对应set的序号为0<br>使用绑定参数的好处:<br>1.可读性好.<br>2.性能提高.<br>3.防止sql注入</p>
<p>HQL语句远不止这些，这里只简单介绍了其中一些，</p>
<p>三：映射文件的配置<br> 映射文件的内容繁多，这里只简单介绍其中一些常见属性。大体说来，映射文件主要对class的映射，还包括属性，属性又分为主键，普通属性和集合属性，甚至还有复合属性，每种属性都需要进行不同的配置。</p>
<p> 先从入门程序中的例子说起：</p>
<blockquote>
<p> <hibernate-mapping package="com.zwl.bean"></hibernate-mapping></p>
<class name="User" table="user">

</class></blockquote>
<p>其中：package : 表示该类在哪个包下，name : 表示类名 table 表示 该类和哪个表映射<br>同时在class内部可以配置各种属性</p>
<p>主键：<br> 主键就是持久化类中标识属性，用于唯一标识该对象，主要通过<id>进行设置，有三个常用属性：name，column，type。<br>  Name  ：表示类的哪个属性是主键   必须指定<br>Column：指定在数据库中主键对应的列明  不必须指定<br>  Type：与数据库中对应字段类型一致  不必须指定<br>例外：主键需指定主键生产策略，即generator，一般用于自增长，针对不同数据库，关键词不一样，由于是mysql，所以自增长选择increment<br>以上的代码表示：</id></p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;id name=<span class="string">"id"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;generator class=<span class="string">"increment"</span>&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div></pre></td></tr></table></figure>
<p>普通属性：<br>  使用<property>标签，该标签必须指定name属性，用于标记持久化类的属性名称。一般有如下常见属性：<br> Type，column，not-null（是否允许为空），lazy（是否支持延迟加载，默认为false不支持），<br>代码如下：</property></p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"name"</span> type=<span class="string">"java.lang.String"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"name"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"age"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"age"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hibernate之二:核心类和接口]]></title>
      <url>http://www.myzwl.win/2017/04/02/hbm2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们对数据进行持久化操作时，必然涉及到hibernate的一些核心类，而这些类是我们在增删改查之前必然要引用和加载的<br>先看总览图：<br><img src="/images/imgs2/26.gif" alt="Alt text"></p>
<p>一般情况下，是由下向上看。</p>
<p>一 ：hibernate.cfg.xml文件<br>①该文件主要用于指定各个参数,是hibernate核心文件<br>    ②默认放在src目录下，也可以放在别的目录下。<br>    ③指定连接数据库的驱动、用户名、密码、url、连接池..<br>    ④指定对象关系映射文件的位置.<br>    ⑤也可使用hibernate.properties文件来替代该文件.(推荐使用<br>hibernate.cfg.xml)。<br>  如：入门程序代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;hibernate-configuration&gt;</div><div class="line">	&lt;session-factory&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.driver_class"</span>&gt;com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span>&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.url"</span>&gt;jdbc:mysql:<span class="comment">//localhost:9806/sshe&lt;/property&gt;</span></div><div class="line">		&lt;property name=<span class="string">"connection.username"</span>&gt;root&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.password"</span>&gt;&lt;/property&gt;</div><div class="line">		&lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt;</div><div class="line">		&lt;property name=<span class="string">"show_sql"</span>&gt;true&lt;/property&gt;</div><div class="line">		&lt;!-- 配置数据库的方言/ --&gt;</div><div class="line">		&lt;property name=<span class="string">"dialect"</span>&gt;org<span class="selector-class">.hibernate</span><span class="selector-class">.dialect</span><span class="selector-class">.MySQL5InnoDBDialect</span>&lt;/property&gt;</div><div class="line">		 &lt;!-- 配置管理的对象映射文件 --&gt;</div><div class="line">		&lt;mapping resource=<span class="string">"com/zwl/bean/User.hbm.xml"</span>/&gt;</div><div class="line">	&lt;/session-factory&gt;</div><div class="line">&lt;/hibernate-configuration&gt;</div></pre></td></tr></table></figure></p>
<p>二：对象关系映射文件(*.hbm.xml)</p>
<p>  ①该文件主要作用是建立表和类的映射关系，是不可或缺的重要文件.<br>  ②一般放在其映射的类同一个目录下,但不是必须的。<br>  ③命名方式一般是 类名.hbm.xml,但不是必须的。<br>  ④示意图:<br><img src="/images/imgs2/27.gif" alt="Alt text"></p>
<p>如：入门程序代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;!-- package : 表示该类在哪个包下 --&gt;</div><div class="line">&lt;hibernate-mapping package=<span class="string">"com.zwl.bean"</span>&gt;</div><div class="line">&lt;!-- name : 表示类名 <span class="selector-tag">table</span> 表示 该类和哪个表映射 --&gt;</div><div class="line">	&lt;class name=<span class="string">"User"</span> table=<span class="string">"user"</span>&gt;</div><div class="line">		&lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt;</div><div class="line">		&lt;!-- name:表示类的哪个属性是主键 --&gt;</div><div class="line">		&lt;id name=<span class="string">"id"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;!-- 指定主键生成策略 --&gt;</div><div class="line">		&lt;generator class=<span class="string">"increment"</span>&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div><div class="line">		&lt;!-- property 里是普通属性 , column表示该属性映射到表中哪个字段 --&gt;</div><div class="line">		&lt;property name=<span class="string">"name"</span> type=<span class="string">"java.lang.String"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"name"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"age"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"age"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>三：Configuration 类<br>它的用处是:</p>
<ol>
<li>读取hibernate.cfg.xml</li>
<li>管理对象关系映射文件 <mapping resource="””"></mapping></li>
<li>加载hibernate 的驱动,url ,用户..</li>
<li>管理hibernate配置信息</li>
</ol>
<p>创建的代码：</p>
<blockquote>
<p>Configuration cf=new Configuration().configure();</p>
</blockquote>
<p>四：SessionFactory （会话工厂）<br>这是典型的工厂设计模式，其是用来生产session实例的，注意由于该工厂启动耗费内存，所以应该只被初始化一次，并且应该是线程安全的，所以应该用单例模式设计</p>
<p>归纳一下特点：<br>1 缓存sql语句和某些数据</p>
<p>2.在应用程序初始化的时候创建,是一个重量级的类(吃内存),一般<br>用单例模式保证一个应用中只需要一个 SessionFactory实例.</p>
<p>3.如果某个应用访问多个数据库，则要创建多个会话工厂实例,一般<br>是一个数据库一个会话工厂实例.</p>
<p>4.通过SessionFactory接口可以获得Session(会话)实例</p>
<p>创建的代码：</p>
<blockquote>
<p>SessionFactory sf=cf.buildSessionFactory();</p>
</blockquote>
<p>五：Session<br> 1.Session一个实例代表与数据库的一次操作<br>(当然一次操作可以是crud组合)</p>
<p> 2.Session实例通过SessionFactory获取，用完<br>需要关闭。</p>
<p> 3.Session是线程不同步的(不安全),因此要保证<br>在同一线程中使用,可以用getCurrentSessiong()。</p>
<p> 4.Session可以看做是持久化管理器,它是与持久<br>化操作相关的接口</p>
<p>如图所示：<br><img src="/images/imgs2/28.gif" alt="Alt text"></p>
<p>另外：有两种方式获得session<br>1：通过openSession()获取session<br>openSession() 是获取一个新的session<br>2 getCurrentSession ()<br>  getCurrentSession () 获取和当前线程绑定的session,换言之，在同一个线程中，我们获取的session是同一session,这样可以利于事务控制</p>
<p>创建的代码：</p>
<blockquote>
<p>Session s=sf.getCurrentSession();<br>//或者是: Session s=sf.openSession();</p>
</blockquote>
<p>如何选择<br>原则:<br>1.如果需要在同一线程中，保证使用同一个Session则，使用getCurrentSession()<br>2.如果在一个线程中，需要使用不同的Session,则使用opentSession()<br>通过 getCurrentSession() 获取的session在事务提交后，会自动关闭，通过openSession()获取的session则必须手动关闭<br>如果是通过getCurrentSession() 获取 sesssion ,进行查询需要事务提交</p>
<p>Session(会话)接口的几个重要方法<br>Session一般以对象的形式来操作<br>    1保存一个对象(记录)—save方法<br>    2删除一个对象(记录)—delete方法<br>    3查询一个对象(记录)—get/load方法<br>    4修改一个对象(记录)—update方法</p>
<p>如：入门程序中的代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Sava方法：User u=new User();</div><div class="line">	   u.setId(1);</div><div class="line">	  u.setName("hello world");</div><div class="line">	  u.setAge(21);</div><div class="line">	 session.save(u);</div><div class="line">	 t.commit();</div><div class="line"></div><div class="line"></div><div class="line">Delete方法：User u=(User)session.get(User.class, 1);</div><div class="line">		    session.delete(u);</div><div class="line">		    t.commit();</div></pre></td></tr></table></figure>
<p>一般情况下，我们从数据库中获取对象，可以通过session.get（或者session.load（）），那么他们有什么区别了？<br>1、get()方法直接返回实体类,如果查不到数据则返回null。load()会<br>    返回一个实体代理对象（当前这个对象可以自动转化为实体对象），<br>    但当代理对象被调用时，如果没有数据不存在，就会抛出个<br>    org.hibernate.ObjectNotFoundException异常</p>
<p>这里：可以将get看做单例中的饿汉式，而load相当于懒汉式</p>
<ol>
<li><p>load先到缓存(session缓存/二级缓存)中去查，如果没有则返回一个<br>代理对象（不马上到DB中去找），等后面使用这个代理对象操作的时<br>候，才到DB中查询,这就是我们常说的 load在默认情况下支持延迟加<br>载（lazy）</p>
</li>
<li><p>get先到缓存(session缓存/二级缓存)中去查，如果没有就到DB中去<br> 查（即马上发出sql）。总之，如果你确定DB中有这个对象就用<br> load(),不确定就用get()（这样效率高）</p>
</li>
</ol>
<p>这里有一点注意：默认lazy加载时不启用，所以如果要启用，则需要在映射文件中配置</p>
<blockquote>
 <class name="User" table="user" lazy="true">

</class></blockquote>
<p>六：Transaction(事务)接口<br>    事务简单的说,就是一组对数据库的操作集合,它们要么全部成功,要<br>么全部失败.这个可以保证数据的一致性,事务具有原子性。</p>
<p>创建的代码：</p>
<blockquote>
<p>Transaction ts=s.beginTransaction();<br> …<br>ts.commit();s.close()； </p>
</blockquote>
<p>注意：如果数据库的数据发生变化，一定需要数据提交</p>
<p>七：Criteria接口<br>如入门程序的查询：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;User&gt; list=session.createCriteria(User.class).list();</div><div class="line">		for(User user : list)&#123;</div><div class="line">			System.out.println(user.getName());</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>即通过面向对象的操作，返回该对象所有的集合</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hibernate之一:hello world]]></title>
      <url>http://www.myzwl.win/2017/04/01/hbm1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对一个框架的直观认识，往往是从一个hello world程序开始的。Hibernate是一个完全的ORM（Object Relationship Mapping）对象映射框架。实现了JDBC轻量级的封装，使得在进行JDBC开发的时候可以直接使用面向对象的思维进行开发，说白了hibernate框架的作业就是在java对象和关系数据库中作了一个映射，使得程序员不用再使用各种SQL语句</p>
<p>Hibernate有如下几个特点：<br>  1：完成了对JDBC的封装，不用再与各种connection打交道<br> 2：是一个持久层框架，即对数据库进行持久化操作<br> 3：是一个ORM框架，不用再与各种sql打交道</p>
<p>接下里就是hibernate入门程序，目的先有一个直观认识，不考虑其含义，只要把流程走一遍就完成了目的。这里用最简的方式完成入门程序</p>
<p>步骤一：创建一个java 工程</p>
<p>步骤二：建一个lib文件夹，并导入如下jar包，然后添加至项目中<br><img src="/images/imgs2/25.gif" alt="Alt text"></p>
<p>步骤三：在src目录下创建一个hibernate.cfg.xml配置文件，并编写，同时添加mysql驱动包<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</div><div class="line">	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</div><div class="line">	"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;</div><div class="line">&lt;!-- 该文件用于配置连接数据的种类,用户名，密码,ul ,驱动.. 连接池,二级缓存 --&gt;</div><div class="line">&lt;hibernate-configuration&gt;</div><div class="line">	&lt;session-factory&gt;</div><div class="line">		&lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;</div><div class="line">		&lt;property name="connection.url"&gt;jdbc:mysql://localhost:9806/sshe&lt;/property&gt;</div><div class="line">		&lt;property name="connection.username"&gt;root&lt;/property&gt;</div><div class="line">		&lt;property name="connection.password"&gt;yourpassword&lt;/property&gt;</div><div class="line">		&lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt;</div><div class="line">		&lt;property name="show_sql"&gt;true&lt;/property&gt;</div><div class="line">		&lt;!-- 配置数据库的方言/ --&gt;</div><div class="line">		&lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;</div><div class="line">	&lt;/session-factory&gt;</div><div class="line">&lt;/hibernate-configuration&gt;</div></pre></td></tr></table></figure></p>
<p>简单说明一下：上面的配置文件指明了一些必要的数据库连接属性，通过这些属性，hibernate可以连接上数据库，可以配置不同的数据库，其中配置数据库的方言指明所配置的是用哪种数据库</p>
<p>步骤四：创建bean对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.zwl.bean;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line"></div><div class="line">	private int age;</div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">。。。此处省略set与get方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里注意：利用hibernate框架时，鼓励我们为每张表设置主键，即为每个对象设置一个id，在映射时与表的id对应</p>
<p>步骤五：创建数据库表，这个步骤也可以在步骤四之前进行。<br>主要为id（主键，自增长），name、age</p>
<p>步骤六：编写表与对象的映射文件User.hbm.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!--该文件要清楚地表述出 类 和 表 的对应关系--&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</div><div class="line">	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">	"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line">&lt;!-- package : 表示该类在哪个包下 --&gt;</div><div class="line">&lt;hibernate-mapping package="com.zwl.bean"&gt;</div><div class="line">&lt;!-- name : 表示类名 table 表示 该类和哪个表映射 --&gt;</div><div class="line">	&lt;class name="User" table="user"&gt;</div><div class="line">		&lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt;</div><div class="line">		&lt;!-- name:表示类的哪个属性是主键 --&gt;</div><div class="line">		&lt;id name="id" type="java.lang.Integer"&gt;</div><div class="line">		&lt;!-- 指定主键生成策略 --&gt;</div><div class="line">		&lt;generator class="increment"&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div><div class="line">		&lt;!-- property 里是普通属性 , column表示该属性映射到表中哪个字段 --&gt;</div><div class="line">		&lt;property name="name" type="java.lang.String"&gt;</div><div class="line">		&lt;column name="name" not-null="false"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="age" type="java.lang.Integer"&gt;</div><div class="line">		&lt;column name="age" not-null="false"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>简单说明一下：上面已经简要说明了一些含义，这里先看做强加的概念，事实上这是比较完整的配置，当然这里并没有给出简化的配置。同时，该文件相当于在java对象和数据库表中作了一个映射，这样以后就可以通过操作java对象来间接操作表<br> 另外，该映射文件一般放在与相应的java对象同处一个文件夹下，并且命名满足规范XXX.hbm.xml，其中xxx就是java对象名，最后还要在hibernate核心配置文件中声明该映射，即加入如下代码：</p>
<blockquote>
 <mapping resource="com/zwl/bean/User.hbm.xml">

</mapping></blockquote>
<p> 步骤六：就是进行测试，实现插入数据的crud操作</p>
<p> 首先写一个工具类：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utils;</div><div class="line"></div><div class="line">import org.hibernate.SessionFactory;</div><div class="line">import org.hibernate.cfg.Configuration;</div><div class="line"></div><div class="line">public class HibernateUtils &#123;</div><div class="line">    private static final SessionFactory sessionFactory=BuildSessionFactory();</div><div class="line">    </div><div class="line">    private static SessionFactory BuildSessionFactory()&#123;</div><div class="line">    	try &#123;</div><div class="line">			return new Configuration().configure().buildSessionFactory();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			throw new ExceptionInInitializerError(e);</div><div class="line">		&#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	public static SessionFactory getSessionFactory()&#123;</div><div class="line">		return sessionFactory;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单说明一下，这里采用单例模式，目的是为了不要每次都加载配置，不然太耗费内存</p>
<p>接下来是测试类，首先是增加功能<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Usertest &#123;</div><div class="line"></div><div class="line">	SessionFactory sessionFactory=HibernateUtils.getSessionFactory();</div><div class="line">	Session session=sessionFactory.openSession();</div><div class="line">	Transaction t=session.beginTransaction();</div><div class="line"></div><div class="line">@Test</div><div class="line">public void save()&#123;</div><div class="line">	User u=new User();</div><div class="line">	u.setId(1);</div><div class="line">	u.setName("hello world");</div><div class="line">	u.setAge(21);</div><div class="line">	</div><div class="line">	session.save(u);</div><div class="line">	t.commit();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来是查询（遍历）<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//查询</div><div class="line">	@Test</div><div class="line">	public void select()&#123;</div><div class="line">		List&lt;User&gt; list=session.createCriteria(User.class).list();</div><div class="line">		for(User user : list)&#123;</div><div class="line">			System.out.println(user.getName());</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>最后是删除：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//删除</div><div class="line">	@Test</div><div class="line">	public void delete()&#123;</div><div class="line">		User u=(User)session.get(User.class, 1);</div><div class="line">		session.delete(u);</div><div class="line">		t.commit();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>修改这里就先不说了。<br>至此入门程序完成，意在了解hibernate的具体过程，有没有发现，到目前为止，我们都没有写sql语句，而都是对java对象进行操作，来操作表</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之六:拦截器]]></title>
      <url>http://www.myzwl.win/2017/03/31/structs6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拦截器是structs2框架的核心功能，理解并使用拦截器有助于更灵活使用structs2.它像一个可插播的组件，围绕action和result进行，可以在方法调用之前、之后使用。通过structs2的工作流程，可以发现调用一个action之前之后有许多的拦截器，这些拦截器都通过后才可以执行具体的action。对与每一个拦截器来说，可以直接返回，从而终止余下的拦截器</p>
<p>以下，是structs工作原理图<br><img src="/images/imgs2/24.gif" alt="Alt text"></p>
<p>从图中可以看出，从一个具体的请求到action需要经过多个拦截器，action处理完成后，后续的拦截器会据需执行，最终到浏览器中。大概其工作流程如下</p>
<p>上述的servlet filters图示与实际有点不一样，其他一样（图不是现在版本）</p>
<p>一 首先请求发送给StrutsPrepareAndExecuteFilter（web.xml配置那个）</p>
<p>二：StrutsPrepareAndExecuteFilter判断该请求是否是一个structs2请求，如果是则进入第3步</p>
<p>三：如果是structs2请求，则把请求交给ActionProxy，是action代理类，ActionProxy创建一个Actioninvocation实例，并进行初始化</p>
<p>在执行具体的action之前，actionProxy会设计相关拦截器的调用<br>Action调用结束后，会根据structs.xml文件中action的result配置对象得到对应的返回结果。调用execute方法之后，执行后面的拦截器，把结果返回给浏览器</p>
<p>从整个请求处理过程来看，拦截器是处理的关键</p>
<p>下面将通过实现Interceptor接口来写一个简单的拦截器，<br>该接口有三个方法，init（），destroy（），intercept（），init（）在拦截器实例创建之后，intercept方法之前调用，主要用于初始化拦截器所需要的资源，destroy主要销毁初始化分配的资源，intercept方法则是在action之前调用，可以通过invocation对象获取action状态，从而根据状态的不同进行需要的拦截操作<br> 如下为一个简单的模拟案例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import com.opensymphony.xwork2.ActionInvocation;</div><div class="line">import com.opensymphony.xwork2.interceptor.Interceptor;</div><div class="line"></div><div class="line">public class lanji implements Interceptor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void destroy() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void init() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String intercept(ActionInvocation invocation) throws Exception &#123;</div><div class="line">		long start=System.currentTimeMillis();</div><div class="line">		String result=invocation.invoke();//没有拦截，正常执行</div><div class="line">		long end=System.currentTimeMillis();</div><div class="line">		System.out.println(end-start);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就需要在配置文件中配置<br>首先申明该拦截器<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;interceptors&gt;</div><div class="line">		&lt;interceptor name=<span class="string">"lanji"</span> class=<span class="string">"com.zwl.pojo.lanji"</span>&gt;&lt;/interceptor&gt;</div><div class="line">		&lt;/interceptors&gt;</div><div class="line">在action中引用</div><div class="line">&lt;action name=<span class="string">"ognlaction"</span> class=<span class="string">"com.zwl.action.ognlaction"</span>&gt;</div><div class="line">  &lt;interceptor-ref name=<span class="string">"lanji"</span>&gt;&lt;/interceptor-ref&gt;</div><div class="line">			 &lt;interceptor-ref name=<span class="string">"defaultStack"</span>&gt;&lt;/interceptor-ref&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>注意必须要带上默认拦截器</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之五:通用标签]]></title>
      <url>http://www.myzwl.win/2017/03/30/structs5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> Struts2框架为我们提供了许多标签，这些标签从总体上可以分为两类：通用标签和ui标签。而较常使用的是通用标签，通用标签又分为两类，数据标签和控制标签。数据标签用于访问值栈中的数据。控制标签用于控制呈现页面时数据执行流程。</p>
<p> 不过使用structs2标签，需要在jsp首部加入如下代码</p>
<blockquote>
<p> &lt;%@ taglib uri=”/struts-tags” prefix=”s” %&gt;</p>
</blockquote>
<p>数据标签<br> 主要用于访问actioncontext和值栈中的数据</p>
<p>一：property标签</p>
<blockquote>
<p>格式：<s:property value="””default=””" escape="”true|false”/"></s:property></p>
</blockquote>
<p>如果value中的内容为object，则Struts2都会把它解析成ognl表达式<br>     如果里面需要表示为字符串，则需要将内容用单引号括起来</p>
<p>1、  利用ognl表达式取值(例如：取值堆栈中的username值)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"username"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>2、  取值为字符串<br>需要将内容用单引号括起来<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"’username’"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>3、  设置默认值-default<br>如果一个对象值取不到，则可以使用default设置一个默认值。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"admin"</span> default=”管理员”/&gt;</div></pre></td></tr></table></figure></p>
<p>4、  设定HTML-escape<br>是否设置返回值为HTML原代码样式<br>true：解析返回值的html代码　false:原封不动返回值<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"'&lt;hr/&gt;'"</span> escape=<span class="string">"false"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>二、 set标签<br>注：var　用于设定变量名<br>     value 变量值(可以是ognl表达式)，也可以是字符串<br>         scope 就是的作用范围 request session page application action(默认)</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;li&gt;set 设定adminName值（默认为request 和 ActionContext）: &lt;s:set var=<span class="string">"adminName"</span>value=<span class="string">"username"</span> /&gt;&lt;/li&gt;</div><div class="line">      </div><div class="line">&lt;li&gt;set 从request取值: &lt;s:property value=<span class="string">"#request.adminName"</span> /&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;set 从ActionContext取值: &lt;s:property value=<span class="string">"#adminName"</span> /&gt;&lt;/li&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;li&gt;set 设定var，范围为ActionContext: &lt;s:set var=<span class="string">"adminPassword"</span> value=<span class="string">"password"</span>scope=<span class="string">"session"</span>/&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;set 使用#取值: &lt;s:property value=<span class="string">"#adminPassword"</span>/&gt; &lt;/li&gt;</div><div class="line">&lt;li&gt;set 从相应范围取值: &lt;s:property value=<span class="string">"#session.adminPassword"</span>/&gt; &lt;/li&gt;</div></pre></td></tr></table></figure>
<p>控制标签<br> 一： If  elseif  else<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">age = &lt;s:property value=<span class="string">"#parameters.age[0]"</span> /&gt; &lt;br /&gt;</div><div class="line">     &lt;s:set var=<span class="string">"age"</span> value=<span class="string">"#parameters.age[0]"</span> /&gt;</div><div class="line">     &lt;s:<span class="keyword">if</span> test=<span class="string">"#age &lt; 0"</span>&gt;wrong age!&lt;/s:<span class="keyword">if</span>&gt;</div><div class="line">     &lt;s:elseif test=<span class="string">"#parameters.age[0] &lt; 20"</span>&gt;too young!&lt;/s:elseif&gt;</div><div class="line">     &lt;s:<span class="keyword">else</span>&gt;yeah!&lt;/s:<span class="keyword">else</span>&gt;&lt;br /&gt;</div></pre></td></tr></table></figure></p>
<p>二：Iterator标签<br>一般格式如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> &lt;s:iterator value=<span class="string">"值"</span> var=<span class="string">"x"</span>&gt;</div><div class="line">&lt;s:property value=<span class="string">"#x.username"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>这个格式将集合里的内容取出<br>该属性一般有三个属性，id，status，value<br>其中value属性指定迭代的集合，status属性可以获得迭代中一个状态信息（比如索引值，是否是奇偶数等）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;s:iterator value="&#123;'aaa', 'bbb', 'ccc'&#125;" status="status"&gt;</div><div class="line">          &lt;s:property/&gt; |</div><div class="line">          遍历过的元素总数：&lt;s:property value="#status.count"/&gt; |</div><div class="line">          遍历过的元素索引：&lt;s:property value="#status.index"/&gt; |</div><div class="line">          当前是偶数？：&lt;s:property value="#status.even"/&gt; |</div><div class="line">          当前是奇数？：&lt;s:property value="#status.odd"/&gt; |</div><div class="line">          是第一个元素吗？：&lt;s:property value="#status.first"/&gt; |</div><div class="line">          是最后一个元素吗？：&lt;s:property value="#status.last"/&gt;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之四:OGNL表达式]]></title>
      <url>http://www.myzwl.win/2017/03/29/structs4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OGNL表达式的全称是 Object Graph Navigation Language，即 对象图导航语言，使用OGNL表达式可以使用简单的语法设置以及读取java对象的值</p>
<p>一般， <s:property value="””">　注意：  value里的内容称为ognl表达式，由于其功能强大，涉及东西太多，只做部分总结</s:property></p>
<p>下面就先模拟一个案例，首先需要几个模拟的对象类<br>首先是Dog类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private String name;</div><div class="line">   </div><div class="line">	public Dog(String name)&#123;</div><div class="line">		this.name=name;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Dog()&#123;&#125;</div><div class="line">此处省略set。。get方法</div></pre></td></tr></table></figure></p>
<p>然后是Cat类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private Dog friend;</div><div class="line">	</div><div class="line">	public String miaomiao()</div><div class="line">	&#123;</div><div class="line">		return "miaomiao";</div><div class="line">	&#125;</div><div class="line">此处省略set。。get方法</div></pre></td></tr></table></figure></p>
<p>接着是user类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private String msg;</div><div class="line"></div><div class="line">public user()&#123;&#125;</div><div class="line"></div><div class="line">public user(String msg)&#123;</div><div class="line">	this.msg=msg;</div><div class="line">&#125;</div><div class="line">此处省略set。。get方法</div></pre></td></tr></table></figure></p>
<p>在配置文件中，仍然不变</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">  &lt;global-results&gt;</div><div class="line">  &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">  &lt;/global-results&gt;</div><div class="line">  </div><div class="line">  &lt;action name=<span class="string">"ognlaction"</span> class=<span class="string">"com.zwl.action.ognlaction"</span>&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure>
<p>下面是action，思路是在action中一点一点加入模拟代码，在相应的jsp中将值回显出来<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class ognlaction extends ActionSupport&#123;</div><div class="line">  private String username;</div><div class="line">	public String execute() throws Exception &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return super.execute();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下面所以属性的set与get方法都将省略。。<br>首先是验证普通属性，对应jsp页面为</p>
<p>1：<li>访问值栈中的action的普通属性:</li></p>
<blockquote>
<p>username = <s:property value="username"> </s:property></p>
</blockquote>
<p>2：访问值栈中对象的普通属性(get set方法)：</p>
<blockquote>
<p>首先action增加 private user use;<br>对应jsp为：<s:property value="use.msg"></s:property></p>
</blockquote>
<p>3访问值栈中对象中的成员对象的普通属性(get set方法)</p>
<blockquote>
<p>首先action增加：private Cat cat;<br>对应jsp为：<s:property value="cat.friend.name"></s:property></p>
</blockquote>
<p>4访问值栈中对象的普通方法<br><s:property value="cat.miaomiao()"></s:property></p>
<p>5访问值栈中action的普通方法<br>首先action增加：public String m() {<br>             return “hello”;}<br>对应jsp为：<s:property value="m()"></s:property></p>
<p>6 OGNL表达式语言访问静态方法，需要在Struts2.xml配置文件如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;constant name=<span class="string">"struts.ognl.allowStaticMethodAccess"</span> value=<span class="string">"true"</span>&gt;&lt;/constant&gt;</div></pre></td></tr></table></figure>
<p>首先增加一个pojo类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class s &#123;</div><div class="line">	 public static String STR = "STATIC STRING";  </div><div class="line">	  public static String s() &#123;</div><div class="line">	     return "static method";  &#125;&#125;</div></pre></td></tr></table></figure>
<p>对应jsp：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;li&gt;访问静态方法：&lt;s:property value=<span class="string">"@com.zwl.pojo.s@s()"</span>/&gt;&lt;/li&gt;</div><div class="line">       &lt;li&gt;访问静态属性：&lt;s:property value=<span class="string">"@com.zwl.pojo.s@STR"</span>/&gt;&lt;/li&gt;</div><div class="line">       &lt;li&gt;访问Math类的静态方法：&lt;s:property value=<span class="string">"@@max(2,3)"</span> /&gt;&lt;/li&gt;</div></pre></td></tr></table></figure></p>
<p>注意使用@符号访问</p>
<p>7访问List中元素某个属性的集合中的特定值：<br>首先action增加<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private List&lt;user&gt; users=new ArrayList&lt;&gt;();</div><div class="line">public ognlaction()&#123;</div><div class="line">		users.add(new user("1"));</div><div class="line">		users.add(new user("2"));</div><div class="line">		users.add(new user("3"));</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>对应jsp为：<s:property value="users[0].msg"></s:property></p>
<p>8：访问Set中某个元素<br>首先action增加：</p>
<blockquote>
<p>private Set<dog> dogs = new HashSet<dog>();</dog></dog></p>
</blockquote>
<p>对应jsp为：<s:property value="dogs[1]"></s:property></p>
<p>9：访问Map中某个元素<br>首先action增加：</p>
<blockquote>
<p>private Map<string, dog=""> dogMap = new HashMap<string, dog="">();<br>  <li>访问Map中某个元素:<s:property value="dogMap['dog101']"></s:property></li><br>               <li>访问Map中所有的key:<s:property value="dogMap.keys"></s:property></li><br>       <li>访问Map中所有的value:<s:property value="dogMap.values"></s:property></li></string,></string,></p>
</blockquote>
<p>  10：调试：   <s:debug></s:debug><br>主要用来查看值栈。而值栈主要来存放对象的，类似于正常的栈，</p>
<p>以下为部分结果截图：<br><img src="/images/imgs2/23.gif" alt="Alt text"></p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之三:result返回结果]]></title>
      <url>http://www.myzwl.win/2017/03/28/structs3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Structs2中的result是作为返回结果的，当一个action处理完之后返回字符串的结果码。框架可以根据这个返回的字符串，映射到指定的页面。Result元素可以分为两部分：一是结果映射，一部分是返回结果类型</p>
<p>结果映射<br>  Result有两个属性可以配置：name属性和type属性，其中name属性主要用来指定资源的逻辑名称，实际名称在标签内指定。Type属性就是result返回的类型，这两个属性不是必须的。其中默认情况下，name为success，type为dispatch（转发）<br>另外，result标签还有一个子标签param，该标签可以为result指定实际资源位置，其中属性name为必填，而当type为dispatch时，param可以省略不写</p>
<p>针对上面，不妨先模拟一个案例<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;result type=<span class="string">"dispatcher"</span>&gt;</div><div class="line">&lt;param name=<span class="string">"location"</span>&gt;/success.jsp&lt;/param&gt;</div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>这里的location是用于指示资源的位置，标签内的内容是参数的值</p>
<p>对应我们习惯写的形式为<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;result name=<span class="string">"success"</span>&gt;</div><div class="line">/success<span class="selector-class">.jsp</span></div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>结果类型：<br> 常用的有四种，dispatch、redirect、redirectAction和chain，其中dispatch相当于转发，redirect相当于重定向，redirectAction也是重定向，但是它是重定向到某个action，而chain则是利用action的链式处理</p>
<p>第一种：dispatch<br> 它是系统默认的结果类型，其有两个属性，localtion和parse，配置如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> &lt;result type=<span class="string">"dispatcher"</span>&gt;</div><div class="line">&lt;param name=<span class="string">"location"</span>&gt;/success.jsp&lt;/param&gt;</div><div class="line">&lt;param name=<span class="string">"parse"</span>&gt;true&lt;/param&gt;</div><div class="line">  &lt;/result&gt;</div></pre></td></tr></table></figure></p>
<p>其中parse是一个布尔类型，当为true时，表示解析localtion参数中的OGNL表达式，默认是true</p>
<p>第二种：redirect<br>  当使用该类型时，框架后台会使用response对象的sendRedirect方法进行重定向，下面先简单对比一下重定向与转发的区别：<br>一：重定向会发生两次请求，转发只会发生一次请求<br>      重定向的时候，浏览器的地址栏会发生变化，而转发的地址栏是无变化的<br>      重定向的实质是服务器告诉浏览器去另外的地方寻找资源，所以地址栏会发生变化，而转发则是在服务器内部发生的，所以地址栏不会发生变化<br>      由于重定向是两次请求，所以第二次请求的会话保存的信息是无效的，而转发的时候会话仍然有效，因为请求不变<br>      对于重定向中会话仍然有效的方法是在配置文件中使用OGNL表达式，将参数传递过去<br>对于以上内容，不妨一个实例来的具体点</p>
<p>首先是上面的dispatch<br>如之前的hello world入门程序，最终观察地址栏和参数是可以接收到的</p>
<p>当type为redirect时<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;result type=<span class="string">"redirect"</span>&gt;</div><div class="line">/success<span class="selector-class">.jsp</span></div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>观察地址栏是显示jsp的，但是参数是无法接收到的<br>那么如何解决了？<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;action name="helloworld" class="com.zwl.action.helloworld"&gt;</div><div class="line">  &lt;result name="success" type="redirect"&gt;</div><div class="line">/success.jsp?user=$&#123;use.msg&#125;</div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>即带一个参数，注意此时的话，在success.jsp中值就不在值栈中了，因为不经过action，所以应该用如下方法取出<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;s:property value=<span class="string">"#parameters.user"</span>/&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>第三种：redirectAction，<br>其底层都是通过Response对象的sendRedirect方法进行重定向的，只不过它是重定向到某个action，所以如果一个action处理完之后还要交给另一个action据需处理，则使用该类型。<br>它的结果类型有两个参数，actionName（指定需要重定向的action）和namespace（指定action所在的命名空间，如果没有指定该参数，框架会从默认的namespace中去寻找）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">   &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">   &lt;result type=<span class="string">"redirectAction"</span>&gt;</div><div class="line">   &lt;param name=<span class="string">"actionName"</span>&gt;helloworld1&lt;/param&gt;</div><div class="line">   &lt;param name=<span class="string">"namespace"</span>&gt;/&lt;/param&gt;</div><div class="line">   &lt;/result&gt;</div><div class="line">   &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>第四种：chain<br>一样，也是跳转到某个action<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"r3"</span>&gt;</div><div class="line">        &lt;result type=<span class="string">"chain"</span>&gt;r1&lt;/result&gt;</div><div class="line">        &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>接下来，进行简单对比<br>Redirect和redirectAciton都是客户端跳转，<br>而dispatch和chain都是服务器端跳转</p>
<p>全局action：<br>当有多个action都需要返回某个页面的时候，就可以用到全局结果<br>即在同一个包下所有的action都共享该result，如下所示<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;global-results&gt;</div><div class="line">  &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">  &lt;/global-results&gt;</div><div class="line">  </div><div class="line">  &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>仍然操作之前的步骤，结果仍能执行全局中的result</p>
<p>Namespace<br>Namespace决定了action的访问路径，默认为“”，可以接收所有路径的action，如果没有找到相应的namespace时，则使用namespace为空的action<br>Namespace可以写为/，或者/xxx,或者/xxx/yyy，对应的action访问路径为/index.action、/xxx/index.action、或者/xxx/yyy/index.action.<br>Namespace最好也用模块来进行命名</p>
<p><package>标签</package></p>
<p><package>是用来解决重名的问题，例如当系统的前台和后台都有一个action名叫hello，这时就需要用package来区分。    前台<package name="front">后台<package name="back"><br>struts2中的package与java的package是相同的作用的</package></package></package></p>
<p>访问Web元素<br>Action中的会话一般有三种request,session,application，但是他们都是map类型<br>一般情况下有四种方式可以获得</p>
<p>方法一：ActionContext方式<br>一般在Action类的构造方法、或execute()方法中获取<br>如下案例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class LoginAction1 extends ActionSupport&#123;</div><div class="line">  private Map request;</div><div class="line">  private Map session;</div><div class="line">  private Map application;</div><div class="line"></div><div class="line">  public LoginAction1() &#123;</div><div class="line">	  request=(Map) ActionContext.getContext().get("request");</div><div class="line">	  session=ActionContext.getContext().getSession();</div><div class="line">	  application=ActionContext.getContext().getApplication();</div><div class="line">  &#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public String execute() throws Exception &#123;</div><div class="line">	       request.put("r1", "r1");</div><div class="line">	       session.put("s1", "s1");</div><div class="line">	       application.put("a1", "a1");</div><div class="line"></div><div class="line">		return super.execute();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>然后在页面中可以通过标签或者java片段取出<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value="#request.r1"/&gt; | &lt;%=request.getAttribute("r1") %&gt; &lt;br /&gt;</div><div class="line">    &lt;s:property value="#session.s1"/&gt; | &lt;%=session.getAttribute("s1") %&gt; &lt;br /&gt;</div><div class="line">&lt;s:property value="#application.a1"/&gt; | &lt;%=application.getAttribute("a1") %&gt; &lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>方式二：Ioc(控制反转)—推荐使用<br>让Action类实现RequestAware、SessionAware、ApplicationAware接口，然后重写他们的set方法(setRequest、setSession、setApplication)，通过依赖注入、控制反转(原来自己控制，现在由别人来控制值。)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class LoginAction2 extends ActionSupport implements RequestAware,SessionAware, ApplicationAware &#123;</div><div class="line">    private Map&lt;String, Object&gt; request;</div><div class="line">    private Map&lt;String, Object&gt; session;</div><div class="line">    private Map&lt;String, Object&gt; application;</div><div class="line">  public String execute() &#123;</div><div class="line">       request.put("r1", "r1");</div><div class="line">       session.put("s1", "s1");</div><div class="line">       application.put("a1", "a1");</div><div class="line">       return SUCCESS;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void setRequest(Map&lt;String, Object&gt; request) &#123;</div><div class="line">       this.request = request;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void setSession(Map&lt;String, Object&gt; session) &#123;</div><div class="line">       this.session = session;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void setApplication(Map&lt;String, Object&gt; application) &#123;</div><div class="line">       this.application = application;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方式三：获取原类型<br>获取是的HttpServletRequest/HttpSession/ServletContext<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private HttpServletRequest request;</div><div class="line">    private HttpSession session;</div><div class="line">    private ServletContext application;</div><div class="line">    public LoginAction3() &#123;</div><div class="line">       request = ServletActionContext.getRequest();</div><div class="line">       session = request.getSession();</div><div class="line">       application = session.getServletContext();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>一般情况下只用前三种，第四种就不说了</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之二:action详解]]></title>
      <url>http://www.myzwl.win/2017/03/27/structs2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在structs2中，action是其核心功能，而使用structs2框架，主要都是围绕action进行，我们编写的action通常需要实现com.opensymphony.xwork2.Action接口，需要实现的方法时execute方法，但是在实际开发中，编写的action也可以不必实现action接口，而是直接创建一个普通的java类，并添加execute方法就可以，如入门程序的案例，还有一种方式就是继承ActionSupport类，其已经实现了action的execute方法，以上方式，后两者比较常用</p>
<p>接下来将在入门程序的基础上，来介绍action属性</p>
<p> 一：action属性<br>  Action中有一个映射框架，主要讲url映射到对应的action，action的配置主要在struts.xml文件中编写，</p>
<p>  以下是action的几个常见属性</p>
<blockquote>
<p>属性       是否必须       说明<br>Name       是           action的名字，用于匹配请求的url<br>Class        否           action实现类的完整类名<br>Method     否            调用action实现类中指定的方法</p>
</blockquote>
<p>需要注意的是，action的name属性有规范，即不允许出现.或者/或者-，另外我们来看看如果只配置一个name属性，class怎么加载？<br>理论上是框架会调用actionsupport类中的execute方法，该方法的实现仅仅是返回一个success，但是实际上去掉之后，入门程序中跳转正确，但是数据取不到，至少说明的确跳转正确，</p>
<p>下面对method属性进行说明<br>由之前我们知道通常action的作用是完成一个功能点，但是如果同时又crud方法，显然创建四个action就太麻烦了，这时候就可以使用method属性，至于怎么用，先看一个实例。<br>即对用户进行增删该查</p>
<p>首先是useraction.java</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import com.opensymphony.xwork2.ActionSupport;</div><div class="line"></div><div class="line">public class useraction extends ActionSupport&#123;</div><div class="line"></div><div class="line">	//查询</div><div class="line">	public String selectall()&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//更新</div><div class="line">	public String update()</div><div class="line">	&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//删除</div><div class="line">	public String delete()</div><div class="line">	&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//添加</div><div class="line">	public String add()&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里注意一下，在action中并不一定非要需要写execute方法，也可以自己指定需要的方法，但是必须要在Struts.xml中做相应的配置，如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">       &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"selectall"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">        &lt;action name=<span class="string">"helloworld1"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"update"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">        &lt;action name=<span class="string">"helloworld2"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"delete"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">        &lt;action name=<span class="string">"helloworld3"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"add"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">&lt;/package&gt;</div></pre></td></tr></table></figure></p>
<p>然后在前台页面写需要调用的action<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> &lt;<span class="selector-tag">form</span> action=<span class="string">"helloworld.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>显然我们发现用此种方法思路清晰，但是太啰嗦，这就是有时需要动态调用action，简称DMI，<br>先看一个例子，<br>首先是useraction1.java<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class useraction1 extends ActionSupport&#123;</div><div class="line"></div><div class="line">	private String msg;</div><div class="line">	</div><div class="line">	public String getMsg() &#123;</div><div class="line">		return msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setMsg(String msg) &#123;</div><div class="line">		this.msg = msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">		//查询</div><div class="line">		public String selectall()&#123;</div><div class="line">			return "selectall";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//更新</div><div class="line">		public String update()</div><div class="line">		&#123;</div><div class="line">			return "update";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//删除</div><div class="line">		public String delete()</div><div class="line">		&#123;</div><div class="line">			return "delete";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//添加</div><div class="line">		public String add()&#123;</div><div class="line">			return "add";</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们可以通过自定义方法返回不同的值，然后通过result中name属性配置相应不同的值，来返回到不同的界面<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里是是否启用DMI方法，默认是关闭的</span></div><div class="line">&lt;constant name=<span class="string">"struts.enable.DynamicMethodInvocation"</span> value=<span class="string">"true"</span> /&gt; </div><div class="line"><span class="comment">//这里是否启用开发者模式，这样就不用每次重启服务器</span></div><div class="line">    &lt;constant name=<span class="string">"struts.devMode"</span> value=<span class="string">"true"</span> /&gt;</div><div class="line">    </div><div class="line">    &lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">     &lt;action name=<span class="string">"useraction1"</span> class=<span class="string">"com.zwl.action.useraction1"</span>&gt;</div><div class="line">     &lt;result name=<span class="string">"selectall"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;result name=<span class="string">"update"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;result name=<span class="string">"delete"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;result name=<span class="string">"add"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;/action&gt;</div><div class="line">&lt;/package&gt;</div></pre></td></tr></table></figure></p>
<p>好了，配置文件也配置好了，接下来就是在页面中调用DMI方法，一般的格式是actionname!xxx.action<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"useraction1!delete.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>至此动态调用action已完成，接下来将是默认的action配置<br>默认的action<br>先看配置实例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">    &lt;default-action-ref name=<span class="string">"helloworld"</span>&gt;&lt;/default-action-ref&gt;</div><div class="line"></div><div class="line">   &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"selectall"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>在表单中跳转到一个不存在的action时，则执行设置的默认action，这里需要注意的是每个namespace下，只能有一个默认的action，否则不知道执行那个默认的action</p>
<p>通配符映射<br> 使用通配符，可以将配置量降到最低，不过一定要实现约定好命名规范，即约定优于配置原则<br>在action配置中，<em>表示所有，可以匹配任意的字符，而{数字}表示第几个通配符，如
</em>_<em>，{1}表示第一个</em>，{2}表示第二个*<br>接下来模拟一个案例，如下所示<br>首先是action<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class useractionsave extends ActionSupport&#123;</div><div class="line">   </div><div class="line">	private String msg;</div><div class="line"></div><div class="line">	public String getMsg() &#123;</div><div class="line">		return msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setMsg(String msg) &#123;</div><div class="line">		this.msg = msg;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String save()&#123;</div><div class="line">		return "save";</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"useraction*"</span> class=<span class="string">"com.zwl.action.useraction&#123;1&#125;"</span> method=<span class="string">"&#123;1&#125;"</span>&gt;</div><div class="line">  &lt;result name=<span class="string">"save"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div><div class="line"></div><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"useractionsave.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>最后测试通过</p>
<p>最后介绍一下action的属性接受参数<br>事实上action中有三种方法</p>
<p>方法一：在Action添加成员属性接受参数<br>之前的案例都是采用这种方法的，就不多介绍了，不过值得注意的是，参数提交的名称必须和action的属性一致，并且要有set与get方法</p>
<p>方法二： 域模型(Domain Model)<br>就是先创建一个对象，通过在action中操作其属性来传递参数，相应的先建立一个user对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class user &#123;</div><div class="line">private String msg;</div><div class="line"></div><div class="line">public String getMsg() &#123;</div><div class="line">	return msg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setMsg(String msg) &#123;</div><div class="line">	this.msg = msg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">然后是action</div><div class="line">	private user use;</div><div class="line">	</div><div class="line">	public user getUse() &#123;</div><div class="line">		return use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setUse(user use) &#123;</div><div class="line">		this.use = use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String save()&#123;</div><div class="line">		return "save";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要注意的是前台参数传递，是action中引用对象的那个属性，其它都一样<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;<span class="selector-tag">form</span> action=<span class="string">"useractionsave.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"use.msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>方法三： ModelDriven接收参数<br>使Action实现com.opensymphony.xwork2.ModelDriven<user>(在实现接口时需要使用泛型，否则使用时需要转型)中利用其getModel()方法返回对象模型，从而获得传入的参数。</user></p>
<p>参数被传入至Action后，会被ModelDriven对象根据参数名自动赋值给User对象相应的属性而生成User对象，并且由getModel()返回。那么我们在Action中就可以利用这个对象了。<br>注意：传入的参数名需要与对象模型中的成员属性一致。</p>
<p>这里在将上述案例中的action修改一下。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class useractionsave extends ActionSupport implements ModelDriven&lt;user&gt;&#123;</div><div class="line">public String save()&#123;</div><div class="line">		return "save";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private user use=new user();</div><div class="line">	</div><div class="line">public user getUse() &#123;</div><div class="line">		return use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setUse(user use) &#123;</div><div class="line">		this.use = use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public user getModel() &#123;</div><div class="line">	// TODO Auto-generated method stub</div><div class="line">	return use;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之一:hello world]]></title>
      <url>http://www.myzwl.win/2017/03/26/structs1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Struts2框架是Apache基金组织下的一个开源框架，是基于MVC模式设计的web应用开发框架。它利用并扩展了java servlet API，鼓励开发者采用MVC架构。</p>
<p>当然本次不介绍strucs2的相关知识，只做一个快速入门案例，及环境搭建和将整个程序走一遍，最后完成hello world程序，也就是先有一个具体印象。</p>
<p>下载并解压struts2开发包，同时建立一个web工程</p>
<p>步骤一：<br> 为了方便，建议直接将开发包中的app下的web-inf下的lib里的文件夹里的jar包全部导入到项目的lib文件夹里</p>
<p>步骤二：编写web.xml文件。<br>一般情况下，我们将开发包中的web.xml复制下来，修改，并且放到web-inf目录下，保留下面内容<br><img src="/images/imgs2/21.gif" alt="Alt text"></p>
<p>步骤三：编写action类，也就是接受前台传过来的数据并进行相应处理和转发<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.zwl.action;</div><div class="line"></div><div class="line">public class helloworld &#123;</div><div class="line"></div><div class="line">	private String msg;</div><div class="line"></div><div class="line">	public String getMsg() &#123;</div><div class="line">		return msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setMsg(String msg) &#123;</div><div class="line">		this.msg = msg;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String execute()&#123;</div><div class="line">		return "success";</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>值得注意的是这里的msg要与前台表单里的name值一致，并且要有set和get方法，这样struct2就自动将前台表单输入的值赋给msg了，然后public String execute()，默认的转发方法，也就是说它返回的值要与result中的name属性设置的值一致，这样就可以跳转到相应界面了，当然这里要结合接下来的步骤才可以</p>
<p>步骤四：配置structs.xml文件，<br>直接将文档中该文件拷到src目录下，修改为如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE struts PUBLIC</div><div class="line">	"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</div><div class="line">	"http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</div><div class="line"></div><div class="line">&lt;struts&gt;</div><div class="line"></div><div class="line">    &lt;package name="default" namespace="/" extends="struts-default"&gt;</div><div class="line">       &lt;action name="helloworld" class="com.zwl.action.helloworld"&gt;</div><div class="line">       &lt;result name="success"&gt;success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">    &lt;/package&gt;</div><div class="line">&lt;/struts&gt;</div></pre></td></tr></table></figure></p>
<p>解释一下：package下name 和namespace就是为了区分重名，这里暂且不管，就按这种默认形式，action中name也就是我们表单提交的路径，class中是要加载的相应的action类，这里是helloworld，而result则是上述方法中返回的字符，里面为要跳转到success.jsp界面，因为这里是个入门程序，目的就是先具体体验。</p>
<p>步骤五：编写相应界面<br>首先是：index.jsp<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;<span class="selector-tag">form</span> action=<span class="string">"helloworld.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>这里结合一下步骤三，只要输入一个文本，后台通过反射机制，自动获得（只要满足标准）该值，并保存在栈中</p>
<p>然后是success.jsp<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib uri="/struts-tags" prefix="s" %&gt;//因为用到structs标签，所以这是声明使用</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;s:property value="msg"/&gt;//取得后台传过来的输入的值</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入到index.jsp。填表单，最后跳转到success.jsp中并取出值</p>
<p>至此，hello world入门程序算是完成了<br>至此，再把上述开发步骤总结一下：</p>
<p>1：准备jar包<br>2：在web.xml中配置structs2的相关过滤器配置<br>3：  开发action，针对不同的功能开发不同的action<br>4：在structs.xml中添加上一步骤开发的action相应的配置（页面跳转等等）<br>5：编写相应的页面</p>
<p>最后我们将整个过程抽象成一个结构图<br><img src="/images/imgs2/22.gif" alt="Alt text"></p>
<p>上述的控制器就是web.xml配置的那个，仔细对比一下整个程序，基本上mvc框架的总体过程就是这样了，当然，这里只是一个入门程序，所以所有的配置都是最简的，只有一个目的，那就是hello world！</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于struts2与easy ui的后台显示界面]]></title>
      <url>http://www.myzwl.win/2017/03/25/easyui1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一直忙着做项目，已经好几天没写博客了。我认为提高自己的最好路径就是先把我知道的东西总结出来，再去从已知探索未知的东西，最后在总结下来。不多说，就用笔者最喜欢的struts2和easy ui来一个需求</p>
<p>利用easy ui的datagrid做一个后台界面（目前只是分页显示数据），并从数据库取出，大概如下界面<br><img src="/images/imgs2/19.gif" alt="Alt text"></p>
<p>在此之前，先简单介绍一下easy ui的特点（和大部分ui基本一样）<br>1.基于jquery 用户界面插件的集合；<br>2.为一些当前用于交互的js 应用提供必要的功能；<br>3.使用EasyUI 你不需要写很多的javascript 代码，通常只需要写HTML 标记来定义用<br>户界面即可；<br>4.支持HTML5；<br>5.开发产品时可节省时间和资源；<br>6.简单，但很强大；<br>7.支持扩展，可根据自己的需求扩展控件；<br>8.源代码加密</p>
<p>总之，在后台界面上easy ui是一个很好的选择</p>
<p>1.新建一个web工程</p>
<p>2.添加ssh整合jar包、gson.jar、mysql驱动包、easy ui的官方文档（ui文件夹）<br>里面有五个文件必须引入（并且有顺序，否则无法引用）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//引入EasyUI 核心UI 文件CSS</span></div><div class="line">  &lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"ui/themes/default/easyui.css"</span> &gt;</div><div class="line">   <span class="comment">//引入EasyUI 图标文件</span></div><div class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"ui/themes/icon.css"</span> &gt;</div><div class="line"><span class="comment">//引入jQuery 核心库</span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"ui/jquery-1.8.0.min.js"</span> &gt;&lt;/script&gt;</div><div class="line">   <span class="comment">//引入jQuery EasyUI 核心库</span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"ui/jquery.easyui.min.js"</span> &gt;&lt;/script&gt;</div><div class="line">   <span class="comment">//引入EasyUI 中文提示信息</span></div><div class="line">   &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"ui/locale/easyui-lang-zh_CN.js"</span> &gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>3.新建一个页面（先贴出代码）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"> &lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;</div><div class="line">&lt;%</div><div class="line">String path = request.getContextPath();</div><div class="line">String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";</div><div class="line">%&gt;</div><div class="line"></div><div class="line">&lt;!DOCTYPE HTML&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;base href="&lt;%=basePath%&gt;"&gt;</div><div class="line">    </div><div class="line">    &lt;title&gt;index&lt;/title&gt;</div><div class="line">    //加载easy ui</div><div class="line">&lt;link rel="stylesheet" type="text/css" href="ui/themes/default/easyui.css" &gt;</div><div class="line">	&lt;link rel="stylesheet" type="text/css" href="ui/themes/icon.css" &gt;</div><div class="line">	&lt;script type="text/javascript" src="ui/jquery-1.8.0.min.js" &gt;&lt;/script&gt;</div><div class="line">	&lt;script type="text/javascript" src="ui/jquery.easyui.min.js" &gt;&lt;/script&gt;</div><div class="line">    &lt;script type="text/javascript" src="ui/locale/easyui-lang-zh_CN.js" &gt;</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line"></div><div class="line">//页面初始化之前执行函数</div><div class="line">	$(function() &#123;</div><div class="line">		</div><div class="line">	 //调用easy ui的datagrid组件，显示json数据，也可以通过html方式加载，这里使用js加载方式</div><div class="line">		$('#admin_yhgl_datagrid').datagrid(&#123;</div><div class="line">			   </div><div class="line">			    //远程加载的json格式数据</div><div class="line">				  url: '$&#123;pageContext.request.contextPath&#125;/booksort!showdatagrid.action',</div><div class="line">				//组件宽度</div><div class="line">                  width : 1200,</div><div class="line">				// 是否可伸缩 	</div><div class="line">			    fitColumns : true,</div><div class="line">		//js对象数组，从后台获得total（总记录）和ids（对象数据集合）然后显示出来	</div><div class="line">columns : [[</div><div class="line">&#123;</div><div class="line">	//字段，与后台字段数据对应</div><div class="line">field : 'id',</div><div class="line"> //标题</div><div class="line">title : '排名',</div><div class="line">//是否排序</div><div class="line">sortable:true,</div><div class="line">//宽度</div><div class="line">width:80,</div><div class="line">//是否居中</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">field : 'barcode',</div><div class="line">title : '图书条形码',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">field : 'bookname',</div><div class="line">title : '图书名称',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'bookshelf',</div><div class="line">title : '书架',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'bookpublish',</div><div class="line">title : '出版社',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">field : 'bookauthor',</div><div class="line">title : '图书作者',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'bookprice',</div><div class="line">title : '定价',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'borrowtime',</div><div class="line">title : '借阅次数',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">]],</div><div class="line"></div><div class="line">//是否有分页插件</div><div class="line">pagination : true,</div><div class="line">//每页显示记录数</div><div class="line">pageSize : 5,</div><div class="line">//设置记录数多少的选项设置</div><div class="line">pageList : [5, 10, 15, 20],</div><div class="line">//排序的字段</div><div class="line">sortName : 'id',</div><div class="line">			</div><div class="line">		&#125;);</div><div class="line">		</div><div class="line">		</div><div class="line">		&#125;);</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">//显示datagrid组件</div><div class="line">&lt;table id="admin_yhgl_datagrid"&gt;</div><div class="line">&lt;/table&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>目前还没有写后台，所以暂无数据加载显示</p>
<p>4 建表（为了方便直接截个图）<br><img src="/images/imgs2/20.gif" alt="Alt text"><br>然后随便加几个数据</p>
<p>5.编写pojo与映射文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class Book &#123;</div><div class="line">private String barcode;</div><div class="line">private String bookauthor;</div><div class="line">private String bookname;</div><div class="line">private String bookprice;</div><div class="line">private String bookpublish;</div><div class="line">private String bookshelf;</div><div class="line">private String booktype;</div><div class="line">private int borrowtime;</div><div class="line">private int id;</div><div class="line"></div><div class="line">省略set与get方法&#125;</div><div class="line"></div><div class="line">//映射文件</div><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line">&lt;!-- </div><div class="line">    Mapping file autogenerated by MyEclipse Persistence Tools</div><div class="line">--&gt;</div><div class="line">&lt;hibernate-mapping package="com.pojo"&gt;</div><div class="line">    &lt;class name="Book" table="book" &gt;</div><div class="line">        &lt;id name="id" &gt;</div><div class="line">            &lt;generator class="increment"&gt;&lt;/generator&gt;</div><div class="line">        &lt;/id&gt;</div><div class="line">        &lt;property name="bookname"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookauthor"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">      &lt;property name="barcode"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookprice"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookpublish"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookshelf"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="booktype"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="borrowtime"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure>
<p>6.dao层service层接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public interface Basedao&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	</div><div class="line">	public List&lt;T&gt; find(String hql, int page, int rows);                             //分页时返回T对象集合</div><div class="line">	</div><div class="line">	</div><div class="line">	public Long count(String hql);                                                   //返回总记录数</div><div class="line">	</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface Basedaoservice &lt;T&gt;&#123;</div><div class="line"></div><div class="line">//Book的包装类，主要增加easy ui所需要的一些属性</div><div class="line">	public DataGrid datagrid(Tbook book);</div><div class="line">	</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>7.编写工具类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class DataGrid &#123;</div><div class="line"></div><div class="line">	private Long total = 0l;                   //总记录</div><div class="line">	private List rows = new ArrayList();       //datagrid需要的json数据加载数据</div><div class="line">	省略set与get方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Tbook &#123;</div><div class="line">       private String barcode;</div><div class="line">	private String bookauthor;</div><div class="line">	private String bookname;</div><div class="line">	private String bookprice;</div><div class="line">	private String bookpublish;</div><div class="line">	private String bookshelf;</div><div class="line">	private String booktype;</div><div class="line">	private int borrowtime;</div><div class="line">	private int id;</div><div class="line">	private String ids;          //前台被选中行的字符转</div><div class="line">	private String order;        //排序</div><div class="line">	private int page;            //多少页</div><div class="line">	private int rows;</div><div class="line">	private String sort;         //排序名</div><div class="line">。。。。。</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Character &#123;</div><div class="line"></div><div class="line">	public static HttpServletResponse Tojson() throws Exception&#123;</div><div class="line">		HttpServletResponse response=ServletActionContext.getResponse();</div><div class="line">		HttpServletRequest request=ServletActionContext.getRequest();</div><div class="line">		request.setCharacterEncoding("utf-8");</div><div class="line">		response.setCharacterEncoding("UTF-8");</div><div class="line">		response.setContentType("application/json; charset=utf-8");          //返回json数据</div><div class="line">	        response.setHeader("Cache-Control", "no-cache");                 //不要缓存</div><div class="line">	        response.setHeader("Pragma", "no-cache");  </div><div class="line">		PrintWriter out = response.getWriter();</div><div class="line">		return response;</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>8.实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class Basedaoimpl&lt;T&gt; extends HibernateDaoSupport  implements Basedao&lt;T&gt; &#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	public List&lt;T&gt; find(String hql, int page, int rows) &#123;</div><div class="line">	</div><div class="line">		Query q=this.getSession().createQuery(hql);</div><div class="line">		</div><div class="line">		return q.setFirstResult((page-1)*rows).setMaxResults(rows).list();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Long count(String hql) &#123;</div><div class="line">		Query q=this.getSession().createQuery(hql);</div><div class="line">		return (Long) q.uniqueResult();</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class Basedaoserviceimpl&lt;T&gt; implements Basedaoservice&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	private Basedao&lt;T&gt; basedao;</div><div class="line">	</div><div class="line">	public Basedao&lt;T&gt; getBasedao() &#123;</div><div class="line">		return basedao;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setBasedao(Basedao&lt;T&gt; basedao) &#123;</div><div class="line">		this.basedao = basedao;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public DataGrid datagrid(Tbook book) &#123;</div><div class="line">	</div><div class="line">		DataGrid dg=new DataGrid();</div><div class="line">		//查询所有的book数据</div><div class="line">		 String hql="from Book b";</div><div class="line">      </div><div class="line">        //排序sql</div><div class="line">		 if(book.getSort()!=null)&#123;</div><div class="line">				hql += " order by " + book.getSort() + " " + book.getOrder();</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		//取出所有的book记录，放在集合汇总</div><div class="line">		 List&lt;Book&gt; l=(List&lt;Book&gt;) basedao.find(hql, book.getPage(), book.getRows());</div><div class="line">		 //查出所有记录数</div><div class="line">		 String totalHql = "select count(*) " + hql;</div><div class="line">	    </div><div class="line">	    //将book对象集合一次加进Tbook包装类集合</div><div class="line">		 List&lt;Tbook&gt; nl=new ArrayList&lt;Tbook&gt;();</div><div class="line">			if (l != null &amp;&amp; l.size() &gt; 0) &#123;</div><div class="line">				for(Book t:l)&#123;</div><div class="line">					Tbook u=new Tbook();</div><div class="line">					BeanUtils.copyProperties(t, u);</div><div class="line">					nl.add(u);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">				dg.setTotal(basedao.count(totalHql));</div><div class="line">				dg.setRows(nl);</div><div class="line">				return dg;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>9 action主题代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class booksort implements ModelDriven&lt;Tbook&gt; &#123;</div><div class="line"></div><div class="line">    //利用modaldriven包装Tbook</div><div class="line">	private Tbook book=new Tbook();</div><div class="line">	</div><div class="line">	private Basedaoservice&lt;Book&gt; basedaoservice;</div><div class="line">	</div><div class="line">	</div><div class="line">	public void showdatagrid() throws Exception&#123;</div><div class="line">		HttpServletResponse response=Character.Tojson();</div><div class="line">		Gson gson=new Gson();          //创建gson对象</div><div class="line">		response.getWriter().write(gson.toJson(basedaoservice.datagrid(book))); //将对象转为json数据</div><div class="line">	&#125;</div><div class="line">	</div><div class="line"></div><div class="line">	</div><div class="line">	public Basedaoservice&lt;Book&gt; getBasedaoservice() &#123;</div><div class="line">		return basedaoservice;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	public void setBasedaoservice(Basedaoservice&lt;Book&gt; basedaoservice) &#123;</div><div class="line">		this.basedaoservice = basedaoservice;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Tbook getModel() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return book;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>10 spring配置和structs配置（参考之前的博客）这里就不配置了，基本都是套路</p>
<p>至此就能加载数据了，当然easy ui在后台界面中的使用不仅方便而且强大，这也是笔者最喜欢使用easy ui的原因</p>
]]></content>
      
        <categories>
            
            <category> 项目经验 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis 之四:mybatis整合spring]]></title>
      <url>http://www.myzwl.win/2017/03/24/mybatis4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整合思路：<br>    1、数据源信息交给spring管理<br>2、sqlsessionfactory交给spring进行单例管理<br>3、由spring来管理mapper代理的代理类</p>
<p>下面以根据用户id查询用户信息案例来搭建工程<br>步骤一：建立java工程</p>
<p>步骤二：添加整合包（这里需要的jar包过多）<br>Mysql的驱动包<br>Mybatis的核心包和依赖包<br>Mybatis和spring的整合包<br>Spring的包<br>dbcp数据库连接池包<br>等等</p>
<p>步骤三：在src目录下建立sqlmapconfig.xml配置文件，里面暂时只有一个dtd文件声明<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE configuration</div><div class="line">PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</div><div class="line">"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>步骤四：在src目录下建立applicationcontext.xml配置文件<br>里面目前只配置一些重要连接数据库的信息，后面步骤将加入重要信息<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt;</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line">	&lt;!-- 创建数据源 --&gt;</div><div class="line">	&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;</div><div class="line">		&lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt;</div><div class="line">		&lt;property name="url" value="jdbc:mysql://localhost:9806/sshe" /&gt;</div><div class="line">		&lt;property name="username" value="root" /&gt;</div><div class="line">		&lt;property name="password" value="root" /&gt;</div><div class="line">		&lt;property name="maxActive" value="10" /&gt;</div><div class="line">		&lt;property name="maxIdle" value="5" /&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">	&lt;!-- SqlSessionFactory --&gt;</div><div class="line">	&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;</div><div class="line">		&lt;!-- 指定mybatis的全局配置文件的路径 --&gt;</div><div class="line">		&lt;property name="configLocation" value="SqlMapConfig.xml"&gt;&lt;/property&gt;</div><div class="line">		&lt;!-- 数据源 --&gt;</div><div class="line">		&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>步骤五：创建pojo类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">private int age;</div><div class="line">private int id;</div><div class="line">private String name;</div><div class="line">此处省略set与get方法。。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤六：创建mapper代理<br>首先是UserMapper.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE mapper    </div><div class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    </div><div class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line">&lt;mapper namespace="com.zwl.mapper.UserMapper"&gt;</div><div class="line">	&lt;!-- 根据用户ID查询用户信息 --&gt;</div><div class="line">	&lt;select id="findUserById" parameterType="int" resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT</div><div class="line">		* FROM user WHERE id =#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure></p>
<p>接下来是mapper接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(int id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在sqlmapconfig.xml文件中声明代理文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">	&lt;!-- 加载映射文件 --&gt;</div><div class="line">	&lt;mappers&gt;</div><div class="line">		&lt;mapper resource=<span class="string">"com/zwl/mapper/UserMapper.xml"</span> /&gt;</div><div class="line">	&lt;/mappers&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>步骤七：spring中注入<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"UserMapper"</span> class=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</div><div class="line">		&lt;!-- 设置代理类的接口 --&gt;</div><div class="line">		&lt;property name=<span class="string">"mapperInterface"</span> value=<span class="string">"com.zwl.mapper.UserMapper"</span>&gt;&lt;/property&gt;</div><div class="line">		&lt;!-- 依赖注入SqlSessionFactory --&gt;</div><div class="line">		&lt;property name=<span class="string">"sqlSessionFactory"</span> ref=<span class="string">"sqlSessionFactory"</span>&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>步骤八：测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class test &#123;</div><div class="line">	private ApplicationContext ctx;</div><div class="line"></div><div class="line">//在测试之前自动加载</div><div class="line">	@Before</div><div class="line">	public void setUp() throws Exception &#123;</div><div class="line">		ctx = new ClassPathXmlApplicationContext(</div><div class="line">				"applicationContext.xml");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Test</div><div class="line">	public void testFindUserById() throws Exception &#123;</div><div class="line">		</div><div class="line">		UserMapper dao = (UserMapper) ctx.getBean("userMapper");</div><div class="line">		</div><div class="line">		User user = dao.findUserById(1);</div><div class="line">		</div><div class="line">		System.out.println(user.getName());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：取出数据库中的helloworld<br>至此mybatis整合spring完成</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis 之三:映射文件]]></title>
      <url>http://www.myzwl.win/2017/03/23/mybatis3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基本上我们对数据库的操作都在映射文件中编写，通过mapper代理方式简化配置，同时依据不同的参数和返回类型完成相关需求</p>
<h5 id="一：parameterType输入参数"><a href="#一：parameterType输入参数" class="headerlink" title="一：parameterType输入参数"></a>一：parameterType输入参数</h5><p>简单类型：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id="findUserById" parameterType="int"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>参数是基本类型，在之前已演示</p>
<p>Pojo类型<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;insert id=<span class="string">"insertuser"</span> parameterType=<span class="string">"com.zwl.pojo.User"</span>&gt;</div><div class="line">&lt;selectKey keyProperty=<span class="string">"id"</span> resultType=<span class="string">"int"</span> <span class="attribute">order</span>=<span class="string">"AFTER"</span>&gt;</div><div class="line">select LAST_INSERT_ID()</div><div class="line">&lt;/selectKey&gt;</div><div class="line">insert into user values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</div><div class="line">&lt;/insert&gt;</div></pre></td></tr></table></figure></p>
<p>即参数类型是一个对象，如之前的添加操作</p>
<p>包装pojo类型<br>即在类中包含另一个对象，如<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class Uservo &#123;</div><div class="line">private User user;</div><div class="line">此处省略set。。get方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件中<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id="findUserById" parameterType="com.zwl.pojo.Uservo"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;user.id&#125;</div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>参数是包装类，注意参数是包装类的属性</p>
<p>Map<br>  同传递pojo对象一样，map的key相当于pojo的属性<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id="findUserById" parameterType="hashmap"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;id&#125; and name=#&#123;name&#125;</div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>显然，参数是hashmap，其中#{id}与#{name}都是hashmap的key</p>
<p>接口文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(HashMap&lt;String, Object&gt; id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">UserMapper mapper=sqlSession.getMapper(UserMapper.class);</div><div class="line">				</div><div class="line">				HashMap&lt;String, Object&gt; hm=new HashMap&lt;&gt;();</div><div class="line">				hm.put("id", 1);</div><div class="line">				hm.put("name","helloworld");</div><div class="line">				</div><div class="line">				User u=mapper.findUserById(hm);</div><div class="line">				System.out.println(u.getAge());</div><div class="line">				sqlSession.close();</div></pre></td></tr></table></figure></p>
<h4 id="输出映射"><a href="#输出映射" class="headerlink" title="输出映射"></a>输出映射</h4><p>Resulttype：<br>    使用要求：<br>  使用resultType进行结果映射时，需要查询出的列名和映射的对象的属性名一致，才能映射成功。<br>如果查询的列名和对象的属性名全部不一致，那么映射的对象为空。<br>如果查询的列名和对象的属性名有一个一致，那么映射的对象不为空，但是只有映射正确那一个属性才有值。</p>
<p>简单类型：resultType=”int”<br>Pojo对象：resultType=”com.zwl.pojo.User”</p>
<p>如之前的案例<br>Resultmap<br>使用resultMap进行结果映射时，不需要查询的列名和映射的属性名必须一致。但是需要声明一个resultMap，来对列名和属性名进行映射<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;resultMap type=<span class="string">"com.zwl.pojo.User"</span> id=<span class="string">"Userresult"</span>&gt;</div><div class="line">	&lt;id column=<span class="string">"id_"</span> property=<span class="string">"id"</span>/&gt;</div><div class="line">	&lt;result column=<span class="string">"name_"</span> property=<span class="string">"name"</span>/&gt;</div><div class="line">	&lt;result column=<span class="string">"age_"</span> property=<span class="string">"age"</span>/&gt;</div><div class="line">	&lt;/resultMap&gt;</div></pre></td></tr></table></figure></p>
<p>其中id为查询结果中唯一列映射，result标签为映射结果中的普通列</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id=<span class="string">"findUserById"</span> parameterType=<span class="string">"int"</span></div><div class="line">		resultMap=<span class="string">"Userresult"</span> &gt;</div><div class="line">		SELECT id id_,name name_,age age_ FROM user WHERE id =#&#123;id&#125; </div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure>
<p>其中resultmap必须与声明中的id保持一致，这样才能引用</p>
<p>接口：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(int id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">User u=mapper.findUserById(1);</div><div class="line">				System.out.println(u.getAge());</div><div class="line">				sqlSession.close();</div></pre></td></tr></table></figure>
<p>mybatis与hibernate的区别及各自应用场景<br>Mybatis技术特点：<br>1、    通过直接编写SQL语句，可以直接对SQL进行性能的优化；<br>2、    学习门槛低，学习成本低。只要有SQL基础，就可以学习mybatis，而且很容易上手；<br>3、    由于直接编写SQL语句，所以灵活多变，代码维护性更好。<br>4、    不能支持数据库无关性，即数据库发生变更，要写多套代码进行支持，移植性不好。</p>
<p>Hibernate技术特点：<br>1、    标准的orm框架，程序员不需要编写SQL语句。<br>2、    具有良好的数据库无关性，即数据库发生变化的话，代码无需再次编写。<br>3、    学习门槛高，需要对数据关系模型有良好的基础，而且在设置OR映射的时候，需要考虑好性能和对象模型的权衡。<br>4、    程序员不能自主的去进行SQL性能优化。</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis 之二:开发dao的两种方式]]></title>
      <url>http://www.myzwl.win/2017/03/22/mybatis2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Dao层的开发，在mybatis中可以通过原始dao（一个接口和接口实现类），而在mybatis中可以更方便的通过mapper代理模式，当然需要满足一定的规范性原则</p>
<p>不多说，以一个增加user信息为例</p>
<p>一：首先在映射文件中写一个增加用户配置信息<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 添加用户 --&gt;</div><div class="line">	&lt;!-- selectKey：查询主键，在标签内需要输入查询主键的sql --&gt;</div><div class="line">	&lt;!-- <span class="attribute">order</span>：指定查询主键的sql和insert语句的执行顺序，相当于insert语句来说 --&gt;</div><div class="line">	&lt;!-- LAST_INSERT_ID：该函数是mysql的函数，获取自增主键的ID，它必须配合insert语句一起使用 --&gt;</div><div class="line">	&lt;insert id=<span class="string">"insertuser"</span> parameterType=<span class="string">"com.zwl.pojo.User"</span>&gt;</div><div class="line">	&lt;selectKey keyProperty=<span class="string">"id"</span> resultType=<span class="string">"int"</span> <span class="attribute">order</span>=<span class="string">"AFTER"</span>&gt;select LAST_INSERT_ID()&lt;/selectKey&gt;</div><div class="line">	insert into user values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</div><div class="line">	&lt;/insert&gt;</div></pre></td></tr></table></figure></p>
<p>注意：这里的插入中原表中主键有自增长，所以需要先获得主键，在增加，这是一个插入语句</p>
<p>二：dao接口及其实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public interface userdao &#123;</div><div class="line">//添加user</div><div class="line">	public void insertusers(User user) throws Exception;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Dao接口实现类</div><div class="line">public class userdaoimpl implements userdao &#123;</div><div class="line"></div><div class="line">	private SqlSessionFactory sqlSessionFactory;</div><div class="line">	</div><div class="line">//通过构造函数注入sqlSessionFactory</div><div class="line">	public userdaoimpl(SqlSessionFactory sqlSessionFactory)&#123;</div><div class="line">		this.sqlSessionFactory=sqlSessionFactory;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void insertusers(User user) throws Exception &#123;</div><div class="line">//通过线程安全方式获得sqlsession，实现增删该查操作</div><div class="line">		SqlSession sqlsession=sqlSessionFactory.openSession();</div><div class="line">//注意这里的test是映射文件中的namespace，insertuser是id用于标识</div><div class="line">		sqlsession.insert("test.insertuser", user);</div><div class="line">//添加操作需要提交事务</div><div class="line">		sqlsession.commit();</div><div class="line">		sqlsession.close();</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>编写测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//读取配置文件</div><div class="line">				//全局配置文件的路径</div><div class="line">				String resource = "SqlMapConfig.xml";</div><div class="line">				InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">				</div><div class="line">				//创建SqlSessionFactory</div><div class="line">				SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div><div class="line"></div><div class="line">              //创建user</div><div class="line">	            User u=new User();</div><div class="line">				u.setName("java");</div><div class="line">				u.setAge(18);</div><div class="line">				</div><div class="line">//调用dao层方法，实现添加功能</div><div class="line">				userdao dao=new userdaoimpl(sqlSessionFactory);</div><div class="line">				dao.insertusers(u);</div></pre></td></tr></table></figure></p>
<p>这种原始dao方式，我们很熟悉，也很好理解，到时当方法多的时候，就会存在大量多余的重复编码问题</p>
<p>Mapper代理的开发模式<br>即开发mapper接口（相当于dao接口）<br>Mapper代理使用的是jdk的代理策略</p>
<p>还有一点是mapper代理最重要的，就是必须满足mapper代理的开发规范<br>1 mapper接口的全限定名要和mapper映射文件的namespace值一致<br>2 mapper接口的方法名称要和mapper映射文件的statement的id一致。<br>3 mapper接口的方法参数类型要和mapper映射文件的statement的parameterType的值一致，而且它的参数是一个。<br>4 mapper接口的方法返回值类型要和mapper映射文件的statement的resultType的值一致。</p>
<p>下面以入门程序的通过id查询user为例<br>首先是修改映射文件，改名为UserMapper.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE mapper    </div><div class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    </div><div class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line">&lt;!-- namespace：命名空间，对statement的信息进行分类管理 --&gt;</div><div class="line">&lt;!-- 注意：在mapper代理时，它具有特殊及重要的作用 --&gt;</div><div class="line">&lt;mapper namespace="com.zwl.mapper.UserMapper"&gt;</div><div class="line">	&lt;!-- 根据用户ID查询用户信息 --&gt;</div><div class="line">	&lt;!-- select：表示一个MappedStatement对象 --&gt;</div><div class="line">	&lt;!-- id：statement的唯一标示 --&gt;</div><div class="line">	&lt;!-- #&#123;&#125;：表示一个占位符？ --&gt;</div><div class="line">	&lt;!-- #&#123;id&#125;：里面的id表示输入参数的参数名称，如果该参数是简单类型，那么#&#123;&#125;里面的参数名称可以任意 --&gt;</div><div class="line">	&lt;!-- parameterType：输入参数的java类型 --&gt;</div><div class="line">	&lt;!-- resultType：输出结果的所映射的java类型（单条结果所对应的java类型） --&gt;</div><div class="line">	</div><div class="line"></div><div class="line">	&lt;select id="findUserById" parameterType="int"</div><div class="line">		resultType="com.zwl.pojo.User" &gt;</div><div class="line">		select * from user where id=#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure></p>
<p>上述的namespace需要和mapper接口的全限定名一致<br>然后是mapper接口开发（UserMapper.java）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package com.zwl.mapper;</div><div class="line"></div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(int id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来是在配置文件中声明映射文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;mappers&gt;</div><div class="line">		&lt;mapper resource=<span class="string">"com/zwl/mapper/UserMapper.xml"</span> /&gt;</div><div class="line">	&lt;/mappers&gt;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">String resource = "SqlMapConfig.xml";</div><div class="line">				InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">				</div><div class="line">				//创建SqlSessionFactory</div><div class="line">				SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div><div class="line">				</div><div class="line">			//创建SqlSession</div><div class="line">				SqlSession sqlSession = sqlSessionFactory.openSession();</div><div class="line">				</div><div class="line">//通过mybatis的sqlsession来创建代理对象</div><div class="line">				UserMapper mapper=sqlSession.getMapper(UserMapper.class);</div><div class="line">				</div><div class="line">				User u=mapper.findUserById(1);</div><div class="line">				System.out.println(u.getName());</div><div class="line">				sqlSession.close();</div></pre></td></tr></table></figure></p>
<p>最后的测试结果是取出数据库中id为1的helloworld</p>
<p>至此mapper代理开发dao完成，这里只给了一个简单的例子，总的来说，只要满足规范，就可以简化配置</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis 之一:hello world]]></title>
      <url>http://www.myzwl.win/2017/03/21/mybatis1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mybatis就是一个封装了jdbc的持久层框架，它和hibernate都属于orm框架，但是具体说，hibernate是一个完全的orm框架，而mybatis是一个不完全的orm框架，mybatis只关注sql本身，而不需要关注如连接的创建，statement的创建等操作。Mybatis会将输入参数、输出结果进行映射。</p>
<p>不多说，先来一个入门程序，意在先从整体了解<br>步骤一：创建一个java工程</p>
<p>步骤二：导入jar包，首先创建一个lib文件夹，在将包导入<br><img src="/images/imgs2/17.gif" alt="Alt text"></p>
<p>步骤三：数据库中的表user<br><img src="/images/imgs2/18.gif" alt="Alt text"></p>
<p>步骤四：创建pojo类，与数据库字段对应<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pojo;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line">	private int age;</div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line">	public int getId() &#123;</div><div class="line">		return id;</div><div class="line">	&#125;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public void setId(int id) &#123;</div><div class="line">		this.id = id;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤五：创建全局配置文件（mybatis核心配置文件SqlMapConfig.xml，放在src目录下）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE configuration</div><div class="line">PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</div><div class="line">"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">	&lt;!-- 配置mybatis的环境信息，与spring整合，该信息由spring来管理 --&gt;</div><div class="line">	&lt;environments default="development"&gt;</div><div class="line">		&lt;environment id="development"&gt;</div><div class="line">			&lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt;</div><div class="line">			&lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;</div><div class="line">			&lt;!-- 配置数据源，采用mybatis连接池 --&gt;</div><div class="line">			&lt;dataSource type="POOLED"&gt;</div><div class="line">				&lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt;</div><div class="line">				&lt;property name="url" value="jdbc:mysql://localhost:9806/sshe" /&gt;</div><div class="line">				&lt;property name="username" value="root" /&gt;</div><div class="line">				&lt;property name="password" value="root" /&gt;</div><div class="line">			&lt;/dataSource&gt;</div><div class="line">		&lt;/environment&gt;</div><div class="line">	&lt;/environments&gt;</div><div class="line"></div><div class="line">	&lt;mappers&gt;</div><div class="line">		还没有映射文件 </div><div class="line">	&lt;/mappers&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>简要说明一下，类似于hibernate核心配置文件，连接数据库，这里暂时还没有映射文件，后面步骤在加上</p>
<p>步骤六：映射文件（User.xml）这里是通过id查询返回对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE mapper    </div><div class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    </div><div class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line">&lt;!-- namespace：命名空间，对statement的信息进行分类管理 --&gt;</div><div class="line">&lt;!-- 注意：在mapper代理时，它具有特殊及重要的作用 --&gt;</div><div class="line">&lt;mapper namespace="test"&gt;</div><div class="line">	&lt;!-- 根据用户ID查询用户信息 --&gt;</div><div class="line">	&lt;!-- select：表示一个MappedStatement对象 --&gt;</div><div class="line">	&lt;!-- id：statement的唯一标示 --&gt;</div><div class="line">	&lt;!-- #&#123;&#125;：表示一个占位符？ --&gt;</div><div class="line">	&lt;!-- #&#123;id&#125;：里面的id表示输入参数的参数名称，如果该参数是简单类型，那么#&#123;&#125;里面的参数名称可以任意 --&gt;</div><div class="line">	&lt;!-- parameterType：输入参数的java类型 --&gt;</div><div class="line">	&lt;!-- resultType：输出结果的所映射的java类型（单条结果所对应的java类型） --&gt;</div><div class="line">	&lt;select id="findUserById" parameterType="int"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure></p>
<p>步骤七：在全局配置文件中声明映射文件（User.xml）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;mappers&gt;</div><div class="line">		&lt;mapper resource=<span class="string">"com/zwl/pojo/User.xml"</span> /&gt;</div><div class="line">	&lt;/mappers&gt;</div></pre></td></tr></table></figure></p>
<p>步骤八：测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">import java.io.InputStream;</div><div class="line"></div><div class="line">import org.apache.ibatis.io.Resources;</div><div class="line">import org.apache.ibatis.session.SqlSession;</div><div class="line">import org.apache.ibatis.session.SqlSessionFactory;</div><div class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public class test &#123;</div><div class="line">	@Test</div><div class="line">	public void findUserByIdtest() throws Exception&#123;</div><div class="line">		        //读取配置文件</div><div class="line">				//全局配置文件的路径</div><div class="line">				String resource = "SqlMapConfig.xml";</div><div class="line">				InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">				</div><div class="line">				//创建SqlSessionFactory</div><div class="line">				SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div><div class="line">				</div><div class="line">				//创建SqlSession</div><div class="line">				SqlSession sqlSession = sqlSessionFactory.openSession();</div><div class="line">				</div><div class="line">				//调用SqlSession的增删改查方法</div><div class="line">				//第一个参数：表示statement的唯一标示</div><div class="line">				User u=sqlSession.selectOne("test.findUserById", 1);</div><div class="line">				System.out.println(u.getName());</div><div class="line">				sqlSession.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后可将数据库中id为1的数据取出</p>
<p>至此，入门程序算是完成了，通过上面步骤发现，这里的不完全orm，还是得最后我们自己写sql，这样我们就可以面对复杂表关系时，自己优化了</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring mvc之四:数据回显与json]]></title>
      <url>http://www.myzwl.win/2017/03/20/springmvc4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>比较struts2与spring mvc<br>实现机制：<br>Struts2是基于过滤器实现的。<br>Springmvc基于servlet实现。Servlet比过滤器快。</p>
<p>运行速度：<br>Struts2是多列<br>请求来了以后，struts2创建多少个对象：<br>ActionContext，valuestack，UserAction，ActionSuport，ModelDriven<br>Springmvc是单列</p>
<p>参数封装来分析：<br>Struts基于属性进行封装。<br>Springmvc基于方法封装。</p>
<p>页面回显：<br> 查询所有<br>构造一组list数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("userlist")</div><div class="line">   //model	相当于application域对象</div><div class="line">	public String userlist(Model modal)&#123;</div><div class="line">		List&lt;User&gt; list=new ArrayList&lt;&gt;();</div><div class="line">		User u1=new User();</div><div class="line">		u1.setId(1);</div><div class="line">		u1.setSex("1");</div><div class="line">		u1.setAddress("lol");</div><div class="line">		u1.setUsername("1");</div><div class="line">		u1.setBirthday(new Date());</div><div class="line">		</div><div class="line">		User u2=new User();</div><div class="line">		u2.setId(1);</div><div class="line">		u2.setSex("1");</div><div class="line">		u2.setAddress("lol");</div><div class="line">		u2.setUsername("1");</div><div class="line">		u2.setBirthday(new Date());</div><div class="line">		</div><div class="line">		list.add(u1);</div><div class="line">		list.add(u2);</div><div class="line">		</div><div class="line">		modal.addAttribute("userlist", list);</div><div class="line">		</div><div class="line">		return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>页面回显（利用jstl标签回显）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;//声明此标签</div><div class="line"></div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;table border="1" style="color: blue"&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">&lt;td&gt;姓名&lt;/td&gt;</div><div class="line">&lt;td&gt;生日&lt;/td&gt;</div><div class="line">&lt;td&gt;性别&lt;/td&gt;</div><div class="line">&lt;td&gt;地址&lt;/td&gt;</div><div class="line">&lt;td&gt;操作&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;c:forEach items="$&#123;userlist &#125;" var="user"&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">&lt;td&gt;$&#123;user.username &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;user.birthday &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;user.sex &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;user.address &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;</div><div class="line">&lt;a href="$&#123;pageContext.request.contextPath &#125;/test/update?id=$&#123;user.id &#125;"&gt;delete&lt;/a&gt;</div><div class="line">&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line"></div><div class="line">&lt;/c:forEach&gt;</div><div class="line"></div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>注意此处有个delete</p>
<blockquote>
<p><a href="${pageContext.request.contextPath }/test/update?id=${user.id }">delete</a></p>
</blockquote>
<p>利用？的方法，无疑将值显示的传过去，很不安全</p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc2/test/userlist.do" target="_blank" rel="external">http://localhost:100/springmvc2/test/userlist.do</a></p>
<p>可以取出集合中的数据，同时delete中有显示id=参数传过去了</p>
<h4 id="URL模版映射"><a href="#URL模版映射" class="headerlink" title="URL模版映射"></a>URL模版映射</h4><p>url模版映射是restfull软件架构<br>Web.xml拦截方式：在rest目录下所有请求都被拦截，servlet可以拦截目录<br>配置如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;/rest<span class="comment">/*&lt;/url-pattern&gt;</span></div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
<p>（）:匹配接受页面Url路径参数<br>@Pathariable：（）里面参数注入后面参数里面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("update/&#123;id&#125;")</div><div class="line">	public String update(@PathVariable Integer id)&#123;</div><div class="line">		System.out.println(id);</div><div class="line">		</div><div class="line">		return "redirect:/test/userlist.do";</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>页面修改：</p>
<blockquote>
<p><a href="${pageContext.request.contextPath }/rest/test/update/${user.id }">delete</a></p>
</blockquote>
<p>测试：同样输入相同地址，会发现href代参直接变成/参数</p>
<h4 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h4><p>转发<br>关键字：forward<br>本类进行转发：<br>本类方法与方法之间进行forward<br>转发方式：</p>
<blockquote>
<p>return “forward : /test/userlist.do”;</p>
</blockquote>
<p>跨类进行转发：<br>转发方式：return ”forward：/items/userlist.do“；<br>其中items是类前面的路径声明</p>
<p>重定向<br>关键字：redirect<br>本类进行重定向：<br>本类方法与方法之间进行redirect<br>重定向方式：</p>
<blockquote>
<p>return “redirect:/test/userlist.do”;</p>
</blockquote>
<p>跨类进行重定向：<br>转发方式：return ”redirect：/items/userlist.do“；</p>
<h4 id="responseBody和-RequestBody"><a href="#responseBody和-RequestBody" class="headerlink" title="@responseBody和@RequestBody"></a>@responseBody和@RequestBody</h4><p>@responseBody把后台pojo转换json对象，返回到页面。<br>@RequestBody接受前台json数据，把json数据自动封装javaBean。</p>
<p>下面以一个实例说明<br>这里ajax传递json数据用jquery来模拟</p>
<p>步骤一：导入jar包（jackson-core-asl-1.9.11.jar和jackson-mapper-asl-1.9.11.jar）<br>加入jquery<br>在springmvc.xml文件中声明对json数据的支持<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</div><div class="line">		&lt;property name=<span class="string">"messageConverters"</span>&gt;</div><div class="line">		&lt;bean class=<span class="string">"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"</span>&gt;&lt;/bean&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>页面传递ajax格式<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">function requestjson()&#123;</div><div class="line">	//模拟了一个json格式数据</div><div class="line">			 var jsonobj=JSON.stringify(&#123;"username":"11","sex":"man","address":"ok"&#125;); </div><div class="line">			$.ajax(&#123;</div><div class="line">				type:'POST',</div><div class="line">				url:'&lt;%=path%&gt;/test/requestjson.do',</div><div class="line">	//申明传递的是json格式</div><div class="line">				 contentType:'application/json;charset=utf-8', </div><div class="line">	//传递的数据</div><div class="line">				data:jsonobj,</div><div class="line">	//如果成功，返回数据</div><div class="line">				success:function(data)&#123;</div><div class="line">					</div><div class="line">					alert(data.username);</div><div class="line">				&#125;</div><div class="line">			&#125;)</div><div class="line">			</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	&lt;/script&gt;</div><div class="line"></div><div class="line">	 &lt;body&gt;</div><div class="line">  &lt;form action=""&gt;</div><div class="line">   &lt;input type="text" name="username1" onclick="requestjson();"/&gt;</div><div class="line">   &lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>后台代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("requestjson")</div><div class="line">	public @ResponseBody User requestjson(@RequestBody User user)&#123;</div><div class="line">		System.out.println(user.getSex());</div><div class="line">		</div><div class="line">		return user;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>此处声明了接受的参数和返回的都是json数据格式</p>
<p>测试：在浏览器输入<a href="http://localhost:100/springmvc2/index.jsp" target="_blank" rel="external">http://localhost:100/springmvc2/index.jsp</a><br>通过点击文本，后台会打印参数，同时返回一个user对象给前台，并显示出来</p>
<p>pojo，后台返回json<br>前台请求数据构造：key=value&amp;key=value.<br>首先是页面<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">				type:'POST',</div><div class="line">				url:'&lt;%=path%&gt;/user/requestjson1.do',</div><div class="line">				data:'username=lol&amp;address=zwl',</div><div class="line">				success:function(data)&#123;</div><div class="line">					</div><div class="line">					alert(data.username);</div><div class="line">				&#125;</div><div class="line">			&#125;)</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">后台代码：</div><div class="line">@RequestMapping("requestjson1")</div><div class="line">	public @ResponseBody User requestjson1(User user)&#123;</div><div class="line">		System.out.println(user.getAddress());</div><div class="line">		</div><div class="line">		return user;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>最后在springmvc中配置的前两个设配器，我们可以通过一个注解声明代替</p>
<blockquote>
<p><mvc:annotation-driven></mvc:annotation-driven></p>
</blockquote>
<p>不仅如此，它还自动包括了json数据格式声明等等<br>即默认创建注解处理器映射器，注解处理器适配器。提供json格式支持。</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[spring mvc之三:注解开发]]></title>
      <url>http://www.myzwl.win/2017/03/19/springmvc3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我们都是通过xml方式显示配置，会发现配置起来特别麻烦。当使用注解时，有时只需在相关类中做相关的声明，就能完成同样的工作。</p>
<p>不多说：先来一个注解开发例子</p>
<p>步骤一：首先创建一个web工程</p>
<p>步骤二：添加jar包</p>
<p>步骤三：配置web.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt;</div><div class="line">  </div><div class="line">  &lt;filter&gt;</div><div class="line">  &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line">  &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">  &lt;init-param&gt;</div><div class="line">  &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line">  &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line">  &lt;/init-param&gt;</div><div class="line">  &lt;/filter&gt;</div><div class="line">  </div><div class="line">  &lt;filter-mapping&gt;</div><div class="line">  &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">  &lt;/filter-mapping&gt;</div><div class="line">  </div><div class="line">  &lt;servlet&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">  &lt;!-- 默认加载方式</div><div class="line">  	   默认加载必须规范：</div><div class="line">  	   * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml</div><div class="line">  	   * 路径规范：必须在WEB-INF目录下面</div><div class="line">   --&gt;</div><div class="line"> &lt;/servlet&gt;</div><div class="line">  </div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>步骤四：配置springmvc-servlet.xml文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt;</div><div class="line">		</div><div class="line">		&lt;!--  扫描基本的父包，这样子类包被自动扫到执行 --&gt;</div><div class="line">		&lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt;</div><div class="line">		</div><div class="line">	&lt;!-- 配置注解处理器映射器 </div><div class="line">			功能：寻找执行类Controller</div><div class="line">		--&gt;</div><div class="line"></div><div class="line">		 &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt;</div><div class="line">		&lt;!-- 配置注解处理器适配器 </div><div class="line">			功能：调用controller方法，执行controller</div><div class="line">		--&gt;</div><div class="line"></div><div class="line">		&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;</div><div class="line">		&lt;/bean&gt;</div><div class="line">		&lt;!-- 配置sprigmvc视图解析器：解析逻辑试图 </div><div class="line">			 后台返回逻辑试图：index</div><div class="line">			视图解析器解析出真正物理视图：前缀+逻辑试图+后缀====/WEB-INF/jsps/index.jsp</div><div class="line">		--&gt;</div><div class="line">		&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;</div><div class="line">		&lt;property name="prefix" value="/"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;		</div><div class="line">		&lt;/bean&gt;</div><div class="line">		&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>这里简要说明一下，以上是注解最基本的配置，有扫描配置，两个基本配置和一个视图配置</p>
<p>步骤五：自定义controller类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import org.springframework.stereotype.Controller;</div><div class="line">import org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"></div><div class="line">@Controller  //相当于&lt;bean class="Usercontrol"/&gt;并且声明这是一个controller</div><div class="line">public class Usercontrol &#123;</div><div class="line"></div><div class="line">	@RequestMapping("hello") //相当于需要访问的路径hello.do</div><div class="line">	public String say()&#123;</div><div class="line">		return "index" ;  //放回到逻辑视图index.jsp</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个最简化的注解配置<br>对应index.jsp<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> &lt;body&gt;</div><div class="line">hello 盲僧</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：浏览器中输入<a href="http://localhost:100/springmvc2/hello.do" target="_blank" rel="external">http://localhost:100/springmvc2/hello.do</a></p>
<p>对应输出结果</p>
<blockquote>
<p>hello 盲僧</p>
</blockquote>
<h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h4><p>它有三种方式，分别为</p>
<blockquote>
<p>requestMapping(“hello”)<br>requestMapping(“/hello.do”)<br>requestMapping(value=”/hello.do”)</p>
</blockquote>
<p>都能达到同样的效果，都是需要访问的路径<br>如果在类前面添加此属性，则相当于映射路径在加一层<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Controller <span class="comment">//&lt;bean class="Usercontrol"/&gt;</span></div><div class="line">@RequestMapping(<span class="string">"/test"</span>)</div><div class="line">public class Usercontrol &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>即<a href="http://localhost:100/springmvc2/test/hello.do" target="_blank" rel="external">http://localhost:100/springmvc2/test/hello.do</a></p>
<p>另外，注意下里面还有个method配置，即按什么模式接受表单</p>
<blockquote>
<p>@RequestMapping(value=”/hello.do”,method=RequestMethod.GET)</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>@RequestMapping(value=”/hello.do”,method=RequestMethod.POST)</p>
</blockquote>
<p>默认是两个都可以的</p>
<blockquote>
<p>requestMapping(value=”/hello.do”,method={RequestMethod.POST, RequestMethod.GET})</p>
</blockquote>
<h4 id="封装参数"><a href="#封装参数" class="headerlink" title="封装参数"></a>封装参数</h4><p>分析接受参数类型：<br>基本类型，int，String等等基本类型。<br>Pojo类型<br>包装类型<br>Springmvc参数封装：基于方法进行封装。</p>
<p>一：基本类型<br> 封装int型参数<br>页面<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  &lt;body&gt;</div><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/ test/recieve.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">id：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"id"</span> id=<span class="string">"id"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>接受参数方法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recieve")</div><div class="line">	public String recieve(Integer id)&#123;</div><div class="line">		System.out.println(id);</div><div class="line">  return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>注意这里的Integer id必须要与页面中的name=”id”一致才能正确接受参数</p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc2/index.jsp" target="_blank" rel="external">http://localhost:100/springmvc2/index.jsp</a></p>
<p>然后输入id，后台即可接收到参数</p>
<p>接受字符转类型<br>页面：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/ test/recievestr.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">id：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"name"</span> id=<span class="string">"name"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>接收参数方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recievestr")</div><div class="line">	public String recievestr(String name)&#123;</div><div class="line">		System.out.println(name);</div><div class="line">		  return "login";&#125;</div></pre></td></tr></table></figure></p>
<p>接受数组：<br>分析：批量：checkbox复选框。Value必须有值<br>页面：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/test/recievearray.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">ID：&lt;<span class="selector-tag">input</span> type=<span class="string">"checkbox"</span> name=<span class="string">"ids"</span> value=<span class="string">"1"</span> id=<span class="string">"ids"</span>&gt;</div><div class="line">ID：&lt;<span class="selector-tag">input</span> type=<span class="string">"checkbox"</span> name=<span class="string">"ids"</span> value=<span class="string">"2"</span> id=<span class="string">"ids"</span>&gt;</div><div class="line">ID：&lt;<span class="selector-tag">input</span> type=<span class="string">"checkbox"</span> name=<span class="string">"ids"</span> value=<span class="string">"3"</span> id=<span class="string">"ids"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>接受参数的方法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recievearray")</div><div class="line">	public String recievearray(Integer []ids)&#123;</div><div class="line">		System.out.println(ids);</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>接受pojo类<br>页面：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/test/recieveUser.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">姓名：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"username"</span> id=<span class="string">"username"</span>&gt;</div><div class="line">生日：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"birthday"</span> id=<span class="string">"birthday"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>Pojo类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">	</div><div class="line">	private String username;</div><div class="line">	private Date birthday;</div><div class="line"></div><div class="line">此处省略set。Get方法&#125;</div></pre></td></tr></table></figure></p>
<p>接受参数的方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recieveUser")</div><div class="line">	public String recievearray(User user)&#123;</div><div class="line">		System.out.println(user.getUsername());</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>接受包装类型参数<br> 包装pojo类</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Usercus &#123;</div><div class="line">	private User user;</div><div class="line">此处省略set。Get方法。&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/usercus.do" method="post"&gt;</div><div class="line">姓名：&lt;input type="text" name="user.username" id="username"&gt;</div><div class="line">生日：&lt;input type="text" name="user.birthday" id="birthday"&gt;</div><div class="line">&lt;input type="submit" value="提交"&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">接受参数的方法：</div><div class="line">@RequestMapping("usercus")</div><div class="line">	public String usercus(Usercus user)&#123;</div><div class="line">		System.out.println(user.getUser().getUsername());</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>接受集合类型参数<br> 接受list集合<br>首先在包装类中加入如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private List&lt;User&gt; userlist;</div><div class="line">此处省略set，get方法</div><div class="line"></div><div class="line">然后是页面</div><div class="line">&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/recievelist.do" method="post"&gt;</div><div class="line">姓名：&lt;input type="text" name="userList[0].username" id="username"&gt;</div><div class="line">地址：&lt;input type="text" name="userList[0].address" id="address"&gt;</div><div class="line"></div><div class="line">姓名：&lt;input type="text" name="userList[1].username" id="username"&gt;</div><div class="line">地址：&lt;input type="text" name="userList[1].address" id="address"&gt;</div><div class="line">&lt;input type="submit" value="提交"&gt;</div><div class="line"></div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">接受参数方法：</div><div class="line">@RequestMapping("recievelist")</div><div class="line">	public String recievelist(Usercus userlist)</div><div class="line">	&#123;</div><div class="line">		System.out.println(userlist.getUserlist().get(0).getUsername());</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[spring mvc之二:处理器]]></title>
      <url>http://www.myzwl.win/2017/03/18/springmvc2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在spring mvc中，使用映射处理器可以把web请求映射到正确的处理器上，spring内置了很多映射器，而且我们也可以自定义处理器，映射处理器都能把请求传递到处理器执行链接上，并且处理器执行链接必须包含能处理该请求的处理器，而且处理器链接也能包含一系列拦截器<br>  接下来就是一些常见的处理映射器</p>
<h4 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h4><p> 功能：寻找Controller<br>        根据url请求去匹配bean的name属性url，从而获取Controller<br>      这里注意：这是默认的映射器，也就是说我们不配置这个，也能自动执行这个<br>     如：入门程序中的案例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置自定义Controler --&gt;</div><div class="line">		&lt;bean id=<span class="string">"mycontrol"</span> name=<span class="string">"/hello.do"</span> class=<span class="string">"com.zwl.control.mycontrol"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p> 即根据自定义的/hello.do，找到对应的mycontrol.java类</p>
<h4 id="SimpleUrlHandlerMaping"><a href="#SimpleUrlHandlerMaping" class="headerlink" title="SimpleUrlHandlerMaping"></a>SimpleUrlHandlerMaping</h4><p> 功能：寻找Controller<br>      根据浏览器url匹配简单url的key，key又Controller的id找到Controller<br>如：在映射文件中配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</div><div class="line">		&lt;property name=<span class="string">"mappings"</span>&gt;</div><div class="line">		&lt;props&gt;</div><div class="line">		&lt;prop key=<span class="string">"zwl.do"</span>&gt;mycontrol&lt;/prop&gt;</div><div class="line">		&lt;prop key=<span class="string">"slycmiaoxi.do"</span>&gt;mycontrol&lt;/prop&gt;</div><div class="line">		&lt;/props&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;/bean&gt;</div><div class="line"></div><div class="line">		   &lt;!-- 配置自定义Controler --&gt;</div><div class="line">		&lt;bean id=<span class="string">"mycontrol"</span>  class=<span class="string">"com.zwl.control.mycontrol"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器输入<a href="http://localhost:100/springmvc1/zwl.do或者http://localhost:100/springmvc1/slycmiaoxi.do" target="_blank" rel="external">http://localhost:100/springmvc1/zwl.do或者http://localhost:100/springmvc1/slycmiaoxi.do</a></p>
<p>输出结果：</p>
<blockquote>
<p>hello world</p>
</blockquote>
<p>此外：这个映射器是把url进行集中配置</p>
<h4 id="ControllerClassNameHandlerMapping"><a href="#ControllerClassNameHandlerMapping" class="headerlink" title="ControllerClassNameHandlerMapping"></a>ControllerClassNameHandlerMapping</h4><p>功能：寻找Controller<br>       根据类名（Mycontrol）类名.do来访问,类名首字母小写<br>在配置文件中增加如下配置</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 定义通过: 类名<span class="selector-class">.do</span> 形式来访问controller --&gt;</div><div class="line">		 &lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>注意，这里并没有声明mycontrol.do和只有一个类mycontrol.java</p>
<p>测试：在浏览器输入<a href="http://localhost:100/springmvc1/mycontrol.do" target="_blank" rel="external">http://localhost:100/springmvc1/mycontrol.do</a><br>结果：</p>
<blockquote>
<p>hello world</p>
</blockquote>
<p>事实上，以上三个映射器都可以同时存在</p>
<p>下面将是处理器适配器</p>
<h4 id="SimpleControllerHandlerAdapter"><a href="#SimpleControllerHandlerAdapter" class="headerlink" title="SimpleControllerHandlerAdapter"></a>SimpleControllerHandlerAdapter</h4><p>功能：执行controller<br>      调用controller里面方法，返回modelAndView。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置处理器适配器执行Controlelr ,springmvc默认的</div><div class="line">		SimpleControllerHandlerAdapter:执行Controller</div><div class="line">		--&gt;</div><div class="line">		&lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h4 id="HttpRequestHandlerAdapter"><a href="#HttpRequestHandlerAdapter" class="headerlink" title="HttpRequestHandlerAdapter"></a>HttpRequestHandlerAdapter</h4><p>功能：执行controller<br>首先新建一个类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import javax.servlet.ServletException;</div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import org.springframework.web.HttpRequestHandler;</div><div class="line"></div><div class="line">public class httpcontrol implements HttpRequestHandler &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void handleRequest(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line">		       request.setCharacterEncoding("utf-8");</div><div class="line">		     //给Request设置值，在页面进行回显</div><div class="line">		       request.setAttribute("hello", "lol");</div><div class="line">		       response.setCharacterEncoding("utf-8");</div><div class="line">		     //跳转页面</div><div class="line">		       request.getRequestDispatcher("/index.jsp").forward(request, response);;</div><div class="line"> </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在配置文件中配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!-- HttpRequestHandlerAdapter负责执行实现接口HttpRequestHandler的后端</div><div class="line">			 控制器。</div><div class="line">		 --&gt;</div><div class="line">		&lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"</span>&gt;&lt;/bean&gt;</div><div class="line">		</div><div class="line">		&lt;!-- 配置自定义HttpController --&gt;</div><div class="line">		&lt;bean id=<span class="string">"http"</span> class=<span class="string">"com.zwl.control.httpcontrol"</span>&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">		&lt;prop key=<span class="string">"/zwl.do"</span>&gt;http&lt;/prop&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入：<a href="http://localhost:100/springmvc1/zwl.do" target="_blank" rel="external">http://localhost:100/springmvc1/zwl.do</a></p>
<p>输出结果：</p>
<blockquote>
<p>lol</p>
</blockquote>
<p>注意这两个处理器设配器可以共存！</p>
<h4 id="命令控制器"><a href="#命令控制器" class="headerlink" title="命令控制器"></a>命令控制器</h4><p>Spring mvc通过命令设计模式接受页面参数。</p>
<p>自定义命令控制器<br>首先新建一个pojo类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pojo;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line">private int id;</div><div class="line">private String username;</div><div class="line">public int getId() &#123;</div><div class="line">	return id;</div><div class="line">&#125;</div><div class="line">public String getUsername() &#123;</div><div class="line">	return username;</div><div class="line">&#125;</div><div class="line">public void setId(int id) &#123;</div><div class="line">	this.id = id;</div><div class="line">&#125;</div><div class="line">public void setUsername(String username) &#123;</div><div class="line">	this.username = username;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自定义控制器<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import org.springframework.validation.BindException;</div><div class="line">import org.springframework.web.servlet.ModelAndView;</div><div class="line">import org.springframework.web.servlet.config.MvcNamespaceHandler;</div><div class="line">import org.springframework.web.servlet.mvc.AbstractCommandController;</div><div class="line"></div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public class CommandController extends AbstractCommandController &#123;</div><div class="line"></div><div class="line">	//指定参数绑定哪个pojo类</div><div class="line">		public CommandController()&#123;</div><div class="line">			</div><div class="line">			this.setCommandClass(User.class);</div><div class="line">			</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected ModelAndView handle(HttpServletRequest request,</div><div class="line">			HttpServletResponse response, Object command, BindException error)</div><div class="line">			throws Exception &#123;</div><div class="line">		//将命令对象强转成用户对象</div><div class="line">		User user=(User)command;</div><div class="line">		ModelAndView mv=new ModelAndView();</div><div class="line">		mv.addObject("user",user);</div><div class="line">        mv.setViewName("index");	</div><div class="line">		return mv;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>封装参数页面（这里是login.jsp）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  &lt;body&gt;</div><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/command.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">姓名：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"username"</span> id=<span class="string">"username"</span>&gt;</div><div class="line">id：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"id"</span> id=<span class="string">"id"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>配置bean<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=<span class="string">"/command.do"</span> class=<span class="string">"com.zwl.control.CommandController"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>回显数据：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> &lt;body&gt;</div><div class="line"> $&#123;user<span class="selector-class">.username</span> &#125; &lt;br&gt;</div><div class="line">$&#123;user<span class="selector-class">.id</span> &#125; &lt;br&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc1/login.jsp到login.jsp" target="_blank" rel="external">http://localhost:100/springmvc1/login.jsp到login.jsp</a><br>然后分别将name输入中文和非中文，发现出现中文乱码</p>
<p>需要Spring编码过滤器：在web.xml配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line"> &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line"> &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line"> &lt;init-param&gt;</div><div class="line"> &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line"> &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line"> &lt;/init-param&gt;</div><div class="line"> &lt;/filter&gt;</div><div class="line"> </div><div class="line"> &lt;filter-mapping&gt;</div><div class="line"> &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line"> &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line"> &lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>然后输入中文，就没有乱码了</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring mvc之一:hello world]]></title>
      <url>http://www.myzwl.win/2017/03/17/springmvc1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MVC模式是Model-View-Control的简写，而spring mvc主要负责c层，主要为封装web请求为一个数据对象、调用业务逻辑层来处理数据对象、返回处理数据结果及相应的视图给用户</p>
<p>简要概述spring mvc：<br>   SpringC层框架的核心是DispatcherServlet，它的作用是将请求分发给不同的后端处理器，springC层框架使用了后端控制器、映射处理器和视图解析器来共同完成c层的主要任务，真正的把业务层处理的数据结果和相应的视图拼成一个对象，即ModelAndView对象</p>
<p>下面以hello world为入门程序搭建环境<br>步骤一：创建一个web工程</p>
<p>步骤二：导入相关jar包<br><img src="/images/imgs2/16.gif" alt="Alt text"></p>
<p>步骤三：编写web.xml配置文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt;</div><div class="line"></div><div class="line">  &lt;servlet&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet</div><div class="line">&lt;/servlet-class&gt;</div><div class="line"> &lt;/servlet&gt;</div><div class="line">  </div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>简要说明一下：dispatcherservlet就是一个servlet，也是对请求进行转发的核心servlet。在这里即所有的.do的请求将首先被dispatcherservlet处理，而它要做的工作就是对请求进行分发（即把请求转发给具体的controller），可以简单的认为，他就是一个总控处理器，除此之外，它还能使用spring的其他功能<br>同时注意一下上面的servlet-name<br>默认加载方式<br>         默认加载必须规范：</p>
<pre><code>* 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml
* 路径规范：必须在WEB-INF目录下面
</code></pre><p> 步骤四：配置springmvc-servlet.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt;</div><div class="line">		</div><div class="line">		</div><div class="line">		&lt;!-- 配置处理器映射器,springmvc默认的处理器映射器</div><div class="line">		BeanNameUrlHandlerMapping：根据bean(自定义Controler)的name属性的url去寻找hanler(Action:Controller)</div><div class="line">		 --&gt;</div><div class="line">		&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt;</div><div class="line">	 	</div><div class="line">		&lt;!-- 配置处理器适配器执行Controlelr ,springmvc默认的</div><div class="line">		SimpleControllerHandlerAdapter:执行Controller</div><div class="line">		--&gt;</div><div class="line">		&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt;</div><div class="line">		</div><div class="line">		&lt;!-- 配置自定义Controler --&gt;</div><div class="line">		&lt;bean id="mycontrol" name="/hello.do" class="com.zwl.control.mycontrol"&gt;&lt;/bean&gt;</div><div class="line">		</div><div class="line">	</div><div class="line">		&lt;!-- 配置sprigmvc视图解析器：解析逻辑试图 </div><div class="line">			 后台返回逻辑试图：index</div><div class="line">			视图解析器解析出真正物理视图：前缀+逻辑试图+后缀--&gt;</div><div class="line"></div><div class="line">		&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;</div><div class="line">		&lt;property name="prefix" value="/"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;		</div><div class="line">		&lt;/bean&gt;</div><div class="line">		&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>步骤五：自定义controller<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import org.springframework.web.servlet.ModelAndView;</div><div class="line">import org.springframework.web.servlet.mvc.Controller;</div><div class="line"></div><div class="line">public class mycontrol implements Controller &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public ModelAndView handleRequest(HttpServletRequest arg0,</div><div class="line">			HttpServletResponse arg1) throws Exception &#123;</div><div class="line">		//接受请求，参数，验证参数</div><div class="line">		//封装参数，调用业务方法</div><div class="line">		//返回视图</div><div class="line">		ModelAndView mv=new ModelAndView();</div><div class="line">		</div><div class="line">		//设置页面回显数据</div><div class="line">		mv.addObject("hello","hello world");</div><div class="line">		//指定跳转的视图</div><div class="line">		//返回物理视图</div><div class="line">        mv.setViewName("index");	</div><div class="line">		return mv;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤六：定义视图页面<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">   $&#123;hello&#125;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc1/hello.do" target="_blank" rel="external">http://localhost:100/springmvc1/hello.do</a></p>
<p>结果：</p>
<blockquote>
<p>hello world </p>
</blockquote>
<p>简要分析入门程序的过程<br>1 启动服务器，根据web.xml的配置加载前端控制器dispatcherservlet。在加载时，会完成一系列的初始化动作。</p>
<p>2 根据servlet的映射请求（上面的.do），并参照spingmvc-servlet.xml文件，把具体的请求分发给特定的后端处理器，如上面的mycontrol</p>
<p>3 后端控制器调用相应的逻辑层代码，完成处理并返回视图对象ModelAndView给前端处理器</p>
<p>4 前端处理器根据后端控制器返回的ModelAndView对象，返回一个相应的页面给客户端</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring之装配bean]]></title>
      <url>http://www.myzwl.win/2017/03/16/spring2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在spring中，对象无需自己负责查找或创建与其关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象，例如一个消费系统需要信誉证件，但它不需要自己创建，它只负责自己两手空空，而容器就赋予它一个信用卡认证组件。<br>  通常，我们将创建应用对象间相互协作关系的行为称为装配。这也是依赖注入的本质。</p>
<h4 id="一：声明bean"><a href="#一：声明bean" class="headerlink" title="一：声明bean"></a>一：声明bean</h4><p>  首先我们假想一个选秀场景，该bean为一个表演接口<br>  public interface Performe {<br>    public void perform();<br>}<br>很显然我们需要一些参赛者，而这些参赛者就需要spring帮我们创建了</p>
<h4 id="二：创建spring配置"><a href="#二：创建spring配置" class="headerlink" title="二：创建spring配置"></a>二：创建spring配置</h4><p>   Spring是一个基于容器的框架，但是如果我们不对他进行任何配置，那么它就相当于一个空框架，一般情况下有采用XML或者注解式声明，这里都采用xml形式。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">		xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">		xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<h4 id="三：声明一个简单的bean"><a href="#三：声明一个简单的bean" class="headerlink" title="三：声明一个简单的bean"></a>三：声明一个简单的bean</h4><p>  这次表演者可以使各种各样的人，首先是一个杂技师。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Juggler implements Performe &#123;</div><div class="line"></div><div class="line">	private int bigbang=5;</div><div class="line">	</div><div class="line">	public Juggler()&#123;	</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Juggler(int bigbang)&#123;</div><div class="line">		this.bigbang=bigbang;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void perform() &#123;</div><div class="line">		System.out.println("it is "+bigbang);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要打印出杂技师扔了多少块Bigbang；</p>
<p>接下来在spring中配置bean，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;bean id=<span class="string">"juggle"</span> class=<span class="string">"com.zwl.dao.Juggler"</span>&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>这是一个最简单的声明格式<br>接下来就是加载spring上下文，进行测试</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Juggler hello=(Juggler) ApplicaionContextUtil.getApplicationContext().getBean("juggle");</div><div class="line">		hello.perform();</div></pre></td></tr></table></figure>
<p>ApplicaionContextUtil.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private static ApplicationContext ac=null;</div><div class="line"></div><div class="line">private ApplicaionContextUtil()&#123;		</div><div class="line">&#125;</div><div class="line">static&#123;</div><div class="line">	ac=new ClassPathXmlApplicationContext("applicationContext.xml");</div><div class="line">&#125;</div><div class="line">public static ApplicationContext getApplicationContext()&#123;</div><div class="line">	return ac;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<blockquote>
<p>it is 5</p>
</blockquote>
<h4 id="四：通过构造器注入"><a href="#四：通过构造器注入" class="headerlink" title="四：通过构造器注入"></a>四：通过构造器注入</h4><p> 有时候我们需要通过构造方法进行注入<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"juggle"</span> class=<span class="string">"com.zwl.dao.Juggler"</span>&gt;</div><div class="line">&lt;constructor-arg value=<span class="string">"66"</span>&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>因为Juggle有一个代参和无参构造函数，默认不配置constructor-arg则是默认构造函数，相反则是代参构造函数，</p>
<p>构造器注入对象引用<br> 上面是注入的基本类型，如果是一个对象了？<br> 在Juggler类中增加如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private Helloworld helloworld;</div><div class="line">	</div><div class="line">	public Juggler(Helloworld helloworld)&#123;</div><div class="line">		this.helloworld=helloworld;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">public void perform() &#123;</div><div class="line">		System.out.println("it is "+bigbang);</div><div class="line">		helloworld.sayhello();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>其中helloworld为入门时的程序</p>
<p>接下来就是配置文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.spring.Helloworld"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"name"</span>&gt;</div><div class="line">&lt;value&gt;hello world!&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt; </div><div class="line"></div><div class="line">&lt;bean id=<span class="string">"juggle"</span> class=<span class="string">"com.zwl.dao.Juggler"</span>&gt;</div><div class="line">&lt;constructor-arg ref=<span class="string">"helloworld"</span>&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>其中ref为注入另一个bean的id<br>测试结果：</p>
<blockquote>
<p>it is 5<br>it is hello world</p>
</blockquote>
<h4 id="五：bean的作用域"><a href="#五：bean的作用域" class="headerlink" title="五：bean的作用域"></a>五：bean的作用域</h4><p>  所有的spring bean默认都是单例，即它总是返回同一个bean实例，通过在bean中的scope属性进行设置，一般有如下属性<br>  Singleton 在每一个spring容器中，一个bean定义只对应一个对象实例（默认）<br>  Prototype  允许bean的定义可以被实例化任意次（每次调用都创建一个实例）<br>  另外还有request，session，global-session，一般只用前两者<br>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Helloworld hello=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld");</div><div class="line">		Helloworld hello1=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld");</div><div class="line">		System.out.println(hello==hello1);</div></pre></td></tr></table></figure></p>
<p>当采用默认scope时，测试结果为true</p>
<p>当进行如下修改时<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.spring.Helloworld"</span> scope=<span class="string">"prototype"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>测试结果为false</p>
<p>另外在我们初始化和销毁bean时，需要在bean中配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.spring.Helloworld"</span> scope=<span class="string">"prototype"</span> init-method=<span class="string">"sayhello"</span> destroy-method=<span class="string">"saybyb"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>其中sayhello与saybyb都是该类中方法，当在调用该bean之前，调用init-method，而在该bean销毁前，即生命周期结束前实现destroy-method，</p>
<h4 id="六：注入bean属性"><a href="#六：注入bean属性" class="headerlink" title="六：注入bean属性"></a>六：注入bean属性</h4><p>   通常，javabean的属性时私有的，同时拥有一组set与get方法取出该属性，spring可以借助set配置属性的值<br>   注意，这里和利用构造器的注入差不多<br>   如注入简单值<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"name"</span> value=<span class="string">"hello world"</span>&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>引用其他bean<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"hello"</span> ref=<span class="string">"helloworld"</span>&gt;&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>其中name中的值是该bean中的属性，名字要一致，而ref是该配置文件中的其他bean</p>
<h4 id="七：装配集合"><a href="#七：装配集合" class="headerlink" title="七：装配集合"></a>七：装配集合</h4><p>  前面我们都是介绍单个对象的装配，对于复合类型该如何装配了<br> 不妨模拟一个案例<br>首相是一个Student类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package com.zwl.spring;</div><div class="line"></div><div class="line">public class Student &#123;</div><div class="line"></div><div class="line">	private String name;</div><div class="line"></div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是School类，主要有的属性为集合，首先是list<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class School &#123;</div><div class="line"></div><div class="line">	private List&lt;Student&gt; stulist;</div><div class="line">	</div><div class="line">	public List&lt;Student&gt; getStulist() &#123;</div><div class="line">		return stulist;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setStulist(List&lt;Student&gt; stulist) &#123;</div><div class="line">		this.stulist = stulist;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置的bean<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"stu"</span> class=<span class="string">"com.zwl.spring.Student"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"name"</span> value=<span class="string">"hello"</span>&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id=<span class="string">"stu1"</span> class=<span class="string">"com.zwl.spring.Student"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"name"</span> value=<span class="string">"world"</span>&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>简要说明一下，这里注入同一个类的不同bean，用于装入集合<br>然后是配置school<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"sch"</span> class=<span class="string">"com.zwl.spring.School"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"stulist"</span>&gt;</div><div class="line">&lt;list&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu"</span>/&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu1"</span>/&gt;</div><div class="line">&lt;/list&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>一般格式如下，属性下，配置<list>和要引入的bean</list></p>
<p>测试代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch");</div><div class="line">		String name1=hello.getStulist().get(0).getName();</div><div class="line">		String name=hello.getStulist().get(1).getName();</div><div class="line">		System.out.println(name1+name);</div></pre></td></tr></table></figure></p>
<p>测试结果:</p>
<blockquote>
<p>helloworld</p>
</blockquote>
<p>Set集合装配<br> 首先在school类中加入如下属性<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> private Set&lt;Student&gt; stuset;</div><div class="line">省略set与get方法</div></pre></td></tr></table></figure></p>
<p>配置文件，添加如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"stuset"</span>&gt;</div><div class="line">&lt;set&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu"</span>/&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu1"</span>/&gt;</div><div class="line">&lt;/set&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>对应测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch");</div><div class="line">	Iterator&lt;Student&gt; it=hello.getStuset().iterator();</div><div class="line">	while(it.hasNext())&#123;</div><div class="line">		Student stu=it.next();</div><div class="line">		System.out.println(stu.getName());</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这里通过迭代器取出对象<br>测试结果：</p>
<blockquote>
<p>hello<br>world</p>
</blockquote>
<p>Map集合装配<br> 首先在school中添加如下属性：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private Map&lt;String, Student&gt; stumap;</div><div class="line">省略set与get方法。。</div></pre></td></tr></table></figure></p>
<p>配置文件，添加如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"stumap"</span>&gt;</div><div class="line">&lt;map&gt;</div><div class="line">&lt;entry key=<span class="string">"11"</span> value-ref=<span class="string">"stu"</span>&gt;&lt;/entry&gt;</div><div class="line">&lt;entry key=<span class="string">"22"</span> value-ref=<span class="string">"stu1"</span>&gt;&lt;/entry&gt;</div><div class="line">&lt;/map&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>其中，key为map的索引值，而value-ref为引用的bean<br>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch");</div><div class="line">		String name=hello.getStumap().get("11").getName();</div><div class="line">		String name1=hello.getStumap().get("22").getName();</div><div class="line">		System.out.println(name+name1);</div></pre></td></tr></table></figure></p>
<p>测试结果:</p>
<blockquote>
<p>helloworld</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring之hello world]]></title>
      <url>http://www.myzwl.win/2017/03/15/spring1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> spring 是容器框架,用于配置bean,并维护bean之间关系的框架，而bean是java中的任何一种对象 javabean/service/action/数据源./dao, ioc(控制反转 inverse of control) di( dependency injection 依赖注入)，而spring的设计思想主要为单例和工厂模式，它能很好的解耦，简化开发，同时贯穿于各层。</p>
<p> 不多说，先来一个入门案例，目的在先具体把握，最后在看细节</p>
<p> 步骤一：创建一个web工程，同时引入两个jar包，一个是spring核心包（spring.jar）和日包（commons-logging.jar）及测试包junit；</p>
<p> 步骤二：新建applicationContent.xml文件，该文件是spring的核心文件，先放在src目录下，里面暂时什么都不写</p>
<p> 步骤三：编写helloworld类：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.zwl.spring;</div><div class="line"></div><div class="line">public class Helloworld &#123;</div><div class="line">private String name;</div><div class="line"></div><div class="line">public String getName() &#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setName(String name) &#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">public void sayhello()&#123;</div><div class="line">	System.out.println("it is "+name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要通过spring自动注入name为helloworld来演示</p>
<p>步骤四：配置applicationContent.xml文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">		xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">		xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;</div><div class="line"></div><div class="line">&lt;!-- bean元素的作用是，当我们的spring框架加载时候，spring就会自动的创建一个bean对象，并放入内存 ,</div><div class="line">相当于Helloworld helloworld=new Helloworld();</div><div class="line">helloworld.setName("helloworld!"); </div><div class="line">id:用于唯一标识该bean，</div><div class="line">class:相应的bean所处的位置</div><div class="line">--&gt;</div><div class="line">&lt;bean id="helloworld" class="com.zwl.spring.Helloworld"&gt;</div><div class="line">&lt;property name="name"&gt;</div><div class="line">&lt;value&gt;hello world!&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>步骤五：编写工具类<br>因为spring也是初始化加载很耗内存，所以同样采取单例模式初始化<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utils;</div><div class="line"></div><div class="line">import org.springframework.context.ApplicationContext;</div><div class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line">public class ApplicaionContextUtil &#123;</div><div class="line">private static ApplicationContext ac=null;</div><div class="line">	</div><div class="line">	private ApplicaionContextUtil()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	static&#123;</div><div class="line">		//1.得到spring 的applicationContext对象(容器对象)</div><div class="line">		ac=new ClassPathXmlApplicationContext("applicationContext.xml");</div><div class="line">	&#125;</div><div class="line">	public static ApplicationContext getApplicationContext()&#123;</div><div class="line">		return ac;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤六：编写测试类（用junit4）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">	public void test()&#123;</div><div class="line">//得到bean对象</div><div class="line">	 Helloworld hello=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld");</div><div class="line">	 hello.sayhello();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>it is hello world ！</p>
</blockquote>
<p>至此helloworld程序完成，当然这只是一个初步的认识spring是什么，事实上spring的注入远不止如此简单，但至少有一点可以明确，通过spring，可以帮我们管理，特别是结合其他开源框架，达到解耦和高效的作用。</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代理模式（四）之模仿spring Aop及真实jdk的动态代理]]></title>
      <url>http://www.myzwl.win/2017/03/14/dyproxy3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式，尤其是动态代理，他从思想上改变了我们对编程的认识，可以想象一个切面我们在其中添加任何控制如事务、日志、权限等，而这也是面向切面编程的核心，更是spring Aop的核心，而设计才是实用的，框架和配置都是虚的，尤其当抛开jdk底层代码设计，才发现其中的来龙去脉和乐趣。</p>
<p>总之，动态代理设计模式的思想太强大了。接下来将用之前模拟的jdk动态代码和jdk本身自带的动态来模拟一个案例</p>
<p>大概物理情景是，添加一个打野信息接口和打野代理，利用InvocationHandler实现代理对具体打野的代理</p>
<p>首先是一个打野接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line"></div><div class="line">public interface JungleInfo &#123;</div><div class="line"></div><div class="line">	public void addJungle();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打野接口实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line"></div><div class="line">public class JungleInfoimpl implements JungleInfo &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void addJungle() &#123;</div><div class="line">		System.out.println("Js is ganking");</div><div class="line">		System.out.println("Leesin is ganking");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打野代理<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line"></div><div class="line">import java.lang.reflect.Method;</div><div class="line"></div><div class="line">public class JungleHandler implements InvocationHandler &#123;</div><div class="line"></div><div class="line">private Object target;</div><div class="line">	</div><div class="line">	public JungleHandler(Object target) &#123;</div><div class="line">		super();</div><div class="line">		this.target = target;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void invoke(Object o, Method m) &#123;</div><div class="line">		//控制之前的业务逻辑</div><div class="line">		System.out.println("JungleHandler is starting");</div><div class="line">		try &#123;</div><div class="line">			m.invoke(target);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		//控制之后的业务逻辑</div><div class="line">		System.out.println("JungleHandler is ending");</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了方便这里只是打印了一个语句<br>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">      //被代理对象</div><div class="line">      JungleInfo jun=new JungleInfoimpl();</div><div class="line">      //代理类</div><div class="line">InvocationHandler invo=new JungleHandler(jun);</div><div class="line">JungleInfo jung=(JungleInfo) Proxy.newProxyInstance(JungleInfo.class, invo);</div><div class="line">jung.addJungle();</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>JungleHandler is starting<br>Js is ganking<br>Leesin is ganking<br>JungleHandler is ending</p>
</blockquote>
<p>至此我们发现如果我们想在这个切面中再加一个控制，好办，再写一个handle类，代理其它handle类，达到切面控制效果。<br>当然，以后只要实现InvocationHandler接口就能达到效果，而proxy底层都不需要知道</p>
<h3 id="jdk的动态代理"><a href="#jdk的动态代理" class="headerlink" title="jdk的动态代理"></a>jdk的动态代理</h3><p>同样是上面的例子，知识代理handler需要改变</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">     package com.zwl.pr;</div><div class="line"></div><div class="line">import java.lang.reflect.InvocationHandler;</div><div class="line">import java.lang.reflect.Method;</div><div class="line"></div><div class="line">public class JungleHandlers implements InvocationHandler &#123;</div><div class="line"></div><div class="line">	</div><div class="line">private Object target;</div><div class="line">	</div><div class="line">	public JungleHandlers(Object target) &#123;</div><div class="line">		super();</div><div class="line">		this.target = target;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public Object invoke(Object proxy, Method method, Object[] args)</div><div class="line">			throws Throwable &#123;</div><div class="line">		System.out.println("Jdk is starting");</div><div class="line">		method.invoke(target, args);</div><div class="line">		System.out.println("Jdk is ending");</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中Object proxy是指代理类，Method method是指被代理的方法，Object[] args为该方法的参数数组</p>
<p>接下来是测试类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">      JungleInfo jun=new JungleInfoimpl();</div><div class="line">JungleHandlers invo=new JungleHandlers(jun);</div><div class="line">JungleInfo jung=(JungleInfo) Proxy.newProxyInstance(JungleInfo.class.getClassLoader(),new Class&lt;?&gt;[]&#123;JungleInfo.class&#125;,  invo);</div><div class="line">jung.addJungle();</div></pre></td></tr></table></figure>
<p>其中jung将返回一个代理类的实例JungleInfo.class.getClassLoader()是类装载器，第二个参数是任何真实类拥有的全部接口的数组，第三个参数就是真实的handles</p>
<p>测试结果：</p>
<blockquote>
<p>Jdk is starting<br>Js is ganking<br>Leesin is ganking<br>Jdk is ending</p>
</blockquote>
<p>至此，我们利用动态代理，就可以在不修改原来代码的基础上，就可以在原来代码的基础上做操作，而这恰恰就是AOP编程的核心</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代理模式（三）之模仿jdk底层动态代理实现]]></title>
      <url>http://www.myzwl.win/2017/03/13/dyproxy2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面的基础上在做进一步的改进，前面我们是动态写死了方法，即自己指定了方法名，当然我们可以利用反射帮我们完成函数名的动态指定</p>
<p>首先是一个反射例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//拿到相应的类</div><div class="line">Method[]  methods=com.zwl.pr.Jungle.class.getMethods();</div><div class="line">		for(Method method: methods)&#123;</div><div class="line">		//循环输出该类的函数名，如public void ss();最后只输出ss</div><div class="line">			System.out.println(method.getName());</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>有了这个原理就可以对之前的proxy进行改造</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">public static Object newProxyInstance(Class interfac) throws Exception&#123;</div><div class="line">      </div><div class="line">      //动态拿到方法的代码</div><div class="line">		String methodStr = "";</div><div class="line">		String rt = "\r\n";</div><div class="line">		</div><div class="line">		//将指定的动态接口类名拿到</div><div class="line">		Method[] methods = interfac.getMethods();</div><div class="line"></div><div class="line">		//循环添加方法</div><div class="line">		for(Method m : methods) &#123;</div><div class="line">			methodStr += "@Override" + rt + </div><div class="line">						 "public void " + m.getName() + "() &#123;" + rt +</div><div class="line">						 	"   long start = System.currentTimeMillis();" + rt +</div><div class="line">							"   leesin." + m.getName() + "();" + rt +</div><div class="line">							"   long end = System.currentTimeMillis();" + rt +</div><div class="line">							"   System.out.println(\"time:\" + (end-start));" + rt +</div><div class="line">						 "&#125;";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line"></div><div class="line">				"public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"Jungle leesin;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(Jungle leesin) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.leesin = leesin;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line">          //这里循环动态输出方法</div><div class="line">					methodStr +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line"></div><div class="line">		//这里将动态生成的代理文件放到指定文件夹中，避免与bin里的.class文件冲突</div><div class="line">		String filename=</div><div class="line">				"E:/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div><div class="line"></div><div class="line">		   //compile</div><div class="line">				JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">				StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">				Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">				CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">				t.call();</div><div class="line">				fileMgr.close();</div><div class="line">				</div><div class="line">				//load into memory and create an instance</div><div class="line">				//更改到指定文件夹</div><div class="line">				URL[] urls = new URL[] &#123;new URL("file:/" + "E:/src/")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div><div class="line">				</div><div class="line">				Constructor ctr = c.getConstructor(Jungle.class);</div><div class="line">				</div><div class="line">				//返回任意一个类</div><div class="line">				Object jungle=ctr.newInstance(new LeeSin());</div><div class="line">				</div><div class="line">		</div><div class="line">		return jungle;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<pre><code>注意这里和之前做了几处修改
1.利用反射动态生成方法
2.更改编译后生成文件的目录
3.返回类型为object
4具体在代码里有注释

测试类：
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class);</div><div class="line">		jungle.gank();</div></pre></td></tr></table></figure>
</code></pre><p>输出结果</p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>LeeSin is ganking…<br>gank time:1336<br>time:1336</p>
</blockquote>
<p>这里很明显发现方法都是固定的，如果想要方法都是动态生成的，则要进行进一步修改<br>首先增加一个<br>InvocationHandler动态生成类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface InvocationHandler &#123;</div><div class="line">	public void invoke(Object o, Method m);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是具体的针对所有接口的时间处理类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class TimeHandler implements InvocationHandler &#123;</div><div class="line"></div><div class="line">   //代理类</div><div class="line">	private Object target;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	public TimeHandler(Object target) &#123;</div><div class="line">		super();</div><div class="line">		this.target = target;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void invoke(Object o, Method m) &#123;</div><div class="line">		long start = System.currentTimeMillis();</div><div class="line">		try &#123;</div><div class="line">			//指定代理类的动态方法</div><div class="line">			m.invoke(target);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		long end = System.currentTimeMillis();</div><div class="line">		System.out.println("time:" + (end-start));</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后proxy里也要进行相应修改</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//参数分别为被代理对象与代理对象</div><div class="line">public static Object newProxyInstance(Class interfac,InvocationHandler h) throws Exception&#123;</div><div class="line">		String methodStr = "";</div><div class="line">		String rt = "\r\n";</div><div class="line">		</div><div class="line">		Method[] methods = interfac.getMethods();</div><div class="line">		</div><div class="line">	//动态生成方法，其中this是指代理对象本身，而md是指方法名，这里的h是构造函数传的代理对象</div><div class="line">		for(Method m : methods) &#123;</div><div class="line">			methodStr += "@Override" + rt + </div><div class="line">						 "public void " + m.getName() + "() &#123;" + rt +</div><div class="line">						 "    try &#123;" + rt +</div><div class="line">						 "    Method md = " + interfac.getName() + ".class.getMethod(\"" + m.getName() + "\");" + rt +</div><div class="line">						 "    h.invoke(this, md);" + rt +</div><div class="line">						 "    &#125;catch(Exception e) &#123;e.printStackTrace();&#125;" + rt +</div><div class="line">						</div><div class="line">						 "&#125;";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line">               "import java.lang.reflect.Method;" + rt +</div><div class="line">				"public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"com.zwl.pr.InvocationHandler h;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(InvocationHandler h) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.h = h;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line"></div><div class="line">					methodStr +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line">		String filename=</div><div class="line">				"E:/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div><div class="line"></div><div class="line">		   //compile</div><div class="line">				JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">				StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">				Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">				CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">				t.call();</div><div class="line">				fileMgr.close();</div><div class="line">				</div><div class="line">				//load into memory and create an instance</div><div class="line">				URL[] urls = new URL[] &#123;new URL("file:/" + "E:/src/")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div><div class="line">				</div><div class="line">				//返回代理类</div><div class="line">				Constructor ctr = c.getConstructor(InvocationHandler.class);</div><div class="line">				</div><div class="line">				Object jungle=ctr.newInstance(h);</div><div class="line">				</div><div class="line">		</div><div class="line">		return jungle;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//被代理对象</div><div class="line">LeeSin leesin=new LeeSin();</div><div class="line">//代理对象</div><div class="line">		InvocationHandler ivo=new TimeHandler(leesin);</div><div class="line">		Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class,ivo);</div><div class="line">		jungle.gank();</div></pre></td></tr></table></figure>
<p>对应生成的java文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line">import java.lang.reflect.Method;</div><div class="line">public class LeeSinTimeProxy implements com.zwl.pr.Jungle&#123;</div><div class="line">com.zwl.pr.InvocationHandler h;</div><div class="line">public LeeSinTimeProxy(InvocationHandler h) &#123;</div><div class="line">super();</div><div class="line">this.h = h;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public void gank() &#123;</div><div class="line">    try &#123;</div><div class="line">    Method md = com.zwl.pr.Jungle.class.getMethod("gank");</div><div class="line">    h.invoke(this, md);</div><div class="line">    &#125;catch(Exception e) &#123;e.printStackTrace();&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>对应的测试结果 </p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>LeeSin is ganking…<br>gank time:2642<br>time:2642</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代理模式（二）之初识动态代理]]></title>
      <url>http://www.myzwl.win/2017/03/12/dyproxy1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我们通过静态代理可以在编译期创建一个代理对象，如果要求我们必须在运行时创建一个代理，如时间代理，如何做了？<br>也就是说，需要写一个代理（proxy），然后我们只需要传入相关接口，它就可以主动生成代理对象</p>
<p>再一次使用之前的情景，即有一个打野对象接口和具体打野盲僧，然后编写一个针对打野的动态代理（proxy），只要传入（打野接口对象），就可以动态自动生成该java文件，并且载入内存并不jvm编译</p>
<p>下面就是其代码实现</p>
<p>Jungle（打野接口）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">  //打野gank方法</div><div class="line">	public void gank();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LeeSin（盲僧）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		//gank开始时间</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		System.out.println("LeeSin is ganking...");</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			//gank进行中</div><div class="line">			Thread.sleep(new Random().nextInt(10000));</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		//gank结束时间</div><div class="line">        long ends=System.currentTimeMillis();</div><div class="line">        System.out.println("gank time:"+(ends-starts));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果想要动态生成一个事件代理（按常理应该新建一个代理类），按照动态思想，我们将该创建该类的所以涉及的代码赋给一个字符串<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">String str=</div><div class="line">		"package com.zwl.pr;" +</div><div class="line"></div><div class="line">		"public class LeeSinTimeProxy implements Jungle &#123;" +</div><div class="line"></div><div class="line">			</div><div class="line">			"Jungle leesin;" +</div><div class="line">			</div><div class="line">			</div><div class="line">			"public LeeSinTimeProxy(Jungle leesin) &#123;" +</div><div class="line">				"super();" +</div><div class="line">				"this.leesin = leesin;" +</div><div class="line">			"&#125;" +</div><div class="line"></div><div class="line"></div><div class="line">			"@Override" +</div><div class="line">			"public void gank() &#123;" +</div><div class="line">				"long starts=System.currentTimeMillis();" +</div><div class="line">				"leesin.gank();" +</div><div class="line">				 "long ends=System.currentTimeMillis();" +</div><div class="line">			      "  System.out.println(\"gank time:\"+(ends-starts));" +</div><div class="line"></div><div class="line">			"&#125;" +</div><div class="line"></div><div class="line">		"&#125;" ;</div></pre></td></tr></table></figure></p>
<p>上面字符串就是创建该代理的代码，然后如果jvm能自动将其编译成.class并且载入内存，就是一个真的类了，按照这种思想，我们可以通过jvm提供的方法完成<br>为了方便先把上述动态创建时间代理放在测试中（也就是main函数中）<br>1.首先将代码格式修整一下，即加个换行，同时将字符写入时间代理文件中<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> //换行，防止所有代码全部挤在一行</div><div class="line">String rt = "\r\n";</div><div class="line"></div><div class="line">//要动态生成的类的代码</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line"></div><div class="line">				"public class LeeSinTimeProxy implements Jungle &#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"Jungle leesin;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(Jungle leesin) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.leesin = leesin;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line"></div><div class="line">					"@Override" + rt +</div><div class="line">					"public void gank() &#123;" + rt +</div><div class="line">						"long starts=System.currentTimeMillis();" + rt +</div><div class="line">						"leesin.gank();" + rt +</div><div class="line">						 "long ends=System.currentTimeMillis();" + rt +</div><div class="line">					      "  System.out.println(\"gank time:\"+(ends-starts));" + rt +</div><div class="line"></div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		//得到该项目的根路径</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line"></div><div class="line">		//该时间代理文件的完整路径，不存在则创建（第一次自动动态创建）</div><div class="line">		String filename=System.getProperty("user.dir")+</div><div class="line">				"/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		//将字符写入该文件</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div></pre></td></tr></table></figure></p>
<p>这里先一小段一小段的加，目前是已经在该包下生成一个LeeSinTimeProxy.java文件，并且里面有被写入的字符，但是纯粹只是一个文件，因为还没被编译和载入内存</p>
<p>2.进行编译<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">            //compile</div><div class="line">            //得到java编译器，也就是javac了，至此我们可以最终将其编译，得到.class（二进制文件）</div><div class="line">JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">           //管理编译文件，默认为空就行</div><div class="line">StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">//所有编译的文件，目前就一个，当然可以传入多个</div><div class="line">Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">//编译任务管理，目前传入上面两个参数，其余默认为空就行</div><div class="line">CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">//执行任务编译</div><div class="line">t.call();</div><div class="line">fileMgr.close();</div></pre></td></tr></table></figure></p>
<p>至此，在包下也动态生成了一个.class文件，而平常我们编译时都会在path路径下，jdk主动生成.class，而此时我们自己指定了位置</p>
<p>3.载入内存<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//指定载入内存的url</div><div class="line">URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir")+"/src")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">//指定class文件载入</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div></pre></td></tr></table></figure></p>
<p>4.利用反射取出实例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//反射取出类</div><div class="line">Constructor ctr = c.getConstructor(Jungle.class);</div><div class="line">				</div><div class="line">		//操作该类相应方法，此处是动态返回类</div><div class="line">				Jungle jubgle= (Jungle) ctr.newInstance(new LeeSin());</div><div class="line">				//调用gank方法</div><div class="line">				jubgle.gank();</div></pre></td></tr></table></figure>
<p>以下是结果：</p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>LeeSin is ganking…<br>gank time:7557<br>gank time:7563</p>
</blockquote>
<p>至此算是动态生成了时间代理，但是目前是很有局限性的，因为我们指定了一个特定接口，而不是泛指，当然通过这个例子，也算是初识了一把动态模式的魅力，当然它的最大魅力，在于制定任何接口，返回相应的代理类</p>
<p>在这里我们先将测试的类中代码移至Proxy类中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class Proxy &#123;</div><div class="line"> </div><div class="line"> //这里的interfac就是动态指定了任何接口代理，而且必须取它的名字，否则是执行其tostring方法</div><div class="line">	public static Object newProxyInstance(Class interfac) throws Exception&#123;</div><div class="line">		String rt = "\r\n";</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line"></div><div class="line">				"public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"Jungle leesin;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(Jungle leesin) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.leesin = leesin;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line"></div><div class="line">					"@Override" + rt +</div><div class="line">					"public void gank() &#123;" + rt +</div><div class="line">						"long starts=System.currentTimeMillis();" + rt +</div><div class="line">						"leesin.gank();" + rt +</div><div class="line">						 "long ends=System.currentTimeMillis();" + rt +</div><div class="line">					      "  System.out.println(\"gank time:\"+(ends-starts));" + rt +</div><div class="line"></div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line">		String filename=System.getProperty("user.dir")+</div><div class="line">				"/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div><div class="line"></div><div class="line">		   //compile</div><div class="line">				JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">				StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">				Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">				CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">				t.call();</div><div class="line">				fileMgr.close();</div><div class="line">				</div><div class="line">				//load into memory and create an instance</div><div class="line">				URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir")+"/src")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div><div class="line">				</div><div class="line">				Constructor ctr = c.getConstructor(Jungle.class);</div><div class="line">				</div><div class="line">				Jungle jubgle= (Jungle) ctr.newInstance(new LeeSin());</div><div class="line">				jubgle.gank();</div><div class="line">		</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目前先不管错误，在做测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      LeeSin leesin=new LeeSin();</div><div class="line">Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class);</div><div class="line">jungle.gank();</div></pre></td></tr></table></figure></p>
<p>这里参数我们可以设置任何class接口，当然先不管错误，至少动态代理算是成功了。</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代理模式（一）之静态代理]]></title>
      <url>http://www.myzwl.win/2017/03/11/stproxy/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式从定义上说就是给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用</p>
<p>一般情况下，我们可以通过继承或者聚合来实现代理，当然继承会造成类爆炸，而聚合则更灵活<br>不多说，模拟一个静态代理的情景<br>假设打野是一个接口，有gank方法，记录打野行为，打野具体对象盲僧，实现其gank的时间并记录下来，然后后续打野盲僧1、盲僧2分别记录打野具体对象的gank时间和gank日志（目前打野对象为LeeSin）</p>
<p>Jungle（打野接口）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">  //打野gank方法</div><div class="line">	public void gank();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LeeSin（盲僧）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		//gank开始时间</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		System.out.println("LeeSin is ganking...");</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			//gank进行中</div><div class="line">			Thread.sleep(new Random().nextInt(10000));</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		//gank结束时间</div><div class="line">        long ends=System.currentTimeMillis();</div><div class="line">        System.out.println("gank time:"+(ends-starts));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是使用代理对象，比如用一个代理记录打野gank方法的时间<br>不妨先用继承（与后面聚合比较会发现继承将造成类爆炸）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//时间代理，记录gank时间</div><div class="line">public class LeeSin1 extends LeeSin &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		super.gank();</div><div class="line">		 long ends=System.currentTimeMillis();</div><div class="line">	        System.out.println("gank time:"+(ends-starts));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这时再有一个log代理，记录gank日志<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class LeeSin2 extends LeeSin &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		System.out.println("LeeSin starts ganking");</div><div class="line">		super.gank();</div><div class="line">		System.out.println("LeeSin ends ganking");		 </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果这时说先记录日志在记录时间或者先记录时间在记录日志，这时就要写两个类<br>列出主体代码（另一个调换位置）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">@Override</div><div class="line">public void gank() &#123;</div><div class="line">	System.out.println("LeeSin starts ganking");</div><div class="line">	long starts=System.currentTimeMillis();</div><div class="line">	super.gank();</div><div class="line">	 long ends=System.currentTimeMillis();</div><div class="line">        System.out.println("gank time:"+(ends-starts));</div><div class="line">        System.out.println("LeeSin ends ganking");	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能目前代理类较少，还没有缺陷，如果是100个甚至更多，只要稍微要求下顺序或者其他，就要增加一个类，显然造成类爆炸，所以继承代理不可取</p>
<p>利用聚合代理（因为被代理类都是继承或者实现Jungle，所以可以用jungle代理，知识子类行为不同而已<br>打野时间代理类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class LeeSinTimeProxy implements Jungle &#123;</div><div class="line"></div><div class="line">	//代理对象</div><div class="line">	Jungle leesin;</div><div class="line">	</div><div class="line">	</div><div class="line">	public LeeSinTimeProxy(Jungle leesin) &#123;</div><div class="line">		super();</div><div class="line">		this.leesin = leesin;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		leesin.gank();</div><div class="line">		 long ends=System.currentTimeMillis();</div><div class="line">	        System.out.println("gank time:"+(ends-starts));</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>日志代理<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSinlogProxy implements Jungle &#123;</div><div class="line"></div><div class="line">	</div><div class="line">	Jungle leesin;</div><div class="line">	</div><div class="line">	</div><div class="line">	public LeeSinlogProxy(Jungle leesin) &#123;</div><div class="line">		super();</div><div class="line">		this.leesin = leesin;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		System.out.println("LeeSin starts ganking");</div><div class="line">		leesin.gank();</div><div class="line">		System.out.println("LeeSin ends ganking");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		LeeSin leesin=new LeeSin();</div><div class="line">		</div><div class="line">		Jungle jungletime=new LeeSinTimeProxy(leesin);</div><div class="line">		Jungle junglelog=new LeeSinlogProxy(jungletime);</div><div class="line">		junglelog.gank();</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>LeeSin starts ganking<br>LeeSin is ganking…<br>gank time:1005<br>gank time:1005<br>LeeSin ends ganking</p>
</blockquote>
<p>注意这里是日志代理时间，时间代理盲僧，如果更改顺序，只需改变被代理对象即可<br><img src="/images/imgs2/15.gif" alt="Alt text"></p>
<p>至此我们可以简单归纳一下静态代理<br>大概有抽象角色：如打野  ，代理角色（被聚合类的引用），以及真实角色</p>
<p>最后不得不提的是静态代理虽然简单，但是有很多局限性，比如它是在编译期由我们主动创建的，也就说在程序运行前已经存在在.class文件中了，如果代理类一旦多的话，代理内容就无法复用，新增方法时，代理对象也要跟着增加方法。</p>
<p>所以代理设计模式真正的魅力和强大之处而是动态代理！！</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[抽象工厂设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/10/abstractfactory/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>抽象工厂方法通俗的讲就是为创建一组相关或相互依赖的对象提供一组接口，无需指定他们的具体类。因此，他们通常为创建一族产品对象，并且该产品由不同等级划分。</p>
<p>这里还是以之前的例子为例，假设有一个产生top（上单）的机器，另一个产生Jungle（打野）的机器，同时top可以有ad（物理上单）和ap(法术上单)，同样，Jungle可以有ad和ap打野，现在需要一个工厂，可以同时产生仅含ad的打野和上单，另一个产生仅含ap的打野和上单，当然可以按照自己的组合<br><img src="/images/imgs2/13.gif" alt="Alt text"><br>打野</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line"></div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ad打野</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class AdJungle implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ap打野<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ApJungle implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上单<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface Top &#123;</div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ad上单<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class AdTop implements Top &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ap上单<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ApTop implements Top &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生产打野和上单的工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface AbstractFactory &#123;</div><div class="line">public Top factorytop();</div><div class="line">public Jungle factoryjungle();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生产ad打野和上单的工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class AdFactory implements AbstractFactory &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Top factorytop() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new AdTop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle factoryjungle() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new AdJungle();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生产ap打野和上单的工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ApFactory implements AbstractFactory &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Top factorytop() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new ApTop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle factoryjungle() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new ApJungle();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过上面例子，我们可以发现抽象工厂易于交换产品系列，通过按需改变具体工厂从而使用不同的产品配置，同时它也将创建实例的过程与客户端分类</p>
<p>当然它的缺点就是和简单工厂一样，如果要从sql server切换到mysql，需要重新实例很多次</p>
<p>最后对应工厂系列的设计模式，无论选择哪一个，最终的目的都是为了解耦！</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[观察者设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/10/observer/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观察者模式从定义上说就是一种一对多的依赖关系，即当一个对象的状态发生改变时，其它依赖此对象的对象会得到通知并且做出相应的改变。一般有“推”模型和“拉”模型，前者是被观察者将所有信息通知所有人，而后者则是被观察者不主动提供信息，观察者主动索要信息</p>
<p>在这里还是以之前的例子为例</p>
<p><img src="/images/imgs2/14.gif" alt="Alt text"></p>
<p>这是一个推模型，也就是被观察者根据状态发生改变时将所有信息都主动通知观察者<br>其中：Jungle（打野）是被观察者，即如果有一些状态变化，如对方打野有动作则将通知observer（目前假定只有上路和adc）<br>observer：观察者，用来监听被观察者并且根据相应的变化做出变化<br>top：上单  adc：Adc LesSin：打野盲僧<br>以下是相关代码：</p>
<p>Jungle（被观察者）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">     </div><div class="line">     //增加观察者</div><div class="line">	public void addObserve(Observer obs);</div><div class="line">	 //删除观察者</div><div class="line">	public void deleteObserve(Observer obs);</div><div class="line">	 //通知观察者</div><div class="line">	public void notifyObserve(String msg);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>observer（观察者）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Observer &#123;</div><div class="line">   //收到通知后状态变化</div><div class="line">	public void notifybyJungle(String msg);</div><div class="line">&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LeeSin<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line">   //存放所有的观察者</div><div class="line">	List&lt;Observer&gt; list=new ArrayList&lt;Observer&gt;();</div><div class="line">	</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void addObserve(Observer obs) &#123;</div><div class="line">		list.add(obs);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void deleteObserve(Observer obs) &#123;</div><div class="line">		list.remove(obs);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void notifyObserve(String msg) &#123;</div><div class="line">		for(Observer obs : list)&#123;</div><div class="line">			obs.notifybyJungle(msg);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>top<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class top implements Observer &#123;</div><div class="line"> </div><div class="line"> //收到消息</div><div class="line">	public String newmsg;</div><div class="line">	</div><div class="line">	public String getNewmsg() &#123;</div><div class="line">		return newmsg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setNewmsg(String newmsg) &#123;</div><div class="line">		this.newmsg = newmsg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void notifybyJungle(String msg) &#123;</div><div class="line">		newmsg=msg;</div><div class="line">		System.out.println("上单收到:"+newmsg);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Adc<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Adc implements Observer &#123;</div><div class="line"></div><div class="line">public String newmsg;</div><div class="line">	</div><div class="line">	public String getNewmsg() &#123;</div><div class="line">		return newmsg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setNewmsg(String newmsg) &#123;</div><div class="line">		this.newmsg = newmsg;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void notifybyJungle(String msg) &#123;</div><div class="line">		newmsg=msg;</div><div class="line">		System.out.println("adc收到:"+newmsg);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		Jungle jungle=new LeeSin();</div><div class="line">		</div><div class="line">		Observer obs1=new Adc();</div><div class="line">		</div><div class="line">		Observer obs2=new top();</div><div class="line">		</div><div class="line">		jungle.addObserve(obs1);</div><div class="line">		jungle.addObserve(obs2);</div><div class="line">		</div><div class="line">		jungle.notifyObserve("敌方打野正在打小龙");</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下面是输出结果</p>
<blockquote>
<p>adc收到:敌方打野正在打小龙<br>上单收到:敌方打野正在打小龙</p>
</blockquote>
<p>如果我们使用拉模型，即观察者主动向被观察者索要信息，那么上面程序将做部分修改</p>
<p>大体思路就是将Jungle（被观察者）的通知函数改为void即<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">     </div><div class="line">     //增加观察者</div><div class="line">	public void addObserve(Observer obs);</div><div class="line">	 //删除观察者</div><div class="line">	public void deleteObserve(Observer obs);</div><div class="line">	 //通知观察者</div><div class="line">	public void notifyObserve();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相应的observer将更改为<br>observer（观察者）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Observer &#123;</div><div class="line">   //收到通知后状态变化</div><div class="line">	public void notifybyJungle(Jungle jungle);</div><div class="line">&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于推与拉模型，如果目标角色过于复杂，则优先使用推模式，反之则使用拉模式</p>
<p>观察者模式应用场景<br>1、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变</p>
<p>2、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[工厂方法设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/09/factory/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工厂方法模式又被称为多态工厂模式，通俗的讲就是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中，因此，也属于创建型模式</p>
<p><img src="/images/imgs2/12.gif" alt="Alt text"><br>这里Jungle的每个具体类都对应一个具体工厂<br>下面就是以工厂方法创建它们，通过抽象工厂选择不同的具体子工厂，从而产生不同的具体打野类</p>
<p>打野接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//打野英雄</div><div class="line">public interface Jungle &#123;</div><div class="line"></div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>工厂接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface junglefactor &#123;</div><div class="line">//产生打野</div><div class="line">public Jungle createjungle();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>盲僧</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("盲僧正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("盲僧太灵活了");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("盲僧正在打野怪");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剑圣</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Js implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("剑圣正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("js也灵活");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("剑圣正在打野");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>盲僧工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class LeeSinFactory implements junglefactor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle createjungle() &#123;</div><div class="line">		</div><div class="line">		return new LeeSin();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">剑圣工厂</div><div class="line">``` stylus</div><div class="line">public class JsFactory implements junglefactor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle createjungle() &#123;</div><div class="line">		</div><div class="line">		return new Js();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">测试类：</div><div class="line">``` stylus</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		// Jungle jungle= JungleFactory.createJungle("LeeSin");</div><div class="line">		// jungle.gankenemy();</div><div class="line"></div><div class="line">      junglefactor factory=new LeeSinFactory();</div><div class="line">    Jungle jubjle=factory.createjungle();</div><div class="line">    jubjle.flexible();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这里通过多态，产生不同的工厂，从而产生不同的打野</p>
<p>工厂方法比较简单工厂模式</p>
<p>现在我们要是把打野对象由盲僧换成剑圣的话，利用简单工厂，那就要<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Jungle jungle= JungleFactory.createJungle("Js");</div><div class="line">``` </div><div class="line">如果是100或者更多的话，那就要重复上述代码那么多次</div><div class="line"></div><div class="line">但是如果采用工厂方法，只需要改一处</div><div class="line">```stylus</div><div class="line">junglefactor factory=new JsFactory();</div></pre></td></tr></table></figure></p>
<p>显然对外扩展开放，对内修改关闭更好。而简单工厂则违背了该原则</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单工厂设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/08/simplefactory/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单工厂模式又叫静态工厂设计模式。通俗的讲，就是通过专门定义一个类来负责建立其他类的实例，与此同时被创建的类都必须满足他们有共同的父类，所以，它是一种创建型模式。</p>
<p><img src="/images/imgs2/11.gif" alt="Alt text"><br>这里Leesin（盲僧）与Js（剑圣）继承Jungle（打野），而JungleFactory（打野生产工厂）产生具体打野对象<br>下面将以简单工厂创建他们，满足通过传入打野工厂不同的参数，产生不同的打野对象</p>
<p>打野接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//打野英雄</div><div class="line">public interface Jungle &#123;</div><div class="line"></div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>盲僧</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("盲僧正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("盲僧太灵活了");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("盲僧正在打野怪");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剑圣</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Js implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("剑圣正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("js也灵活");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("剑圣正在打野");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打野工厂</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class JungleFactory &#123;</div><div class="line"></div><div class="line">	public static Jungle createJungle(String Junglename)&#123;</div><div class="line">		 Jungle jungle=null;</div><div class="line">		 switch(Junglename)&#123;</div><div class="line">		 case "LeeSin":</div><div class="line">			 jungle=new LeeSin();</div><div class="line">			 break;</div><div class="line">		 case "Js" :</div><div class="line">			 jungle=new Js();</div><div class="line">			 break;</div><div class="line">		 default :</div><div class="line">			  break;</div><div class="line">		 </div><div class="line">		 &#125;</div><div class="line">		return jungle;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是测试类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		Jungle jungle= JungleFactory.createJungle("LeeSin");</div><div class="line">		jungle.gankenemy();</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>当然，我们这里通过不同的参数，获得不同的打野英雄<br>当然这个例子也很好理解简单工厂</p>
<p>事实上，我们知道如果我们一开始用的是sql server数据库，然后我们想换数据库，如果不用工厂模式，那么将替换许多东西，如果这时，使用简单工厂模式，就会使问题变简单许多。</p>
<p>利用简单工厂模式大概思路就是先创建一个抽象数据库(DBobject)，然后是具体实现类sql server与mysql类，然后再来一个生成数据库工厂(DBobjectFactory)通过传入不同的数据库参数，从而连接不同的数据库</p>
<p>至此我们发现，简单工厂的优点在于工厂类中包含了必要的逻辑判断，而且可以根据客户端的选择条件不同而动态的实例化相关的类</p>
<p>当然它的缺点也很明显，当我们创建的抽象实例过多时，显然高内聚就增多了，不利于维护了</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[职责链设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/07/filter/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 职责链，通俗地讲就是把责任处理对象连城一条链，这样当一个处理对象不能及时处理的时候就会交给下一个处理对象直到被处理为止。就好比生活中，我们有事向学校请假，得找班主任签字同意，然后有些时候需要院里签字，甚至教务处，最后将假条交给同学，最后在给相应授课老师，可能这个例子还不太准确，但是总之经过一些列流程，最后才会处理。</p>
<p>当然，在程序中，最常见的就是过滤关键字了，首先模拟一下非web下的责任链</p>
<p><strong>首先定义一个过滤接口</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Filter &#123;</div><div class="line">	String doFilter(String str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>接下来就是各式各样的过滤字</strong><br>敏感字过滤</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SesitiveFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String doFilter(String str) &#123;</div><div class="line">		//第一个参数是非法字符，第二个参数是被替换的字符</div><div class="line">		String r = str.replace("瞎子", "李青")</div><div class="line">			 .replace("小学僧", "盲僧");</div><div class="line">		</div><div class="line">		return r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>过滤html标签</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class HTMLFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String doFilter(String str) &#123;</div><div class="line">	//&lt;&gt;被替换成[]</div><div class="line">		String r = str.replace('&lt;', '[')</div><div class="line">				   .replace('&gt;', ']');</div><div class="line">		return r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>过滤链:将过滤器串成一个链，并保存过滤后的字</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class FilterChain implements Filter &#123;</div><div class="line">     //保存所有的具体过滤器</div><div class="line">	List&lt;Filter&gt; filters=new ArrayList&lt;Filter&gt;();</div><div class="line">	</div><div class="line">    //过滤器串成链</div><div class="line">	public FilterChain addFilter(Filter f)</div><div class="line">	&#123;</div><div class="line">		this.filters.add(f);</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">  //返回过滤后的字符</div><div class="line">	@Override</div><div class="line">	public String doFilter(String str) &#123;</div><div class="line">		String r=str;</div><div class="line">		for(Filter f:filters)&#123;</div><div class="line">			r=f.doFilter(r);</div><div class="line">		&#125;</div><div class="line">		return r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		String msg = "因为一个英雄而爱上了lol，他就是瞎子，虽然我是小学僧，但是我还是只坚信我的&lt;我的信仰&gt;英雄！！";</div><div class="line">		FilterChain fc = new FilterChain();</div><div class="line">		fc.addFilter(new SesitiveFilter())</div><div class="line">		  .addFilter(new HTMLFilter());</div><div class="line">		String result=fc.doFilter(msg);</div><div class="line">		System.out.println(result);</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>输出结果:</p>
<blockquote>
<p>因为一个英雄而爱上了lol，他就是李青，虽然我是盲僧，但是我还是只坚信我的[我的信仰]英雄！！</p>
</blockquote>
<h4 id="Web下责任链"><a href="#Web下责任链" class="headerlink" title="Web下责任链"></a>Web下责任链</h4><p>当然一般情况下，都是过滤web环境下的字符，大概思路跟非web下差不多</p>
<p>首先需要建立request和response对象，即接收和响应</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Request &#123;</div><div class="line">String requestStr;</div><div class="line"></div><div class="line">public String getRequestStr() &#123;</div><div class="line">	return requestStr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setRequestStr(String requestStr) &#123;</div><div class="line">	this.requestStr = requestStr;</div><div class="line">&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Response &#123;</div><div class="line">	 String responseStr;</div><div class="line">	public String getResponseStr() &#123;</div><div class="line">		return responseStr;</div><div class="line">	&#125;</div><div class="line">	public void setResponseStr(String responseStr) &#123;</div><div class="line">		this.responseStr = responseStr;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是Filter接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Filter &#123;</div><div class="line">	void doFilter(Request request, Response response, FilterChain chain);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>紧接着是filterchain类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class FilterChain implements Filter &#123;</div><div class="line">    //存放各种filter</div><div class="line">	List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();</div><div class="line">   </div><div class="line">    //控制filter的索引</div><div class="line">	int index = 0;</div><div class="line"></div><div class="line">    //添加filter</div><div class="line">	public FilterChain addFilter(Filter f) &#123;</div><div class="line">		this.filters.add(f);</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">//filter链，特别注意这里有一个迭代，与具体filter里的迭代相呼应</div><div class="line">//主要是依次先取出request的接受字符过滤，然后在倒叙依次取完response的响应过滤,而这恰恰是struts2框架原理的核心，当然spring mvc(直接基于servlet)也类似，都是基于拦截或者过滤实现的</div><div class="line">	@Override</div><div class="line">	public void doFilter(Request request, Response response, FilterChain chain) &#123;</div><div class="line">		// 过滤器取完退出</div><div class="line">if(index == filters.size()) return ;</div><div class="line">		</div><div class="line">	//依次取出过滤器</div><div class="line">		Filter f = filters.get(index);</div><div class="line">		index ++;</div><div class="line">		f.doFilter(request, response, chain);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就是具体的filter了（这里就是web中的真实拦截顺序了）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SesitiveFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void doFilter(Request request, Response response, FilterChain chain) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		request.requestStr = request.requestStr.replace("瞎子", "李青")</div><div class="line">				 .replace("小学僧", "盲僧") ;</div><div class="line">		chain.doFilter(request, response, chain);</div><div class="line">		response.responseStr += "SesitiveFilterresponse";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一个filter</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class HTMLFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void doFilter(Request request, Response response,FilterChain chain) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		request.requestStr = request.requestStr.replace('&lt;', '[')</div><div class="line">				   .replace('&gt;', ']') ;</div><div class="line">		</div><div class="line">		chain.doFilter(request, response, chain);</div><div class="line">		response.responseStr += "HTMLFilterresponse";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先附一张structs2原理图，来对比一下上述过滤过程<br><img src="/images/imgs2/9.gif" alt="Alt text"><br>主要关注action invocation中部分</p>
<p>测试类:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		String msg = "因为一个英雄而爱上了lol，他就是瞎子，虽然我是小学僧，但是我还是只坚信我的&lt;我的信仰&gt;英雄！！";</div><div class="line">		Request request = new Request();</div><div class="line">		request.setRequestStr(msg);</div><div class="line">		Response response = new Response();</div><div class="line">		response.setResponseStr("response");</div><div class="line">		FilterChain fc = new FilterChain();</div><div class="line">		fc.addFilter(new HTMLFilter())</div><div class="line">		  .addFilter(new SesitiveFilter())</div><div class="line">		  ;</div><div class="line">		</div><div class="line">		fc.doFilter(request, response, fc);</div><div class="line">		System.out.println(request.getRequestStr());</div><div class="line">		System.out.println(response.getResponseStr());</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>结果:</p>
<blockquote>
<p>因为一个英雄而爱上了lol，他就是李青，虽然我是盲僧，但是我还是只坚信我的[我的信仰]英雄！！<br>response–SesitiveFilterresponse–HTMLFilterresponse</p>
</blockquote>
<p>最后归纳一下责任链设计模式的一般形式<br><img src="/images/imgs2/10.gif" alt="Alt text"><br>分别为客户端、处理者和具体处理者</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[迭代器设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/06/iterator/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 为什么会有迭代器？<br>当我们想要 遍历取出集合一组数据时，一般都是用for里面套着i循环，或者使用for（对象 x :某个集合)的形式取出，不过因为集合类型的不同，取出的形式也不同，但是当我们想要一种统一的方法去遍历集合时，就可以用迭代器去实现，说了那么多，不如来一个直观的例子。</p>
<p><img src="/images/imgs2/7.gif" alt="Alt text"><br>这里模仿Arraylist集合中的迭代器实现过程，其中<br>Iterator:执行递增遍历的接口<br>Collection:一些集合的上层接口<br>Arraylist: 目前只实现了add、size及迭代器<br>ArrayListIterator: 用于Arraylist的迭代器</p>
<p>Iterator接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;</div><div class="line">//取得下一个元素</div><div class="line">Object next();</div><div class="line">//检查有没有下一个元素</div><div class="line">boolean hasNext();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Collection接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Collection &#123;</div><div class="line">public void add(Object o);//增加一个对象</div><div class="line">public int size();//返回长度</div><div class="line">Iterator iterator();//内聚迭代器</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Arraylist类（这里ArrayListIterator是其内部类）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">package com.zwl.iterator;</div><div class="line"></div><div class="line">public class ArrayList implements Collection&#123;</div><div class="line">//默认都是初始化为10的</div><div class="line">Object objects[]=new Object[10];</div><div class="line">//默认集合长度都为0的</div><div class="line">int index=0;</div><div class="line"></div><div class="line">//增加方法</div><div class="line">public void add(Object o)&#123;</div><div class="line">//集合长度动态增长，每次都使其长度增加2倍，并且创建一个增长后的新数组</div><div class="line">//将旧数组先copy给新数组，在指向旧数组的引用</div><div class="line">//同时保证每添加一个对象，集合长度自增长，这样就不会出现越界情况</div><div class="line">	if(index==objects.length)&#123;</div><div class="line">		Object newobjects[]=new Object[objects.length*2];</div><div class="line">		System.arraycopy(objects, 0, newobjects, 0, objects.length);</div><div class="line">		objects=newobjects;</div><div class="line">	&#125;</div><div class="line">	objects[index]=o;</div><div class="line">	index++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回集合长度</div><div class="line">public int size()&#123;</div><div class="line">	return index;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//统一迭代器方法</div><div class="line">@Override</div><div class="line">public Iterator iterator() &#123;</div><div class="line">	// TODO Auto-generated method stub</div><div class="line">	return new ArrayListIterator();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//内部类，返回arraylist的专有迭代器</div><div class="line">private class ArrayListIterator implements Iterator&#123;</div><div class="line">    //取集合中对象的索引</div><div class="line">        private int currentIndex=0;</div><div class="line">    </div><div class="line">   //取出集合中当前索引的一个对象</div><div class="line">	@Override</div><div class="line">	public Object next() &#123;</div><div class="line">		Object o = objects[currentIndex];</div><div class="line">		currentIndex ++;</div><div class="line">		return o;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//判断集合是否含有下一个元素</div><div class="line">	@Override</div><div class="line">	public boolean hasNext() &#123;</div><div class="line">//索引值超出集合长度，集合中元素取完</div><div class="line">		if(currentIndex&gt;=index) return false;</div><div class="line">		else</div><div class="line">			return true;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		Collection al=new ArrayList();</div><div class="line">		</div><div class="line"> for(int i=0;i&lt;15;i++)&#123;</div><div class="line">	 al.add(new Object());</div><div class="line"> &#125;</div><div class="line"> System.out.println(al.size());</div><div class="line"> </div><div class="line"> Iterator it=al.iterator();</div><div class="line"> while(it.hasNext())&#123;</div><div class="line">	 Object o=it.next();</div><div class="line">	 System.out.println(o+"  ");</div><div class="line"> &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>至此，可以归纳一下迭代器设计模式的一般形式<br><img src="/images/imgs2/8.gif" alt="Alt text"></p>
<p>其中：<br>1：Iterator(迭代器) 参与者：<br> 定义访问和遍历元素的接口（如Iterator)</p>
<p>2.ConcreteIterator(具体迭代器)参与者<br>实现迭代器的接口(如ArrayListIterator)</p>
<p>3.Aggregate(聚合)参与者<br>定义建立Iterator参与者的接口(如Collection)</p>
<p>4.ConcreteAggregate（具体聚合）参与者<br>实现Aggregate所定义的接口（如Arraylist）</p>
<p>最后不得不提的是，无论一个集合实现的结果如何，都能使用iterator，此外，我们通过改变iterato，来增加各种iterator，如反向遍历，双向遍历（即，增加一个previous方法），只要注意一下currentInde和index就可以了</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jquery之ajax]]></title>
      <url>http://www.myzwl.win/2017/03/05/jqajax/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ajax ：异步请求，浏览器地址栏不改变，进行局部刷新</p>
<p>首先先来看一下ajax在浏览器与服务器之间的传输过程</p>
<p><img src="/images/imgs2/3.gif" alt="Alt text"></p>
<h4 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h4><p>jquery中有多种ajax请求，根据应用场景不同，选择的ajax不同</p>
<p><img src="/images/imgs2/4.gif" alt="Alt text"></p>
<ol>
<li><p>$.ajax(…) 最底层ajax请求，编写最复杂，完成功能最全的</p>
</li>
<li><p>load() 、$.get() 、$.post() </p>
</li>
<li><p>$.getJSON() 可以完成js“跨域”请求<br>域名：域名+端口+项目，js默认不能跨域请求</p>
</li>
</ol>
<ol>
<li>$.getScript()  动态加载js文件。</li>
</ol>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p><img src="/images/imgs2/5.gif" alt="Alt text"></p>
<h4 id="json解析"><a href="#json解析" class="headerlink" title="json解析"></a>json解析</h4><p><img src="/images/imgs2/6.gif" alt="Alt text"></p>
<p>下面将对上面部分进行模拟<br>首先是有一个按钮</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"button"</span> value=<span class="string">"发送ajax"</span> /&gt;</div></pre></td></tr></table></figure>
<p>然后在js中操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   // 请求路径，我这里是请求到一个servlet</div><div class="line">var url = "getajaxname";</div><div class="line">// 请求参数，采用json</div><div class="line">var params = &#123;"username":"盲僧", "password":"我的最爱"&#125;;</div></pre></td></tr></table></figure>
<p>接下来就是利用不同形式的ajax发送请求<br>1 load()函数 ，必须使用jquery对象</p>
<pre><code>* * 格式：load(url, [data], [callback])
*         参数1：url ，请求路径
*         参数2：data，请求参数
*         参数3：callback，回调函数
* * 如果没有请求参数，发送的GET请求
* * 如果有请求参数，发送的POST请求。请求没有中文乱码
* * 回调函数的参数
*         参数1：data，响应数据。load()永远获得字符串，如果需要使用，必须手动转换json对象。
*         
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(this).load(url,params,function(data)&#123;</div><div class="line">		//转换json对象</div><div class="line">		var jsonData = eval("("+data+")");</div><div class="line">		alert(jsonData.value);</div><div class="line">	&#125;);</div></pre></td></tr></table></figure>
<p>后台servlet，这里利用gson.jar包回送json数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">		response.setContentType("text/html,charset=utf-8");</div><div class="line">		PrintWriter out = response.getWriter();</div><div class="line">   String name= request.getParameter("username");</div><div class="line">      String age= request.getParameter("password");</div><div class="line">      System.out.println(name);</div><div class="line">      System.out.println(age);</div><div class="line">      /*out.println("ajax ok");*/</div><div class="line">      JsonObject json=new JsonObject();</div><div class="line">      json.addProperty("value", "ok");</div><div class="line">      response.getWriter().write(json.toString());</div><div class="line">		out.flush();</div><div class="line">		out.close();</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>我们可以通过火狐里的firebug进行测试和观察</p>
<p>2 $.get() 全局函数，发送get请求</p>
<pre><code>* * 格式：jQuery.get(url, [data], [callback], [type])
*         * 参数4：type ，返回内容格式，xml, html, script, json, text, _default。
* * GET请求不适合发送中文数据，存放请求的中文乱码。
*         必须手动解码   new String(username.getBytes(&quot;ISO-8859-1&quot;) ,&quot;UTF-8&quot;)
* * 响应数据，如果使用  application/json;charset=UTF-8 ，jQuery自动将数据转换json对象。
* * 响应数据，如果使用  text/html;charset=UTF-8 ，回调函数获得字符串数据，需要手动转换。
*         使用“参数4”，设置&quot;json&quot;，jQuery将字符串 转换成 json对象
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.get(url,params,function(data)&#123;</div><div class="line">		alert(data.value);</div><div class="line">	&#125;,"json");</div></pre></td></tr></table></figure>
<p>将servlet中post中代码copy到get中，但是后台接受的是乱码</p>
<p>3 $.post() 全局函数，发送post请求</p>
<pre><code>* * 格式：jQuery.post(url, [data], [callback], [type])
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.post(url,params,function(data)&#123;</div><div class="line">		alert(data.value);</div><div class="line">	&#125;,"json")</div></pre></td></tr></table></figure>
<p>4 $.ajax() 底层功能最强大的</p>
<pre><code>* * 格式：jQuery.ajax([settings])
*         参数settings：设置所有的参数
*             url:发送请求的地址
*             data:发送到服务器的数据,请求参数
*             type:请求方式 (&quot;POST&quot; 或 &quot;GET&quot;)， 
*             success:成功的回调函数，success(data, textStatus, jqXHR)
*             error:请求失败时调用此函数
*             dataType:预期服务器返回的数据类型
*                 &quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理。
*                 &quot;html&quot;: 返回纯文本 HTML 信息；包含的script标签会在插入dom时执行。
*                 &quot;script&quot;: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了&quot;cache&quot;参数。&apos;&apos;&apos;注意：&apos;&apos;&apos;在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载)
*                 &quot;json&quot;: 返回 JSON 数据 。
*                 &quot;jsonp&quot;: JSONP 格式。使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。
*                 &quot;text&quot;: 返回纯文本字符串
*/
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">	"url":url,</div><div class="line">	"data":params,</div><div class="line">	"type":"POST",</div><div class="line">	"success":function(data)&#123;</div><div class="line">		alert(data.value);</div><div class="line">	&#125;,</div><div class="line">	"error":function()&#123;</div><div class="line">		alert("服务器繁忙，请稍后重试");</div><div class="line">	&#125;,</div><div class="line">	"dataType":"json"</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一般情况下，我都会选择使用.ajax前后台交互，因为它功能相对较多，其次我们也可以选择适合我们的属性用。</p>
<p>当然后面的ajax，平时也没用到过，所以就不介绍了，当然api是最好的资料，google是最好的老师。</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识原生态ajax]]></title>
      <url>http://www.myzwl.win/2017/03/04/ajax/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1 Ajax是一种网页开发技术，（Asynchronous Javascript+XML）异步JavaScript和xml，<br>2 Ajax是异步交互，局部刷新<br>3 Ajax是减少服务器压力<br>4 Ajax能提高用户体验</p>
<h4 id="Ajax交互与传统交互比较"><a href="#Ajax交互与传统交互比较" class="headerlink" title="Ajax交互与传统交互比较"></a>Ajax交互与传统交互比较</h4><p>传统交互：网页整体刷新（同步），服务器压力大，用户体验不好<br> Ajax交互：局部刷新，服务器压力小，用户体验好</p>
<p>不妨先来一个实例，先从整体把握，在细节看<br>首先是jsp页面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div style="text-align: center;"&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">    &lt;input type="button" value="ajax异步交互" onclick="loadname()"/&gt;&amp;nbsp;&amp;nbsp;&lt;input type="text" name="name" id="name"/&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>有个按钮事件，用于验证ajax</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">	function loadname()&#123;</div><div class="line">		var xmlHttp;</div><div class="line">		if(window.XMLHttpRequest)&#123;</div><div class="line">			xmlHttp=new XMLHttpRequest();</div><div class="line">		&#125;</div><div class="line">		else&#123;</div><div class="line">			xmlHttp=new ActiveXObject("Microsoft.XMLHTTP");</div><div class="line">		&#125;</div><div class="line">		xmlHttp.open("post", "getajaxname?name=666&amp;age=16", true);</div><div class="line">		xmlHttp.send();	</div><div class="line">	&#125;</div><div class="line">	&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这段作用是利用ajax异步向后台传了两个参数name=666与age=16，路径是getajaxname为一个servlet路径，通过post方式</p>
<p>后台servlet</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">		response.setContentType("text/html,charset=utf-8");</div><div class="line">		PrintWriter out = response.getWriter();</div><div class="line">      String name= request.getParameter("name");</div><div class="line">      String age= request.getParameter("age");</div><div class="line">      System.out.println(name);</div><div class="line">      System.out.println(age);</div><div class="line">		out.flush();</div><div class="line">		out.close();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这里接受前台传来的参数并打印出来</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Web.xml文件</div><div class="line">&lt;servlet&gt;</div><div class="line">    &lt;servlet-name&gt;getajaxname&lt;/servlet-name&gt;</div><div class="line">    &lt;<span class="attribute">display</span>-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;</div><div class="line">    &lt;description&gt;This is the description of my J2EE component&lt;/description&gt;</div><div class="line">    &lt;servlet-class&gt;com<span class="selector-class">.zwl</span><span class="selector-class">.servlet</span><span class="selector-class">.getajaxname</span>&lt;/servlet-class&gt;</div><div class="line">  &lt;/servlet&gt;</div><div class="line"></div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;getajaxname&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;/getajaxname&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
<p>主要是映射一个servlet</p>
<p>至此入门程序算是完成，下面将对上述部分进行分析</p>
<h4 id="创建XMLHttpRequest对象"><a href="#创建XMLHttpRequest对象" class="headerlink" title="创建XMLHttpRequest对象"></a>创建XMLHttpRequest对象</h4><p>所有现代浏览器均支持XMLHttpRequest 对象（IE5 和IE6 使用ActiveXObject）<br>XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>创建语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var xmlHttp;</div><div class="line">		if(window.XMLHttpRequest)&#123;</div><div class="line">			xmlHttp=new XMLHttpRequest();</div><div class="line">		&#125;</div><div class="line">		else&#123;</div><div class="line">			xmlHttp=new ActiveXObject("Microsoft.XMLHTTP");</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h4 id="XMLHttpRequest-对象请求后台"><a href="#XMLHttpRequest-对象请求后台" class="headerlink" title="XMLHttpRequest 对象请求后台"></a>XMLHttpRequest 对象请求后台</h4><p>open(method,url,async)<br>规定请求的类型、URL 以及是否异步处理请求。<br>method：请求的类型；GET 或POST<br>url：文件在服务器上的位置<br>async：true（异步）或false（同步）</p>
<p>send(string)<br>将请求发送到服务器。<br>string：仅用于POST 请求</p>
<p>语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xmlHttp.open("post", "getajaxname?name=666&amp;age=16", true);</div><div class="line">xmlHttp.send();</div></pre></td></tr></table></figure>
<p>有时候需要将参数封装在一个函数中<br>首先得声明setRequestHeader(header,value)</p>
<p>向请求添加HTTP 头。<br>header: 规定头的名称<br>value: 规定头的值<br>创建语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");</div></pre></td></tr></table></figure>
<p>将入门程序部分代码修改如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xmlHttp.open("post", "getajaxname", true);</div><div class="line">	xmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");</div><div class="line">		xmlHttp.send("name=666&amp;age=16");</div></pre></td></tr></table></figure>
<h4 id="XMLHttpRequest-对象响应服务器"><a href="#XMLHttpRequest-对象响应服务器" class="headerlink" title="XMLHttpRequest 对象响应服务器"></a>XMLHttpRequest 对象响应服务器</h4><p>现在在前面的代码基础上添加几行代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alert("readystate:"+xmlHttp.readyState+" status:"+xmlHttp.status);</div><div class="line">		xmlHttp.onreadystatechange=function()&#123;</div><div class="line">			alert("readystate:"+xmlHttp.readyState+" status:"+xmlHttp.status);</div><div class="line">		&#125;;</div><div class="line">		</div><div class="line">		xmlHttp.open("post", "getajaxname", true);</div><div class="line">		xmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");</div><div class="line">		xmlHttp.send("name=666&amp;age=16");</div></pre></td></tr></table></figure>
<p>先分析一下onreadystatechange 事件<br>当请求被发送到服务器时，我们需要执行一些基于响应的任务。<br>每当readyState 改变时，就会触发onreadystatechange 事件。<br>readyState 属性存有XMLHttpRequest 的状态信息。</p>
<p>下面是XMLHttpRequest 对象的三个重要的属性：<br>onreadystatechange存储函数（或函数名）<br>每当readyState 属性改变时，就会调用该函数。</p>
<p>readyState<br>存有XMLHttpRequest 的状态。从0 到4 发生变化。<br>0: 请求未初始化<br>1: 服务器连接已建立<br>2: 请求已接收<br>3: 请求处理中<br>4: 请求已完成，且响应已就绪</p>
<p>status<br>200: “OK”<br>404: 未找到页面</p>
<p>执行上面程序就会发现相应值的变化</p>
<p>接下来在后台加入返回的信息<br>public void doPost(HttpServletRequest request, HttpServletResponse response)<br>            throws ServletException, IOException {</p>
<pre><code>    response.setContentType(&quot;text/html,charset=utf-8&quot;);
    PrintWriter out = response.getWriter();
//向前台返回一个信息
  out.println(&quot;ajax ok&quot;);
    out.flush();
    out.close();
}
</code></pre><p>页面：根据前面的状态码，进行接收参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(xmlHttp.readyState==4 &amp;&amp; xmlHttp.status==200)&#123;</div><div class="line">				document.getElementById("name").value=xmlHttp.responseText;</div><div class="line">			&#125;</div></pre></td></tr></table></figure>
<p>responseText 获得字符串形式的响应数据</p>
<p>最后会发现表单被自动填充</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识git]]></title>
      <url>http://www.myzwl.win/2017/03/03/git/</url>
      <content type="html"><![CDATA[<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git是linux之父Linus的第二个伟大的作品，它是分布式版本控制系统，即每个人可以通过clone将工作建立在本地库中</p>
<p>对比之前我们是通过hexo d的提交给远程仓库的master branch，当然我们也可以git提交或者clone到本地。</p>
<p><strong>远程仓库代码clone到本地</strong></p>
<ol>
<li>首先需要生成公钥与仓库连接<br>首先添加用户名<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global user<span class="selector-class">.name</span> <span class="string">"yourname"</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>其次添加e-mail</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global user<span class="selector-class">.email</span> <span class="string">"youreamil"</span></div></pre></td></tr></table></figure>
<p>默认在administrator目录下生成.ssh并在下生成两个文件id_rsa和id_rsa.pub秘钥，</p>
<p>生成公钥</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -C <span class="string">"youremail"</span></div></pre></td></tr></table></figure>
<p>这时候我们可以在.ssh文件下用 ls -al显示所有文件（因为.ssh是隐藏的，我是新建了一个.ssh）</p>
<p>2 配置公钥<br>在setting中的ssh and GPG keys中新建ssh key将id_rsa.pub中的内容辅助进去<br>最后用ssh -T git@github.com检查公钥是否配置成功</p>
<p>3 初始化.git<br>在本地新建任意一个文件，在该路径下，<br>初始化为本地仓库<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure></p>
<p>提交文件到缓存区</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add filename（.表示所有文件）</div></pre></td></tr></table></figure>
<p>查看状态</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
<p>本地提交，即完成提交至远程仓库的准备</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m <span class="string">"words"</span></div></pre></td></tr></table></figure>
<p>查看commit记录</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure>
<p>远程最新的代码更新到本地</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull origin master</div></pre></td></tr></table></figure>
<p>本地代码推到远程仓库，实现本地与远程仓库的同步</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master</div></pre></td></tr></table></figure>
<p>这里我是先将我的一个仓库先clone到本地</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone 仓库地址</div></pre></td></tr></table></figure>
<p>然后在该仓库目录下执行add和commit，最后在push提交到远程仓库，如果没有远程仓库，可先关联</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin 仓库</div></pre></td></tr></table></figure>
<p>再push</p>
<p>3.其他常用命令<br>查看当前项目有哪些远程仓库可以执行</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure>
<p>建立分支<br>查看分支（branch）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch</div></pre></td></tr></table></figure>
<p>默认都是master，并且master提交<br>新建分支</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch name</div></pre></td></tr></table></figure>
<p>切换分支`</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout name</div></pre></td></tr></table></figure>
<p>删除分支</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d name</div></pre></td></tr></table></figure>
<p>如果我们想要传送另一个分支到远程仓库<br>只需在push中</p>
<p>git push origin branch master</p>
<p>当然git的命令太多了，只总结了学习过程中实验到的</p>
<p>接下来如果将别人代码clone到本地，一般先fork，在利用clone</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ssm三大框架整合]]></title>
      <url>http://www.myzwl.win/2017/03/02/ssm/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> ssm三大框架整合主要指的是spring mvc+mybatis+spring，利用mvc分层思想实现解耦，其中spring mvc负责业务控制和跳转，mybatis负责持久层，spring管理各层，下面将以一个通过id查询用户信息功能搭建整合环境</p>
<ol>
<li><p>建立一个web工程</p>
</li>
<li><p>导入ssm整合的相关jar包，包括spring(包含springmvc)，mybatis，mybatis-spring整合。数据库驱动，jstl，c3p0管理数据源，log4j.由于整合包过多，可以自行到网上下载</p>
</li>
<li><p>配置核心文件初始化<br>Web.xml配置</p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt;</div><div class="line">  &lt;display-name&gt;springmvc19_day01_01&lt;/display-name&gt;</div><div class="line">  </div><div class="line">  //配置中文乱码过滤器</div><div class="line">  &lt;filter&gt;</div><div class="line">  &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line">  &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">  &lt;init-param&gt;</div><div class="line">  &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line">  &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line">  &lt;/init-param&gt;</div><div class="line">  &lt;/filter&gt;</div><div class="line">  </div><div class="line">  &lt;filter-mapping&gt;</div><div class="line">  &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">  &lt;/filter-mapping&gt;</div><div class="line">  </div><div class="line">  //启用spring监听</div><div class="line">  &lt;listener&gt;</div><div class="line">		&lt;listener-class&gt;</div><div class="line">			org.springframework.web.context.ContextLoaderListener</div><div class="line">		&lt;/listener-class&gt;</div><div class="line">	&lt;/listener&gt;</div><div class="line">  </div><div class="line">  //启动spring mvc</div><div class="line">  &lt;servlet&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">  &lt;!-- 默认加载方式</div><div class="line">  	   默认加载必须规范：</div><div class="line">  	   * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml</div><div class="line">  	   * 路径规范：必须在WEB-INF目录下面</div><div class="line">   --&gt;</div><div class="line"> &lt;/servlet&gt;</div><div class="line">  </div><div class="line">  //spring mvc 过滤文件</div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line">  </div><div class="line">  //rest格式拦截，主要用在提交带参数问题</div><div class="line">   &lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line">  </div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<ol>
<li>加载springmvc-servlet.xml文件</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt;</div><div class="line">		//自动扫面根路径以下的所有包，就不要显示配置bean了</div><div class="line">		&lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt;</div><div class="line">		</div><div class="line">		//默认创建注解处理器映射器，注解处理器适配器。提供json格式支持。</div><div class="line">		 &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; </div><div class="line">		 </div><div class="line">&lt;!-- 配置sprigmvc视图解析器：解析逻辑视图 </div><div class="line">			 后台返回逻辑试图：index</div><div class="line">			视图解析器解析出真正物理视图：前缀+逻辑试图+后缀====/WEB-INF/jsps/index.jsp</div><div class="line">		--&gt;</div><div class="line"></div><div class="line">		&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;</div><div class="line">		&lt;property name="prefix" value="/"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;		</div><div class="line">		&lt;/bean&gt;</div><div class="line">		&lt;/beans&gt;</div></pre></td></tr></table></figure>
<ol>
<li>加载spring配置文件</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt;</div><div class="line">		//自动扫面根路径以下的所有包，就不要显示配置bean了</div><div class="line">		&lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt;</div><div class="line">		</div><div class="line">	&lt;!-- 第一步：配置数据源 --&gt;</div><div class="line">	&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;</div><div class="line">		&lt;property name="jdbcUrl" value="jdbc:mysql://localhost:mysql端口/你的项目"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="user" value="你的用户名"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="password" value="你的密码"&gt;&lt;/property&gt;</div><div class="line"></div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 第二步：创建sqlSessionFactory。生产sqlSession，即产生会话 --&gt;</div><div class="line">	&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;</div><div class="line">	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 配置mybatis接口代理开发</div><div class="line">		* 接口类名和映射文件必须同名</div><div class="line">		*　接口类和映射文件必须在同一个目录　下</div><div class="line">		* 映射文件namespace名字必须是接口的全类路径名</div><div class="line">		*　接口的方法名必须和映射Statement的ｉｄ一致</div><div class="line">	 --&gt;</div><div class="line">	 &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;</div><div class="line">	 &lt;property name="basePackage" value="com.zwl.dao"&gt;&lt;/property&gt;</div><div class="line">	 &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt;</div><div class="line">	 &lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 第三步：事务 --&gt;</div><div class="line">	&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;</div><div class="line">	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 配置通知 --&gt;</div><div class="line">	&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;</div><div class="line">	&lt;tx:attributes&gt;</div><div class="line">	&lt;tx:method name="save*" propagation="REQUIRED" /&gt;</div><div class="line">	&lt;tx:method name="update*" propagation="REQUIRED" /&gt;</div><div class="line">	&lt;tx:method name="delete*" propagation="REQUIRED" /&gt;</div><div class="line">	&lt;tx:method name="insert*" propagation="REQUIRED" /&gt;</div><div class="line">	&lt;tx:method name="*" propagation="REQUIRED" /&gt;	</div><div class="line">	&lt;/tx:attributes&gt;</div><div class="line">	&lt;/tx:advice&gt;</div><div class="line"></div><div class="line">&lt;!-- 配置拦截service --&gt;</div><div class="line">	&lt;aop:config&gt;</div><div class="line">	&lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.zwl.service.*.*(..))"/&gt;</div><div class="line">	&lt;/aop:config&gt;</div><div class="line">	</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>以上三个包都必须在web-inf下</p>
<ol>
<li>编写接口代码<br>首先是pojo类</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">	 private String name;       //用户名</div><div class="line">	private String pwd;        //密码</div><div class="line">	private int uid;           //用户id</div><div class="line">此处省略set、get方法。&#125;</div></pre></td></tr></table></figure>
<p>然后利用mapper代理模式开发dao层<br>首先是Usermapper.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE mapper    </div><div class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    </div><div class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line">&lt;mapper namespace="com.zwl.dao.Usermapper"&gt;</div><div class="line">	&lt;!-- 根据用户ID查询用户信息 --&gt;</div><div class="line">	&lt;select id="findUserById" parameterType="int" resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT</div><div class="line">		* FROM users WHERE uid =#&#123;uid&#125;</div><div class="line">	&lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure>
<p>然后是接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Usermapper &#123;</div><div class="line">	public User findUserById(int id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>编写service层<br>这里用到spring注解依赖注入</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Userservice &#123;</div><div class="line"></div><div class="line">	public User finduserbyid(Integer id) throws Exception;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//声明业务层为注解，为控制层依赖注入服务</div><div class="line">@Service</div><div class="line">public class Userserviceimpl implements Userservice &#123;</div><div class="line"> </div><div class="line">//通过注解注入dao层组件</div><div class="line">	@Resource</div><div class="line">	private Usermapper usermapper;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public User finduserbyid(Integer id) throws Exception &#123;</div><div class="line">		User user=usermapper.findUserById(id);</div><div class="line">		return user;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>控制层</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//注解自动在spring中注入该bean</div><div class="line">@Controller</div><div class="line">//请求路径，放在开头，请求url，controller前必须加入该映射路径</div><div class="line">@RequestMapping("/user")</div><div class="line">public class Usercontrol &#123;</div><div class="line">  //自动注入bean</div><div class="line">	@Resource</div><div class="line">	private Userservice userservice;</div><div class="line"></div><div class="line">//请求路径，放在方法前，为请求url，到时根据这个找到类里相应方法</div><div class="line">	@RequestMapping("toadd")</div><div class="line">	public String toadd()&#123;</div><div class="line">//返回视图，在配置文件中已经配置了前缀和后缀，所以返回到index.jsp</div><div class="line">		return "index";</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@RequestMapping("uid")</div><div class="line">	//这里的参数id必须和前台提交的参数name相同，才能接收到</div><div class="line">	public void finduserbyid(Integer id)</div><div class="line">	&#123;</div><div class="line">		try &#123;</div><div class="line">			User u=userservice.finduserbyid(id);</div><div class="line">			System.out.println(u.getName());</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li>页面<br>index.jsp</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/user/uid.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">id：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"id"</span> id=<span class="string">"id"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<ol>
<li>数据库<br>里面字段必须为uid，name和password，和pojo类相对应，并且里面有数据</li>
</ol>
<p>最后我们可以在浏览器输入http：//localhost:端口/项目名/user/toadd.do到index.jsp页面，最后通过输入id，后台输出用户信息</p>
<p>至此ssm整合完成，会发现它比ssh2更方便，特别是注解开发</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ssh三大框架整合]]></title>
      <url>http://www.myzwl.win/2017/03/01/ssh/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>ssh三大框架整合主要指的是structs2+hibernate+spring，利用mvc分层思想实现解耦，其中structs2负责业务控制和跳转，hibernate负责持久层，spring管理各层</strong></p>
<h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>下面将以一个简单的登录功能搭建整合环境</p>
<ol>
<li><p>首先建立一个web工程，取名ssh2</p>
</li>
<li><p>导入jar包，由于ssh2整合包过多，可以自行官网下载</p>
</li>
<li><p>导入相关配置文件<br>Spring核心文件：applicationcontent.xml放在web-inf下<br>web工程核心文件：web.xml也放在web-inf下<br>structs2核心文件：structs.xml放在src目录下<br>里面暂时什么都不配置</p>
</li>
<li><p>数据库<br>为了方便，设置三个字段，id（int）、name（varchar）、age（int），其中id为主键，且是自增长的</p>
</li>
<li><p>配置核心文件初始化<br>Web.xml配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app version="2.5" </div><div class="line">	xmlns="http://java.sun.com/xml/ns/javaee" </div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" </div><div class="line">	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee </div><div class="line">	http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;</div><div class="line">	&lt;filter&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">	//启动structs2框架	&lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;</div><div class="line">	&lt;/filter&gt;</div><div class="line">//允许后缀名为.action或者.jsp的请求通过</div><div class="line">	&lt;filter-mapping&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">		&lt;url-pattern&gt;*.action&lt;/url-pattern&gt;</div><div class="line">	&lt;/filter-mapping&gt;</div><div class="line">	&lt;filter-mapping&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">		&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</div><div class="line">	&lt;/filter-mapping&gt;</div><div class="line">//启动spring监听，即开启spring框架</div><div class="line">	&lt;listener&gt;</div><div class="line">		&lt;listener-class&gt;</div><div class="line">			org.springframework.web.context.ContextLoaderListener</div><div class="line">		&lt;/listener-class&gt;</div><div class="line">	&lt;/listener&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Applicationcontent.xml文件配置（目前没有实现任何功能，给出原始配置）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans</div><div class="line">xmlns="http://www.springframework.org/schema/beans"</div><div class="line">xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt;</div><div class="line">	&lt;!-- 定义数据源 ，即连接数据库所需的配置--&gt;</div><div class="line">	&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;</div><div class="line">		&lt;property name="driverClassName"&gt;</div><div class="line">			&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="url"&gt;</div><div class="line">			&lt;value&gt;jdbc:mysql://localhost:mysql端口/数据库名&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="username"&gt;</div><div class="line">			&lt;value&gt;你的用户名&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="password"&gt;</div><div class="line">			&lt;value&gt;你的密码&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 定义SessionFactory --&gt;</div><div class="line">	&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;</div><div class="line">		&lt;property name="dataSource"&gt;</div><div class="line">			&lt;ref bean="dataSource"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="hibernateProperties"&gt;</div><div class="line">			&lt;props&gt;</div><div class="line">//hibernate的方言，决定用哪个数据库</div><div class="line">				&lt;prop key="hibernate.dialect"&gt;</div><div class="line">					org.hibernate.dialect.MySQLDialect</div><div class="line">				&lt;/prop&gt;</div><div class="line">            //是否启动显示sql语句</div><div class="line">				&lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt;</div><div class="line">			&lt;/props&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">//声明hibernate的映射文件，目前没有，后续步骤在此处加上</div><div class="line">		&lt;property name="mappingResources"&gt;</div><div class="line">			&lt;list&gt;</div><div class="line">				&lt;value&gt;&lt;/value&gt;</div><div class="line">			&lt;/list&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	&lt;!-- 定义HibernateTemplate，相当于纯hibernate的session --&gt;</div><div class="line">	&lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt;</div><div class="line">		&lt;property name="sessionFactory"&gt;</div><div class="line">			&lt;ref bean="sessionFactory"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	省略具体的业务代码注入配置</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>Structs.xml文件配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE struts PUBLIC</div><div class="line">    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"</div><div class="line">    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</div><div class="line">&lt;struts&gt;</div><div class="line"></div><div class="line">//防止乱码</div><div class="line">&lt;constant name="struts.i18n.encoding" value="utf-8"/&gt;</div><div class="line">&lt;/struts&gt;</div><div class="line">目前该文件里面什么功能都没配置，只是个声明</div></pre></td></tr></table></figure>
<ol>
<li>编写业务代码<br>按照mvc思想，先从持久层开始，即编写hibernate的orm对象user.java</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line"></div><div class="line">	private int age;</div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">此处省略set。Get方法&#125;</div></pre></td></tr></table></figure>
<p>映射文件User.hbm.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC </div><div class="line">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line">&lt;hibernate-mapping package="com.zwl.pojo"&gt;</div><div class="line">&lt;class name="User" &gt;</div><div class="line">&lt;id name="id"&gt;</div><div class="line">&lt;generator class="increment"&gt;&lt;/generator&gt;</div><div class="line">&lt;/id&gt;</div><div class="line">&lt;property name="name"&gt;&lt;/property&gt;</div><div class="line">&lt;property name="age"&gt;&lt;/property&gt;</div><div class="line">&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure>
<p>注意这里普通属性有时为了方便，只要声明一个name，其他属性hibernate会自动识别并补充</p>
<p>接下来要在spring中声明该映射文件</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"mappingResources"</span>&gt;</div><div class="line">			&lt;list&gt;</div><div class="line">				&lt;value&gt;com/zwl/pojo/User<span class="selector-class">.hbm</span><span class="selector-class">.xml</span>&lt;/value&gt;</div><div class="line">			&lt;/list&gt;</div><div class="line">		&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>至此，持久层完成</p>
<p>接下来是dao层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public interface dengludao &#123;</div><div class="line">//登录功能</div><div class="line">public User denglu(User u);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Dao层的实现类</div><div class="line">import org.springframework.orm.hibernate3.support.HibernateDaoSupport;</div><div class="line"></div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public class dengludaoimpl extends HibernateDaoSupport implements dengludao&#123;</div><div class="line">	//这里用了spring提供的操作hibernate的模板方法</div><div class="line">	@Override</div><div class="line">	public User denglu(User u) &#123;</div><div class="line">    //find里可以写sql语句</div><div class="line">		List&lt;User&gt; list=this.getHibernateTemplate().find("select user from User as user where user.id=?",u.getId());</div><div class="line">		if(list.size()==0)&#123;</div><div class="line">			return null;&#125;</div><div class="line">					else&#123;</div><div class="line">						return (User) list.get(0);</div><div class="line">					&#125;</div><div class="line">	&#125;&#125;</div><div class="line">	</div><div class="line">接下来要在spring中注入到组件</div><div class="line">&lt;!-- 配置DAO组件 --&gt;</div><div class="line">	&lt;bean id="dengludao" class="com.zwl.dao.dengludaoimpl"&gt;</div><div class="line">		&lt;property name="hibernateTemplate"&gt;</div><div class="line">			&lt;ref bean="hibernateTemplate"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>接下来是业务层：<br> 首先是接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public interface dengluservice &#123;</div><div class="line">public boolean isdenglu(User u);</div><div class="line">&#125;</div><div class="line">然后是实现类</div><div class="line">public class dengluserviceimpl implements dengluservice&#123;</div><div class="line"> //引用dao层组建</div><div class="line">	private dengludao denglu;</div><div class="line">	</div><div class="line">	public dengludao getDenglu() &#123;</div><div class="line">		return denglu;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setDenglu(dengludao denglu) &#123;</div><div class="line">		this.denglu = denglu;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public boolean isdenglu(User u) &#123;</div><div class="line">		if(denglu.denglu(u)!=null)</div><div class="line">		return true;</div><div class="line">		else&#123;</div><div class="line">		return false;</div><div class="line">		&#125;</div><div class="line">	&#125;&#125;</div><div class="line">接下来就要在spring中注入业务层组件</div><div class="line">&lt;!-- 配置业务逻辑组件 --&gt;</div><div class="line">	&lt;bean id="dengluservice" class="com.zwl.dao.dengluserviceimpl"&gt;</div><div class="line">		&lt;property name="denglu"&gt;</div><div class="line">			&lt;ref bean="dengludao"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div></pre></td></tr></table></figure>
<ol>
<li>表现层<br>首先是两个页面<br>Index.Jsp主要提交表单</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"userdenglu.action"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">   id:&lt;<span class="selector-tag">input</span> name=<span class="string">"id"</span> type=<span class="string">"text"</span>&gt;</div><div class="line">   &lt;br/&gt;</div><div class="line">   &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">   &lt;/form&gt;</div></pre></td></tr></table></figure>
<p>Success.jsp<br>主要就是一句success提示</p>
<ol>
<li>控制层</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class userdenglu extends ActionSupport&#123;</div><div class="line"></div><div class="line">	private dengluservice dengluservic;</div><div class="line">	private int id;</div><div class="line">省略set与get方法。。</div><div class="line">	@Override</div><div class="line">	public String execute() throws Exception &#123;</div><div class="line">		User u=new User();</div><div class="line">		u.setId(id);</div><div class="line">//如果id存在，返回成功</div><div class="line">		if(dengluservic.isdenglu(u))&#123;</div><div class="line">			return SUCCESS;</div><div class="line">		&#125;</div><div class="line">		return ERROR;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>接下来需要在spring中注入action</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置userdengluAction --&gt;</div><div class="line">	&lt;bean id=<span class="string">"userdenglu"</span> class=<span class="string">"com.zwl.action.userdenglu"</span>&gt;</div><div class="line">		&lt;property name=<span class="string">"dengluservic"</span>&gt;</div><div class="line">			&lt;ref bean=<span class="string">"dengluservice"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>同时在structs.xml中配置跳转</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"userdenglu"</span> class=<span class="string">"userdenglu"</span>&gt;</div><div class="line">			&lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">			&lt;result name=<span class="string">"error"</span>&gt;/error.jsp&lt;/result&gt;</div><div class="line">		&lt;/action&gt;</div></pre></td></tr></table></figure>
<p>最后通过在浏览器输入到index.jsp，然后输入id，数据库中可以预先插入数据，最后跳转，如果成功则跳到success.jsp，否则产生错误</p>
<p><strong>至此：ssh2框架环境搭建成功，最后提醒的是，这只是一个框架环境，我们可以在此基础上按照mvc思想，可以进行我们想要功能的开发</strong></p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于java的execl导入数据库和取数据至页面]]></title>
      <url>http://www.myzwl.win/2017/02/28/execl/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在踩了许多坑之后，急需总结一下来提高自己，当然探索未知的过程也是自我能力的提升</p>
<h4 id="POI"><a href="#POI" class="headerlink" title="POI"></a>POI</h4><p><strong>akarta POI 是apache的子项目，它提供了一组操纵Windows文档的Java API，一般我们使用HSSF接口来操作execl对象，从而实现用纯Java代码来读取、写入、修改Excel文件</strong></p>
<p>我们可以到其官网下载最新<a href="http://www.apache.org/dyn/closer.cgi/jakarta/poi/" target="_blank" rel="external">poi文档</a></p>
<h4 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h4><p>首先我们定义一个需求，上传本地一个execl表（里面含有数据），提交给服务器，然后跳转到另一个界面（显示execl表中内容）</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>MyEclipse。ssh整合包，mysql，poi的相关包（去官网下载，导入poi-3.7-20101029.jar，poi-examples-3.7-20101029.jar，poi-ooxml-3.7-20101029.jar，poi-ooxml-schemas-3.7-20101029.jar，poi-scratchpad-3.7-20101029.jar）</p>
<ol>
<li><p>首先是建一个pojo类，主要与execl表中对应的字段相对应<br>为了方便，这里只有id，name，password字段</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pojo;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line"></div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">	private String password;</div><div class="line">	省略set..get方法</div></pre></td></tr></table></figure>
<p>2.execl表中写数据</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>password</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>java</td>
<td>lol</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>c</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>3.写读取execl表格的工具类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">package com.zwl.util;</div><div class="line"></div><div class="line">import java.io.FileInputStream;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">import org.apache.poi.hssf.usermodel.HSSFSheet;</div><div class="line">import org.apache.poi.hssf.usermodel.HSSFWorkbook;</div><div class="line">import org.apache.poi.hssf.usermodel.HSSFRow;</div><div class="line">import org.apache.poi.hssf.usermodel.HSSFCell;</div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public class ReadExcel &#123;</div><div class="line">      //将execl表中的数据读取出，并与pojo类对应，最后放在集合中</div><div class="line">	 public List&lt;User&gt; readXls(String path) throws IOException &#123;</div><div class="line">	   //execl表的全路径,并保存在输入流</div><div class="line">		 InputStream is = new FileInputStream(path);</div><div class="line">		 //HSSFWorkbook excell 文档对象介绍 </div><div class="line">		 HSSFWorkbook hssfWorkbook = new HSSFWorkbook(is);</div><div class="line">		 User user=null;</div><div class="line">		 List&lt;User&gt; list=new ArrayList&lt;User&gt;();</div><div class="line">		 // 循环工作表Sheet</div><div class="line">         for (int numSheet = 0; numSheet &lt; hssfWorkbook.getNumberOfSheets(); numSheet++) &#123;</div><div class="line">              // HSSFSheet excell的表单 </div><div class="line">             HSSFSheet hssfSheet = hssfWorkbook.getSheetAt(numSheet);</div><div class="line">             if (hssfSheet == null) &#123;</div><div class="line">                 continue;</div><div class="line">             &#125;</div><div class="line">          // 循环行Row</div><div class="line">             for (int rowNum = 1; rowNum &lt;= hssfSheet.getLastRowNum(); rowNum++) &#123;</div><div class="line">            	 //HSSFRow excell的行</div><div class="line">                 HSSFRow hssfRow = hssfSheet.getRow(rowNum);</div><div class="line">                 if (hssfRow != null) &#123;</div><div class="line">                    User u = new User();</div><div class="line">                    //HSSFCell excell的格子单元</div><div class="line">                    //这里取出每一行的数据，依次分别添加到pojo对象中，最后放在集合中</div><div class="line">                     HSSFCell no = hssfRow.getCell(0);</div><div class="line">                     HSSFCell name = hssfRow.getCell(1);</div><div class="line">                     HSSFCell age = hssfRow.getCell(2);</div><div class="line">                     int i=(int)Double.parseDouble(getValue(no));</div><div class="line">                     u.setId(i);</div><div class="line">                     u.setName(getValue(name));</div><div class="line">                     u.setPassword(getValue(age));</div><div class="line">                     list.add(u);</div><div class="line">                 &#125;</div><div class="line">             &#125;&#125;</div><div class="line">                 return list;</div><div class="line">                 &#125;</div><div class="line">                 </div><div class="line">                 @SuppressWarnings("static-access")</div><div class="line">                 private String getValue(HSSFCell hssfCell) &#123;</div><div class="line">                         if (hssfCell.getCellType() == hssfCell.CELL_TYPE_BOOLEAN) &#123;</div><div class="line">                             // 返回布尔类型的值</div><div class="line">                             return String.valueOf(hssfCell.getBooleanCellValue());</div><div class="line">                         &#125; else if (hssfCell.getCellType() == hssfCell.CELL_TYPE_NUMERIC) &#123;</div><div class="line">                             // 返回数值类型的值</div><div class="line">                             return String.valueOf(hssfCell.getNumericCellValue());</div><div class="line">                         &#125; else &#123;</div><div class="line">                             // 返回字符串类型的值</div><div class="line">                             return String.valueOf(hssfCell.getStringCellValue());</div><div class="line">                         &#125;</div><div class="line">                 &#125;	&#125;</div></pre></td></tr></table></figure>
<p>4.上传execl页面，这里只有主体部分</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//上传至后台的uploadaction，同时规定只能上传execl文件，并且这里的myFile要与后台action中属性对应</span></div><div class="line">  &lt;<span class="selector-tag">form</span> action=<span class="string">"upload.action"</span> enctype=<span class="string">"multipart/form-data"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> id=<span class="string">"share_box"</span> type=<span class="string">"file"</span> name=<span class="string">"myFile"</span> accept=<span class="string">"excel/*"</span>&gt;&lt;hr/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> id=<span class="string">"submit"</span> type=<span class="string">"submit"</span> name=<span class="string">""</span> value=<span class="string">"分享"</span>&gt;</div><div class="line">  &lt;/form&gt;</div></pre></td></tr></table></figure>
<p>5.action编写</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public class upload extends ActionSupport &#123;</div><div class="line">	private File myFile;                                         //上传的图片文件</div><div class="line">	private String myFileContentType;                            //文件类型</div><div class="line">	private String myFileFileName;                                //文件名</div><div class="line">              省略set与get方法</div><div class="line">	@Override</div><div class="line">	public String execute() throws Exception &#123;</div><div class="line">		</div><div class="line">	                         //创建一个输入流</div><div class="line">				InputStream is = new FileInputStream(myFile);</div><div class="line">				 //设置文件保存目录</div><div class="line">				String photoPath = </div><div class="line">					ServletActionContext.getServletContext().getRealPath("");</div><div class="line">				  //建立该文件</div><div class="line">				File filePhotoPath = new File(photoPath);</div><div class="line">				  //该用户第一次上传则创建</div><div class="line">				/*if(!filePhotoPath.isDirectory()) &#123;</div><div class="line">					filePhotoPath.mkdir();</div><div class="line">				&#125;*/</div><div class="line">				</div><div class="line">				 //解决中文文件名问题，将中文文件转化为uuid码</div><div class="line">						String extension = FilenameUtils.getExtension(this.getMyFileFileName());</div><div class="line">                                  //上传到服务器的execl表的全路径</div><div class="line">						String s=photoPath+'\\'+filename;</div><div class="line">						System.out.println(s);</div><div class="line">				//设置目标文件</div><div class="line">				File tofile = new File(photoPath,filename);</div><div class="line">				//使用输出流来包装目标文件</div><div class="line">				OutputStream os = new FileOutputStream(tofile);</div><div class="line">				//通过字节输入</div><div class="line">				byte[] buffer = new byte[1024];</div><div class="line">				int length = 0;</div><div class="line">				while((length = is.read(buffer)) &gt; 0) &#123;</div><div class="line">					os.write(buffer, 0, length);</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				</div><div class="line">				//关闭输入流</div><div class="line">				is.close();</div><div class="line">				//关闭输出流</div><div class="line">				os.close();</div><div class="line">				//引用读取execl表类</div><div class="line">		      ReadExcel rs=new ReadExcel();</div><div class="line">		                //取出execl表中的内容</div><div class="line">		 List&lt;User&gt; list=rs.readXls(s);</div><div class="line">		                      //将execl表中取出的数据放在session中，以便在下个界面显示数据</div><div class="line">		 Map session = ServletActionContext.getContext().getSession();</div><div class="line">		 session.put("stu", list);</div><div class="line">		return super.execute();</div><div class="line">	&#125;&#125;</div></pre></td></tr></table></figure>
<p>6.structs配置文件编写</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//spring中注入bean</span></div><div class="line">&lt;bean id=<span class="string">"upload"</span> class=<span class="string">"com.zwl.action.upload"</span>&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line"><span class="comment">//strucs.xml文件，其中涉及文件上传，必须有拦截栈的设置，ok.jsp为显示execl表格信息</span></div><div class="line">      &lt;action name=<span class="string">"upload"</span> class=<span class="string">"upload"</span>&gt;</div><div class="line">			&lt;result name=<span class="string">"success"</span>&gt;/ok.jsp&lt;/result&gt;</div><div class="line">			&lt;result name=<span class="string">"input"</span>&gt;/ok.jsp&lt;/result&gt;</div><div class="line">			&lt;!-- 配置fileUpload拦截器 --&gt;</div><div class="line">			&lt;interceptor-ref name=<span class="string">"fileUpload"</span>&gt;</div><div class="line">				&lt;!-- 配置允许上传文件类型 这里是execl文件格式允许上传--&gt;</div><div class="line">				&lt;param name=<span class="string">"allowedTypes"</span>&gt;application/excel,application/vnd.ms-excel&lt;/param&gt;</div><div class="line">				&lt;!-- 配置允许上传文件大小最大值 --&gt;</div><div class="line">				&lt;param name=<span class="string">"maximumSize"</span>&gt;<span class="number">5120000</span>&lt;/param&gt;</div><div class="line">			  &lt;/interceptor-ref&gt;</div><div class="line">			  &lt;interceptor-ref name=<span class="string">"defaultStack"</span>&gt;&lt;/interceptor-ref&gt;</div><div class="line">		&lt;/action&gt;</div></pre></td></tr></table></figure>
<p>7.取出信息在页面显示<br>通过标签循环取出session中的数据<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;s:iterator value=<span class="string">"#session.stu"</span>  id=<span class="string">"cri"</span>&gt;</div><div class="line">id:&lt;s:property value=<span class="string">"#cri.id"</span> escape=<span class="string">"false"</span>/&gt;&lt;br/&gt;</div><div class="line">name:&lt;s:property value=<span class="string">"#cri.name"</span> escape=<span class="string">"false"</span>/&gt;&lt;br/&gt;</div><div class="line">password:&lt;s:property value=<span class="string">"#cri.password"</span> escape=<span class="string">"false"</span>/&gt;&lt;br/&gt;</div><div class="line">&lt;/s:iterator&gt;</div></pre></td></tr></table></figure></p>
<p>至此我们可以本地上传execl，然后取出表中内容在另一个页面显示信息</p>
<h4 id="导入数据库"><a href="#导入数据库" class="headerlink" title="导入数据库"></a>导入数据库</h4><p>同样关键在于通过execl路径，通过工具包取出表中内容（存在集合中），将该集合循环取出放在数据库即可<br>9.后台插入数据到数据库的接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//映射文件</div><div class="line">hibernate-mapping package="com.zwl.pojo"&gt;</div><div class="line">    &lt;class name="User" table="user" &gt;</div><div class="line">        &lt;id name="id" &gt;</div><div class="line">            &lt;generator class="increment"&gt;&lt;/generator&gt;</div><div class="line">        &lt;/id&gt;</div><div class="line">        &lt;property name="name"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="password"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div><div class="line"></div><div class="line">//dao层</div><div class="line">public interface dengludao &#123;</div><div class="line">	public void insert(User u);</div><div class="line">&#125;</div><div class="line">//sercive层</div><div class="line">public interface dengluservice &#123;</div><div class="line">public void isinsert(User u);</div><div class="line">&#125;</div><div class="line">//实现类</div><div class="line">//dao层实现类</div><div class="line">@Override</div><div class="line">	public void insert(User u) &#123;</div><div class="line">		this.getHibernateTemplate().save(u);</div><div class="line">		&#125;</div><div class="line">//service层实现类</div><div class="line">private dengludao denglu;</div><div class="line">@Override</div><div class="line">	public void isinsert(User u) &#123;</div><div class="line">		denglu.insert(u);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	当然最后还得在spring中注入</div></pre></td></tr></table></figure>
<p>10.最后在action中修改一下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//首先增加组件（spring中注入）</div><div class="line">private dengluservice dengluservic;</div><div class="line">省略set与get</div><div class="line">// 在execute中末尾增加如下代码</div><div class="line">                    for(User u : list)&#123;</div><div class="line">			//循环取出execl表中数据</div><div class="line">			User ss=new User();</div><div class="line">			ss.setId(u.getId());</div><div class="line">			ss.setName(u.getName());</div><div class="line">			ss.setPassword(u.getPassword());</div><div class="line">			//循环插入到数据库</div><div class="line">			dengluservic.isinsert(ss);</div><div class="line">		 &#125;</div></pre></td></tr></table></figure>
<p><strong>最后只要我们上传execl文件，就可以先插入数据库，再在另一个页面显示信息了，注意这里有些地方笔者只给出主体代码，其次有些spring中要注入bean，这里省略了</strong></p>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java工具包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Arraylist底层]]></title>
      <url>http://www.myzwl.win/2017/02/27/arraylist/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ArrayList也叫数组列表，底层使用的是数组实现的，严格来说是动态数组。<br> 一般情况下，一个问题的认识都是由具体到抽象，先看一个入门案例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; al=new ArrayList&lt;&gt;();</div><div class="line">	al.add("hello");</div><div class="line">	al.add("world");</div><div class="line">	al.add("lol");</div><div class="line">	System.out.println(al.size());</div><div class="line">	System.out.println(al.get(0));</div><div class="line">	System.out.println(al.get(1));</div><div class="line">	System.out.println(al.get(2));</div><div class="line">	al.remove(1);</div><div class="line">	System.out.println(al.size());</div><div class="line">	System.out.println(al.get(1));</div></pre></td></tr></table></figure>
<p>测试结果：3 hello world lol 2<br>这个例子也很好理解，大概流程是先创建集合，在依次加入数据，依次取出和大小，在删除其中一个，在看大小和删除的数据是否存在，好了，入门程序就到这了，运用这几个方法我们可以把它复杂化运用到我们以后想要的上面。</p>
<p>至此下面将开始简单介绍一下add，get，remove方法的源码分析。<br>（当然我们也可以通过设置断点追踪源码）</p>
<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>在此之前，先介绍一下源码中的几个静态常量</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private static final int DEFAULT_CAPACITY=10;//数组为空默认的最小分配数组容量</div><div class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//默认空数组</div><div class="line">private int size;//数组长度，初始化默认为0；</div></pre></td></tr></table></figure>
<p><strong>下面就是add方法</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line">//保证数组容量的容量始终够用</div><div class="line">     ensureCapacityInternal(size + 1);  </div><div class="line">   //size是elementData数组中元素的个数，初始为0</div><div class="line">     elementData[size++] = e;</div><div class="line">      return true;&#125;</div></pre></td></tr></table></figure>
<p>首先进入第一个方法分析：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private void ensureCapacityInternal(int minCapacity) &#123;</div><div class="line">//如果数组没有元素，给数组一个默认大小，会选择实例化时的值与默认大小较大者</div><div class="line">        if (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">        &#125;</div><div class="line">        //保证容量够用</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   private void ensureExplicitCapacity(int minCapacity) &#123;</div><div class="line">//数组发生size更改的次数，默认为0</div><div class="line">        modCount++;</div><div class="line">         //如果数组长度小于默认的容量10，则调用扩大数组大小的方法</div><div class="line">             if (minCapacity - elementData.length &gt; 0)</div><div class="line">            grow(minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//数组长度的上限</div><div class="line">   private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</div><div class="line">  </div><div class="line">   private void grow(int minCapacity) &#123;</div><div class="line">        // 保证数组容量扩大一倍</div><div class="line">        int oldCapacity = elementData.length;</div><div class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</div><div class="line">        if (newCapacity - minCapacity &lt; 0)</div><div class="line">            newCapacity = minCapacity;</div><div class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div class="line">            newCapacity = hugeCapacity(minCapacity);</div><div class="line">        // 得到扩大容量后的新数组</div><div class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private static int hugeCapacity(int minCapacity) &#123;</div><div class="line">//返回新数组的大小</div><div class="line">        if (minCapacity &lt; 0) </div><div class="line">            throw new OutOfMemoryError();</div><div class="line">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">            Integer.MAX_VALUE :</div><div class="line">            MAX_ARRAY_SIZE;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>至此算是把add方法的底层分析了一遍，我们现在是不是可以假象一个简单例子来模拟流程</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; al=new ArrayList&lt;&gt;();</div><div class="line">	al.add("hello");</div></pre></td></tr></table></figure>
<p>大概执行流程，数组为空，分配一个默认大小为10的容量，容量动态扩充，然后size变化，最后将值赋给数组，说了这么多，还是有点，总之，可以自己模拟数据，然后进行断点调试，就大概了解其过程了。</p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>在此之前先补充一下arraylist的构造函数，如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//如果构造函数不指定大小，则将默认空对象给数组对象</div><div class="line">public ArrayList() &#123;</div><div class="line">        super();</div><div class="line">        this.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">//指定初始化数组大小</div><div class="line">public ArrayList(int initialCapacity) &#123;</div><div class="line">        super();</div><div class="line">        if (initialCapacity &lt; 0)</div><div class="line">            throw new IllegalArgumentException("Illegal Capacity: "+</div><div class="line">                                               initialCapacity);</div><div class="line">        this.elementData = new Object[initialCapacity];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面就来看一看get方法的执行过程</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line">//判断index是否合法</div><div class="line">        rangeCheck(index);</div><div class="line">      //得到相应的数组数据</div><div class="line">        return elementData(index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private void rangeCheck(int index) &#123;</div><div class="line">//判断数组是否越界</div><div class="line">        if (index &gt;= size)</div><div class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到它的执行过程就这两步</p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><p>这里先说明一下，由于删除操作会改变size，所以每次删除都需要把元素向前移动一个位置，然后把最后一个位置设置为null，一次删除操作完成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public E remove(int index) &#123;</div><div class="line">   //判断index是否合法</div><div class="line">        rangeCheck(index);</div><div class="line">// size更改的次数</div><div class="line">        modCount++;</div><div class="line">//保存待删除的位置的元素</div><div class="line">        E oldValue = elementData(index);</div><div class="line">        //要移动的元素个数</div><div class="line">        int numMoved = size - index - 1;</div><div class="line">    //如果index不是最后一个元素，则从第index+1到最后一个位置，依次向前移动一个位置</div><div class="line">        if (numMoved &gt; 0)</div><div class="line">            System.arraycopy(elementData, index+1, elementData, index,</div><div class="line">                             numMoved);</div><div class="line"> //元素的size-1并且最后一个元素位置设为null</div><div class="line">        elementData[--size] = null; </div><div class="line">        return oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static native void arraycopy(Object src,  int  srcPos,</div><div class="line">                                        Object dest, int destPos,</div><div class="line">                                        int length);</div></pre></td></tr></table></figure>
<p>很遗憾：断点调试中没有源码，因为其是native，是其他语言编写的，这里只做简单介绍<br>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的源数组到 dest 引用的目标数组，数组组件的一个子序列被复制下来。被复制的组件的编号等于 length 参数。源数组中位置在 srcPos 到 srcPos+length-1 之间的组件被分别复制到目标数组中的 destPos 到 destPos+length-1 位置。</p>
<p>最后不得不提的是因为arraylist是动态增长的，即容量增产幅度遵循size/2+1，即默认为10，所以依次为：10,16,25.。。。。<br>这就造成arraylist是线程不安全的，多线程中产生问题，参考单例模式</p>
]]></content>
      
        <categories>
            
            <category> 学习进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于servlet的验证码和md5加密]]></title>
      <url>http://www.myzwl.win/2017/02/26/md5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>验证码通俗的讲就是为了防止机器人自动注册无限制，而md5加密则将明文密码转化为一个32位字符串</p>
<h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>这里是基于servlet的，也就是说通过java代码随机生成一个你设置的位数的字符串，然后将其保存在session中，以便后续是通过ajax传给前台验证或者是后台验证<br><strong>首先是生成验证码的类,这里我放在了com.ltw.tools包下</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class yanzhengma extends HttpServlet &#123;</div><div class="line"></div><div class="line">	public void doGet(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line">		// 7.禁止浏览器缓存随机图片</div><div class="line">		response.setDateHeader("Expires", -1);</div><div class="line">		response.setHeader("Cache-Control", "no-cache");</div><div class="line">		response.setHeader("Pragma", "no-cache");</div><div class="line">		// 6.通知客户机以图片方式打开发送过去的数据</div><div class="line">		response.setHeader("Content-Type", "image/jpeg");</div><div class="line">		// 1.在内存中创建一副图片</div><div class="line">		BufferedImage image = new BufferedImage(60, 30,</div><div class="line">				BufferedImage.TYPE_INT_RGB);</div><div class="line">		// 2.向图片上写数据</div><div class="line">		Graphics g = image.getGraphics();</div><div class="line">		// 设背景色</div><div class="line">		g.setColor(Color.BLACK);</div><div class="line">		g.fillRect(0, 0, 60, 30);</div><div class="line">		// 3.设置写入数据的颜色和字体</div><div class="line">		g.setColor(Color.RED);</div><div class="line">		g.setFont(new Font(null, Font.BOLD, 20));</div><div class="line">		// 4.向图片上写数据</div><div class="line">		String num = makeNum();</div><div class="line">		//这句话就是把随机生成的数值，保存到session，</div><div class="line">//通过session就可以直接去到随即生成的验证码了</div><div class="line">		request.getSession().setAttribute("checkcode", num);		g.drawString(num, 0, 20);</div><div class="line">		// 5.把写好数据的图片输出给浏览器</div><div class="line">		ImageIO.write(image, "jpg", response.getOutputStream());</div><div class="line">	&#125;</div><div class="line">	//该函数时随机生成7位数字</div><div class="line">	public String makeNum() &#123;</div><div class="line">		Random r = new Random();</div><div class="line">		//9999999 可以生成7位</div><div class="line">		String num = r.nextInt(99999) + ""; </div><div class="line">		StringBuffer sb = new StringBuffer();</div><div class="line">		//如果不够4位，前面补零</div><div class="line">		for (int i = 0; i &lt; 5 - num.length(); i++) &#123;</div><div class="line">			sb.append("0");</div><div class="line">		&#125;</div><div class="line">		num = sb.toString() + num;</div><div class="line">		return num;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要注意的是随机生成的数字放在session的checkcode中，通过设置r.nextInt(xxx)，xxx表示生成几位，如9999，则为四位验证码，然后在for循环中改成设置的位即可<br><strong>接下来将验证码映射成资源文件，在web.xml中设置</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;servlet&gt;</div><div class="line">    &lt;servlet-name&gt;yanzhengma&lt;/servlet-name&gt;</div><div class="line">    &lt;servlet-class&gt;com<span class="selector-class">.ltw</span><span class="selector-class">.tools</span><span class="selector-class">.yanzhengma</span>&lt;/servlet-class&gt;</div><div class="line">  &lt;/servlet&gt;</div><div class="line">  </div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;yanzhengma&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;/yanzhengma&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
<p>这样该类就被映射成一个资源，然后在页面中直接取资源</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"yanzhenma"</span> placeholder=<span class="string">"请输入验证码"</span> required=<span class="string">"required"</span>&gt;</div><div class="line">&lt;!--      验证码，后台已将该.java映射为文件 --&gt;</div><div class="line">            &lt;<span class="selector-tag">img</span> src=<span class="string">'/项目名/yanzhengma'</span> style=<span class="string">"width:400px;height: 50px;"</span> &gt;</div><div class="line">           &lt;<span class="selector-tag">input</span> id=<span class="string">"submit"</span> type=<span class="string">"submit"</span> value=<span class="string">"登录"</span>&gt;</div></pre></td></tr></table></figure>
<p>如果这里我们需要在前台输入验证码验证，可以通过ajax传值验证。<br>然后在写一个servlet用来将checkcode转换为json传给前台</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class dengluyanzhen extends HttpServlet &#123;</div><div class="line"></div><div class="line">	public void doGet(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;&#125;</div><div class="line"></div><div class="line">	public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line">		String code = (String) request.getSession().getAttribute("checkcode");  //获得验证码</div><div class="line">		  </div><div class="line">        response.setContentType("text/html; charset=UTF-8");  </div><div class="line">        response.setHeader("Cache-Control", "no-cache");  </div><div class="line">        response.setHeader("Pragma", "no-cache");  </div><div class="line">        PrintWriter out = response.getWriter();  </div><div class="line">          </div><div class="line">        StringBuffer sb = new StringBuffer();  </div><div class="line">        sb.append(code);  </div><div class="line">        out.write(sb.toString());     //转化为json格式将验证码返回给前端</div><div class="line">        out.close();  </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在前台，还是上面那个页面增加如下代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> &lt;script type="text/javascript"&gt;</div><div class="line">$(function()&#123;</div><div class="line"></div><div class="line">	/* 利用ajax异步传值，result获得后台传过来的json数据，即验证码 */</div><div class="line">	 var result = "";</div><div class="line">       $.ajax(&#123;</div><div class="line">           url:'&lt;%=path%&gt;/dengluyanzhen',</div><div class="line">           type:"POST",</div><div class="line">           dataType:"json",</div><div class="line">           async:true,//关闭异步加载,这样只有加载完成才进行下一步</div><div class="line">           success:function (data) &#123;</div><div class="line">               result = data;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">	 $("#submit").click(function () &#123; </div><div class="line">			var num1=$("[name='yanzhenma']").val();</div><div class="line">			 if(result!=num1)&#123;</div><div class="line">				alert("您输入的验证码不一致！请重新输入");</div><div class="line">				return false;</div><div class="line">				window.location.href="error.jsp";</div><div class="line">			&#125;	</div><div class="line">			&#125;); </div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h4 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h4><p>主要是一个算法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class MD5 &#123;</div><div class="line">	public final static String MD5(String s) &#123;      </div><div class="line">		char hexDigits[] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9','a', 'b', 'c', 'd', 'e', 'f' &#125;;      </div><div class="line">		try &#123;      </div><div class="line">			byte[] strTemp = s.getBytes();      </div><div class="line">			MessageDigest mdTemp = MessageDigest.getInstance("MD5");      </div><div class="line">			mdTemp.update(strTemp);      </div><div class="line">			byte[] md = mdTemp.digest();      </div><div class="line">			int j = md.length;      </div><div class="line">			char str[] = new char[j * 2];      </div><div class="line">			int k = 0;      </div><div class="line">			for (int i = 0; i &lt; j; i++) &#123;      </div><div class="line">				byte byte0 = md[i];      </div><div class="line">				str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];      </div><div class="line">				str[k++] = hexDigits[byte0 &amp; 0xf];      </div><div class="line">			&#125;      </div><div class="line">			return new String(str);      </div><div class="line">		&#125; catch (Exception e) &#123;      </div><div class="line">			return null;      </div><div class="line">		&#125;     </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们想要将一个字符加密，直接调用该类的静态方法即可，如<br>MD5.MD5(users.getPwd())。</p>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java工具包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于struts2的二维码]]></title>
      <url>http://www.myzwl.win/2017/02/25/erweima/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间因为一些原因要做一个二维码，故此google了许多，当然是在踩了许多坑之后，找到了适合自己的方法，故在此将其总结一下，来提高自己</p>
<h4 id="什么是二维码"><a href="#什么是二维码" class="headerlink" title="什么是二维码"></a>什么是二维码</h4><p>总的来说就是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，最后通过相关设备读取。</p>
<h4 id="zxing"><a href="#zxing" class="headerlink" title="zxing"></a>zxing</h4><p>zxing是google的一个开源源码，主要用于java生成和解析的条形码，二维码，通过引用相关jar包，实现其中的相关接口来开发，这里我引用的是QRCode.jar主要是生成二维码</p>
<h4 id="需求案例"><a href="#需求案例" class="headerlink" title="需求案例"></a>需求案例</h4><p><strong>假设我们通过扫描二维码将数据库中的信息取出来并显示在另一个页面</strong></p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>MyEclipse、mysql数据库（这里建了一张简单表，有id、name、password）、ssh整合包（事实上，我们可以单独使用struts2，只不过耗时一些），QRCode.jar包，jquery-1.8.3.js,gson.jar</p>
<h4 id="二维码工具包"><a href="#二维码工具包" class="headerlink" title="二维码工具包"></a>二维码工具包</h4><p>这里主要有三个类，一个是图像本身类（包含其本身一些属性）、二维码处理类（包括生成和解析图像二维码），最后一个是将本地图片通过调用处理类转化为二维码。<br>这里我将其放在com.zwl.util包下（以下是相关代码）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class QRCodeImageBean implements QRCodeImage&#123;</div><div class="line"></div><div class="line">	  BufferedImage bufImg;  </div><div class="line">	    </div><div class="line">	    public QRCodeImageBean(BufferedImage bufImg) &#123;  </div><div class="line">	        this.bufImg = bufImg;  </div><div class="line">	    &#125;  </div><div class="line">	    public int getHeight() &#123;  </div><div class="line">	        return bufImg.getHeight();  </div><div class="line">	    &#125;  </div><div class="line">	    public int getPixel(int x, int y) &#123;  </div><div class="line">	        return bufImg.getRGB(x, y);  </div><div class="line">	    &#125;  </div><div class="line">	    public int getWidth() &#123;  </div><div class="line">	        return bufImg.getWidth();  </div><div class="line">	    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>生成和解析二维码类</strong><br>public class QRCode {</p>
<pre><code> /**
 * 解析二维码(QRCode)
 * @param imgPath
 * @return content（返回二维码内容）
 */
public static  String decoderQRCode(String imgPath) {  
    // QRCode 二维码图片的文件  
    File imageFile = new File(imgPath);  
    BufferedImage bufImg = null;  
    String content = null;  
    try {  
        bufImg = ImageIO.read(imageFile);  
        QRCodeDecoder decoder = new QRCodeDecoder();  
        content = new String(decoder.decode(new QRCodeImageBean(bufImg)), &quot;utf-8&quot;);   
    } catch (IOException e) {  
        System.out.println(&quot;Error: &quot; + e.getMessage());  
        e.printStackTrace();  
    } catch (DecodingFailedException dfe) {  
        System.out.println(&quot;Error: &quot; + dfe.getMessage());  
        dfe.printStackTrace();  
    }  
    return content;  
}  

/**  
 * 生成二维码(QRCode)图片  
 * @param content 存储内容  
 * @param imgPath 图片路径  
 * @param imgType 图片类型  
 */    
public static void encoderQRCode(String content, String imgPath, String imgType) {    
    encoderQRCode(content, imgPath, imgType, 7);    
}  

/**  
 * 生成二维码(QRCode)图片  
 * @param content 存储内容  
 * @param imgPath 图片路径  
 * @param imgType 图片类型  
 * @param size 二维码尺寸  
 */    
public static void encoderQRCode(String content, String imgPath, String imgType, int size) {    
    try {    
        BufferedImage bufImg = qRCodeCommon(content, imgType, size);    

        File imgFile = new File(imgPath);    
        // 生成二维码QRCode图片    
        ImageIO.write(bufImg, imgType, imgFile);    
    } catch (Exception e) {    
        e.printStackTrace();    
    }    
}  

/**  
 * 生成二维码(QRCode)图片的公共方法  
 * @param content 存储内容  
 * @param imgType 图片类型  
 * @param size 二维码尺寸  
 * @return  
 */    
private static BufferedImage qRCodeCommon(String content, String imgType, int size) {    
    BufferedImage bufImg = null;    
    try {    
        Qrcode qrcodeHandler = new Qrcode();    
        // 设置二维码排错率，可选L(7%)、M(15%)、Q(25%)、H(30%)，排错率越高可存储的信息越少，但对二维码清晰度的要求越小    
        qrcodeHandler.setQrcodeErrorCorrect(&apos;M&apos;);    
        qrcodeHandler.setQrcodeEncodeMode(&apos;B&apos;);    
        // 设置设置二维码尺寸，取值范围1-40，值越大尺寸越大，可存储的信息越大    
        qrcodeHandler.setQrcodeVersion(size);    
        // 获得内容的字节数组，设置编码格式    
        byte[] contentBytes = content.getBytes(&quot;utf-8&quot;);    
        // 图片尺寸    
        int imgSize = 67 + 12 * (size - 1);    
        bufImg = new BufferedImage(imgSize, imgSize, BufferedImage.TYPE_INT_RGB);    
        Graphics2D gs = bufImg.createGraphics();    
        // 设置背景颜色    
        gs.setBackground(Color.WHITE);    
        gs.clearRect(0, 0, imgSize, imgSize);    

        // 设定图像颜色&gt; BLACK    
        gs.setColor(Color.BLACK);    
        // 设置偏移量，不设置可能导致解析出错    
        int pixoff = 2;    
        // 输出内容&gt; 二维码    
        if (contentBytes.length &gt; 0 &amp;&amp; contentBytes.length &lt; 800) {    
            boolean[][] codeOut = qrcodeHandler.calQrcode(contentBytes);    
            for (int i = 0; i &lt; codeOut.length; i++) {    
                for (int j = 0; j &lt; codeOut.length; j++) {    
                    if (codeOut[j][i]) {    
                        gs.fillRect(j * 3 + pixoff, i * 3 + pixoff, 3, 3);    
                    }    
                }    
            }    
        } else {    
            throw new Exception(&quot;QRCode content bytes length = &quot; + contentBytes.length + &quot; not in [0, 800].&quot;);    
        }    
        gs.dispose();    
        bufImg.flush();    
    } catch (Exception e) {    
        e.printStackTrace();    
    }    
    return bufImg;    
}  }
</code></pre><p>最后一个类是本地生成二维码图片</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;  </div><div class="line">       String imgPath = "C:/Users/Administrator/Desktop/img/xiazi.jpg";  </div><div class="line">        QRCode handler = new QRCode();  </div><div class="line">        String qrCon = handler.decoderQRCode(imgPath);</div><div class="line">        String encoderContent = "http://192.168.43.44:100/librarytest/success1.jsp?id=2";    </div><div class="line">       handler.encoderQRCode(encoderContent, imgPath, "png"); </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>其中imgPath是本地你想将某个图片生成二维码的那个图片</strong><br><strong>qrCon为解析后的二维码内容，我这里就是一个url地址</strong><br><strong>encoderContent：设置二维码的内容，这里为url带个参数，扫描后就会跳转到相应界面</strong><br>这里的参数想要取出，可以先将内容取出，在通过string类中的方法将字符创相应位置字符取出即可<br>至此，工具类算是有了，接下来就是结合具体配置</p>
<h4 id="后台方法"><a href="#后台方法" class="headerlink" title="后台方法"></a>后台方法</h4><p>首先是web.xml（启用struts2和spring）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app version="2.5" </div><div class="line">	xmlns="http://java.sun.com/xml/ns/javaee" </div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" </div><div class="line">	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee </div><div class="line">	http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;</div><div class="line">	&lt;filter&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">		&lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;</div><div class="line">	&lt;/filter&gt;</div><div class="line">	&lt;filter-mapping&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">		&lt;url-pattern&gt;*.action&lt;/url-pattern&gt;</div><div class="line">	&lt;/filter-mapping&gt;</div><div class="line">	&lt;filter-mapping&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">		&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</div><div class="line">	&lt;/filter-mapping&gt;</div><div class="line">	&lt;listener&gt;</div><div class="line">		&lt;listener-class&gt;</div><div class="line">		org.springframework.web.context.ContextLoaderListener</div><div class="line">		&lt;/listener-class&gt;</div><div class="line">	&lt;/listener&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<p>然后是applicationContext.xml（为了方便直接将所有方法都注入了）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans</div><div class="line">xmlns="http://www.springframework.org/schema/beans"</div><div class="line">xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt;</div><div class="line">	&lt;!-- 定义数据源 --&gt;</div><div class="line">	&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;</div><div class="line">		&lt;property name="driverClassName"&gt;</div><div class="line">			&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="url"&gt;</div><div class="line">			&lt;value&gt;jdbc:mysql://localhost:msql端口/项目&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="username"&gt;</div><div class="line">			&lt;value&gt;你的用户名&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="password"&gt;</div><div class="line">			&lt;value&gt;你的密码&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	&lt;!-- 定义SessionFactory --&gt;</div><div class="line">	&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;</div><div class="line">		&lt;property name="dataSource"&gt;</div><div class="line">			&lt;ref bean="dataSource"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="hibernateProperties"&gt;</div><div class="line">			&lt;props&gt;</div><div class="line">				&lt;prop key="hibernate.dialect"&gt;</div><div class="line">					org.hibernate.dialect.MySQLDialect</div><div class="line">				&lt;/prop&gt;</div><div class="line">				&lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt;</div><div class="line">			&lt;/props&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="mappingResources"&gt;</div><div class="line">			&lt;list&gt;</div><div class="line">				&lt;value&gt;com/zwl/pojo/User.hbm.xml&lt;/value&gt;</div><div class="line">			&lt;/list&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	&lt;!-- 定义HibernateTemplate --&gt;</div><div class="line">	&lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt;</div><div class="line">		&lt;property name="sessionFactory"&gt;</div><div class="line">			&lt;ref bean="sessionFactory"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">	&lt;!-- 配置DAO组件 --&gt;</div><div class="line">	&lt;bean id="returnuserdao" class="com.zwl.impl.returnuserdaoimpl"&gt;</div><div class="line">		&lt;property name="hibernateTemplate"&gt;</div><div class="line">			&lt;ref bean="hibernateTemplate"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	&lt;!-- 配置业务逻辑组件 --&gt;</div><div class="line">	&lt;bean id="returnuserservice" class="com.zwl.impl.returnuserserviceimpl"&gt;</div><div class="line">		&lt;property name="userdao"&gt;</div><div class="line">			&lt;ref bean="returnuserdao"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	&lt;!-- 配置userdengluAction --&gt;</div><div class="line">	&lt;bean id="userreturn" class="com.zwl.action.userreturn"&gt;</div><div class="line">		&lt;property name="returnuser"&gt;</div><div class="line">			&lt;ref bean="returnuserservice"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>pojo类（与数据库映射那个类）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">	private String password;</div><div class="line">省略set与get方法。。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>映射文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line">&lt;hibernate-mapping package="com.zwl.pojo"&gt;</div><div class="line">    &lt;class name="User" table="user" &gt;</div><div class="line">        &lt;id name="id" &gt;</div><div class="line">            &lt;generator class="increment"&gt;&lt;/generator&gt;</div><div class="line">        &lt;/id&gt;</div><div class="line">        &lt;property name="name"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="password"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接下来就是接口编写</p>
<p>dao层<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface returnuserdao &#123;</div><div class="line">//通过id返回User</div><div class="line">public User returnuserbyid(int id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>service层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface returnuserservice &#123;</div><div class="line">public   User  returnuser(int id);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>分别得实现类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class returnuserdaoimpl extends HibernateDaoSupport implements	returnuserdao &#123;</div><div class="line">	@Override</div><div class="line">	public User returnuserbyid(int id) &#123;</div><div class="line">		List list=this.getHibernateTemplate().find(" from User user where user.id = '" + id + "'");</div><div class="line">		if(list.size()==0)&#123;</div><div class="line">			return null;</div><div class="line">		&#125;else&#123;</div><div class="line">			return (User)list.get(0);</div><div class="line">		&#125;	&#125;&#125;</div><div class="line">public class returnuserserviceimpl implements returnuserservice&#123;</div><div class="line"></div><div class="line">	private returnuserdao userdao;</div><div class="line"></div><div class="line">	public returnuserdao getUserdao() &#123;</div><div class="line">		return userdao;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setUserdao(returnuserdao userdao) &#123;</div><div class="line">		this.userdao = userdao;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public User returnuser(int id) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return userdao.returnuserbyid(id);</div><div class="line">	&#125;&#125;</div></pre></td></tr></table></figure>
<p><strong>这里只有两个页面，一个只有二维码，另一个是扫描后跳转的页面并且可以从数据库中取出相关信息</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">			   &lt;figure&gt;</div><div class="line">&lt;figcaption&gt;图书1扫码:&lt;/figcaption&gt;</div><div class="line">&lt;img src="img/dl.gif"&gt;你本地生成的二维码图片</div><div class="line">&lt;/figure&gt;</div><div class="line">``` </div><div class="line">接下来是通过ajax从后台异步加载数据，当然是在你扫码后，直接将数据显示在表单中</div><div class="line"></div><div class="line">``` stylus</div><div class="line"> &lt;script type="text/javascript"&gt;</div><div class="line">  $(function()&#123;</div><div class="line">      /*     通过ajax异步提交表单 */</div><div class="line">$.ajax(&#123;</div><div class="line">	        /* 提交路径 */</div><div class="line">	url : '$&#123;pageContext.request.contextPath&#125;/userreturn!userreturn.action',</div><div class="line">	data:params,</div><div class="line">	type:"POST",</div><div class="line">	 dataType:"json",</div><div class="line">	/* 提交成功后，并得到后台返回的数据 */</div><div class="line">	success : function(r) &#123;</div><div class="line">		/* 解析后台json格式，并得到对象 */</div><div class="line">		$("#id").val(r.id);</div><div class="line">		$("#name").val(r.name);</div><div class="line">		$("#password").val(r.password);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">	   &#125;);</div><div class="line">  &lt;/script&gt;</div><div class="line">  </div><div class="line">  &lt;body&gt;</div><div class="line">  &lt;form action="" method="post"&gt;</div><div class="line">  id  :&amp;nbsp;&lt;input id="id" name="id" type="text"/&gt;&lt;br/&gt;</div><div class="line">  name  :&amp;nbsp;&lt;input id="name" name="name" type="text"/&gt;&lt;br/&gt;</div><div class="line">  password  :&amp;nbsp;&lt;input id="password" name="password" type="text"/&gt;&lt;br/&gt;</div><div class="line">  &lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure>
<h4 id="Action类"><a href="#Action类" class="headerlink" title="Action类"></a>Action类</h4><p><strong>接下来就是action的编写</strong><br>首先是 QRCodeAction</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class QRCodeAction extends ActionSupport &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	// 封装上传文件域的属性</div><div class="line">	private File image;</div><div class="line">	// 封装上传文件类型的属性</div><div class="line">	private String imageContentType;</div><div class="line">	// 封装上传文件名的属性</div><div class="line">	private String imageFileName;</div><div class="line">	private String message;</div><div class="line">	private String content;</div><div class="line"></div><div class="line">	此处省略属性的set与get方法。。</div><div class="line">	/**</div><div class="line">	 * 生成二维码</div><div class="line">	 * @return  String</div><div class="line">	 *</div><div class="line">	 */</div><div class="line">	public String encoderQRCode()&#123;</div><div class="line">		String realpath = ServletActionContext.getServletContext().getRealPath("/file");</div><div class="line">		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");</div><div class="line">		String imgName = sdf.format(new Date()) + ".png";</div><div class="line">		String  imgPath= realpath+"/"+imgName;</div><div class="line">		QRCode.encoderQRCode(content, imgPath, "png");</div><div class="line">		message = imgName;</div><div class="line">		return Action.SUCCESS;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 获取二维码</div><div class="line">	 * @return  String</div><div class="line">	 *</div><div class="line">	 */</div><div class="line">	public String decoderQRCode() &#123;</div><div class="line">        try &#123;</div><div class="line">        	String realpath = ServletActionContext.getServletContext().getRealPath("/img");</div><div class="line">        	File savefile = new File(new File(realpath), imageFileName);</div><div class="line">        	if (!savefile.getParentFile().exists())</div><div class="line">        		savefile.getParentFile().mkdirs();</div><div class="line">			FileUtils.copyFile(image, savefile);</div><div class="line">			message   = QRCode.decoderQRCode(realpath+"/"+imageFileName);</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		return Action.SUCCESS;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>然后是我们需要的userreturnaction（主要后台信息通过json格式传给前台）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class userreturn  &#123;</div><div class="line"></div><div class="line">	private returnuserservice returnuser;  //通过用户id查询用户信息</div><div class="line">	private String img;                    //接受二维码图片的名字</div><div class="line">	省略set与get方法。。</div><div class="line"></div><div class="line">       //解析二维码，入库查询，并返回用户信息</div><div class="line">	public void userreturn() throws Exception &#123;</div><div class="line">		HttpServletResponse response=ServletActionContext.getResponse();</div><div class="line">		HttpServletRequest request=ServletActionContext.getRequest();</div><div class="line">		response.setCharacterEncoding("UTF-8");</div><div class="line">		response.setContentType("application/json; charset=utf-8");          //返回json数据</div><div class="line">	        response.setHeader("Cache-Control", "no-cache");                 //不要缓存</div><div class="line">	        response.setHeader("Pragma", "no-cache");  </div><div class="line">		PrintWriter out = response.getWriter();</div><div class="line">		System.out.println("被扫描的二维码图片的名字:"+img);</div><div class="line">		QRCode qrcode=new QRCode();</div><div class="line">		String path=qrcode.decoderQRCode("E:/newday/librarytest/WebRoot/img/"+img);//二维码图片地址</div><div class="line">		System.out.println("二维码解析的内容:"+path);</div><div class="line">		int id=Integer.parseInt(path.substring(path.length()-1));</div><div class="line">		System.out.println("用户的id号:"+id);</div><div class="line">		User user=returnuser.returnuser(id);</div><div class="line">		System.out.println("用户的姓名:"+user.getName());</div><div class="line">		System.out.println("用户的密码:"+user.getPassword());</div><div class="line">		JsonObject json=new JsonObject();</div><div class="line">		json.addProperty("id", id);</div><div class="line">		json.addProperty("name", user.getName());</div><div class="line">		json.addProperty("password", user.getPassword());</div><div class="line">		response.getWriter().write(json.toString());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意在页面中需要jquery-1.8.3.js包，同时此处json格式转换用的是gson.jar包<br>最后就是struts.xml配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line"></div><div class="line">&lt;!DOCTYPE struts PUBLIC</div><div class="line">    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"</div><div class="line">    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</div><div class="line">&lt;struts&gt;</div><div class="line"></div><div class="line">&lt;constant name="struts.i18n.encoding" value="utf-8"/&gt;</div><div class="line">&lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt; </div><div class="line"> &lt;constant name="struts.devMode" value="false" /&gt;</div><div class="line">	&lt;constant name="struts.i18n.encoding" value="UTF-8"/&gt;</div><div class="line">	&lt;constant name="struts.multipart.maxSize" value="10701096"/&gt;&lt;!-- 上传文件最大值 --&gt;</div><div class="line">	&lt;constant name="struts.multipart.saveDir" value="/tmp"/&gt;&lt;!-- 上传文件设置属性 --&gt;</div><div class="line">	&lt;constant name="struts.custom.i18n.resources" value="global" /&gt;</div><div class="line">	&lt;constant name="struts.action.extension" value="action"&gt;&lt;/constant&gt;</div><div class="line">	</div><div class="line">	&lt;package namespace="/"   name="struct2" extends="struts-default"&gt;</div><div class="line">		&lt;action name="userreturn" class="userreturn" method="userreturn"&gt;</div><div class="line">		&lt;/action&gt;</div><div class="line">	&lt;/package&gt;</div><div class="line">	</div><div class="line">     &lt;package name="QRCode" extends="json-default"&gt;</div><div class="line">	    &lt;action name="qRCodeAction_*" class="com.zwl.action.QRCodeAction" method="&#123;1&#125;" &gt;</div><div class="line">	        &lt;result  type="json"&gt;</div><div class="line">		       &lt;param name="root"&gt;message&lt;/param&gt;</div><div class="line">		    &lt;/result&gt;</div><div class="line">		&lt;/action&gt;</div><div class="line">	&lt;/package&gt; </div><div class="line">&lt;/struts&gt;</div></pre></td></tr></table></figure>
<p>最后打开含有二维码那个页面，然后扫一扫就可以跳转到含数据的界面，当然笔者之前遇到了几个问题，首先是图片地址在action中要正确，不然出现null，其次这是只能一个二维码并且含参数id的，只能有一个action，当然可以优化。。。</p>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java工具包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用nat123搭建本地服务器]]></title>
      <url>http://www.myzwl.win/2017/02/24/nat123/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>这是笔者去年第一次将web项目通过外网访问，当然结果很美好，过程很艰难，当时也是第一次用文档记录了探索过程，当然也是在google老师的帮助下，诚然学习最大的乐趣就是通过自己忘我的想尽一切办法最后solve的那种快感</strong><br><em>进入正题</em></p>
<p> 1 因为要把服务器架在自己的机子上，所以可以选择花生壳和nat123，于是当时百度了一堆关于该技术，充其量只是了解了概念，然后修改tomcat配置文件，先将默认的8080端口改为100（按理讲应该改为80，之后注意中讲为什么），然后将root文件夹全部删掉，当然还有一部（但是我配置了只要一输入域名就是空白页，所以我舍弃了这一步）配置域名与tomcat项目的映射</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Context path=<span class="string">""</span> debug=<span class="string">"0"</span> docBase=<span class="string">"你项目的决定路径"</span> reloadable=<span class="string">"true"</span>&gt;&lt;/Context&gt;</div></pre></td></tr></table></figure>
<p> 2 tomcat部分算是完成了，之后我选择了用nat123，建议去官网下载最新版本，注册，登录然后按照百度步骤，懒得写了就截个图吧<br> <img src="/images/imgs1/15.gif" alt="Alt text"></p>
<pre><code>注意应用类型我们选80（http）网站，毕竟这是相对来说最佳选择，内网端口（默认可以写80）我选择了100（之后一定要打开和开放端口，后面再说），内网地址，命令行中输入ipconfig查看ip4就是内网，当然也可以用localhost等等（因为他们在tomcat配置，或者在c盘的一个文件中为他们设置了常量，百度就能找到c盘那个源码，tomcat不多说就在配置里面，很好找），其他配置不动，然后保存
</code></pre><p>  <img src="/images/imgs1/16.gif" alt="Alt text"><br>    这样就有了域名<br>  <img src="/images/imgs1/17.gif" alt="Alt text"></p>
<pre><code>在打开nav123客户端，出现笑脸，如图等表示映射正常，
</code></pre><hr>
<p><strong>然后下面才是最恐怖的地方了（出现各种问题）</strong></p>
<p><strong>1 如果你内网和tomcat选择的是80端口，注意80端口默认不打开的，先开启控制面板-系统与安全-windows防火墙-高级设置-入站规则-新建规则-端口-80-下一步。。-完成，</strong><br>   然后在用netstat –a看看有没有80端口，假设有了，然后以为顺利 了，结果点击客户端的设置，发现最上面出现无公网连接，也就是说内网的80端口不能映射外网，这下麻烦了，好吧，据需钻研解决方案。试着其中一个靠谱的，说路由器配置中没有开放外网，好吧<br><img src="/images/imgs1/18.gif" alt="Alt text"><br>   先在计算机中输入192.168.1.1（这是电信的），打开路由器（然后简单去了解了一下路由器）先开启dmz主机，指派一个特定内网ip（那个机子对外开放），然后</p>
<p><img src="/images/imgs1/19.gif" alt="Alt text"></p>
<p><strong>在虚拟服务中打开相应端口80（暂且不是100），然后自以为一切顺利，在点开客户端那个设置或打开命名行输入ipconfig，都显示自己的公网了，相当于一道闸门打开了，当然也找不出问题了，结果又出现将域名输入出现错误。</strong></p>
<p><strong>结果觉得可能是80端口被封（可是已经在客户端能做的范围内把80打开了，最好的解释是要去电信局备案，才能在服务器端解封80端口），也就是说，80端口我们用不了了）</strong></p>
<p><strong>居然一时用不了，就用其他端口吧，就100吧，把之前所有的80开放改为100，然后在打开网页（注意：tomcat没有配置项目初始化，自己指定），然后在用手机或者其他机子试一次，即域名+项目名，结果成功了，但是网速不行啊（又头疼了~~）</strong></p>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 踩坑 , window </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单例设计模式]]></title>
      <url>http://www.myzwl.win/2017/02/23/danli/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>在介绍单例设计模式之前，先简单介绍一下java的内存分析，可以帮助我们更好的了解相关内容。在此之前，先简单介绍几个相关概念</strong></p>
<h3 id="Stack（栈）"><a href="#Stack（栈）" class="headerlink" title="Stack（栈）"></a>Stack（栈）</h3><p>存放基本数据类型的数据和对象的引用及存放变量，如果存放的是基本数据类型（非static），直接将变量名和值存入stack中，如果是引用，只将变量名存入栈，然后指向它new的对象（存放在堆中）</p>
<h3 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a>Heap（堆）</h3><p>存放new产生的数据</p>
<h3 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h3><p>存放在对象中用static定义的静态成员（基本类型）</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>存放所有数据</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><strong>下面将模拟几个实例先说明在证明。（此外注意String不是基本数据类型）</strong><br><img src="/images/imgs2/1.gif" alt="Alt text"><br>上面给出了一个实例，意在了解内存分配，接下来将以String为例说明</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String str="abc";</div><div class="line">String str1="abc";</div><div class="line">String str2=str;</div><div class="line">String str3=new String("abc");</div><div class="line">String str4=new String("abc");</div><div class="line">String str5=str3;</div><div class="line">static String str6="abc";</div><div class="line">static String str7=new String("abc");</div></pre></td></tr></table></figure>
<p>对应的测试内存地址是否相等</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   System.out.println(str==str1);</div><div class="line">System.out.println(str==str2);</div><div class="line">System.out.println(str1==str2);</div></pre></td></tr></table></figure>
<p>测试结果 true true true<br>说明String 是引用类型，而且上面方法产生的变量都只在栈中并且都是同一个地址</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   System.out.println(str==str3);</div><div class="line">System.out.println(str3==str4);</div></pre></td></tr></table></figure>
<p>测试结果：false false<br>说明：new 之后的对象地址存放在堆中，同时堆中每个new之后的对象地址都是不一样的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   System.out.println(str==str6);</div><div class="line">System.out.println(str3==str6);</div><div class="line">System.out.println(str6==str7);</div><div class="line">System.out.println(str3==str7);</div></pre></td></tr></table></figure>
<p>测试结果：true false false false<br>说明：String类型的静态变量存放在栈中，而new之后的静态变量存放在堆中</p>
<p>关于内存分配，比较复杂，这里只简单验证其中一些，其他可以自己设计案例模拟</p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>顾名思义就是指唯一的对象实例<br>具体点说就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例只存在一个，<br>通常其结构如下所示。<br><img src="/images/imgs2/2.gif" alt="Alt text"><br>入门案例：首先是单例类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pojo;</div><div class="line"></div><div class="line">public class Singleton &#123;</div><div class="line"> private static Singleton singleton=new Singleton();</div><div class="line"> </div><div class="line"> private Singleton()&#123;&#125;</div><div class="line"></div><div class="line"> public static Singleton getInstance()</div><div class="line"> &#123;</div><div class="line">	 return singleton;</div><div class="line"> &#125;&#125;</div></pre></td></tr></table></figure>
<p>测试用junit4进行测试</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test1()&#123;</div><div class="line">	System.out.println("start test..");</div><div class="line">	Singleton obj1=Singleton.getInstance();</div><div class="line">	Singleton obj2=Singleton.getInstance();</div><div class="line">	System.out.println(obj1==obj2);</div><div class="line">	System.out.println("end test..");</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果：start test.. true end test..<br>说明，obj1与obj2是同一个实例，间接说明了单例的特性</p>
<p>至此我们对单例有了一个初步的形式上的认识了，那么它的特点是什么了？主要为三点<br>一：单例类确保自己只有一个实例（构造函数私有：不被外部实例化，也不被继承）<br>二：单例类必须自己创建自己的实例<br>三：单例类必须为其他对象提供唯一的实例</p>
<p>说到单例就必然涉及到多线程，不多说，先模拟一个多线程来说明单例中存在的并发问题。<br>友情提醒一下，上面用的是饿汉式创建单例，就一开始就创建了一个实例，显然浪费内存，接下来将用懒汉式创建单例<br>主体类代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static Singleton singleton;</div><div class="line">	</div><div class="line">	 private Singleton()&#123; &#125;</div><div class="line">	 </div><div class="line">	 public static Singleton getInstance()</div><div class="line">	 &#123;</div><div class="line">		 if(singleton==null)&#123;</div><div class="line">			 singleton=new Singleton();</div><div class="line">		 &#125;</div><div class="line">		 return singleton;</div><div class="line">	 &#125;</div></pre></td></tr></table></figure>
<p>下面将用三个线程模拟，两个线程调用单例类，第三个线程启动前两个线程，测试用junit</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class thread1 implements Runnable&#123;</div><div class="line">	Singleton singleton;</div><div class="line">	public Singleton getSingleton() &#123;</div><div class="line">		return singleton;</div><div class="line">	&#125;</div><div class="line">	public void setSingleton(Singleton singleton) &#123;</div><div class="line">		this.singleton = singleton;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		singleton=Singleton.getInstance();	&#125;&#125;</div><div class="line">		</div><div class="line">public class Thread2 implements Runnable&#123;</div><div class="line">	Singleton singleton;</div><div class="line">	public Singleton getSingleton() &#123;</div><div class="line">		return singleton;	&#125;</div><div class="line">		</div><div class="line">	public void setSingleton(Singleton singleton) &#123;</div><div class="line">		this.singleton = singleton;	&#125;</div><div class="line">		</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		 singleton=Singleton.getInstance();</div><div class="line">			&#125;&#125;</div></pre></td></tr></table></figure>
<p>简单说明一下，这两个线程目的是调用单例类（注意如果是单例，决不允许出现不同实例）<br>先贴出测试类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   thread3 t=new thread3();</div><div class="line">Thread tt=new Thread(t);</div><div class="line">tt.start();</div></pre></td></tr></table></figure>
<p>这里我们通过控制第三个线程来构造并发，(这里采用数学中的极限思想)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class thread3 implements Runnable&#123;</div><div class="line">	thread1 t1=new thread1();</div><div class="line">	Thread2 t2=new Thread2();</div><div class="line">	Thread t=new Thread(t1);</div><div class="line">	Thread t3=new Thread(t2);</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">	long start=System.currentTimeMillis();</div><div class="line">		t.start();</div><div class="line">		t3.start();</div><div class="line">		long end=System.currentTimeMillis();</div><div class="line">		System.out.println(end-start);   //并发的时间间隔</div><div class="line">		System.out.println(t1.getSingleton());</div><div class="line">		System.out.println(t2.getSingleton());</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试结果：0 null null<br>多次运行，又出现另一种结果：6<br>com.zwl.pojo.Singleton@8fdcd1<br>null和其他不同步结果<br>说明在很短的时间间隔类，一个居然已经有了实例，而另一个居然是空，显然不是单例，想想倘若在此时去操作该单例，可能就会是静态类发生变化，也就是并发问题了。</p>
<p>很自然。那么怎么去解决了，一种很通用的方法就是加锁实现同步</p>
<h3 id="双锁机制"><a href="#双锁机制" class="headerlink" title="双锁机制"></a>双锁机制</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static Singleton getInstance()</div><div class="line"> &#123;</div><div class="line">	 if(singleton==null)</div><div class="line">	 &#123;</div><div class="line">		 synchronized(Singleton.class)</div><div class="line">		 &#123;</div><div class="line">	 if(singleton==null)&#123;</div><div class="line">		 singleton=new Singleton();</div><div class="line">	 &#125;</div><div class="line">		 &#125;</div><div class="line">	 &#125;</div><div class="line">	 return singleton;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Synchronized关键字，声明使该线程在某处同步，也就是一个线程先占用，另一个线程被阻塞，显然如果不为空，就直接返回对象，对应第二个线程也就不执行if语句了，达到单例效果，可以想象如果为计数变量，同样可以通过二次加锁实现同步<br>  但是实际还是出现不同步，原因是jvm的一个bug，它允许无序写入线程，导致不同步，当然我们可以通过申明volatile关键字。<br> 为什么就可以解决双重解锁的bug了？<br>原因是volatile保证原子性，顺序性，即在双重加锁前保证多线程实现顺序性，举个例子吧，现在有两个线程t1和t2，分别执行b，c操作，如果乱序写入，可能出现t1正在操作b还没完成，t2操作c，致使单例失败，所以需要保证顺序性。<br>经过不断的测试，发现完全同步，只不过时间间隔为0，和null，null，至少是同步了~</p>
<p><strong>接下来简单比较一下饿汉式和懒汉式的区别</strong><br>从速度和反应时间上，饿汉式加载好，从资源利用率上懒汉式好，<br>饿汉式很明显不会出现多线程并发问题，所以是线程安全的，而懒汉式则是非线程安全的</p>
<p>关于单例模式的应用，笔者在当初学习过程中，遇到很多，学习总是一个不断压缩与重新认识的过程，像sql工具类，hibernate的懒加载，mybatis及 spring中的一些配置等等，往往把握不好，就会出现错误，这里只列举一些工具类，因为它是笔者接触的第一个单例应用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Private static Connection connection;</div><div class="line">Private sqlhelper()&#123;&#125;；</div><div class="line">	public static Connection mysqlconn() throws Exception &#123;</div><div class="line">		try &#123;</div><div class="line">			// 加载驱动</div><div class="line">			Class.forName("com.mysql.jdbc.Driver");</div><div class="line">			// 连接数据库</div><div class="line">			 connection = DriverManager.getConnection(</div><div class="line">					"jdbc:mysql://localhost:3306/software", "root", "");</div><div class="line">			System.out.println("获得数据库");</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; </div><div class="line">		return connection;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[window分区导致双系统无引导界面]]></title>
      <url>http://www.myzwl.win/2017/02/22/fenqu/</url>
      <content type="html"><![CDATA[<p><strong>先简单介绍一下情境，笔者电脑上装的是双系统，而且bios上设置了system password（当然，已经忘记了是多少了），然后心血来潮在阿里云买了一个学生优惠的服务器，安装了mysql+tomcat7+jdk，在电脑上d盘已经装了linux，在c盘上分了一个分区，那么问题来了，当再次打开电脑时，无引导界面，取而代之的是</strong></p>
<p><img src="/images/z4.gif" alt="Alt text"><br>然后google了许多解决方案，当然是在彩果许多坑之后找到了适合自己的解决方案，毕竟一个问题的解决总不是一帆风顺的。<br>  <em>进入正题</em><br>  <strong>如果我们要重装系统，肯定得用到bios设置，那么问题来了，如果你设置了密码，并且密码忘记了，那怎么办?</strong><br>  一种办法是通过硬件，通过把电池正负极按照网上说的折腾一下，就可以恢复bios出厂设置，显然这种方法有极大风险，可能会损坏硬件（具体参考google）或者用相关修复工具，但是笔者的电脑都无引导界面，尴尬了~<br>  还有一种办法就是在你输入3次错误的密码时会出现如下错误代码</p>
<p> <img src="/images/z1.gif" alt="Alt text"><br> 然后就是<a href="https://bios.pw.org" target="_blank" rel="external">在这里面设置</a>，如下图，输入上述的错误代码，就出现了bios密码，</p>
<p> <img src="/images/z2.gif" alt="Alt text"></p>
<p> <strong>当然，笔者电脑里有许多宝贵的数据，不可能也不愿意重装系统，经过google一番，发现是分区导致引导盘不能引导，只需要找到该分区，在llinux上重新修复就行了</strong></p>
<blockquote>
<p>首先在页面中输入如下ls<br>grub rescue&gt; ls<br>出现如下（基本都差不多）<br>hd0，（hd0，nsdoc9），（hd0，nsdoc8），（hd0，nsdoc7），（hd0<br>，nsdoc6），（hd0，nsdoc5），（hd0，nsdoc2），（hd0，nsdoc1）</p>
</blockquote>
<p>然后通过ls 如上的分区循环一遍，如ls （hd0，nsdoc9）/<br>上述有一个会出现详细信息，他就是安装linux那个分区，其余都是unknown filesystem，当然如果出现bad filesystem那是你没加/<br>如下图：</p>
<p><img src="/images/z3.gif" alt="Alt text"></p>
<p><strong>接下来设置root引导盘</strong></p>
<blockquote>
<p>set root=(hd0，nsdoc6）<br>这里设置的是上述找到分区的那个盘<br>set prefix=(hd0，nsdoc6）/boot/grub/</p>
</blockquote>
<p>然后可以用set验证一下</p>
<blockquote>
<p>set<br>会出现上述设置的信息</p>
</blockquote>
<p>最后执行下述命令</p>
<blockquote>
<p>insmod normal<br>在输入normal，就会自动跳转到引导界面，我们选择ubuntu进入，在里面进行修复即可</p>
</blockquote>
<p>进入linux系统打开终端，先更新grub，即输入</p>
<blockquote>
<p>sudo update-grub</p>
</blockquote>
<p>ok后在输入</p>
<blockquote>
<p>sudo grub-install /dev/sda<br>结束后，我们就可以重启电脑，一切都ok了。<br>进入电脑后笔者做的第一件事就是备份数据，毕竟要给自己留条后路，如果遇到更复杂的情况就后悔莫及了。。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 踩坑 , window </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里云服务器上搭建javaweb站点]]></title>
      <url>http://www.myzwl.win/2017/02/21/dajianserver/</url>
      <content type="html"><![CDATA[<p><strong>事实上笔者在去年8月份的时候就已经在自己电脑上通过nat123搭建了一台服务器，即p2p，自己的电脑作为服务器，但是这很不安全，而且每次别人通过外网访问，电脑必须打开而且开着服务器，由于是免费的，导致别人访问网速跟不上等等，最近阿里云有学生9.9元购买服务器，所以笔者买了一个，也很有兴趣将笔者之前写的两个网站部署上，结果很美好，但过程很坑，所以就需要总结来提高自己</strong><br><em>进入正题</em><br>笔者也是google了许多例子和前人的经验找到适合自己的方法</p>
<p><strong>首先需要租一台云服务器，我选择了阿里云</strong><br><img src="/images/imgs1/1.gif" alt="Alt text"></p>
<p>注意这里操作系统有四个选项，笔者发现只有第四个符合自己（貌似是自定义），然后按照步骤，其中有些需要注意<br><img src="/images/imgs1/1.gif" alt="Alt text"></p>
<p>安全组，这里暂时可以选择默认的第一个，因为后面如果在搭建web时需要一些端口（如mysql默认3306端口改掉，tomcat8080端口换成80等等），到时可以在后台操作）</p>
<p><img src="/images/imgs1/3.gif" alt="Alt text"><br>关于镜像选择，因为笔者是window7，而且还是32位的，相对64位只能有不大于4g的内存，</p>
<p><img src="/images/imgs1/4.gif" alt="Alt text"><br>这里的密码就是之后在本地机子上远程登录这个服务器所要的密码</p>
<p>ok至此，成功租了一台服务器，这时你会收到一条短信，里面有你这台服务器的公网地址</p>
<p><strong>然后笔者就开始着手在本机上登录该服务器，当然是为了搭建javaweb准备的</strong></p>
<ol>
<li><p>在本机上准备javaweb需要的环境<br><img src="/images/imgs1/5.gif" alt="Alt text"></p>
</li>
<li><p>在本机上新建一个分区用来放上述软件供服务器远程使用（其实也可以不用分区，直接复制也行，毕竟笔者被分区坑了，导致后来的双系统引导界面消失）</p>
</li>
<li><p>本机上登录远程连接可以用运行-mstsc-直接进入到如下界面<br><img src="/images/imgs1/6.gif" alt="Alt text"><br>其中计算机就是你的公网地址，如果你是新建了一个分区，那么就点选项在本地资源的详细信息中就新建的那个分区勾上，笔者这里是x盘（如果没有的话就直接连接）<br><img src="/images/imgs1/7.gif" alt="Alt text"></p>
</li>
<li><p>后面什么证书，安全啊先不管了，应该是进入远程服务器了<br><img src="/images/imgs1/8.gif" alt="Alt text"></p>
</li>
<li><p>接下来就是将mysql，jdk等复制到c盘中，因为只有一个盘，后续就是安装配置了</p>
</li>
<li>安装jdk，笔者的是jdk1.6（注意jdk版本不同，后续运行高版本会出像版本错误，笔者已吃过亏），配置环境变量</li>
<li>安装tomcat，配置tomcat环境变量，注意上述不需要自定义文件夹，因为只有一个c盘，tomcat默认端口是8080</li>
<li>安装mysql，这里面需要注意的是里面有端口设置，可以选择默认的3306或者自定义，然后就是用户与密码设置</li>
<li>可以使用可视化数据库工具，这里笔者使用了navicat<br><strong>至此算是搭建了一个简单web环境，可以先测试一下</strong><br>拷贝一个已经被编译过的web项目，启动tomcat与mysql，然后利用localhost:8080/项目名访问，如果出现界面就表示以上配置成功</li>
</ol>
<p><strong>接下来需要买一个域名</strong><br><img src="/images/imgs1/9.gif" alt="Alt text"></p>
<ol>
<li>成功后点击解析，在里面找到新手设置，点进去<br><img src="/images/imgs1/10.gif" alt="Alt text"><br>点击设置网站解析，然后输入公网，即可。</li>
<li>在远程服务器中，找到tomcat下conf下的server.xml文件，如果我们不想要8080端口并且输入域名时不想要端口的话，就先把8080端口改成80</li>
</ol>
<blockquote>
<p> Connector port=”80” protocol=”HTTP/1.1”<br>               connectionTimeout=”20000”<br>               redirectPort=”8443” /&gt;</p>
</blockquote>
<p> 3.然后找到host</p>
<blockquote>
<p>  Host name=”你刚刚解析的域名”  appBase=”webapp”<br>            unpackWARs=”true” autoDeploy=”true”&gt;</p>
<p>&lt;Context path=”” docBase=”/项目名” debug=”0” reloadable=”true” </p>
</blockquote>
<p>注意这里appBase是放项目的站点，context内的docBase是你的项目名，目前我们只是一个tomcat运行一个域名执行一个项目<br>然后打开C:\Windows\System32\drivers\etc下的host文件<br>增加如下设置</p>
<blockquote>
<p>127.0.0.1       localhost<br>  ::1             localhost<br>192.168.1.11    刚刚的域名</p>
</blockquote>
<p>保存，然后重启服务器，可能会发现会遇到一些问题，如80端口被占用，80端口未开放等等，假设未被占有（如果占用，google上有解决方法），<br>如果未开放，这里我们就需要在云服务器上进行端口开放设置</p>
<p><strong>进入我们购买的云服务器，点击安全组，选中一个实例，点击配置，选择公网入方向，按照步骤开放想要的端口</strong><br> <img src="/images/imgs1/10.gif" alt="Alt text"></p>
<p> 至此只要输入域名就可以访问了。</p>
<p> 当然，如果我们想要一个tomcat上配置多个域名，每个域名运行各自不同的项目，那如何做了，经过踩坑后，大概如下步骤</p>
<ol>
<li>可以选择在tomcat下新建一个站点，类似于原来的webapp，然后在server.xml中进行配置一个新host</li>
</ol>
<blockquote>
<p>  Host name=”第二个域名”  appBase=”新创建的站点”<br>            unpackWARs=”true” autoDeploy=”true”&gt;</p>
<p>&lt;Context path=”” docBase=”/第二个项目名” debug=”0” reloadable=”true”</p>
</blockquote>
<p>2.然后在hosts文件汇总加入第二个域名</p>
<blockquote>
<p>127.0.0.1       localhost<br>  ::1             localhost<br>192.168.1.11    刚刚的域名<br>192.168.1.11    第二个域名</p>
</blockquote>
<p>最后重启服务器。<br>笔者在这里遇到了一个很奇怪的坑，同一服务器下的项目出现奇怪的jar包冲突，只要删掉xerces包就行了（当然是在远程服务器上才产生冲突的）</p>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 踩坑 , window </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初步搭建hexo博客]]></title>
      <url>http://www.myzwl.win/2017/02/20/hexo1/</url>
      <content type="html"><![CDATA[<p>博客是一种能够更好提高自己的途径，关于利用hexo搭建博客，笔者是一路google一路踩坑，才完成的，当然关于这方面的搭建，实在太多了，笔者也只是稍微总结一下</p>
<ol>
<li>首先在github上注册一个账号</li>
<li>创建代码库（repository），一般以yourname/youname.github.io</li>
<li>setting中选择主题</li>
<li>购买一个域名（这里以笔者在阿里云买的为例）</li>
<li>点击域名里的解析<br><img src="/images/imgs1/12.gif" alt="Alt text"><br>注意CNAME为你的仓库名，其他套用<br>6.回到setting中在Custom domain下填写你刚才的域名，然后在code中会出现一个CNAME文件<br>7.yourname.gthub.io访问你的博客，目前应该只是一个默认主页</li>
</ol>
<p><strong>接下来就是本地安装hexo与github page联系起来</strong><br> 1.官网安装node.js（注意是32位还是64位）<br> 2安装git（在过程中会有一项自带环境变量设置，选中，不然后面无法识别git）<br> 3安装hexo（以笔者的在e:/blog下为例）<br> 在git bush中</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-cli -g</div></pre></td></tr></table></figure>
<p>然后在输入</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo --save</div></pre></td></tr></table></figure>
<p>然后利用</p>
<blockquote>
<p>hexo -v</p>
</blockquote>
<p>验证安装是否成功</p>
<p> 4.然后在要创建的目录下初始化hexo</p>
<blockquote>
<p>hexo init</p>
</blockquote>
<p>5安装所需的组件和依赖组件<br>  npm install</p>
<p>笔者当时一下子全部安装了很多扩展组件如:</p>
<blockquote>
<p>npm install hexo-deployer-git –save</p>
</blockquote>
<p>在看看目录下应该产生如下目录<br><img src="/images/imgs1/13.gif" alt="Alt text"></p>
<p>6 生成静态文件</p>
<blockquote>
<p>hexo g</p>
</blockquote>
<p>7 启动服务器，进行本地预览访问</p>
<blockquote>
<p>hexo s</p>
</blockquote>
<p>然后在浏览器中打开<a href="http://localhost:4000/，会出现一个默认的hexo主页" target="_blank" rel="external">http://localhost:4000/，会出现一个默认的hexo主页</a></p>
<p>8 Hexo与github page 联系<br>首先是配置Git个人信息</p>
<blockquote>
<p>git config –global user.name “用户名”<br>git config –global user.email “邮箱地址”</p>
</blockquote>
<p>9 生成密钥</p>
<blockquote>
<p>sh-keygen -t rsa -C “邮箱地址”</p>
</blockquote>
<p>这里笔者遇到一个坑，默认是在administrator目录下生成一个.ssh文件夹里面包含<br><img src="/images/imgs1/14.gif" alt="Alt text"><br>结果没有，所以自己在该目录下创建一个.ssh文件夹</p>
<p>10 配置Deployment（以笔者的为例）</p>
<blockquote>
<p>deploy:<br>  type: git<br>repository: <a href="http://github.com/slycmiaoxi/slycmiaoxi.github.io.git" target="_blank" rel="external">http://github.com/slycmiaoxi/slycmiaoxi.github.io.git</a><br>branch: master</p>
</blockquote>
<p>这里的repository是git上对应的use ssh进行clone的</p>
<p>11 登录到git的use ssh将.ssh文件下的id_rsa.pub里的内容复制到改里面</p>
<p>12 写文章上传</p>
<blockquote>
<p>hexo new post “article title” 新建一个文章，默认放再_post下<br>  hexo clean 清空public里的文件，该文件夹是上传到git上<br>  hexo g 生成到public文件夹中<br>  hexo d 部署，此过程要输入用户名和密码，</p>
</blockquote>
<p>  笔者在hexo d过程中曾出现一致无权限，后来在google老师的指引下需要设置用户名和密码，在.ssh文件下生成known_hosts文件，如果没有遇到，那是比较幸运了<br>  目前还是默认的主题，显然不好看，其次编写文章需要markdown语言，笔者使用的是小书匠，因为其组件丰富，操作简单</p>
<p> 13 更换主题<br> 首先需要cd到你的hexo根目录，然后</p>
<blockquote>
<p>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> themes/next</p>
</blockquote>
<p> 我选择的是next主题，因为其功能，配置方面相对较强大，当然在主题配置方面一路是坑，这里推荐去next官网看配置，大部分都涉及到<br> 如果我们启用next主题，只要在_config.yml（站配置文件中）找到theme，将默认的改成next即可，<br> 另一方面，在theme文件夹下的next文件夹下的_config.yml(主题配置文件）进行主题的配置，当然里面其他文件也是可以配置的，当然google是最好的帮手<br> 最后主题也配置好了，只需要输入yourname.github.io就可以访问你的博客了<br> 当然笔者是一路踩坑过来，很多google也不一定适合自己，只有自己探索过的才是最适合自己的。<br> 最后需要说一下，多说老是注册异常，后来干脆选择友言代替，总之theme里面有很多需要探索的，google是最好的老师</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
