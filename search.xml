<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F08%2F27%2Foffer_23%2F</url>
      <content type="text"><![CDATA[title: 输出字符串的全排列date: 2017-05-03 14:48:51tags: 剑指offer categories: 剑指offer问题描述输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如：输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab,cba 思路分析回想字符串的模式匹配思想，我们可以将该字符串分成两部分，一部分是第一个字符串，第二部分是剩余的字符，然后保持第一个字符不变，从剩余字符遍历，同时交换遍历的位置，很显然这是一个递归的过程，最后在回溯，交换第一个字符和剩余字符的位置，依次类推 码上有戏12345678910111213141516171819202122232425262728293031323334353637383940414243public class StringSort &#123; public ArrayList&lt;String&gt; permitution(String str)&#123; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); if(str==null||str.length()&lt;0) return list; list=permitution(list,str.toCharArray(),0,str.length()); Collections.sort(list); return list; &#125; private ArrayList&lt;String&gt; permitution(ArrayList&lt;String&gt; list,char[] str,int begin,int length) &#123; if(begin==length-1) &#123; if(!list.contains(str)) list.add(String.valueOf(str)); &#125; else&#123; for(int i=begin;i&lt;length;i++)&#123; if(i==begin||str[i]!=str[begin])&#123; swap(str,begin,i); permitution(list,str,begin+1,length); swap(str,begin,i); &#125; &#125; &#125; return list; &#125; public void swap(char[] str,int begin,int i)&#123; char temp=str[i]; str[i]=str[begin]; str[begin]=temp; &#125; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list=new StringSort().permitution("abcc"); for(String s:list)&#123; System.out.print(s+" "); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F08%2F26%2Foffer_22%2F</url>
      <content type="text"><![CDATA[title: 序列化二叉树date: 2017-05-02 14:48:51tags: 剑指offer categories: 剑指offer问题描述请实现两个函数，分别用来序列化和反序列化二叉树。其中序列化的意思返回一个带有逗号和特殊符号的字符串，而反序列化就是根据带有特殊符号和逗号的字符串返回一个二叉树 思路分析对应序列化二叉树来说，因为每次都是将根结点序列化，所以可用前序遍历，即如果结点有孩子，先保存结点值，在继续，当遇到孩子为空时，就用特殊符号输出代替反序列化，同样用递归实现，即先利用一个索引，用于取出每次遍历的字符串中的值，同时把字符串变成一个字符数组，然后比较是否是特殊符号，如果是特殊符号，不做处理，反之，变成根结点的孩子 码上有戏123456789101112131415161718192021222324252627282930313233343536373839404142434445static class TreeNode&#123; int data; TreeNode left; TreeNode right; public TreeNode(int data)&#123; this.data=data; &#125; &#125; public String serialize(TreeNode root)&#123; StringBuilder sb=new StringBuilder(); if(root==null) &#123; sb.append("$"+","); return sb.toString(); &#125; sb.append(root.data+","); sb.append(serialize(root.left)); sb.append(serialize(root.right)); return sb.toString(); &#125; int n=-1; public TreeNode deSerialize(String str)&#123; n++; if(n&gt;=str.length()) return null; TreeNode node=null; String[] s=str.split(","); if(!s[n].equals("$"))&#123; node=new TreeNode(Integer.parseInt(s[n])); node.left=deSerialize(str); node.right=deSerialize(str); &#125; return node; &#125; void preTraver(TreeNode root)&#123; if(root!=null)&#123; System.out.print(root.data+" "); preTraver(root.left); preTraver(root.right); &#125; &#125; 测试： TreeNode root=new TreeNode(10); TreeNode a=new TreeNode(6); TreeNode b=new TreeNode(14); TreeNode c=new TreeNode(4); TreeNode d=new TreeNode(8); TreeNode e=new TreeNode(12); TreeNode f=new TreeNode(16); root.left=a; root.right=b; a.left=c; a.right=d; b.left=e; b.right=f; String s=new ConvertTreeToDLinkList().serialize(root); System.out.println(s); TreeNode head=new ConvertTreeToDLinkList().deSerialize(s); System.out.println(); new ConvertTreeToDLinkList().preTraver(head); 测试结果 10,6,4,$,$,8,$,$,14,12,$,$,16,$,$,10 6 4 8 14 12 16]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F08%2F25%2Foffer_21%2F</url>
      <content type="text"><![CDATA[title: 二叉搜索树与双向链表date: 2017-05-01 14:48:51tags: 剑指offer categories: 剑指offer问题描述输入一颗二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向 思路分析由于是二叉排序树，其左子树结点值小于根结点，右子树大于根节点，可以利用中序遍历，即先左孩子递归，找到树中最小的节点，然后作为头结点，然后遍历到该左子树最后一个结点，在其后继追加根结点，同样，遍历右子树，得到右子树中的第一个结点，然后将根结点追加到其前继结点即可 码上有戏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ConvertTreeToDLinkList &#123; static class TreeNode&#123; int data; TreeNode left; TreeNode right; public TreeNode(int data)&#123; this.data=data; &#125; &#125; public TreeNode Convert(TreeNode root)&#123; if(root==null) return null; if(root.left==null&amp;&amp;root.right==null) return root; TreeNode LastOfLeftTreeNode=Convert(root.left); TreeNode p=LastOfLeftTreeNode; //定位到左子树的最后一个结点 while(p!=null&amp;&amp;p.right!=null)&#123; p=p.right; &#125; //将根结点追加到左子树最后一个结点 if(LastOfLeftTreeNode!=null)&#123; p.right=root; root.left=p; &#125; TreeNode LastOfRightTreeNode=Convert(root.right); if(LastOfRightTreeNode!=null)&#123; LastOfRightTreeNode.left=root; root.right=LastOfRightTreeNode; &#125; if(LastOfLeftTreeNode!=null) return LastOfLeftTreeNode; return root; &#125; public static void main(String[] args) &#123; TreeNode root=new TreeNode(10); TreeNode a=new TreeNode(6); TreeNode b=new TreeNode(14); TreeNode c=new TreeNode(4); TreeNode d=new TreeNode(8); TreeNode e=new TreeNode(12); TreeNode f=new TreeNode(16); root.left=a; root.right=b; a.left=c; a.right=d; b.left=e; b.right=f; TreeNode node=new ConvertTreeToDLinkList().Convert(root); while(node!=null)&#123; System.out.println(node.data); node=node.right; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F08%2F24%2Foffer_20%2F</url>
      <content type="text"><![CDATA[title: 复杂链表的复制date: 2017-04-30 14:48:51tags: 剑指offer categories: 剑指offer问题描述输入一个复杂链表（每个节点中有结点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点） 思路分析很自然的第一个想法就是采取分治法，首先复制原来链表的结点，把每个复制的结点都链在原结点后面，接下来，设置复制节点的特殊指针，并且如果原来节点指向特殊指针N，则原结点复制后的结点指向N的复制指针，最后，需要抽取出复制的结点，由于原结点与复制节点都是间隔的，所以可间接处理 码上有戏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class CopyCompLicateLinkedList &#123; static class RandomListNode&#123; int label; RandomListNode next=null; RandomListNode random=null; RandomListNode(int label)&#123; this.label=label; &#125; &#125; //复制链表结点 private void CloneNodes(RandomListNode pHead)&#123; RandomListNode node=pHead; while(pHead!=null) &#123; RandomListNode cloneNode=new RandomListNode(node.label); cloneNode.next=node.next; cloneNode.random=null; cloneNode.random=null; node.next=cloneNode; node=cloneNode.next; &#125; &#125; //设置每个节点的随机指针 private void ConnectSibLingNodes(RandomListNode pHead)&#123; RandomListNode node=pHead; while(node!=null) &#123; RandomListNode clone=node.next; if(node.random!=null) &#123; clone.random=node.random.next; &#125; node=clone.next; &#125; &#125; //组合复制的结点 private RandomListNode ConnectFinalListNodes(RandomListNode pHead)&#123; RandomListNode node=null; RandomListNode cloneHead=null; RandomListNode cloneNode=null; if(node!=null)&#123; cloneHead=node.next; cloneNode=node.next; node.next=cloneNode.next; node=node.next; &#125; while(node!=null)&#123; cloneNode.next=node.next; cloneNode=cloneNode.next; node.next=cloneNode.next; node=node.next; &#125; return cloneHead; &#125; public RandomListNode Clone(RandomListNode pHead)&#123; this.CloneNodes(pHead); this.ConnectSibLingNodes(pHead); return this.ConnectFinalListNodes(pHead); &#125;]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F08%2F23%2Foffer_19%2F</url>
      <content type="text"><![CDATA[title: 二叉树中和为某一值的所有路径date: 2017-04-29 14:48:51tags: 剑指offer categories: 剑指offer问题描述输入一颗二叉树和一个整数，打印出二叉树中结点值的和为整数的所有路径。路径定义为从树的根结点开始往下一直到叶子结点所经过的结点形成一条路径 思路分析从问题描述知道，前序遍历符合从根结点遍历，所有可用此方法遍历，同时可以设置两个集合，一个用来保存每次遍历的结点，一个用来记录每次访问过的结点路径，如果等于和的话，就将结点路径加入，如果不等于，则看是否有左右孩子，在递归遍历，最后如果，返回上层，每一次都要删掉保存的结点 码上有戏1234567891011121314151617181920212223242526272829303132333435363738394041424344public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode root,int target)&#123; int currentSum=0; ArrayList&lt;Integer&gt; nodes=new ArrayList&lt;Integer&gt;(); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathNodes=new ArrayList&lt;&gt;(); if(root==null) return pathNodes; return findPath(pathNodes,nodes,root,target,currentSum); &#125; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathNodes, ArrayList&lt;Integer&gt; nodes, TreeNode root, int target, int currentSum) &#123; currentSum+=root.data; nodes.add(currentSum); boolean isLeafNode=(root.left==null)&amp;&amp;(root.right==null); if(target==currentSum&amp;&amp;isLeafNode)&#123; ArrayList&lt;Integer&gt; path=new ArrayList&lt;Integer&gt;(); for(Integer val:nodes) &#123; path.add(val); &#125; pathNodes.add(path); &#125; if(root.left!=null)&#123; this.findPath(pathNodes, nodes, root.left, target, currentSum); &#125; if(root.right!=null)&#123; this.findPath(pathNodes, nodes, root.right, target, currentSum); &#125; Integer value=nodes.remove(pathNodes.size()-1); currentSum-=value; return pathNodes; &#125;&#125; class TreeNode&#123; int data; TreeNode left; TreeNode right; TreeNode(int data)&#123; this.data=data; &#125;&#125; 测试： TreeNode a=new TreeNode(10); TreeNode b=new TreeNode(5); TreeNode c=new TreeNode(12); TreeNode d=new TreeNode(4); TreeNode e=new TreeNode(7); a.left=b; a.right=c; b.left=d; b.right=e; ArrayList]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F08%2F22%2Foffer_18%2F</url>
      <content type="text"><![CDATA[title: 二叉树的后续遍历序列date: 2017-04-28 14:48:51tags: 剑指offer categories: 剑指offer问题描述输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历的结果。如果是，则输出true，否则返回false 思路分析如{5,7,6,9,11,10,8}，根据二叉排序树的后续遍历特点，首先知道最后一个数是根结点，然后让前面的数与它比较，当到某一个数大于他时，那门这个数的前面就是左子树，右边就是右子树，比如{5,7,6}为左子树，{9,11,10}为右子树，接着判断如果右子树中有存在某个数小于根结点8，也就是返回false，如果不是，在将左子树和右子树依次递归 码上有戏1234567891011121314151617181920212223242526272829303132333435363738394041public class BinaryOfOut &#123; public boolean IsBianry(int[] ids)&#123; if(ids.length&lt;0) return false; int root=ids[ids.length-1]; int i=0; for(;i&lt;ids.length-1;i++) &#123; if(ids[i]&gt;root) break; &#125; int[] leftTree=new int[i]; System.arraycopy(ids, 0, leftTree, 0,i); int j=i; for(;j&lt;ids.length-1;j++) &#123; if(root&gt;ids[j]) return false; &#125; int[] rightTree=new int[ids.length-1-i]; System.arraycopy(ids, i, rightTree, 0,ids.length-1-i); boolean leftFlag=true; if(i&gt;0)&#123; leftFlag=IsBianry(leftTree); &#125; boolean rightFlag=true; if(i&lt;ids.length-1)&#123; rightFlag=IsBianry(rightTree); &#125; return leftFlag&amp;&amp;rightFlag; &#125; public static void main(String[] args) &#123; System.out.println(new BinaryOfOut().IsBianry(new int[]&#123;5,7,6,9,11,10,8&#125;)); System.out.println(new BinaryOfOut().IsBianry(new int[]&#123;7,4,6,5&#125;)); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F08%2F21%2Foffer_17%2F</url>
      <content type="text"><![CDATA[title: 包含min函数的栈date: 2017-04-27 14:48:51tags: 剑指offer categories: 剑指offer问题描述定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。调用min、push、pop的时间复杂度都是O(1) 思路分析可以构造一个辅助栈，该栈里只放每次的最小栈顶元素集合，比如刚开始往栈里放3,4；则辅助栈里存放的是3,3；即每次比较新加的元素和原辅助栈栈顶最小元素的大小 码上有戏1234567891011121314151617181920212223242526272829303132333435363738394041public class StackWithMin &#123; Stack&lt;Integer&gt; m_data=new Stack&lt;&gt;(); Stack&lt;Integer&gt; m_min=new Stack&lt;&gt;(); public void push(Integer value)&#123; m_data.push(value); if(m_min.size()==0||value&lt;m_min.peek()) m_min.push(value); else&#123; m_min.push(m_min.peek()); &#125; &#125; public void pop()&#123; if(m_data.size()&gt;0&amp;&amp;m_min.size()&gt;0) &#123; m_data.pop(); m_min.pop(); &#125; &#125; public Integer min()&#123; if(m_data.size()&gt;0&amp;&amp;m_min.size()&gt;0) return m_min.peek(); return null; &#125; public static void main(String[] args) &#123; StackWithMin sta=new StackWithMin(); sta.push(3); sta.push(4); sta.push(2); System.out.println(sta.min()); sta.pop(); System.out.println(sta.min()); &#125;&#125; 输出结果 2,3]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F08%2F21%2Foffer_16%2F</url>
      <content type="text"><![CDATA[title: 从上到下打印二叉树date: 2017-04-26 14:48:51tags: 剑指offer categories: 剑指offer问题描述不分行的从上到下打印二叉树的每个节点，同一层的结点按照从左到右的顺序打印 思路分析其实也就是树的层次遍历，而层次遍历的通法就是构造一个队列或者其他容器集合，按照从上到下依次加进结点，每次删除一个结点，就把它的左右孩子结点加入队列，依次类推，这里使用list模拟层序遍历 码上有戏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class TreeNode&#123; int data; TreeNode left; TreeNode right; TreeNode(int data)&#123; this.data=data; &#125;&#125;public List&lt;Integer&gt; printFromToptoButtom(TreeNode root)&#123; List&lt;TreeNode&gt; node=new ArrayList&lt;TreeNode&gt;(); List&lt;Integer&gt; treeDate=new ArrayList&lt;Integer&gt;(); int index=1; if(root==null) return null; node.add(root); while(node.size()&gt;0)&#123; TreeNode front=node.remove(0); index--; treeDate.add(front.data); if(front.left!=null) &#123; node.add(index++,front.left); &#125; if(front.right!=null)&#123; node.add(index++,front.right); &#125; &#125; return treeDate; &#125; public static void main(String[] args) &#123; TreeNode a=new TreeNode(1); TreeNode b=new TreeNode(2); TreeNode c=new TreeNode(3); TreeNode d=new TreeNode(4); TreeNode e=new TreeNode(5); a.left=b; a.right=c; b.left=e; b.right=null; c.right=d; c.left=null; d.left=null; d.right=null; e.left=null; e.right=null; List&lt;Integer&gt; data= new ConstructBinaryTree().printFromToptoButtom(a); for(Integer h:data)&#123; System.out.print(h+" "); &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F08%2F18%2Foffer_15%2F</url>
      <content type="text"><![CDATA[title: 二叉树的镜像date: 2017-04-25 14:48:51tags: 剑指offer categories: 剑指offer问题描述请完成一个函数，输入一颗二叉树，该函数输出它的镜像。 思路分析镜像也就是将每个子节点的左右子节点交换，可以先判断根结点是否有左右子树，然后依次交换，然后在利用递归的思想继续交换 码上有戏12345678910111213141516171819202122public class TreeNode&#123; int data; TreeNode left; TreeNode right; TreeNode(int data)&#123; this.data=data; &#125; &#125;public void Mirror(TreeNode root)&#123; if(root==null||(root.left==null&amp;&amp;root.right==null)) return; TreeNode temp=root.left; root.left=root.right; root.right=temp; if(root.left!=null) Mirror(root.left); if(root.right!=null) Mirror(root.right); &#125;]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F08%2F18%2Foffer_14%2F</url>
      <content type="text"><![CDATA[title: 树的子结构date: 2017-04-24 14:48:51tags: 剑指offer categories: 剑指offer问题描述输入两颗二叉树A，B，判断B是不是A的子结构 思路分析要在原二叉树中查找是否具有某棵子树，只需要判断每个节点是否都在二叉树中是否出现即可。所以需要先判断头结点，只有头结点符合要求才继续比较其子树是否符合，然后在从左右子树依次比较，如果都符合，则说明B是A的子树 码上有戏12345678910111213141516171819202122232425262728293031323334353637383940public class TreeNode&#123; int data; TreeNode left; TreeNode right; TreeNode(int data)&#123; this.data=data; &#125; &#125; public boolean HasSubtree(TreeNode root1,TreeNode root2)&#123; boolean hasSubTree=false; if(root1!=null&amp;&amp;root2!=null) &#123; if(root1.data==root2.data) &#123; hasSubTree=nodesValEqual(root1,root2); &#125; if(!hasSubTree) &#123; hasSubTree=HasSubtree(root1.left,root2.left); &#125; if(!hasSubTree) &#123; hasSubTree=HasSubtree(root1.right,root2.right); &#125; &#125; return hasSubTree; &#125; private boolean nodesValEqual(TreeNode root1,TreeNode root2)&#123; if(root2==null) return true; if(root1==null) return false; if(root1.data!=root2.data) return false; return nodesValEqual(root1.left,root2.left)&amp;&amp;nodesValEqual(root1.right,root2.right); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图的深度和广度遍历]]></title>
      <url>%2F2017%2F08%2F01%2Fgraph_2%2F</url>
      <content type="text"><![CDATA[前言图是数据结构中最复杂的，正是因为它的复杂，它也是最优魅力的。当然图的存储结构有多种方式，最常用的就是邻接矩阵和邻接表。为了方便，这里图的遍历使用邻接矩阵表示 邻接矩阵如图，这里只画了无向图，其中顶点由一个一维数组表示，一个二维数组存储图中的边或弧的信息，可以发现无向图是一个对称矩阵，并且约定二维数组arc[i][j]=w，若边（vi，vj）属于该图，arc[i][j]=0，若i=j，否则arc[i][j]=一个无强大值，图中是用1代替了，实际中按上述规则1234567891011121314151617181920212223242526272829303132typedef char VertexType; /* 顶点类型应由用户定义 */typedef int EdgeType; /* 边上的权值类型应由用户定义 */#define MAXSIZE 9 /* 存储空间初始分配量 */#define MAXEDGE 15#define MAXVEX 9#define INFINITY 65535typedef struct&#123; VertexType vexs[MAXVEX]; /* 顶点表 */ EdgeType arc[MAXVEX][MAXVEX]; /* 邻接矩阵，可看作边表 */ int numVertexes,numEdges; /* 图中当前的顶点数和边数 */ &#125;MGraph;void CreateMGraph(MGraph *G)&#123; int i,j,k,w; printf("输入顶点数和边数:\n"); scanf("%d,%d",&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges); for(i=0;i&lt;G-&gt;numVertexes;i++) scanf(&amp;G-&gt;vexs[i]); for(i=0;i&lt;G-&gt;numVertexes;i++) for(j=0;j&lt;G-&gt;numVertexes;j++) G-&gt;arc[i][j]=INFINITY; for(k=0;k&lt;G-&gt;numEdges;k++) &#123; printf("输入边（vi，vj）上的下标i，下标j和权值w：\n"); scanf("%d,%d,%d",&amp;i,&amp;j,&amp;w); G-&gt;arc[i][j]=w; G-&gt;arc[j][i]=G-&gt;arc[i][j]; &#125;&#125; 深度优先遍历图的遍历就是指从图中某一顶点出发遍历图中其余顶点且使每一个顶点仅被访问一次，然而由于同一个图可能在空间形式上有不同画法，所以造成不能采用之前使用的双亲等方法，所以可以把访问过的顶点打上标记，即设置一个访问数组visited[n]，n是图中原点个数，初值为0，访问过后设置为1，这样就可以避免访问重复的了而深度优先遍历，也叫深度优先搜索，简称DFS，就像在一个房子中搜索一样，从每一个房间开始，而是不留死角的搜索，也就是说该房间内所有地方搜索完，在去搜索其他房间，以此类推从图中可以发现它是一个递归过程，也就是像二叉树的先序遍历，只不过，已经遍历的结点可以跳过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091void CreateMGraph(MGraph *G)&#123; int i, j; G-&gt;numEdges=15; G-&gt;numVertexes=9; /* 读入顶点信息，建立顶点表 */ G-&gt;vexs[0]='A'; G-&gt;vexs[1]='B'; G-&gt;vexs[2]='C'; G-&gt;vexs[3]='D'; G-&gt;vexs[4]='E'; G-&gt;vexs[5]='F'; G-&gt;vexs[6]='G'; G-&gt;vexs[7]='H'; G-&gt;vexs[8]='I'; for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */ &#123; for ( j = 0; j &lt; G-&gt;numVertexes; j++) &#123; G-&gt;arc[i][j]=0; &#125; &#125; G-&gt;arc[0][1]=1; G-&gt;arc[0][5]=1; G-&gt;arc[1][2]=1; G-&gt;arc[1][8]=1; G-&gt;arc[1][6]=1; G-&gt;arc[2][3]=1; G-&gt;arc[2][8]=1; G-&gt;arc[3][4]=1; G-&gt;arc[3][7]=1; G-&gt;arc[3][6]=1; G-&gt;arc[3][8]=1; G-&gt;arc[4][5]=1; G-&gt;arc[4][7]=1; G-&gt;arc[5][6]=1; G-&gt;arc[6][7]=1; for(i = 0; i &lt; G-&gt;numVertexes; i++) &#123; for(j = i; j &lt; G-&gt;numVertexes; j++) &#123; G-&gt;arc[j][i] =G-&gt;arc[i][j]; &#125; &#125;&#125;Boolean visited[MAXSIZE];//访问标志的数组//深度优先递归算法void DFS(MGraph G,int i)&#123; int j; visited[i]=TRUE; printf("%c",G.vexs[i]); for(j=0;j&lt;G.numVertexes;j++) if(G.arc[i][j]==1&amp;&amp;!visited[j]) //对未访问的顶点递归调用 DFS(G,j);&#125;//深度遍历void DFSTraverse(MGraph G)&#123; int i; for(i=0;i&lt;G.numVertexes;i++) //初始化 visited[i]=FALSE; for(i=0;i&lt;G.numVertexes;i++) if(!visited[i]) DFS(G,i);&#125;int main(void)&#123; MGraph G; CreateMGraph(&amp;G); printf("\n深度遍历："); DFSTraverse(G); return 0;&#125; 为了方便，就创建图的过程写死，最终深度遍历的结果为ABCDEFGHI 广度优先遍历又称为广度优先搜索，简称BFS，它像二叉树遍历中的层序遍历，也就是一层一层的遍历，如上图，与A相连的有B、F，先遍历，又与B相连的有C,I,G，F相连的有G,E，所以下一层为C,I,G,F，依次类推一层一层遍历如图它的核心思想就是构造一个队列，每一层的结点，如A出队后，与它相连的下一层结点B、F就要入队开始遍历，然后B遍历完出队，与B相连的下一层结点C、I、J入队，依次类推队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 循环队列的顺序存储结构 */typedef struct&#123; int data[MAXSIZE]; int front; /* 头指针 */ int rear; /* 尾指针，若队列不空，指向队列尾元素的下一个位置 */&#125;Queue;/* 初始化一个空队列Q */Status InitQueue(Queue *Q)&#123; Q-&gt;front=0; Q-&gt;rear=0; return OK;&#125;/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */Status QueueEmpty(Queue Q)&#123; if(Q.front==Q.rear) /* 队列空的标志 */ return TRUE; else return FALSE;&#125;/* 若队列未满，则插入元素e为Q新的队尾元素 */Status EnQueue(Queue *Q,int e)&#123; if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front) /* 队列满的判断 */ return ERROR; Q-&gt;data[Q-&gt;rear]=e; /* 将元素e赋值给队尾 */ Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;/* rear指针向后移一位置， */ /* 若到最后则转到数组头部 */ return OK;&#125;/* 若队列不空，则删除Q中队头元素，用e返回其值 */Status DeQueue(Queue *Q,int *e)&#123; if (Q-&gt;front == Q-&gt;rear) /* 队列空的判断 */ return ERROR; *e=Q-&gt;data[Q-&gt;front]; /* 将队头元素赋值给e */ Q-&gt;front=(Q-&gt;front+1)%MAXSIZE; /* front指针向后移一位置， */ /* 若到最后则转到数组头部 */ return OK;&#125; 广度遍历12345678910111213141516171819202122232425262728293031323334353637383940414243/* 邻接矩阵的广度遍历算法 */void BFSTraverse(MGraph G)&#123; int i, j; Queue Q; for(i = 0; i &lt; G.numVertexes; i++) visited[i] = FALSE; InitQueue(&amp;Q); /* 初始化一辅助用的队列 */ for(i = 0; i &lt; G.numVertexes; i++) /* 对每一个顶点做循环 */ &#123; if (!visited[i]) /* 若是未访问过就处理 */ &#123; visited[i]=TRUE; /* 设置当前顶点访问过 */ printf("%c ", G.vexs[i]);/* 打印顶点，也可以其它操作 */ EnQueue(&amp;Q,i); /* 将此顶点入队列 */ while(!QueueEmpty(Q)) /* 若当前队列不为空 */ &#123; DeQueue(&amp;Q,&amp;i); /* 将队对元素出队列，赋值给i */ for(j=0;j&lt;G.numVertexes;j++) &#123; /* 判断其它顶点若与当前顶点存在边且未访问过 */ if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j]=TRUE; /* 将找到的此顶点标记为已访问 */ printf("%c ", G.vexs[j]); /* 打印顶点 */ EnQueue(&amp;Q,j); /* 将找到的此顶点入队列 */ &#125; &#125; &#125; &#125; &#125;&#125;int main(void)&#123; MGraph G; CreateMGraph(&amp;G); printf("\n深度遍历："); DFSTraverse(G); printf("\n广度遍历："); BFSTraverse(G); return 0;&#125; 最终的结果是 A B F C I G E D H 总结最后发现深度优先和广度优先遍历的时间复杂度是一样的，他们的适用场景不一样，深度优先更适合目标比较明确，已找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[反射机制简单总结]]></title>
      <url>%2F2017%2F07%2F31%2Freflaction_1%2F</url>
      <content type="text"><![CDATA[前言反射机制是java中非常非常重要的东西，比如以前模拟jdk的代理实现和spring的aop实现都用到了反射（见以前设计模式总结），同时，正是由于反射机制，才让我们能更动态的去写程序，比如说在配置文件中配置配置，就能调用某些方法，是在太方便了，下面就开始探索反射机制，下图是类的加载模型 ClassLoad类加载过程它的特点是1.并非一次性加载2.需要的时候加载（运行期动态加载）3.static语句块在加载后执行一次4.dynamic语句块每次new新的对象都会执行（等同于构造方法中语句）程序验证在eclipse中有-verbose:class运行命令可详细的打印出jvm虚拟机第一次在内存中加载类的详细信息，如下：先看模拟的程序1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; new A(); System.out.println("**------------------------**"); new B(); new C(); new C(); new D(); new D(); &#125;&#125;class A&#123; &#125;class B&#123;&#125;class C&#123; static&#123; System.out.println("CCCCCCCCCCCCCCCCCCCCCCCCCCC"); &#125;&#125;class D&#123; &#123; System.out.println("DDDDDDDDDDDDDDDDDDDDDDDDDDDD"); &#125;&#125; 其中d就是动态方法以下是输出结果 [Opened E:\myeclipse\jdk1.8\jre\lib\rt.jar][Loaded java.lang.Object from E:\myeclipse\jdk1.8\jre\lib\rt.jar][Loaded java.io.Serializable from E:\myeclipse\jdk1.8\jre\lib\rt.jar]。。。。。。[Loaded com.zwl.tree.A from file:/E:/ecli/shiro/target/classes/] [Loaded com.zwl.tree.B from file:/E:/ecli/shiro/target/classes/][Loaded com.zwl.tree.C from file:/E:/ecli/shiro/target/classes/]CCCCCCCCCCCCCCCCCCCCCCCCCCC[Loaded com.zwl.tree.D from file:/E:/ecli/shiro/target/classes/]DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD[Loaded java.lang.Shutdown from E:\myeclipse\jdk1.8\jre\lib\rt.jar][Loaded java.lang.Shutdown$Lock from E:\myeclipse\jdk1.8\jre\lib\rt.jar] 可以发现，jvm在初始化执行程序时需要加载很多类到内存中，并且是动态加载的，就像A和B中间输出语句打印出来，说明不是一次性加载的，这里静态函数只加载了一次，动态方法每次都会加载，其实还有一点，就是jvm会在类加载时，找到jdk中已有的类加载，加载过了一次，就不加载了如D classLoad类事实上，jdk中有各种各样的ClassLoad将类加载进内存，大致分为以下几种 一：bootstrap class loaderimplemented by native language and load ths core classes of jdk也就是说，它不是用java写的，而是用操作系统语言，如c、c++写的加载类，它是最核心的类用于加载java中核心的类，当然他没有具体名字二:extesion class loaderloader the class from jre/lib/ext三:application class loaderload user-define classes and ClassLoader.getSystemClassLoader()也就是说它是java的核心类用于加载用户自定义的类和其他类四:other class loadersSecureClassLoader、URLClassLoader等等，该类是其他加载类加载其它类 程序验证1234System.out.println(String.class.getClassLoader()); System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName()); System.out.println(Test.class.getClassLoader().getClass().getName()); System.out.println(ClassLoader.getSystemClassLoader().getClass().getName()); 测试结果： nullsun.misc.Launcher$ExtClassLoadersun.misc.Launcher$AppClassLoadersun.misc.Launcher$AppClassLoader 分析一下：String类bootstrap类加载的类，但是它的加载类是空，而DESKeyFactory的的加载类是扩展类，而第三和第四都是java核心类加载，总之，我们知道classload是有多种并且有顺序和层次的 如 ClassLoader c=Test.class.getClassLoader(); while(c!=null){ System.out.println(c.getClass().getName()); c=c.getParent(); } 结果： sun.misc.Launcher$AppClassLoadersun.misc.Launcher$ExtClassLoader 注意这里的getparent（）是得到引用，不是继承。也就是说jdk底层深层次加载是，问上一层有没有加载我这个类，如果加载了就不加载了 动态方法从classload的角度来看，内存中的一切包括方法等都是对象，也就是说我们可以动态的调用，jdk中为我们提供了类methods类如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; String str="com.zwl.tree.T"; Class c=Class.forName(str); Object o=c.newInstance(); Method[] methods=c.getMethods(); for(Method m:methods)&#123; if(m.getName().equals("mm"))&#123; m.invoke(o); &#125; if(m.getName().equals("m1"))&#123; m.invoke(o, 1,2); System.out.println(m.getReturnType().getName()); &#125; &#125; &#125; class T&#123; static&#123; System.out.println("T loader!"); &#125; public T()&#123; System.out.println("T constructed!"); &#125; int i; String s; public void m1(int i,int j)&#123; this.i=i+j; System.out.println(this.i); &#125; public void mm()&#123; System.out.println("mm"); &#125; public String getS()&#123; return s; &#125;&#125; 测试结果： T loader!T constructed!mm3void 上面的程序通过class提供的forname（）方法将相应的类加载至内存，然后通过newInstance()方法取得实例，methods方法能够得到一个类的所有方法，最后通过public Object invoke(Object obj,Object… args)第二个参数是可变参数，也就是可以有多个参数来调用相应对象的相应方法，而getReturnType()是拿到方法的返回类型，也就是说我们通过class和methods可以动态的调用方法，就好比我们只要在配置文件中配置一下类或方法名，就可以动态的调用类或方法，是在是太方便了 反射一些类常用方法ClassLoader常用方法 public abstract class ClassLoaderextends Object构造方法：protected ClassLoader()：使用方法 getSystemClassLoader() 返回的 ClassLoader 创建一个新的类加载器，将该加载器作为父类加载器protected ClassLoader(ClassLoader parent)：使用指定的、用于委托操作的父类加载器创建新的类加载器public final ClassLoader getParent()：返回委托的父类加载器public URL getResource(String name)：查找具有给定名称的资源。 Class常用方法 public final class Classextends Objectimplements Serializable, GenericDeclaration, Type, AnnotatedElementClass 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的public static Class&lt;?&gt; forName(String className)throws ClassNotFoundException：返回与带有给定字符串名的类或接口相关联的 Class 对象public ClassLoader getClassLoader()：返回该类的类加载器public Method[] getMethods()throws SecurityException：返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。public String getName()：以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称public String getName()：查找带有给定名称的资源。public T newInstance()throws InstantiationException,IllegalAccessException： 创建此 Class 对象所表示的类的一个新实例。 Methods类常用方法 public final class Methodextends AccessibleObjectimplements GenericDeclaration, Memberpublic String getName():以 String 形式返回此 Method 对象表示的方法名称。public Class&lt;?&gt; getReturnType():返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型。public Object invoke(Object obj, Object… args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法,此方法为可变参数 反射的知识其实是很复杂的，这里只做了一次简单的总结，反射的应用也是在太广了，像strcts、spring、hibernate、mybatis、spring mvc包括shiro等等框架，你会发现他们的很多底层实现都基于反射机制。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[哈夫曼树之压缩与解压]]></title>
      <url>%2F2017%2F07%2F30%2Fhuffman_2%2F</url>
      <content type="text"><![CDATA[前言压缩与解压的另一种说法就是，压缩相当于对文件的加密过程，解压相当于对文件的解密过程，比如说，盲-z，僧-w，那么盲僧-zw，当然加密与解密各种各样，不一定非是字符型的 压缩对比如图，最左边是未压缩的原始txt文本文件，里面有38个字节，所以占38字节，中间是利用哈夫曼编码压缩的，居然只占15个字节，最右边是好压自带的压缩，占185个字节，通过对比，发现哈夫曼压缩居然节约这么多空间！ 压缩原理计算机只能存储二进制数，即非0即1，比如刚学c语言那会接触到的ASCII码，它是专门处理英文的，比如一个字节占8位（由8个01串组成）来表示各种英文字母以及符号，比如0在ASCII编码的十进制表示是48（00110000），a是97，所以英文共有2的8次方个，但是汉字远远不止256个，所以一个汉字用两个字节表示，所以共有2的16次方汉字，而汉字编码一般用UTF-8和GBK等存储过程比如在文件中存储aaabbc，理论上占6个字节，并且存储的二进制为01100001（a）01100001（a）01100001（a）01100010 （b）01100010 （b）01100011 （c）那么哈夫曼是怎么存储该数据的了它是根据某个字出现的次数，比如a出现3次，b出现2次，c出现1次，将次数作为相应字的权值来构造哈夫曼树的所以得到：哈夫曼编码为a（1），b（01），c（00），所以的到压缩后的编码为aaabbc（111010100），注意这里变成2个字节了，然后将该二进制转换成10进制就行了 压缩实现一般有以下步骤1.读取文件，统计文件中每个字节出现的次数，将该次数作为权值2.根据权值构建哈夫曼树3，根据哈夫曼树构建码表4在读取文件，通过码表对文件中读取的字节进行加密处理在这里定义了一个256的整型数组（存取次数作为权值）和一个256的字符串数组（存取哈夫曼编码值） 码上有戏哈夫曼结点与之前不同的是增加了索引，便于搜索123456789101112131415161718192021222324252627282930313233343536373839404142public class HuffmNode &#123; //数据域 private int data; //索引 private int index; //左子节点 private HuffmNode left; //右子节点 private HuffmNode right; //哈夫曼节点的构造函数 public HuffmNode(int data,int index)&#123; this.data=data; this.index=index; &#125; //私有属性的封装 public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125; public HuffmNode getLeft() &#123; return left; &#125; public void setLeft(HuffmNode left) &#123; this.left = left; &#125; public HuffmNode getRight() &#123; return right; &#125; public void setRight(HuffmNode right) &#123; this.right = right; &#125; &#125; 压缩实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public class Compress &#123; public int[] times=new int[256]; public String[] HuffmCodes=new String[256]; public LinkedList&lt;HuffmNode&gt; list = new LinkedList&lt;HuffmNode&gt;(); //初始化 public Compress()&#123; for(int i=0;i&lt;HuffmCodes.length;i++) &#123; HuffmCodes[i]=""; &#125; &#125; public void countTimes(String path)throws Exception&#123; //构造文件输入流 FileInputStream fis=new FileInputStream(path); //读取文件 int value=fis.read(); while(value!=-1)&#123; times[value]++; value=fis.read(); &#125; fis.close(); &#125; //构造哈夫曼树 public HuffmNode createTree()&#123; //将次数作为权值构造森林 for (int i = 0; i &lt; times.length; i++) &#123; if(times[i]!=0)&#123; HuffmNode node = new HuffmNode(times[i],i); //将构造好的节点加入到容器中的正确位置 list.add(getIndex(node), node); &#125; &#125; //将森林（容器中的各个节点）构造成哈夫曼树 while(list.size()&gt;1) &#123; //获取容器中第一个元素（权值最小的节点） HuffmNode firstNode =list.removeFirst(); //获取中新的第一个元素，原来的第一个元素已经被移除了（权值次小的节点） HuffmNode secondNode =list.removeFirst(); //将权值最小的两个节点构造成父节点 HuffmNode fatherNode = new HuffmNode(firstNode.getData()+secondNode.getData(),-1); fatherNode.setLeft(firstNode); fatherNode.setRight(secondNode); //父节点加入到容器中的正确位置 list.add(getIndex(fatherNode),fatherNode); &#125; //返回整颗树的根节点 return list.getFirst(); &#125; //利用前序遍历获取编码表 public void getHuffmCode(HuffmNode root,String code)&#123; //往左走，哈夫曼编码加0 if(root.getLeft()!=null)&#123; getHuffmCode(root.getLeft(),code+"0"); &#125; //往右走，哈夫曼编码加1 if(root.getRight()!=null)&#123; getHuffmCode(root.getRight(),code+"1"); &#125; //如果是叶子节点，返回该叶子节点的哈夫曼编码 if(root.getLeft()==null &amp;&amp; root.getRight()==null)&#123; // System.out.println(root.getIndex()+"的编码为："+code); HuffmCodes[root.getIndex()]=code; &#125; &#125; //压缩文件 public void compress(String path,String destpath)throws Exception&#123; //构建文件输出流 FileOutputStream fos=new FileOutputStream(destpath); FileInputStream fis=new FileInputStream(path); //读文件，并将对应的哈夫曼编码串接成字符串 int value=fis.read(); String str=""; while(value!=-1)&#123; str+=HuffmCodes[value]; value=fis.read(); &#125; System.out.println(str); fis.close(); String s=""; while(str.length()&gt;=8)&#123; s=str.substring(0, 8); int b=changeStringToInt(s); fos.write(b); fos.flush(); str=str.substring(8); &#125; int last1=8-str.length(); for(int i=0;i&lt;last1;i++)&#123; str+="0"; &#125; s=str.substring(0, 8); int d=changeStringToInt(s); fos.write(d); fos.close(); &#125; //插入元素位置的索引 public int getIndex(HuffmNode node) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; if(node.getData()&lt;=list.get(i).getData())&#123; return i; &#125; &#125; return list.size(); &#125; //将字符串转换成整数 public int changeStringToInt(String s)&#123; int v1=(s.charAt(0)-48)*128; int v2=(s.charAt(1)-48)*64; int v3=(s.charAt(2)-48)*32; int v4=(s.charAt(3)-48)*16; int v5=(s.charAt(4)-48)*8; int v6=(s.charAt(5)-48)*4; int v7=(s.charAt(6)-48)*2; int v8=(s.charAt(7)-48)*1; return v1+v2+v3+v4+v5+v6+v7+v8; &#125; &#125; 这里有几处需要注意下，首先changeStringToInt(String s）方法是根据二进制的定义做转换的，void countTimes(String path)throws Exception中那个value是根据其相应的字节的ASCII码值得，比如a是97，就是times[97]++，初始值都是0；然后void compress(String path,String destpath)throws Exception中读文件刚开始是取8位然后转成int在写进文件，然后取第8未到末尾，在循环直至最后不足8位，在后面补0，在写进去。 测试类1234567891011//创建压缩对象 Compress compress = new Compress(); //统计文件中0-255出现的次数 compress.countTimes("C:\\Users\\Administrator\\Desktop\\test.txt"); //构造哈夫曼树，并得到根节点 HuffmNode root=compress.createTree(); //得到哈夫曼编码 compress.getHuffmCode(root, ""); //压缩文件 compress.compress("C:\\Users\\Administrator\\Desktop\\test.txt", "C:\\Users\\Administrator\\Desktop\\tes.zip"); 结果： 1011010101110010110101011011011011100111011110011000010000100111010100010000010011111101101111110111111011000010000100 同时会生成一个压缩文件，如前面的图所示 解压解压原理之前说过哈夫曼编码不会出现像0和01这样前者是后者子串的情况，所以解压采取的办法就是在压缩时写进去每个编码的长度和对应的编码，就像密码本一样，记录着每个密码的详细信息（这里理解每个密码长度和密码数据域唯一确定一个解码）打个比方，假设ab压缩后为0和10，当然压缩后是变成010，那怎么解码了？，首先在压缩时，在之前压缩代码上加上一个记录编码长度和对应的编码，像a不是97吗，那在写入时记录code[97]=1，对应的编码str[97]=0，code[98]=1；str[98]=0，一次类推，写入时是先写入编码长度的，不过要将字符串转换成十进制，然后通过字符串分割成不同编码，这样每个字节也就拿到手了模拟一下，不妨把abbcc先压缩，然后读出它的二进制如下 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015214308 再来分析分析：前面在152之前都是存取密码长度的信息，212是对应ASSII码的相应字节的编码长度，如a（10）、b（0），c（11）所以长度分别对应212，接下来就是152也就是abc的二进制值了，10011，不足8位后面补0，即10011000，对应十进制就是152，后面143就是文本的需要解密的编码，后面08没有弄懂，在压缩文件中并没有输入这个东西，也做了大量实验发现都有后面这些数字，暂且认为就是压缩文件自带的标识吧（逻辑上还没有证明，所以勉强这么认为）所以，解码思路就是先根据长度读取相应位置，然后分割每个位置得到相应二进制编码，最后再转回来，看看编码的打印结果 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000212000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000codeLength:1int152哈夫曼编码：10011000huff10huff0huff11需要解密的字符串：10001111截取的字符串：10截取后剩余编码长度：6截取的字符串：0截取后剩余编码长度：5截取的字符串：0截取后剩余编码长度：4截取的字符串：11截取后剩余编码长度：2截取的字符串：11截取后剩余编码长度：0 不是很规范，但是大概跟踪了过程，长度为5（10011），不足8位不以为，所以codeLength为1,152就是哈夫曼密码手册值了，变成二进制为10011000，然后分割成10,0,11分别对应ASSII码为a、b、c三个字符，需要解密的是10001111，也就是143，解密分别对应abbcc，所以至此完成解密了说了这么多，再来看看代码吧 码上有戏压缩编码由于解压需要的压缩编码在之前主要修改一点，所以这里就把增加的代码贴出来，分析分析1234567891011121314151617181920212223242526272829//将整个哈夫曼编码以及每个编码的长度写入文件 String code =""; for (int i = 0; i &lt; 256; i++) &#123; fos.write(HuffmCodes[i].length()); code+=HuffmCodes[i]; fos.flush(); &#125; //把哈夫曼编码写入文件 System.out.println("code="+code); String str1=""; while(code.length()&gt;=8)&#123; str1=code.substring(0, 8); int c=changeStringToInt(str1); System.out.println(c); fos.write(c); fos.flush(); code=code.substring(8); &#125; //处理最后一个不为8的数 int last=8-code.length(); for (int i = 0; i &lt;last; i++) &#123; code+="0"; &#125; str1=code.substring(0, 8); int c=changeStringToInt(str1); System.out.println("c:"+c); fos.write(c); fos.flush(); 上面代码是说首先我们已经统计了文本中字符出现的次数，压缩那里已经写过了，然后将长度表写入进压缩文件，也就是那一大串000中间含有长度的字符串，存在code里，注意长度为空就是空字符，所以code就是那5位的二进制，然后不足8位的补成8位，再变成十进制也就是152了，这是这段代码与之前增加的部分，我们也称为码表构造 解压实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//每个编码的长度 public int [] codelengths = new int [256]; //对应的哈夫曼编码值 public String [] codeMap=new String[256]; public static void main(String[] args) &#123; Decompress d = new Decompress(); d.decompress("C:\\Users\\Administrator\\Desktop\\tes.zip", "C:\\Users\\Administrator\\Desktop\\mytes.txt"); &#125; /* * 解压思路： * 1、读取文件里面的码表 * 2、得到码表 * 3、读取数据 * 4、还原数据 */ public void decompress(String srcpath,String destpath) &#123; try &#123; FileInputStream fis = new FileInputStream(srcpath); FileOutputStream fos = new FileOutputStream(destpath); int zwl; int value; int codeLength=0; String code=""; //还原码表 for (int i = 0; i &lt; codelengths.length; i++) &#123; value=fis.read(); codelengths[i]=value; System.out.print(codelengths[i]); codeLength+=codelengths[i]; &#125; // System.out.println("总长度:"+codeLength); //得到总长度 //将总长度除以8的到字节个数 int len=codeLength/8; //如果不是8的倍数，则字节个数加1（对应压缩补0的情况） if((codeLength)%8!=0)&#123; len++; &#125; //读取哈夫曼编码 System.out.println("codeLength:"+len); for (int i = 0; i &lt; len; i++) &#123; //把读到的整数转换成二进制 int s=fis.read(); System.out.println("int"+s); code+=changeIntToString(s); &#125; System.out.println("哈夫曼编码："+code); for (int i = 0; i &lt; codeMap.length; i++) &#123; //如果第i个位置不为0 ，则说明第i个位置存储有哈夫曼编码 if(codelengths[i]!=0)&#123; //将得到的一串哈夫曼编码按照长度分割分割 String ss=code.substring(0, codelengths[i]); codeMap[i]=ss; System.out.println("huff"+codeMap[i]); code=code.substring(codelengths[i]); &#125;else&#123; //为0则没有对应的哈夫曼编码 codeMap[i]=""; &#125; &#125; //读取压缩的文件内容 String codeContent=""; while(fis.available()&gt;1)&#123; codeContent+=changeIntToString(fis.read()); &#125; //读取最后一个 value=fis.read(); //把最后补的0给去掉 codeContent=codeContent.substring(0, codeContent.length()-value); for (int i = 0; i &lt; codeContent.length(); i++) &#123; String codecontent=codeContent.substring(0, i+1); for (int j = 0; j &lt; codeMap.length; j++) &#123; if(codeMap[j].equals(codecontent))&#123; System.out.println("截取的字符串："+codecontent); fos.write(j); fos.flush(); codeContent=codeContent.substring(i+1); System.out.println("截取后剩余编码长度："+codeContent.length()); i=-1; break; &#125; &#125; &#125; fos.close(); fis.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //十进制转二进制字符串 public String changeIntToString(int value) &#123; String s=""; for (int i = 0; i &lt; 8; i++) &#123; s=value%2+s; value=value/2; &#125; return s; &#125; &#125; 这里的codelengths[]和codeMap[]就是分别存放码表和码表值的数组，流程就是先读取文本内容，拿到长度表中有长度的编码，如212，然后判断其是多少个字节，然后读哈夫曼编码，根据字节数，转成二进制后，找到对应的码表，然后就是分割编码了，最后就得到我们想要的解码了。最后分别为压缩前，压缩后的，会发现压缩居然比压缩前占得空间还大，那是因为我们压缩的文件太小了，而之前也比较过了，压缩一般都是针对大文件的 总结最后不得不说哈夫曼树的精妙让人惊叹和着迷，同时也认识到了计算机底层知识的重要性，当你回过头来再去看以前的知识，会有另一种不同的感受，当然当再去看压缩与解压，原来是这么回事。当然探索的过程是很累的，会遇到各种难题和挫折，而在当下这个追求功利主义，很多时候都是表象的去用一些东西，当然有时候你把时间花在一些与收益不是很正相关的上面，可能会让你的性价比不是很高，但是正是由于这种自娱自乐的快乐，才更让人充实，而不是每天都去追求“外功”。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[哈夫曼树之构建]]></title>
      <url>%2F2017%2F07%2F30%2Fhuffman_1%2F</url>
      <content type="text"><![CDATA[前言说到哈夫曼树，就不得不说它在压缩与解压方面的应用太完美了，就是把一个大的文件，通过算法压缩成一个较小的文件，从而大大节约了空间 哈夫曼树通俗的说就是给定n个权值作为n个叶子结点，构造一颗二叉树，若带权路径长度达到最小，称这样的树为哈夫曼树，也称为最优二叉树，同时，由定义可知，哈夫曼树是带权路径长度最短的树，所以权值较大的结点离根较近 相关术语路径长度结点路径长度：从树中一个结点到另一个结点之间的分支，构成两个结点之间路径，路径上的分支数目称为结点长度，如结点100到结点29的结点路径长度就是2 树的路径长度：从树根到每一个结点的路径长度之和 权值所有叶子结点的date域，也就是当前叶子结点存放的数据域带权路径长度结点带权路径长度：从该节点到树根之间的路径长度与结点上权值的乘积树的带权路径长度：树中所有结点的带权路径长度之和，并且几位WPL，如果WPL最小，则称该二叉树为哈夫曼树 哈夫曼树构建过程它的构建思想其实很简单的，大概如下1.根据给定的n个权值{w1,w2,..wn}构成n棵二叉树的集合F={T1,T2,..Tn};其中每棵二叉树Ti中只有一个带权为wi的根结点，器左右子树为空2：在F中选取两颗根结点权值最小的树作为左右子树构造一颗新二叉树，并且新二叉树的根结点权值为左右子根结点的权值之和3:在F中删除这两颗树，同时将新二叉树加入F中4:重复2和3步骤，知道F中只含一棵树为止 构造哈夫曼树哈夫曼结点12345678910111213141516171819202122232425262728293031public class HuffmNode &#123; //构造HuffmNode类 private int data; private HuffmNode left; private HuffmNode right; //HuffmNode类构造函数 public HuffmNode(int data) &#123; this.data=data; &#125; //封装属性 public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public HuffmNode getLeft() &#123; return left; &#125; public void setLeft(HuffmNode left) &#123; this.left = left; &#125; public HuffmNode getRight() &#123; return right; &#125; public void setRight(HuffmNode right) &#123; this.right = right; &#125; &#125; 构造哈夫曼树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class HuffmTree &#123; public int [] datas =&#123;42,8,19,100,58,15,29&#125;; public LinkedList&lt;HuffmNode&gt; list = new LinkedList&lt;HuffmNode&gt;(); public HuffmNode createTree() &#123; //按照从小到大的将数据封装成节点 for (int i = 0; i &lt; datas.length; i++) &#123; HuffmNode node = new HuffmNode(datas[i]); //得到需要插入的位置索引 int index=getIndex(node); //将数据添加到容器中 list.add(index, node); &#125; //构造哈夫曼树 while(list.size()&gt;1)&#123; //移除容器中的第一个节点 HuffmNode firstNode =list.removeFirst(); //容器中原来的第二个节点变成新的第一个节点 HuffmNode secondNode =list.removeFirst(); //构造父节点数据域 HuffmNode fatherNode = new HuffmNode(firstNode.getData()+secondNode.getData()); //构造父节点左子叶 fatherNode.setLeft(firstNode); //构造父节点右子叶 fatherNode.setRight(secondNode); //得到构造好的父节点的索引 int index=getIndex(fatherNode); //将父节点加入森林 list.add(index, fatherNode); &#125; //返回根节点 return list.getFirst(); &#125; //得到索引 public int getIndex(HuffmNode node) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; if(node.getData()&gt;list.get(i).getData())&#123; continue; &#125;else &#123; return i; &#125; &#125; //如果比容器中的任何一个数大，则插入最后面 return list.size(); &#125; //得到哈夫曼编码 public void getHuffmCode(HuffmNode root,String code) &#123; if(root.getLeft()!=null)&#123; getHuffmCode(root.getLeft(),code+"0"); &#125; if(root.getRight()!=null)&#123; getHuffmCode(root.getRight(),code+"1"); &#125; if(root.getLeft()==null &amp;&amp; root.getRight()==null)&#123; System.out.println(root.getData()+":"+code); &#125; &#125; &#125; 其实这段代码就是上述四个步骤的实现，代码也很好理解，带权值为datas，将结点放到链表中，然后注意利用非正规的选择排序将链表集合里权值从小到大排好序，然后开始选择权值最小的两个构造一个新的权值结点，同时删除那两个，加入这个新的。。重复直到只剩一个根结点为止，很明显此时就是哈夫曼树了，最后通过后序遍历得到哈夫曼编码值，这里我们约定左子树一个路径为0，右子树一个路径为1，所以一定不存在像01与010这样前面是后面子串的编码值测试类12345public static void main(String[] args) &#123; HuffmTree tree = new HuffmTree(); HuffmNode root = tree.createTree(); tree.getHuffmCode(root, ""); &#125; 结果： 8:00011:00123:0114:1007:10103:101105:1011129:11 注意这里的结果和图示有一个地方不一样，就是那个几点8，这里的结点8是合成的，可以根据结果画出哈夫曼树，比较就会看出不同]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络编程简单总结]]></title>
      <url>%2F2017%2F07%2F29%2Fsocket_1%2F</url>
      <content type="text"><![CDATA[前言在java网络编程中最主要的是tcp/ip协议，这个协议也是Internet最基本的协议，而其就是由网络层的ip协议和传输层的tcp协议组成，同时由于分层的思想，也就是每一层只能与它下面的层打交道，也就是说，应用层只跟传输层打交道，传输层只跟网络层打交道 ip协议关于底层协议的具体过程是在太复杂了，当初学习计算机网络的时候也是被各种细节弄得云里雾里的，总之ip层就是唯一确定了一台机器，就像我们住的房间地址一样，唯一确定了我们的住处这里需要注意的是，ip地址由四位字节组成，每个字节由8位二进制组成，同时有a，b，c三类地址，如图由网络号和主机号组成，当然这是公网，如果是局域网的话，就需要配网关和子网掩码了，如192.168.1.1和255.255.0.0那么255.255就是确定了ip地址哪几位字节是网络号，如192.168就是网络号，当然其配置各种内网ip是很复杂的，具体参考计算机网络 TCP与UDP协议tcp协议 它是专门设计用于在不可靠的因特网上提供端到端的字节流通信的协议，它是一种面向连接的协议，它连接的是字节流。这里面有几个注意的地方：可靠性：就是建立三次握手过程，就是说，我把信息传给你，等待，收到回复后，在确认。。最后在发送消息，它保证了数据一定发送给了对方，所以是一种可靠传输，但是遇到阻塞效率会很低端口：ip地址唯一确定了这台机器，相当于一个房子，但是你消息总不能发给整个电脑吧，比如qq，而端口就相当于一间房间，具体发给那个，比如送到qq这间房间 端口分类 有65536个端口 0号是保留端口1-1024是固定端口又叫有名端口，即被某些程序固定使用，一般程序员不使用。22：SSH远程登录协议 23：telnet使用 21：ftp使用25：smtp服务使用 80：iis使用 7：echo服务1025-65535是动态端口这些端口，程序员可以使用端口(port)–注意事项1、在计算机(尤其是做服务器)要尽可能的少开端口；2、一个端口只能被一个程序监听；3、如果使用netstat -an可以查看本机有哪些端口在监听 UDP协议UDP向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接。简单来说，就是只发一次数据，不管对方有没有接收到都不会再发了，但是有时候效率会很高，像网络拥堵时 url统一资源定义符也被称为网页地址。Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL地址，这种地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是Internet上的站点，简单地说，URL就是Web地址，俗称“网址”，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法，如：http://www.sina.com:8080/index.html1、协议；2、ip地址(32位)；3、端口号(16位)0-65535；4、资源名称。 单工、半双工和全双工 如果甲可以向乙发送数据，但是乙不能向甲发送数据，这样的通信就是单工通信(Simplex Communication)。 单工数据传输只支持数据在一个方向上传输，就和传呼机一样。 半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信，就和对讲机(步话机)一样；全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力，就和电话一样 Socket编程如模拟的客户端与服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MyServer &#123; public static void main(String[] args) &#123; new MyServer(); &#125; public MyServer()&#123; try &#123; //在9999号端口上监听 ServerSocket ss=new ServerSocket(9999); System.out.println("9999端口监听..."); //等待某个客户端来连接，该函数会返回一个Socket连接 Socket s=ss.accept(); //要读取s中传递的数据 InputStreamReader isr=new InputStreamReader(s.getInputStream()); BufferedReader br=new BufferedReader(isr); String info=br.readLine(); System.out.println("服务器接收到:\t"+info); PrintWriter pw=new PrintWriter(s.getOutputStream(),true); pw.println("我是服务器，已收到你发送的信息!"); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;&#125;public class MyClient &#123; public static void main(String[] args) &#123; new MyClient(); &#125; public MyClient()&#123; try &#123; //Socket()就是去连接某个服务器端 127.0.0.1表示服务器的ip //9999是服务器的端口号 Socket s=new Socket("127.0.0.1",9999); //如果s连接成功，就可以发送数据到服务器端 //我们通过pw向s写数据,true表示即时刷新 PrintWriter pw=new PrintWriter(s.getOutputStream(),true); pw.println("你好吗？我是客户端"); //要读取s中传递的数据 InputStreamReader isr=new InputStreamReader(s.getInputStream()); BufferedReader br=new BufferedReader(isr); String info=br.readLine(); System.out.println("接收到服务器：\t"+info); &#125;catch (Exception e) &#123; // TODO: handle exception &#125; &#125;&#125; 这里需要注意的几个地方，必须是服务端先开启，然后accept（）等待客户端，没有客户端连接，它将处于阻塞状态，一旦有了客户端它将回应，其次这是理由tcp实现的，UDP实现用java提供的另外类，最后这里有一个问题，就是只能接受一次，需要改进，也就是不断循环接收客户端连接 12345678910111213141516171819202122232425262728293031323334353637383940414243try &#123; //在9999号端口上监听 ServerSocket ss=new ServerSocket(9999); //等待客户端连接，该函数会返回一个Socket连接 Socket s=ss.accept(); //要读取s中传递的数据 isr=new InputStreamReader(s.getInputStream()); br=new BufferedReader(isr); pw=new PrintWriter(s.getOutputStream(),true); //接收从控制台输入的信息 isr2=new InputStreamReader(System.in); br2=new BufferedReader(isr2); while(true)&#123; //接收客户端信息 String infoFromClient=br.readLine(); System.out.println("服务器接收到:\t"+infoFromClient); //接收从控制台输入的信息 System.out.println("请输入要发送到客户端的信息："); String response=br2.readLine(); //服务器从控制台上接收bye服务器端退出 if(response.equals("bye"))&#123; System.out.println("退出对话"); s.close(); break; &#125; //把从控制台输入的信息，回送给客户端 pw.println(response); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; if(br2!=null) br2.close(); if(isr2!=null) isr2.close(); if(pw!=null) pw.close(); if(br!=null) br.close(); if(isr!=null) isr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 最后当然网络编程中也就是流的数据传送的应用，也不得不说网络底层协议其实很复杂的，只有当我们有精力了，再去细细研究它，才会有更多的收获]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AVL树]]></title>
      <url>%2F2017%2F07%2F28%2Fbalace_1%2F</url>
      <content type="text"><![CDATA[前言AVL树，也叫平衡二叉树，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。同时，将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，还将距离插入结点最近的且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树如图：一为一个不平衡二叉排序树，显然时间复杂度较大，二为改进后的平衡二叉树，而在改进的过程中，最重要的就是通过平衡因子来判断是进行左旋还是右旋，如右旋，新增一个节点N后，平衡被打破，需要平衡因子2大于0，需要右旋，就是将其左子树作为根结点，左子树的右子树作为原根结点的左子树，这样做的原因就是根据二叉排序树的左右子树特点来的，很容易想明白 模拟平衡二叉树不妨构造一个a[10]={3,2,1,4,5,6,7,10,9,8};大概过程如图所示，其中最重要的就是平衡因子的判断，如果是同号，且绝对值大于1的话，就要做相应的旋转操作，如果是不同号的话，就要通过旋转先转换成同号，在做操作 左右旋操作12345678910111213141516171819202122232425typedef struct BiTNode&#123; int data; int bf; struct BiTNode *lchild,*rchild;&#125;BiTNode,*BiTree;//左旋处理void R_Rotate(BiTree *p)&#123; BiTree L; L=(*p)-&gt;lchild; //L指向p的左子树根结点 (*p)-&gt;lchild=L-&gt;rchild; //L的右子树挂接为p的左子树 L-&gt;rchild=(*p); *p=L; //p指向新的根结点&#125;//右旋处理void L_Ronate(BiTree *p)&#123; BiTree R; R=(*p)-&gt;rchild; //R指向p的右子树根结点 (*p)-&gt;rchild=R-&gt;lchild; //R的左子树挂接为P的右子树 R-&gt;lchild=(*p); *p=R; //p指向新的根结点&#125; 可以通过之前的图来对比看，其实质也就是交互根结点位置和挂接新左右子树 左右平衡旋转1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#define LH +1 /* 左高 */ #define EH 0 /* 等高 */ #define RH -1 /* 右高 */ /* 对以指针T所指结点为根的二叉树作左平衡旋转处理 *//* 本算法结束时，指针T指向新的根结点 */void LeftBalance(BiTree *T)&#123; BiTree L,Lr; L=(*T)-&gt;lchild; /* L指向T的左子树根结点 */ switch(L-&gt;bf) &#123; /* 检查T的左子树的平衡度，并作相应平衡处理 */ case LH: /* 新结点插入在T的左孩子的左子树上，要作单右旋处理 */ (*T)-&gt;bf=L-&gt;bf=EH; R_Rotate(T); break; case RH: /* 新结点插入在T的左孩子的右子树上，要作双旋处理 */ Lr=L-&gt;rchild; /* Lr指向T的左孩子的右子树根 */ switch(Lr-&gt;bf) &#123; /* 修改T及其左孩子的平衡因子 */ case LH: (*T)-&gt;bf=RH; L-&gt;bf=EH; break; case EH: (*T)-&gt;bf=L-&gt;bf=EH; break; case RH: (*T)-&gt;bf=EH; L-&gt;bf=LH; break; &#125; Lr-&gt;bf=EH; L_Rotate(&amp;(*T)-&gt;lchild); /* 对T的左子树作左旋平衡处理 */ R_Rotate(T); /* 对T作右旋平衡处理 */ &#125;&#125;/* 对以指针T所指结点为根的二叉树作右平衡旋转处理， */ /* 本算法结束时，指针T指向新的根结点 */ void RightBalance(BiTree *T)&#123; BiTree R,Rl; R=(*T)-&gt;rchild; /* R指向T的右子树根结点 */ switch(R-&gt;bf) &#123; /* 检查T的右子树的平衡度，并作相应平衡处理 */ case RH: /* 新结点插入在T的右孩子的右子树上，要作单左旋处理 */ (*T)-&gt;bf=R-&gt;bf=EH; L_Rotate(T); break; case LH: /* 新结点插入在T的右孩子的左子树上，要作双旋处理 */ Rl=R-&gt;lchild; /* Rl指向T的右孩子的左子树根 */ switch(Rl-&gt;bf) &#123; /* 修改T及其右孩子的平衡因子 */ case RH: (*T)-&gt;bf=LH; R-&gt;bf=EH; break; case EH: (*T)-&gt;bf=R-&gt;bf=EH; break; case LH: (*T)-&gt;bf=EH; R-&gt;bf=RH; break; &#125; Rl-&gt;bf=EH; R_Rotate(&amp;(*T)-&gt;rchild); /* 对T的右子树作右旋平衡处理 */ L_Rotate(T); /* 对T作左旋平衡处理 */ &#125;&#125; 插入与主函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */ /* 数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */ /* 失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */Status InsertAVL(BiTree *T,int e,Status *taller)&#123; if(!*T) &#123; /* 插入新结点，树“长高”，置taller为TRUE */ *T=(BiTree)malloc(sizeof(BiTNode)); (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=NULL; (*T)-&gt;bf=EH; *taller=TRUE; &#125; else &#123; if (e==(*T)-&gt;data) &#123; /* 树中已存在和e有相同关键字的结点则不再插入 */ *taller=FALSE; return FALSE; &#125; if (e&lt;(*T)-&gt;data) &#123; /* 应继续在T的左子树中进行搜索 */ if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) /* 未插入 */ return FALSE; if(taller) /* 已插入到T的左子树中且左子树“长高” */ switch((*T)-&gt;bf) /* 检查T的平衡度 */ &#123; case LH: /* 原本左子树比右子树高，需要作左平衡处理 */ LeftBalance(T); *taller=FALSE; break; case EH: /* 原本左、右子树等高，现因左子树增高而使树增高 */ (*T)-&gt;bf=LH; *taller=TRUE; break; case RH: /* 原本右子树比左子树高，现左、右子树等高 */ (*T)-&gt;bf=EH; *taller=FALSE; break; &#125; &#125; else &#123; /* 应继续在T的右子树中进行搜索 */ if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) /* 未插入 */ return FALSE; if(*taller) /* 已插入到T的右子树且右子树“长高” */ switch((*T)-&gt;bf) /* 检查T的平衡度 */ &#123; case LH: /* 原本左子树比右子树高，现左、右子树等高 */ (*T)-&gt;bf=EH; *taller=FALSE; break; case EH: /* 原本左、右子树等高，现因右子树增高而使树增高 */ (*T)-&gt;bf=RH; *taller=TRUE; break; case RH: /* 原本右子树比左子树高，需要作右平衡处理 */ RightBalance(T); *taller=FALSE; break; &#125; &#125; &#125; return TRUE;&#125;int main(void)&#123; int i; int a[10]=&#123;3,2,1,4,5,6,7,10,9,8&#125;; BiTree T=NULL; Status taller; for(i=0;i&lt;10;i++) &#123; InsertAVL(&amp;T,a[i],&amp;taller); &#125; return 0;&#125; 最后不得不说，AVL树是在是太复杂了，但是其思想是在是太精妙了，它克服了二叉排序树在查找效率上的不足，通过在插入数据时，就将其变成一个平衡二叉树，从而使其时间复杂度为O(logn)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二叉排序树]]></title>
      <url>%2F2017%2F07%2F27%2FBSTSort_1%2F</url>
      <content type="text"><![CDATA[前言二叉排序树，又称为二分查找树，它或者是一颗空树，或者具有如下性质1.若它的左子树不为空，则左子树上所有结点的值均小于根结点值2.若它的右子树不为空，则右子树上所有结点的值均小于根结点值3.它的左右子树也分别为二叉排序树 二叉排序树查找操作123456789101112131415161718192021222324252627282930typedef struct BiTNode&#123; int data; struct BiTNode *lchild,*rchild;&#125;BiTNode,*BiTree;//递归查找二叉排序树中是否存在key//f指向T的双亲，初始值为NULL//若查找成功，则p指向该节点，并返回true//若查找失败，则p指向查找路径上访问的最后一个结点，并返回FALSEStatus SearchBST(BiTree T,int key,BiTree f,BiTree *p)&#123; if(!T) //查找不成功 &#123; *p=f; return FALSE; &#125; else if(key==T-&gt;data) //查找成功 &#123; *p=T; return TRUE; &#125; else if(key&gt;T-&gt;data)&#123; //在右子树中递归查找 return SearchBST(T-&gt;rchild,key,T,p); &#125; else if(key&lt;T-&gt;data) //在左子树中递归查找 return SearchBST(T-&gt;lchild,key,T,p);&#125; 我们来看看它的过程是如何运行的，比如现在要查找93，显然初始化为SearchBST(T,93,NULL,p),因为93&gt;62，所以递归执行SearchBST(T-rchild,93,T,p),即SearchBST(88,93,62,P)这里用结点data值表示结点，又93&gt;88,继续SearchBST(99,93,88,P)，又93&lt;99，SearchBST(93,93,99,P)，所以93==93，得到最终p=T=93，f=99，查找成功。可以发现二叉排序树的查找算法如此精妙而又优雅 二叉排序树的插入操作插入操作是基于查找操作的，也就是如果该二叉树为空，则新插入点为根结点，如果不为空，在先查找是否存在此元素，存在返回FALSE，否则在查找路径上的最后一个结点，通过比较插入到左孩子还是右孩子，最终返回TRUE12345678910111213141516171819Status InsertBST(BiTree *T,int key)&#123; BiTree p,s; if(!SearchBST(T,key,NULL,&amp;p)) //查找不成功 &#123; s=(BiTree)malloc(sizeof(BiTNode)); s-&gt;data=key; s-&gt;lchild=s-&gt;rchild=NULL; if(!p) //插入s为新的根结点 *T=s; else if(key&lt;s-data) //插入s为左孩子 p-&gt;lchild=s; else //插入s为右孩子 p-&gt;rchild=s; return TRUE; &#125; else //树中已存在此关键字，则不插入 return FALSE;&#125; 二叉排序树的删除操作删除操作需要考虑三种情况，因为删除之后要保证还是一颗二叉排序树。如图一：删除叶子结点，这对这个二叉树来说并无影响，所以不移动其它元素二：删除只含有左子树或者右子树的二叉排序树，因为根据二叉排序树的特点，很明显只要将它的左子树或右子树全部移动到它双亲的左子树或右子树就行了三：删除既有左子树又有右子树的结点，我们可以通过它的中序遍历，也就是让它的直接前驱或者直接后继来替换它的位置，然后直接后继在分三种情况，直至只有一个孩子或者无孩子来替换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Status DeleteBST(BiTree *T,int key) //找到待删结点&#123; if(!*T) return FALSE; else &#123; if(key==(*T)-&gt;data) return Delete(T); else if(key&lt;(*T)-&gt;data) return DeleteBST(&amp;(*T)-&gt;lchild,key); else return DeleteBST(&amp;(*T)-&gt;rchild,key); &#125;&#125;//从二叉树中删除结点p，并重接它的左或右子树Status Delete(BiTree *p)&#123; BiTree q,s; if((*p)-&gt;rchild==NULL) //右子树空则重接它的左子树 &#123; q=*p; *p=(*p)-&gt;lchild; free(q); &#125; else if((*p)-&gt;lchild==NULL) //左子树空则重接它的右子树 &#123; q=*p; *p=(*p)-&gt;rchild; free(q); &#125; else&#123; //左右子树均不为空 q=*p; s=(*p)-&gt;lchild; while(s-&gt;lchild) //找到待删结点的前驱 &#123; q=s; s=s-&gt;rchild; &#125; (*p)-&gt;data=s-&gt;data; if(q!=*p) //重接q的右子树 q-&gt;rchild=s-&gt;lchild; else //重接q的左子树 q-&gt;lchild=s-&gt;lchild; free(s); &#125; return TRUE;&#125; 总结二叉排序树是以链式结构进行存储，所以在插入和删除元素上高效，，但是查找上走的是从根路径到结点的路径，其比较次数与数的层数有关如果该数是一颗斜数，那么查找就会比较很多次，如果该树是一颗完全二叉树，那么比较次数就最优，此时时间复杂度为O(logn),但是平均来说时间复杂度为O(n)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[死锁和生产者消费者问题]]></title>
      <url>%2F2017%2F07%2F26%2Fprocos_1%2F</url>
      <content type="text"><![CDATA[死锁线程同步操作的是同一个线程对象，所以可能造成线程不安全，出现非数据的原子操作，所以，需要加锁，同时线程是程序的执行顺序，也就是cpu根据不同时间片选择某个时间执行某个线程，关于线程并发，在以前的总结中做过了几个简单的总结。而死锁最经典的例子就是哲学家进餐问题，每个哲学家都左手拿着一只筷子，并且总共有五个哲学家，5个筷子，只有当哲学家左右手都有筷子时才能进餐，所以每个哲学家都在等右边哲学家方上筷子，处于僵持等待状态，称为死锁。这里模仿两个线程死锁的情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class LockTest implements Runnable&#123; public int flag=1; static Object o1=new Object(),o2=new Object(); @Override public void run() &#123; System.out.println("flag="+flag); if(flag==1)&#123; synchronized (o1) &#123; try &#123; Thread.sleep(5000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (o2) &#123; System.out.println("1"); &#125; &#125; &#125; if(flag==0)&#123; synchronized (o2) &#123; try &#123; Thread.sleep(5000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (o1) &#123; System.out.println("0"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; LockTest lt1=new LockTest(); LockTest lt2=new LockTest(); lt1.flag=1; lt2.flag=0; Thread t1=new Thread(lt1); Thread t2=new Thread(lt2); t1.start(); t2.start(); &#125;&#125; 结果： flag=1flag=0 大概分析一下，该类本身是一个线程类，flag用来控制执行哪个锁，O1和O2是两个被锁住对象，flag为1时先锁住o1，在锁住o2，flag为0则相反，而死锁发生就在此处两个线程启动了，o1被锁住了，另一个o2被锁住了，都在等待对方释放锁，显然处于僵持，产生死锁，解决死锁的一个简单办法就是增大锁的粒度，扩大锁对象，比如讲前面的O1与O2改成this结果： flag=1flag=010 生产者与消费者概述，模拟一个生产者利用生产食物放到篮子里，而一个消费者从篮子里消费食物123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class Food &#123; //食物类 int id; public Food(int id)&#123; this.id=id; &#125;&#125;public class UtilStack &#123;//工具，用来放食物 int index=0; //食物计数变量 Food[] arrFD=new Food[4]; //最多工具能放食物容量 public synchronized void push(Food fd)&#123; //生产食物，必须加锁，保证生产过程不被打断 while(index==arrFD.length) &#123; try &#123; System.out.println("full"); this.wait(); //生产满了，就去休息区休息，等待被唤醒 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; this.notify();//唤醒当前在休息区的线程 arrFD[index]=fd; index++; &#125; public synchronized Food pop()&#123; //消费 while(index==0) //消费完了，进休息区 try &#123; System.out.println("empty"); this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.notify(); index--; return arrFD[index]; &#125;&#125;public class Producer implements Runnable&#123;//生产者 UtilStack ss=null; Producer(UtilStack ss)&#123; this.ss=ss; &#125; @Override public void run() &#123; for(int i=0;i&lt;20;i++) &#123; Food fd=new Food(i); ss.push(fd); System.out.println("生产了"+fd.id); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;public class Consumer implements Runnable&#123;//消费者 UtilStack ss=null; Consumer(UtilStack ss)&#123; this.ss=ss; &#125; @Override public void run() &#123; for(int i=0;i&lt;20;i++) &#123; Food fd=ss.pop(); System.out.println("消费了"+fd.id); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 消费利用一对生产者和消费者模拟 UtilStack ss=new UtilStack(); Producer p=new Producer(ss); Consumer c=new Consumer(ss); new Thread(p).start(); new Thread(c).start(); 结果如下： 生产了0消费了0生产了1生产了2消费了2生产了3生产了4消费了4生产了5生产了6消费了6生产了7full消费了7生产了8full消费了8生产了9full消费了9生产了10full消费了10生产了11full消费了11生产了12full消费了12生产了13full消费了13生产了14full消费了14生产了15full 这里优于设置了消费者消费时间长，所以导致index不一样。可以发现当生产者满了，生产者不生产了，进入休息区，等待被唤醒，关于wait（）、notify（）、notifyAll（），在之前的多线程总结中已总结了 结果分析从中我们可以看到生产者有满了的情况，但是消费者消费完了，index就不满了，然后就去叫醒了生产者继续生产，同样如果我们把消费者时间设置短一点看看，预测应该是empty的，在被生产者叫醒 生产了0消费了0empty消费了1生产了1empty消费了2生产了2empty消费了3生产了3empty生产了4消费了4empty 最后不得不说生产者与消费者问题可以解决平时在项目开发配置中不求甚解的一些问题，像缓冲区、连接池、消息队列、死锁、同步等等，]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>%2F2017%2F07%2F25%2Fquick_1%2F</url>
      <content type="text"><![CDATA[前言快速排序被列为20世纪十大算法之一，正如其名一样，排序的速度非常快。而它的基本思想就是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续排序，最终达到有序的目的 快速排序采取同样的策略，从计算机的角度看看程序是怎么执行的123456789101112void QuickSort(SqList *L)&#123; QSort(L,1,L-&gt;length);&#125;void QSort(SqList *L,int low,int high)&#123; int pivot; if(low&lt;high)&#123; pivot=Partition(L,low,high);//将L-&gt;r[low..high]一分为二 QSort(L,low,pivor-1); //对低子表递归排序 QSort(L,pivot+1,high); //对高子表递归排序 &#125;&#125; 里面有个函数Partition(L,low,high),和归并排序一样，暂时先不管它，初始化数组为{50,10,90,30,70,40,80,60,20}，初始low=1，high=9；pivot为选择其中一个关键字，比pivot小的排到左边，比pivot大的排到右边，显然此时pivot=5，然后执行 QSort(L，1,4）直至排好序，同样右边也是递归调用QSort（L，6,9），这里的核心算法也就是Partition(L,low,high)如何排序的了1234567891011121314int Partition(SqList *L,int low,int high)&#123; int pivotkey; pivotkey=L-&gt;[low]; //用子表的第一个记录做关键字 while(low&lt;high) &#123; while(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey) high--; swap(L,low,high);//交换low和high的记录 while(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey) low++; swap(L,low,high); &#125; return low;&#125; 同样一行一行的看，这里默认选取子表的第一个记录作为关键字pivotkey=L-&gt;[low];接下来，由于low=1r[high]=L-&gt;r[9]=20与pivotkey=50大小，显然前者小于后者，不满足，将high与low交换，也就是说小的在左边，此时为{20,10,90.。。50},；然后明显20]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[归并排序]]></title>
      <url>%2F2017%2F07%2F24%2Fguibin_1%2F</url>
      <content type="text"><![CDATA[前言归并的意思就是将两个或者两个以上的有序数组合成一个有序表。而归并排序就是将含有n个记录的子序列，每个子序列长度为1，然后两两归并，得到[n/2]个长度为2或者1的有序子序列，在两两归并，。。。。，如此重复，直到得到一个长度为n的有序序列为止 归并排序不妨先看代码，在从计算机角度去看看是如何执行代码过程的123456789101112131415161718void MergeSort(SqList *L)&#123; MSort(L-&gt;r,L-&gt;r,1,L-&gt;length);&#125;//将SR[s..t]归并到TR1[s..t]void MSort(int SR[],int TR1[],int s,int t)&#123; int m; int TR2[MAXSIZE+1]; if(s==t) TR1[s]=SR[s]; else &#123; m=(s+t)/2; MSort(SR,TR2,s,m); MSort(SR,TR2,m+1,t); Merge(TR2,TR1,s,m,t);//将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t] &#125;&#125; 里面有个递归 Merge(TR2,TR1,s,m,t);暂时先不管它，假设模拟的数组为{50,10,90,30,70,40,80,60,20}，所以知道初始化时SR和TR1都是该数组，s=1，t-9；由于s！=t，所以执行else中的语句。此时m=5，也就是正中间下标，所以开始先执行递归MSort(SR,TR2,1,5)，递归过程如下所示其核心部分就是最后都变成叶子结点，递归结束，然后执行if里语句，不过此时TR1[s]=SR[s]，注意这里s是元素下标，所以第一次TR2={50,10}，然后就要执行Merge(TR2,TR1,s,m,t);前面是50与10已结归并了，暂时我们知道它就是把无需归并为有序就行了，即TR2={10,50}后面在详细分析它，接下来同理，依次向上归并，最后得到{10,30,50,70,90}，同理，根结点右子树也一样，最终完成了归并 再来看看Merge(TR2,TR1,s,m,t)函数1234567891011121314151617181920void Merge(int SR[],int TR[],int i,int m,int n)&#123; int j,k,l; for(j=m+1,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++) &#123; if(SR[i]&lt;SR[j]) TR[k]=SR[i++]; else TR[k]=SR[j++]; &#125; if(i&lt;=m)&#123; //将剩余元素归并 for(l=0;l&lt;=m-1;l++) TR[k+1]=SR[i+1]; &#125; if(j&lt;=n) &#123; for(l=0;l&lt;n-j;l++) TR[k+1]=SR[j+1]; &#125;&#125; 就拿{10,30,50,70,90}和{20,40,60,80}归并为有序序列来说，此时i=1，m=5,n=9；进入for循环，此时j从6到9，i由1到5，k由1开始每次加1，并且k就是TR数组的下标，然后开始归并，左右子树的SR[i]=SR[1]=10与SR[j]=SR[6]=20开始比较，将较小数放入到一个初始化时空的TR[]中，比如是10，然后i++；否则j++，这样就可以得到有序序列了，但是最终当j=10时退出循环，而后面还有一些元素未归并，将执行后面if语句，将最后的90复制到最后，最终完成了归并 最后再来看看归并排序的时间复杂度，由于其与完全二叉树有关，最终得到其为O（nlogn)，而它也是比较占用内存但是很稳定的一种算法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java IO简单总结]]></title>
      <url>%2F2017%2F07%2F23%2FIO_1%2F</url>
      <content type="text"><![CDATA[前言在涉及IO流之前需要知道文件的概念。文件是数据源（保存数据的的地方）的一种，比如word文件、txt文件。他既可以保存一张图片，也可以保存视频、声音。。。等等文件流文件在程序中是以流的形式来操作的流：数据在数据源（文件）和程序（内存）之间经历的路径输入流：数据从数据源到内存的路径输出流：数据从内存到数据源的路径 IO流分类1.根据处理数据类型的不同分为：字符流和字节流字节流：可以用于读写二进制文件及任何类型的byte，也就是一个字节一个的读字符流：可以用于读写文本文件，不能操作二进制文件，也就是两个字节两个字节的读2.根据数据流向不同分为：输入流和输出流3。节点流和处理流节点流：直接与数据源相连，读入或读出，可以发现使用该流过于频繁操作硬件，从而使读写很不方便常用的结点流： 父类：InputStream、OutputStream、Reader、Writer文件 ：FileInputStream 、 FileOutputStrean 、FileReader、FileWriter 文件进行处理的节点流数 组 ：ByteArrayInputStream、 ByteArrayOutputStream、 CharArrayReader 、CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）字符串 ：StringReader、 StringWriter 对字符串进行处理的节点流管 道 ：PipedInputStream 、PipedOutputStream 、PipedReader 、PipedWriter 对管道进行处理的节点流 处理流：处理流和节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。常用的处理流： 缓冲流：BufferedInputStrean 、BufferedOutputStream、 BufferedReader、 BufferedWriter 增加缓冲功能，避免频繁读写硬盘转换流：InputStreamReader 、OutputStreamReader实现字节流和字符流之间的转换数据流： DataInputStream 、DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来 文件File类File常用方法 创建：createNewFile()在指定位置创建一个空文件，成功就返回true，如果已存在就不创建，然后返回false。mkdir() 在指定位置创建一个单级文件夹。mkdirs() 在指定位置创建一个多级文件夹。renameTo(File dest)如果目标文件与源文件是在同一个路径下，那么renameTo的作用是重命名， 如果目标文件与源文件不是在同一个路径下，那么renameTo的作用就是剪切，而且还不能操作文件夹。删除：delete() 删除文件或者一个空文件夹，不能删除非空文件夹，马上删除文件，返回一个布尔值。deleteOnExit()jvm退出时删除文件或者文件夹，用于删除临时文件，无返回值。 判断：exists() 文件或文件夹是否存在。isFile() 是否是一个文件，如果不存在，则始终为false。isDirectory() 是否是一个目录，如果不存在，则始终为false。isHidden() 是否是一个隐藏的文件或是否是隐藏的目录。isAbsolute() 测试此抽象路径名是否为绝对路径名。 获取：getName() 获取文件或文件夹的名称，不包含上级路径。getAbsolutePath()获取文件的绝对路径，与文件是否存在没关系length() 获取文件的大小（字节数），如果文件不存在则返回0L，如果是文件夹也返回0L。getParent() 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回null。lastModified()获取最后一次被修改的时间。文件夹相关：static File[] listRoots()列出所有的根目录（Window中就是所有系统的盘符）list() 返回目录下的文件或者目录名，包含隐藏文件。对于文件这样操作会返回null。listFiles() 返回目录下的文件或者目录对象（File类实例），包含隐藏文件。对于文件这样操作会返回null。list(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。listFiles(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。 1234567891011121314151617181920212223242526272829303132333435363738394041 //创建一个文件对象 File f1=new File("e:\\aa.txt"); //得到文件的路径 System.out.println("文件路径"+f1.getAbsolutePath());//得到文件的大小,字节数 System.out.println("文件的大小"+f1.length());//创建文件夹 File f3=new File("e:\\ff"); //判断文件夹是否存在 if(f3.isDirectory())&#123; System.out.println("文件夹存在，不能创建!"); &#125;else&#123; //创建文件夹 f3.mkdir(); &#125; //创建文件和创建文件夹 File f2=new File("e:\\ff\\zwl.txt"); //判断文件是否存在 if(!f2.exists())//可以创建 try &#123; f2.createNewFile();//创建一个新文件 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; else&#123; System.out.println("文件存在，不能创建!"); &#125; //列出一个文件夹下面的所有文件 File f4=new File("e:\\ff"); //判断文件夹是事存在 if(f4.isDirectory())&#123; //将文件夹的文件，传给lists数组 //将文件夹的文件，传给lists数组 File lists[]=f4.listFiles(); //遍历数组 for(int i=0;i&lt;lists.length;i++)&#123; //输出文件夹下所有文件文件名 System.out.println("显示出文件名是"+lists[i].getName()); &#125; &#125; 对应的结果： 文件路径e:\aa.txt文件的大小0显示出文件名是zwl.txt 文件字节与字符流InputStream常用方法 public abstract int read() throws IOException:从输入流中读取数据的下一个字节,到达末尾，返回-1； public int read(byte[] b)throws IOException：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中 public int read(byte[] b,int off,int len)throws IOException：将输入流中最多 len 个数据字节读入 byte 数组 public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源 OutputStream常用方法 public void flush()throws IOException:刷新此输出流并强制写出所有缓冲的输出字节 public abstract void write(int b)throws IOException:将 b.length 个字节从指定的 byte 数组写入此输出流。 public void write(byte[] b, int off, int len)throws IOException:将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流 public void write(byte[] b)throws IOException:将指定的字节写入此输出流。 Reader与Writer和上述方法基本类似，只不过它操作的是字符。123456789101112131415161718192021222324252627int b=0; //FileInputStream in=null; FileReader in=null; FileOutputStream out=null; try &#123; in=new FileReader("E:\\php练习\\readmeFirst.txt"); out=new FileOutputStream("E:\\php练习\\ttl.txt"); &#125; catch (Exception e) &#123; System.out.println("not file"); System.exit(-1); &#125; try &#123; long num=0; while((b=in.read())!=-1)&#123; System.out.print((char)b); //out.write(b);; num++; &#125; in.close(); out.close(); System.out.println(); System.out.println("共读取了"+num+"个字符"); &#125; catch (Exception e) &#123; System.out.println("error!"); System.exit(-1); &#125; System.out.println("copy ok"); 上面程序是将已存在的一个文件复制到另一个文件中 缓冲字节与字符流它是在原来节点流基础上增加了一根管道，用于缓存数据，用法基本类似，但是它的构造函数必须是结点流，同时在字符缓冲流中有一个可以读取或存取字符串的方法如： public String readLine()throws IOException:读取一个文本行 Object流Object流的意思将是像一根节点流插入一根Object流管道，专门操作Object，而它必须实现Serializable接口，该接口的意思是可序列化，就是说将一个对象流序列化成子节流写进网络或者文件，比如说游戏存盘，有各个游戏的记录，如果以面向对象来写进管道，它的各个成员变量，会在内存中被序列化成二进制写进去，而Serializable接口无方法，它只是个标记接口，编译器看到实现该接口的类就知道它应该被序列化，同样有一个transient关键字，是使可序列化的某个属性变成透明，也就是它不能变成字节写进去，那个属性只能为默认属性写进去ok，接下来就来看看Object流相关常用方法 ObjectOutput:有一个void writeObject(Object obj) throws IOException：将对象写入底层存储或流。ObjectInput：Object readObject()throws ClassNotFoundException,IOException：读取并返回对象 最后不得不说IO流是在太复杂，就是一根管道不断套接着另一根管道，但是IO流是非常有用的，不仅能帮助我们了解计算机底层，而且涉及到数据传输都离不开它。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[直接插入和希尔排序]]></title>
      <url>%2F2017%2F07%2F22%2FinserSort_1%2F</url>
      <content type="text"><![CDATA[前言直接插入在本质上改良了之前的冒泡和选择排序，而希尔排序更是超越O（n^2)的传统排序的改良算法 直接插入排序算法描述：直接插入排序就是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表首先先定义数据结构 #define MAXSIZE 10typedef struct{ int r[Maxsize+1]//用于存储要排序的数组，r[0]用作哨兵或者临时变量 int length; //记录顺序表的长度}SqList; 接下来不妨以5个数模拟该算法执行过程 初始化为{0,5,3,4,6,2}从第二个数开始往前比较，如3比5小，那么，3赋值给哨兵，5后移到3位置，哨兵赋值给5位置，此时变成{3,3,5,4,6,2}；继续循环，哨兵初始化为0,4比5小，4给哨兵，5后移至4，在比较哨兵与3大小，如果比3小，3后移，在插入到该位置，否则直接插到5位置，ok这就是该算法的核心，在合适的位置直接插入 码上有戏下面在来看算法，一般理解算法的过程，就把自己当做计算机，自我调试，然后就会发现其中无穷的乐趣12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt; #include &lt;string.h&gt;#include &lt;ctype.h&gt; #include &lt;stdlib.h&gt; #include &lt;io.h&gt; #include &lt;math.h&gt; #include &lt;time.h&gt;#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status; #define MAXSIZE 10000 /* 用于要排序数组个数最大值，可根据需要修改 */typedef struct&#123; int r[MAXSIZE+1]; /* 用于存储要排序数组，r[0]用作哨兵或临时变量 */ int length; /* 用于记录顺序表的长度 */&#125;SqList;void InsertSort(SqList *L)&#123; int i,j; //i用来控制外层循环，也就是r[i]中每个数，j用来控制r[i]与前面的数大小，并插到合适的位置for(i=2;i&lt;=L-&gt;length;i++)&#123; if(L-&gt;r[i]&lt;L-&gt;r[i-1]) //要插的数比前一个数大 &#123; L-&gt;r[0]=L-&gt;r[i]; //要插入的数先放到哨兵 for(j=i-1;L-&gt;r[j]&gt;L-&gt;r[0];j--) //依次比较插入的数前面的数，放到合适的位置 L-&gt;r[j+1]=L-&gt;r[j]; //记录后移 L-&gt;r[j+1]=L-&gt;r[0]; //插入合适的位置 &#125;&#125;&#125;void print(SqList L) //打印元素&#123; int i; for(i=1;i&lt;L.length;i++) printf("%d,",L.r[i]); printf("%d",L.r[i]); printf("\n");&#125;int main()&#123; int i; int d[5]=&#123;5,3,4,6,2&#125;; SqList L; for(i=0;i&lt;5;i++) L.r[i+1]=d[i]; L.r[0]=0; L.length=5; printf("直接插入排序:\n"); InsertSort(&amp;L); print(L);return 0;&#125; 下面在看看它的时间复杂度，最好的情况就是{2,3,4,5,6}，也就是说其本身已经是一个有序的，很显然只需要L-&gt;r[i]与L-&gt;r[r-1]大小，所以此时时间复杂度为O(n);最坏的情况就是{6,5,4,3,2}，即2+3+。。+n为（n+2)(n-1)/2所以最后根据平局原则，知道直接插入排序的时间复杂度为O(n^2); 希尔排序基本有序首先需要了解一下基本有序的概念，就是指小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，如{2,1,3,6,4,7,5,8,9}，但如{1,5,9,3,7,8,2,4,6}这种9在第三位，2在倒数第三位就不叫基本有序 希尔排序的关键就是将相隔某个”增量”的记录组成一个子序列，实现跳跃式的移动 初始一个数组{0,9,1,5,8,3,7,4,6,2}，其中0为哨兵并且初始化增量为数组长度（哨兵不算），所以为9，并约定一个循环，当且仅当增量小于等于1退出循环，并且每次增量都执行增量=增量/3+1（也可以是其他增量原则），第一次就是4了然后一个循环变量i从增量+1开始直到小于等于数组长度，然后比较该i值与i-增量值，也就是第一个值大小，后面就是直接插入算法思想了，有一点不一样，就是循环变量j控制不太一样 然后看看上述数组怎么比较的 第一次：i=增量+1=5开始，也就是3与9比较，明显满足3&lt;9,然后交换（直接插入思想），依次7与1，不交换，4与5交换，6与8交换，2与9交换这里那个j条件也满足并且2&lt;3在交换，ok得到一个交换后的数组{2,1,4,6,3,7,5,8,9}可以发现经过第一轮后，该数组基本有序了紧接着开始进行第二轮，即增量=增量/3+1=2，即从第三个2与4不交换，1与6不交换，4与3交换，6与7不交换，4与5不交换，7与8不交换，5与9不交换，即得到{2,1,3,6,4,7,5,,8,9};最后一轮：增量为1,2与1交换，2与4不交换，然后依次比较，由于目前已经基本有序，所以交换的比较少，最后得到{1,2,3,4,5,6,7,8,9} 码上有戏通过上面的例子，大概就是希尔排序的模拟过程，可以发现增量值是一个很巧妙的地方1234567891011121314151617181920212223242526272829303132333435void ShellSort(SqList *L)&#123; int i,j; int increment=L-&gt;length; //初始化增量为数组长度 do&#123; increment=increment/3+1; //增量序列 for(i=increment+1;i&lt;=L-&gt;length;i++) //从增量序列后一位开始 &#123; if(L-&gt;r[i]&lt;L-&gt;r[i-increment]) //该位置与第一位比较，是否交换 &#123; L-&gt;r[0]=L-&gt;r[i]; //若交换，先放到哨兵位置 for(j=i-increment;j&gt;0&amp;&amp;L-&gt;r[0]&lt;L-&gt;r[j];j-=increment) L-&gt;r[j+increment]=L-&gt;r[j]; //记录后移 L-&gt;r[j+increment]=L-&gt;r[0];//插入到正确位置 &#125; &#125; &#125;while(increment&gt;1);&#125;int main()&#123; int i; int d[5]=&#123;5,3,4,6,2&#125;; SqList L; for(i=0;i&lt;5;i++) L.r[i+1]=d[i]; L.r[0]=0; L.length=5; printf("希尔排序:\n"); ShellSort(&amp;L); print(L); print(L);return 0;&#125; 可以发现希尔排序的关键就是增量的选择，而它的时间复杂度是O(n^(3/2)),显然比传统的算法O(n^2)时间复杂度要小很多]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用集合类简单总结]]></title>
      <url>%2F2017%2F07%2F21%2Fjihes_1%2F</url>
      <content type="text"><![CDATA[前言在没有集合之前我们都是直接用数组存放对象，但是这样操作会很不方便，于是利用数据结构封装了一些列集合，而集合中不存放输几局的基本类型，只存放对象的引用，如图（部分集合源码分析在之前的总结中已经简单研究过）java集合主要分为以下三种类型：Set(集)：集合中的对象不按特定方式排序，且没有重复对象。它的有些实现类能对集合中的对象按照特地方式排序。List(列表)：集合中的对象按照索引位置排序，可以有重复对象，允许使用索引检索对象。Map(映射)：集合中的每一个元素都包含一对键对象和值对象（key-value），集合中的键对象是不能重复的,它的一些实现类能对集合中的键对象进行排序。 注意这里的不能重复与比较hashcode和equals有关 集合底层概述Collection接口Collection接口是Set、List、Queue接口的父接口，提供了多数集合常用的方法声明，包括 add()、remove()、contains() 、size() 、iterator() 等 List接口它的特点是有序可重复，使用此接口能够精确的控制每个元素插入的位置用户能够使用索引来访问List中的元素并且允许有可重复的元素 ArrayList底层实现是一个动态的数组，查询快，增删慢，线程不安全，效率高 LinkedList底层实现是一个双向循环链表，查询慢，增删快，线程不安全，效率较高 Vector是ArrlyList的线程安全版，底层同它基本一致，但是效率低，现在基本很少用 Set接口它的特点就是唯一性并且不允许出现重复元素和是无序的 hashSet底层是基于哈希表实现的，而其核心就是先比较hashCode（）值是否相同（相当于索引），然后在用equals比较是否相同，从而确定元素是否重复，所以当不希望集合中有重复值，并且不关心元素之间的顺序时可以使用此类 LinkedHashSet底层实现是使用链表和哈希表，它由链表保证元素有序，哈希表保证元素唯一，因此当不希望集合中有重复值，并且希望按照元素的插入顺序进行迭代遍历时可采用此类 TreeSet底层实现是红黑树，也就是一种平衡AVL树，通过比较返回值是否是0来保证元素唯一性，并且通过自然排序来保证元素的排序（自然排序也就是让元素所属的类实现Comparable接口，比如abc排在abd前面，总之就是和插入顺序无关，只和元素本身的内容和特质有关） Queue接口它的特点就是队列，即用于保存将要执行的任务列表 LinkedList实现了该接口，可以实现先进先出的队列 PriorityQueue底层采用某种排序的单链表存储队列元素，用来创建自然排序的优先级队列 Map接口Map关心的是唯一的标识符，也就是将唯一的键映射到某个元素，以键值对形式存储，键唯一，值可重复 HashMap底层实现是基于哈希表依赖于hashCode（）和equals（）方法，线程不安全，允许key和value为NULL，效率高 HashtableHashMap的线程安全版，效率低，不允许key和value为NULL LinkedHashMap底层是由链表和哈希表组成，链表保证元素有序，哈希表保证元素唯一，所以当需要键值对，并且关心插入顺序时可采用它 TreeMap底层是由红黑树实现，当需要键值对，并关心元素的自然排序时可采用它 Collections内置了一些常见的集合算法，像排序，查找算法等 如何选择哪种集合1 首先看是否是键值对形式 是的话就选择Map 然后再看是否需要排序： 是的话就是TreeMap 不是的话就是HashMap 一般情况下都使用HashMap 不是键值对的话就选择Collection 再看元素是否唯一： 是的话就选set 元素是否需要排序 是的话就选TreeSet 反之选择HashSet 一般情况选择HashSet 不是元素唯一就选List 再看是否是否需要线程安全： 是的话就选Vector 不是的话就选择ArrayList或者LinkedList 增删选择：LinkedList 查询选择ArrayList 一般情况下都选择ArrayList 集合常见方法Collection的常见方法 1，添加。 boolean add(Object obj): boolean addAll(Collection coll):2，删除。 boolean remove(object obj): boolean removeAll(Collection coll); void clear();3，判断： boolean contains(object obj): boolean containsAll(Colllection coll); boolean isEmpty():判断集合中是否有元素。4，获取： int size(): Iterator iterator():取出元素的方式：迭代器。 5，其他： boolean retainAll(Collection coll);取交集。 Object[] toArray():将集合转成数组。 Map的常见方法 1，添加。 value put(key,value):返回前一个和key关联的值，如果没有返回null. 2，删除。 void clear():清空map集合。 value remove(key):根据指定的key翻出这个键值对。 3，判断。 boolean containsKey(key): boolean containsValue(value): boolean isEmpty(); 4，获取。 value get(key):通过键获取值，如果没有该键返回null。 当然可以通过返回null，来判断是否包含指定键。 int size(): 获取键值对的个数。5.特殊方法： Collection values() 包含的值的 Collection 视图。 Set]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[String与StringBuffer常用方法总结]]></title>
      <url>%2F2017%2F07%2F20%2FStringBuf_1%2F</url>
      <content type="text"><![CDATA[前言String与StringBuffer的区别，简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。 String常用方法在之前的数据结构与算法中已经模拟了部分String常用的方法 public final class Stringextends Objectimplements Serializable, Comparable, CharSequence 构造方法 public String()：初始化一个新创建的 String 对象，使其表示一个空字符序列。注意，由于 String 是不可变的，所以无需使用此构造方法。 public String(String original）：创建一个String对象为original的拷贝 public String(char[] value)：用一个字符数组创建一个String对象 public String(char[] value, int offset,int count)：用一个字符数组从offset项开始的count个字符序列创建一个String对象 普通方法 public char charAt(int index):返回字符串中第index个字符 public int length():返回字符串的长度 public int indexOf(String str):返回字符串中出现str的第一个位置 public int indexOf(String str,int fromIndex):返回字符串中从fromIndex开始起出现str的第一个位置 public boolean equalsIgnoreCase(String another):比较字符串与another是否一样（忽略大小写） public String replace(char oldChar,char newChar):在字符串中用newChar替换oldChar public boolean startWith(String prefix):判断字符串是否以prefix字符串开头 public boolean endsWith(String suffix):判断字符串是否以suffix为结尾 public String toLowerCase():返回一个字符串为该字符串的小写形式 public String substring(int beginIndex):返回该字符串从beginIndex开始到结尾的字符串 public String substring(int beginIndex,int endIndex):返回该字符串从beginIndex开始到endIndex结尾的字符串 public String trim():返回将该字符串去掉开头和结尾空格后的字符串 静态重载方法 public static String valueOf(..):将基本类型数据转化为字符串，如 public static String valueOf(double d) 其它常用方法 public String[] split(String regix):可以将一个字符串按照指定的分隔符分隔，返回分隔后的字符串数组public String concat(String str)//将参数中的字符串str连接到当前字符串的后面，效果等价于”+”；contains(String str)//判断参数s是否被包含在字符串中，并返回一个布尔类型的值。字符串转换为基本类型java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：1)public static byte parseByte(String s)2)public static short parseShort(String s)3)public static short parseInt(String s)4)public static long parseLong(String s)5)public static float parseFloat(String s)6)public static double parseDouble(String s) 字符串比较 1)public int compareTo(String anotherString)//该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。2)public int compareToIgnore(String anotherString)//与compareTo方法相似，但忽略大小写。3)public boolean equals(Object anotherObject)//比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。4)public boolean equalsIgnoreCase(String anotherString)//与equals方法相似，但忽略大小写。 StringBuffer常用方法构造方法 StringBuffer() ：构造一个没有任何字符的StringBuffer类。StringBuffer(int length) ：：构造一个没有任何字符的StringBuffer类，并且，其长度为length。StringBuffer(String str) ：以str为初始值构造一个StringBuffer类。 append方法为该对象添加字符序列，返回添加后的该对象引用，同时是调用了toString方法转化为字符串 StringBuffer append(boolean b) StringBuffer append(char c) StringBuffer append(char[] str) StringBuffer append(char[] str, int offset, int len) StringBuffer append(double d) StringBuffer append(float f) StringBuffer append(int i) StringBuffer append(long l) StringBuffer append(Object obj) StringBuffer append(String str) StringBuffer append(StringBuffer sb) 其他方法 12.int capacity() ：返回当前StringBuffer对象（字符串缓冲区）的总空间，而非字符号串的长度。 char charAt(int index) ：在当前StringBuffer对象中取索引号为index的字符。第一个字符的索引为“0” StringBuffer delete(int start, int end) ：删除当前StringBuffer对象中以索引号start开始，到end结束的子串。 StringBuffer deleteCharAt(int index) ：删除当前StringBuffer对象中索引号为index的字符。 void ensureCapacity(int minimumCapacity) ：重新设置字符号串缓冲区的总空间。如果minimumCapacity大于当前的总空间，则新的空间被设置：一种结果是minimumCapacity；另一种结果是{“老空间”乘2加2}17.void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) ：从当前StringBuffer对象的索引号srcBegin开始，到srcEnd结束的子串，赋值到字符数组dst中，并且从dst的索引号dstBegin开始 int indexOf(String str) ：返回当前StringBuffer对象中，第一个满足str子串的位置。 int indexOf(String str, int fromIndex) ：从当前StringBuffer对象的fromIndex开始查找，返回第一个满足str子串的位置。 StringBuffer insert(int offset, boolean b) StringBuffer insert(int offset, char c) StringBuffer insert(int offset, char[] str) StringBuffer insert(int index, char[] str, int offset, int len) StringBuffer insert(int offset, double d) StringBuffer insert(int offset, float f) StringBuffer insert(int offset, int i) StringBuffer insert(int offset, long l) StringBuffer insert(int offset, Object obj) StringBuffer insert(int offset, String str) int lastIndexOf(String str) ：返回当前StringBuffer对象中，最后一个满足str子串的位置。 int lastIndexOf(String str, int fromIndex) ：从当前StringBuffer对象的fromIndex开始查找，返回最后一个满足str子串的位置。 int length() ：返回当前StringBuffer对象（字符缓冲区）中，字符串的长度。注意：此方法与capacity() 不同。 StringBuffer replace(int start, int end, String str) ：替换当前StringBuffer对象的字符串。从start开始，到end结束的位置替换成str。 StringBuffer reverse() ：将字符串翻转。 void setCharAt(int index, char ch) ：设置索引号index的字符为ch。 void setLength(int newLength) ：重新设置字符串缓冲区中字符串的长度，如果newLength小于当前的字符串长度，将截去多余的字符。 String substring(int start) ：取当前StringBuffer对象中，从start开始到结尾的子串。 String substring(int start, int end) ：取当前StringBuffer对象中，从start开始到end的子串。 String toString() ：将当前StringBuffer对象转换成String对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Brute-Force与KMP算法]]></title>
      <url>%2F2017%2F07%2F19%2Fsuanfa_2%2F</url>
      <content type="text"><![CDATA[前言设有两个串：目标串target和模式串pattern，在目标串中查找与模式串pattern相等得一个子串并确定孩子串位置的操作称为串的模式匹配。而匹配的结果有两种，如果target中存在等于pattern的子串，则匹配成功，给出孩子串在target中的位置，否则匹配失败 Brute-Force算法算法描述：如图，该算法的核心就是在target中从begin位置，这里begin=0开始，比较ti与pi是否相等，如果有一个不相等，则begin开始从之前的下一个字符开始匹配，同时pattern中退回到第一个字符，在依次比较，知道存在相等字符，返回相应位置，可以发现该算法是一个回溯算法。123456789101112131415161718192021222324252627//模式匹配，pattern为待匹配子串，begin为起始匹配位置public int indexOf(MyString pattern,int begin)&#123; //待匹配子串不为空并且长度大于0和目标串大于等于带匹配子串 if(pattern!=null&amp;&amp;pattern.length()&gt;0&amp;&amp;this.length()&gt;=pattern.length()) &#123; int i=begin,j=0; //记录i为开始位置，j为待匹配子串计数器 while(i&gt;this.length())&#123; //目标串全部匹配完，退出 if(this.charAt(i)==pattern.charAt(j))//如果，有字符相等 &#123; i++; //计数器都加1，并且开始比较后一个字符 j++; &#125; else&#123; i=i+j+1; //i回溯，变成上一个目标串匹配字符的下一个字符 j=0; //待匹配字符，回溯为0 &#125; if(j==pattern.length()) return i-j; //返回匹配到的位置 &#125; &#125; return -1; //匹配失败&#125;//返回当前目标串的首次位置，从第一个位置开始public int indexOf(MyString pattern)&#123; return this.indexOf(pattern, 0);&#125; 模式匹配应用一般我们要替换或者删除相关子串时，首先就是查找是否存在此串，然后在进行相关操作首先是替换操作12345678910111213141516171819//返回当前串替换之后的串public MyString replaceFirst(MyString pattern,MyString replacement)&#123; int i=this.indexOf(pattern, 0);//找到要替换串的下标 if(i==-1) return this; //不存在要替换的部分，返回当前串 //连接三个串 return this.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length())); &#125;public MyString replaceAll(MyString pattern,MyString replacement)&#123; MyString temp=new MyString(this); int i=this.indexOf(pattern, 0); while(1!=-1) &#123; temp=temp.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length())); i=temp.indexOf(pattern, i+replacement.length());//从下一个字符开始继续寻找匹配 &#125; return temp;&#125; 注意，String是不变类型，也就是一个新的字符串是在堆栈上又开辟了一个新空间，不是原来的对象下面是删除操作12345678910111213141516public MyString deleteFirst(MyString target,MyString pattern)&#123; int i=target.indexOf(pattern); if(i==-1) return target; return target.substring(0, i)+target.substring(i+pattern.length());&#125;public MyString deleteAll(MyString target,MyString pattern)&#123; int i=target.indexOf(pattern); while(i!=-1) &#123; target=target.substring(0, i)+target.substring(i+pattern.length()); i=target.indexOf(pattern, i); &#125; return target;&#125; 核心思想就是先模式匹配，然后在构造一个新的串 最后分析一下该模式匹配算法，假设模式串长度为m，可以发现他的时间复杂度为O(m);并且匹配中存在很多重复，所以算法效率是很低的 KMP算法由之前的算法我们知道，它存在重复匹配，如之前的pattern=abc，此时p的各个字符都不相等，而在匹配时target=ababdabcd中，第一次从a匹配，到第三位不等，开始从第二位匹配，但由于第一次已经知道pi各位不等，所以第二位就不用匹配了，他肯定与第一位不等，所以可省略，而这恰恰是KMP算法的核心 next数组next数组的作用就是研究pattern串，依次确定如果不匹配下一次target串从哪一位开始匹配。并且这样定义next数组 next[J]=-1，当j=0；next[j]=k 当0&lt;=k&lt;f时且使p_0..p_k-1=p_j-k..p_j-1的最大整数 如图：pattern=”abcabc”，当j=0时，next[0]=-1；当j=1,2,3时，”a”,”ab”,”abc”都没有相同前缀子串和后缀子串next[j]=k=0；当j=4时，”abca”钟相同的前缀子串和后缀子串是”a”，所以k=1；当j=5时，为”ab”，所以k=2，依次类推123456789101112131415161718private int[] getNext(String pattern)&#123; //求next int j=0,k=-1; //初始化j，k，next int[] next=new int[pattern.length()]; next[0]=-1; while(j&lt;pattern.length()-1) //当j遍历完pattern字符串，结束 &#123; if(k==-1||pattern.charAt(j)==pattern.charAt(k)) //k为初始值或者pattern的后缀字符与前缀相同 &#123; j++; //j后移，k加一，同时第j个字符的next值为k k++; next[j]=k; &#125; else //否则，k重新回到前缀值，继续比较 k=next[k]; return next; &#125; return next; &#125; 下面是KMP的算法12345678910111213141516171819public int indexOf(String target,String pattern,int begin)&#123; if(pattern!=null&amp;&amp;pattern.length()&gt;0&amp;&amp;this.length()&gt;=pattern.length()) &#123; int i=begin,j=0; int[] next=getNext(pattern); //求得next数组，这样就可以避免一些重复比较了 while(i&lt;target.length())&#123; if(j==-1||target.charAt(i)==pattern.charAt(j)) &#123; i++; j++; &#125; else j=next[j]; //退回到next[J]个字符开始比较 if(j==pattern.length()) return i-j; &#125; &#125; return -1; &#125; 改进的KMP算法当target=”aaaabcde”时，pattern=”aaaax”时，发现，a重复了，按照之前的算法，当i=5时，有重复比较四个a，所以可改进如图：改进的nextval是在next数组基础上，这里约定的next初始值为-1，所以如j=3，与next[j]+1比较，如果相等，则其值等于next[j]+1的next值，否则，保持原next值不变123456789101112131415161718192021private int[] getNext(String pattern)&#123; int j=0,k=-1; int[] next=new int[pattern.length()]; next[0]=-1; while(j&lt;pattern.length()-1) &#123; if(k==-1||pattern.charAt(j)==pattern.charAt(k)) &#123; j++; k++; if(pattern.charAt(j)!=pattern.charAt(k))//改进之处 next[j]=k; else next[j]=next[k]; &#125; else k=next[k]; return next; &#125; return next; &#125; 由此发现KMP算法的时间复杂度为O(n);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[冒泡与选择排序]]></title>
      <url>%2F2017%2F07%2F18%2Fsuanfa_1%2F</url>
      <content type="text"><![CDATA[冒泡排序算法描述：冒泡排序是一种交换排序，它的基本思想就是两两比较相邻的关键字，如果反序则交换，直到没有反序的记录为止就像冒泡一样，第一次先把最大的选出来冒到最后，依次类推，从下个继续冒最大的1234567891011public static void bubbleSort(int a[])&#123; int temp; //临时变量，用于交换 for(int i=a.length-1;i&gt;0;i--) //外层循环，用于控制需要冒泡的个数 for(int j=0;j&lt;=i-1;j++) //内存循环 if(a[j]&gt;a[j+1]) //如果需要交换，则交换 &#123; temp=a[j+1]; a[j+1]=a[j]; a[j]=temp; &#125; &#125; 可以看出这个冒泡的实现是很简单的，但是效率上存在严重问题，比如有序数列2,1,3,4,5这个除了第一个，其余都已经是有序了，但是根据算法还是不断循环，比较增加了冗余，所以需要改进1234567891011121314public static void bubbleSort(int a[])&#123; int temp; boolean flag=true; //用来作为标记 for(int i=a.length-1;i&gt;0&amp;&amp;flag;i--)&#123; //如果flag为false，也就是已经有序了，退出 flag=false; //初始化为false for(int j=0;j&lt;=i-1;j++) if(a[j]&gt;a[j+1]) &#123; temp=a[j+1]; a[j+1]=a[j]; a[j]=temp; flag=true; //如果有数据交换，则设为true &#125;&#125;&#125; 显然从效率上提高了许多，由内外循环次数可以得出其时间复杂度为o(n^2) 选择排序算法描述：选择排序就是通过n-i此关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换1234567891011121314151617public static void ChooseSort(int[] a)&#123; int min,temp; //分别为每一次循环的当前最小变量和临时变量 for(int i=0;i&lt;a.length;i++)&#123; min=i; //初始化最小变量，为当前循环的第一个变量 for(int j=i+1;j&lt;a.length;j++) &#123; if(a[j]&lt;a[i]) //找到比当前循环的最小变量小的记录，并记录下标 min=j; &#125; if(min!=i) //如果有比当前最小变量小，则交换记录 &#123; temp=a[min]; a[min]=a[i]; a[i]=temp; &#125; &#125;&#125; 可以看出它的时间复杂度仍然是O(n^2) 约瑟夫环的另一种解法至于问题描述就不描述了，在之前的数据结构总结中已经有了这个问题的描述123456789101112131415161718192021222324252627public static void Count3Quit()&#123; boolean[] arr=new boolean[500]; //初始化500个人围成圈 for(int i=0;i&lt;arr.length;i++) //假设每个人值都为true arr[i]=true; int len=arr.length; //记录总人数 int index=0; //记录每个人的索引 int count=0; //记录数数变量，这里是数三退一 while(len&gt;1)//直到只剩最后一个人为止 &#123; if(arr[index]==true) //人还在圈内 &#123; count++; //数数加一 if(count==3) //数到三时，退一个人 &#123; count=0; //计数重置为0 arr[index]=false; //该人退出 len--; //总人数减一 &#125; &#125; index++; //索引加一 if(index==arr.length)//索引超出人数长度，循环从0开始 index=0; &#125; for(int i=0;i&lt;arr.length;i++)//输出最后一个人 if(arr[i]==true) System.out.println(i); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java异常处理二]]></title>
      <url>%2F2017%2F07%2F17%2Fyc_2%2F</url>
      <content type="text"><![CDATA[前言通过一已经初步了解了异常的一些原理和相关性质，当然在平时写程序时被各种各样的异常类型弄得叫苦不堪 java常见异常从api文档中可以看出，java已经为我们内置了很多异常先来看看RuntimeException中常见异常 1java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 2、java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。 3、java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等 4、java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 5、java.lang.NegativeArraySizeException 数组长度为负异常 6、java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常 7、java.lang.SecurityException 安全性异常 8、java.lang.IllegalArgumentException 非法参数异常 IOException IOException：操作输入流和输出流时可能出现的异常。 EOFException 文件已结束异常 FileNotFoundException 文件未找到异常 其他异常 ClassCastException 类型转换异常类 ArrayStoreException 数组中包含不兼容的值抛出的异常 SQLException 操作数据库异常类 NoSuchFieldException 字段未找到异常 NoSuchMethodException 方法未找到抛出的异常 NumberFormatException 字符串转换为数字抛出的异常 StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常 IllegalAccessException 不允许访问某类异常 InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常 自定义异常在Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。 所有异常都必须是 Throwable 的子类。 如果希望写一个检查性异常类，则需要继承 Exception 类。 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。 如下1234567891011121314151617181920212223242526272829303132333435363738394041public class MyException extends Exception&#123; private int id; public MyException()&#123; &#125; public MyException(String msg,int id)&#123; super(msg); this.id=id; &#125; public int getId()&#123; return this.id; &#125; &#125;public class Ttest &#123; public void regist(int num) throws MyException&#123; if(num&lt;0)&#123; throw new MyException("不能为负数",404); &#125; System.out.println("it is"+num); &#125; public void manager()&#123; try &#123; regist(-10); &#125; catch (MyException e) &#123; System.out.println("Error Code"+e.getId()); e.printStackTrace(); &#125; System.out.println("over"); &#125; public static void main(String args[])&#123; Ttest t=new Ttest(); t.manager(); &#125;&#125; 如果有异常时运行结果如下： com.test.QQ.MyException: 不能为负数 at com.test.QQ.Ttest.regist(Ttest.java:6) at com.test.QQ.Ttest.manager(Ttest.java:12) at com.test.QQ.Ttest.main(Ttest.java:21)Error Code404over 将regist（-10）改为regist（10），如下 it is10over spring异常处理前面我们都是用try..catch来捕获异常，造成业务逻辑较多，而spring通过注解式使捕获异常更方便。核心如下： @ExceptionHandler：统一处理某一类异常，从而能够减少代码重复率和复杂度 @ControllerAdvice：异常集中处理，更好的使业务逻辑与异常处理剥离开 @ResponseStatus：可以将某种异常映射为HTTP状态码 @ExceptionHandler源码如下： @Target({ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ExceptionHandler { Class&lt;? extends Throwable&gt;[] value() default {}; } 首先是注解的说明： @Retention: 定义注解的保留策略@Retention(RetentionPolicy.SOURCE) //注解仅存在于源码中，在class字节码文件中不包含@Retention(RetentionPolicy.CLASS) // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，@Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到 @Target：定义注解的作用目标@Target(ElementType.TYPE) //接口、类、枚举、注解@Target(ElementType.FIELD) //字段、枚举的常量@Target(ElementType.METHOD) //方法@Target(ElementType.PARAMETER) //方法参数@Target(ElementType.CONSTRUCTOR) //构造函数@Target(ElementType.LOCAL_VARIABLE)//局部变量@Target(ElementType.ANNOTATION_TYPE)//注解@Target(ElementType.PACKAGE) ///包 @Document：说明该注解将被包含在javadoc中@Inherited：说明子类可以继承父类中的该注解 该注解作用对象为方法，并且在运行时有效，value()可以指定异常类方法返回值可以为： ModelAndView对象 Model对象 Map对象 View对象 String对象 还有@ResponseBody、HttpEntity&lt;?&gt;或ResponseEntity&lt;?&gt;，以及void 如 @ControllerAdvice //在所有的controller中执行该异常public class DefaultExceptionHandler { /** * 没有权限 异常 * &lt;p/&gt; * 后续根据不同的需求定制即可 */ @ExceptionHandler({UnauthorizedException.class}) //不同的异常处理 @ResponseStatus(HttpStatus.UNAUTHORIZED) public String processUnauthenticatedException(NativeWebRequest request, UnauthorizedException e) { System.out.println(&quot;un&quot;); return null; } @ExceptionHandler(RuntimeException.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public String handleUnexpectedServerError(RuntimeException ex) { System.out.println(&quot;500&quot;); return null; } @ExceptionHandler(ServletException.class) @ResponseStatus(value = HttpStatus.NOT_FOUND) public String handleNotFoundError() { System.out.println(&quot;404&quot;); return null; } } 如上的500和404错误，先给出错误的异常，在给出错误的状态码并且异常与状态码必须是对应的，该类的源码在org.springframework.http下，如 public enum HttpStatus {成功 OK(200, “OK”), 创建 CREATED(201, “Created”), /接受 ACCEPTED(202, “Accepted”), BAD_REQUEST(400, “Bad Request”), 没有认证权限 UNAUTHORIZED(401, “Unauthorized”), PAYMENT_REQUIRED(402, “Payment Required”), 禁止 FORBIDDEN(403, “Forbidden”), NOT_FOUND(404, “Not Found”), 有了上述全局处理的异常，就不许要在每个类里面重复写了，同时如果我们是在页面中需要捕获异常，如页面的404和500，只需在web.xml中配置一下（在spring配置文件中注入无效，也不知道怎么回事），如下： 404 /404.jsp 500 /500.jsp]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java异常处理一]]></title>
      <url>%2F2017%2F07%2F16%2Fyc_1%2F</url>
      <content type="text"><![CDATA[前言不得不说，我们平时在写程序时遇到最多的情形或者最头疼的事情就是遇到异常，然后各种调试，各种方法用尽最后才解决它，那么异常主要分为几类，每个类又有什么特征了（如图）从大的角度说主要分成两类：Error类代表了编译和系统的错误，不允许捕获，也就是我们自己无法主动去处理它；Exception类代表了我们可捕获并且可自己可处理异常，而Exception有包括两类，一个是你必须要处理的异常，如某个类有throws异常了，在未进入运行期就必须处理，另一类就是Runtime Exception（运行期异常），就是只有在运行时（也就是编译成class文件）时才知道，这个异常可处理或不处理 处理异常机制在java应用程序中，异常处理机制主要为两种:抛出异常和捕获异常抛出异常简单的说，就是不处理异常，将异常不断抛给上一级，直至某一级有有处理异常措施，一般用throws、throw如 public readFile() throws IOException{ throw new xxx();} 捕获异常定义是这样说的，在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。一般有try..catch语句块，其语法格式如下： try { // 可能会发生异常的程序代码 } catch (Type1 id1){ // 捕获并处置try抛出的异常类型Type1 } catch (Type2 id2){ //捕获并处置try抛出的异常类型Type2 } 如果，不管异常有没有捕获，都要执行某段代码，如数据库查询后都要关闭等等，就可以用finally，上面修改 try { // 可能会发生异常的程序代码 } catch (Type1 id1){ // 捕获并处置try抛出的异常类型Type1 } catch (Type2 id2){ //捕获并处置try抛出的异常类型Type2 } finally{ //必须执行的代码 } try-catch-finally 规则try块：用于捕获异常。其后可接0个或多个catch块，如果没有catch块，则必须跟一个finally块 catch块：用于处理try捕获到的异常。 finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行： 1）在finally语句块中发生了异常。2）在前面的代码中用了System.exit()退出程序。3）程序所在的线程死亡。4）关闭CPU。 try..catch..拥有执行顺序，即第一个catch之后，后面不在执行catch，所以一般将较详细的catch放在最前面，如先捕获IOException在捕获Exception throws规则1) 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。 2）必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误 3)仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出 4）调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。如下 void method1() throws IOException{} //合法 //编译错误，必须捕获或声明抛出IOException void method2(){ method1(); } //合法，声明抛出IOException void method3()throws IOException { method1(); } //合法，声明抛出Exception，IOException是Exception的子类 void method4()throws Exception { method1(); } //合法，捕获IOException void method5(){ try{ method1(); }catch(IOException e){…} } //编译错误，必须捕获或声明抛出Exception void method6(){ try{ method1(); }catch(IOException e){throw new Exception();} } //合法，声明抛出Exception void method7()throws Exception{ try{ method1(); }catch(IOException e){throw new Exception();} } 这里需要注意的是throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象 Throwable类源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286/** * * Throwable是所有Error和Exceptiong的父类 * 注意它有四个构造函数: * Throwable() * Throwable(String message) * Throwable(Throwable cause) * Throwable(String message, Throwable cause) * */ public class Throwable implements Serializable &#123; private static final long serialVersionUID = -3042686055658047285L; /** * Native code saves some indication of the stack backtrace in this slot. */ private transient Object backtrace; /** * 描述此异常的信息 */ private String detailMessage; /** * 表示当前异常由那个Throwable引起 * 如果为null表示此异常不是由其他Throwable引起的 * 如果此对象与自己相同,表明此异常的起因对象还没有被初始化 */ private Throwable cause = this; /** * 描述异常轨迹的数组 */ private StackTraceElement[] stackTrace; /** * 构造函数,起因对象没有被初始化可以在以后使用initCause进行初始化 * fillInStackTrace可以用来初始化它的异常轨迹的数组 */ public Throwable() &#123; fillInStackTrace(); &#125; /** * 构造函数 */ public Throwable(String message) &#123; //填充异常轨迹数组 fillInStackTrace(); //初始化异常描述信息 detailMessage = message; &#125; /** * 构造函数,cause表示起因对象 */ public Throwable(String message, Throwable cause) &#123; fillInStackTrace(); detailMessage = message; this.cause = cause; &#125; /** * 构造函数 */ public Throwable(Throwable cause) &#123; fillInStackTrace(); detailMessage = (cause==null ? null : cause.toString()); this.cause = cause; &#125; /** * 获取详细信息 */ public String getMessage() &#123; return detailMessage; &#125; /** * 获取详细信息 */ public String getLocalizedMessage() &#123; return getMessage(); &#125; /** * 获取起因对象 */ public Throwable getCause() &#123; return (cause==this ? null : cause); &#125; /** * 初始化起因对象,这个方法只能在未被初始化的情况下调用一次 */ public synchronized Throwable initCause(Throwable cause) &#123; //如果不是未初始化状态则抛出异常 if (this.cause != this) throw new IllegalStateException("Can't overwrite cause"); //要设置的起因对象与自身相等则抛出异常 if (cause == this) throw new IllegalArgumentException("Self-causation not permitted"); //设置起因对象 this.cause = cause; //返回设置的起因的对象 return this; &#125; /** * 字符串表示形式 */ public String toString() &#123; String s = getClass().getName(); String message = getLocalizedMessage(); return (message != null) ? (s + ": " + message) : s; &#125; /** * 打印出错误轨迹 */ public void printStackTrace() &#123; printStackTrace(System.err); &#125; /** * 打印出错误轨迹 */ public void printStackTrace(PrintStream s) &#123; synchronized (s) &#123; //调用当前对象的toString方法 s.println(this); //获取异常轨迹数组 StackTraceElement[] trace = getOurStackTrace(); //打印出每个元素的字符串表示 for (int i=0; i &lt; trace.length; i++) s.println("\tat " + trace[i]); //获取起因对象 Throwable ourCause = getCause(); //递归的打印出起因对象的信息 if (ourCause != null) ourCause.printStackTraceAsCause(s, trace); &#125; &#125; /** * 打印起因对象的信息 * @param s 打印的流 * @param causedTrace 有此对象引起的异常的异常轨迹 */ private void printStackTraceAsCause(PrintStream s, StackTraceElement[] causedTrace) &#123; //获得当前的异常轨迹 StackTraceElement[] trace = getOurStackTrace(); //m为当前异常轨迹数组的最后一个元素位置, //n为当前对象引起的异常的异常轨迹数组的最后一个元素 int m = trace.length-1, n = causedTrace.length-1; //分别从两个数组的后面做循环,如果相等则一直循环,直到不等或数组到头 while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(causedTrace[n])) &#123; m--; n--; &#125; //相同的个数 int framesInCommon = trace.length - 1 - m; //打印出不同的错误轨迹 s.println("Caused by: " + this); for (int i=0; i &lt;= m; i++) s.println("\tat " + trace[i]); //如果有相同的则打印出相同的个数 if (framesInCommon != 0) s.println("\t... " + framesInCommon + " more"); //获得此对象的起因对象,并递归打印出信息 Throwable ourCause = getCause(); if (ourCause != null) ourCause.printStackTraceAsCause(s, trace); &#125; /** * 打印出错误轨迹 */ public void printStackTrace(PrintWriter s) &#123; synchronized (s) &#123; s.println(this); StackTraceElement[] trace = getOurStackTrace(); for (int i=0; i &lt; trace.length; i++) s.println("\tat " + trace[i]); Throwable ourCause = getCause(); if (ourCause != null) ourCause.printStackTraceAsCause(s, trace); &#125; &#125; /** * 打印起因对象的信息 */ private void printStackTraceAsCause(PrintWriter s, StackTraceElement[] causedTrace) &#123; // assert Thread.holdsLock(s); // Compute number of frames in common between this and caused StackTraceElement[] trace = getOurStackTrace(); int m = trace.length-1, n = causedTrace.length-1; while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(causedTrace[n])) &#123; m--; n--; &#125; int framesInCommon = trace.length - 1 - m; s.println("Caused by: " + this); for (int i=0; i &lt;= m; i++) s.println("\tat " + trace[i]); if (framesInCommon != 0) s.println("\t... " + framesInCommon + " more"); // Recurse if we have a cause Throwable ourCause = getCause(); if (ourCause != null) ourCause.printStackTraceAsCause(s, trace); &#125; /** * 填充异常轨迹 */ public synchronized native Throwable fillInStackTrace(); /** * 返回当前的异常轨迹的拷贝 */ public StackTraceElement[] getStackTrace() &#123; return (StackTraceElement[]) getOurStackTrace().clone(); &#125; /** * 获取当前的异常轨迹 */ private synchronized StackTraceElement[] getOurStackTrace() &#123; //如果第一次调用此方法则初始化异常轨迹数组 if (stackTrace == null) &#123; //获得异常轨迹深度 int depth = getStackTraceDepth(); //创建新的异常轨迹数组,并填充它 stackTrace = new StackTraceElement[depth]; for (int i=0; i &lt; depth; i++) stackTrace[i] = getStackTraceElement(i);//获取指定位标的异常轨迹 &#125; return stackTrace; &#125; /** * 设置异常轨迹 */ public void setStackTrace(StackTraceElement[] stackTrace) &#123; //拷贝设置参数 StackTraceElement[] defensiveCopy = (StackTraceElement[]) stackTrace.clone(); //如果设置参数有空元素则抛出异常 for (int i = 0; i &lt; defensiveCopy.length; i++) if (defensiveCopy[i] == null) throw new NullPointerException("stackTrace[" + i + "]"); //设置当前对象的异常轨迹 this.stackTrace = defensiveCopy; &#125; /** * 异常轨迹的深度,0表示无法获得 */ private native int getStackTraceDepth(); /** * 获取指定位标的异常轨迹 */ private native StackTraceElement getStackTraceElement(int index); private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; getOurStackTrace(); s.defaultWriteObject(); &#125; &#125; 以上源码分析来自于互联网，同时由于目前是jdk1.8和这个源码有一小部分不一样，但不影响整体分析。当然，我们真正关心的是他的下面几个方法 e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息: getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。 getMeage()：返回异常的消息信息。 printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。而当我们出现异常时，就形成一条异常链，一个一个堆栈的打印出相关信息和异常]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二分查找]]></title>
      <url>%2F2017%2F07%2F15%2Fsjjg_10%2F</url>
      <content type="text"><![CDATA[前言查找操作，通俗的讲，就是给定一个值key，在一个数据结构中找出关键字为key的元素。而基于线性表的查找算法有顺序查找（O（n）），二分查找和分块查找 二分查找主要用于已排序的顺序表算法描述：假定顺序表已按照升序排列，从表的中间位置开始比较，如果当前元素的关键字等于给定值，则查找成功，否则，若给定的值小于当前元素关键字，则在表的前半段继续查找，反之，在后半段查找，以此重复，直到获得查找结果 12345678910111213141516171819202122public class BSArray &#123; //在升序排列的数组中，若找到关键字，则返回相应下标，否则返回-1 public static&lt;T&gt; int binarySearch(Comparable&lt;T&gt;[] value,T key)&#123; return binarySearch(value,0,value.length-1,key); &#125; public static&lt;T&gt; int binarySearch(Comparable&lt;T&gt;[] value,int begin,int end,T key)&#123; if(key!=null) while(begin&lt;=end)&#123; //边界有效 int mid=(begin+end)/2; //中间位置，当前比较元素位置 System.out.println(value[mid]+"?"); if(value[mid].compareTo(key)==0) //对象比较大小 return mid; //查找成功 if(value[mid].compareTo(key)&gt;0) end=mid-1; //缩小到前半段 else begin=mid+1; //缩小到后半段 &#125; return -1; //查找不成功 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hash散列表]]></title>
      <url>%2F2017%2F07%2F14%2Fsjjg_9%2F</url>
      <content type="text"><![CDATA[前言散列（hash）表是一种支持高效的查找、插入和删除操作的数据结构，它是针对查找效率接近O（1）而专门设计的。它根据元素的关键字确定元素的存储位置，而其中主要解决两个问题，设计散列函数和处理冲突 散列函数在数据元素的关键字和该元素的存储位置之间建立一种对应关系，称为散列函数，而由散列函数决定元素存储位置的存储结构称为散列表，散列函数声明为 public int hash(int key) //散列函数，确定关键字为key元素的散列地址 散列函数实质上是关键字集合到地址集合的映射，如果这种映射是一一对应的，则查找效率是O（1），但是由于散列表是一个压缩映射，即存储容量有限，即映射关系是多对一的映射，所以会产生冲突 冲突设两个关键字k1和k2（k1！=k2），如果有hash（k1）=hash（k2），即它们的散列值相同，表示不同关键字的多个元素映射到同一个存储位置，称为冲突，如图，所设的关键字序列是（1,4,3,11,12,6,14,74,16,96），元素个数是10，关键字范围是0~99，如果散列值的容量是100，很明显是一对一不会产生冲突，但是空间利用率此时只有10%，如果容量是10或者20，冲突差生的频率会减少 除留余数法该散列函数定义为hash（k）=k%p，函数结果范围为0~p-1，图示就是采用这种方法，而p取值为小于散列表长度的最大素数，如散列表长度分别为8,16,128，则对应的p（最大素数）分别为7,13,127 冲突处理开放定址法当产生冲突时，开放定址法在散列表内寻找另一个位置存储冲突的元素，如利用线性探查发实现，即设一个元素关键字为k，其散列地址为i=hash（k），若散列表中i位置已存储元素，则产生冲突，探测下一个位置i+1是否为空，。。直到找到一个空位置，但是它的缺陷就是在散列表内处理冲突，使得一个存储地址i可被任意一个元素抢占，这样就破坏了散列函数i=hash（k）的规则 链地址法该方法是将多个冲突的元素存储在一条单链表中（称为同义词单链表），如图示而对链地址法表进行插入、删除、查找等操作主要分两步完成1.计算元素的散列函数值2.根据元素的散列函数值，对某一条同义词单链表进行插入、删除和查找操作规定查找成功的平均查找长度为（根据图示）ASL=(91+32)/12并且有如下结论：1.查找操作的时间复杂度为O（m），其中m为一条痛一次单链表的长度，插入操作为O(1),删除操作为O(m) 模拟HashSet类这里同义词单链表采用单链表123456789101112131415161718192021222324252627282930313233343536373839404142public class HashSet&lt;T&gt; &#123; private SinglyLinkenList&lt;T&gt;[] table; //散列表，同义词单链表对象数组 public HashSet(int size)&#123; //构造指定容量的散列表 this.table=new SinglyLinkenList[Math.abs(size)]; for(int i=0;i&lt;table.length;i++) table[i]=new SinglyLinkenList&lt;T&gt;(); &#125; public HashSet()&#123; //构造最大质数为97的容量 this(97); &#125; private int hash(T x)&#123; //散列函数，确定关键字为key元素的散列地址 int key=Math.abs(x.hashCode()); //每个对象的hashcode（）方法返回散列码，并且每个对象不同 return key%table.length; //出留余数法，除数是散列表长度 &#125; public void insert(T x)&#123;//插入x元素 table[hash(x)].insert(0, x); &#125; public void remove(T x)&#123; //删除x元素 table[hash(x)].remove((Integer) x); &#125; public T search(T key)&#123; //返回查找到的关键字为key元素，查找不成功返回null return table[hash(key)].search(key); &#125; public boolean contain(T key)&#123; //判断散列表是否包含关键字为key元素 return this.search(key)!=null; &#125; public String toString()&#123; String str=""; for(int i=0;i&lt;table.length;i++) //遍历各同义词单链表 if(!table[i].isEmpty()) str+=table[i].toString()+"\n"; return str; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树和二叉树]]></title>
      <url>%2F2017%2F07%2F13%2Fsjjg_8%2F</url>
      <content type="text"><![CDATA[前言树是数据元素（结点）之间具有层次关系的非线性结构。在树结构中，除根以外的结点只有一个前驱结点，可以有零至多个后继结点，根结点没有前驱结点 基本术语1.父母、孩子、兄弟结点2.度（结点所拥有的子树数目），如A的度为33.结点的层次（结点处于树中的位置，约定根结点层次为1），树的高度（树中结点的最大层次数）如图中树高度为34.边（设X结点是y结点的父母结点，有序对（X，y）称为这两个结点的边，路径如A到E结点，表示为（A，B，E），路径长度（路径上的边数）为25.无序数与有序树（区别子树之间有没有次序）6.森林（删除根结点） 二叉树性质二叉树最多有两颗子树，分别为左右子树性质1：若根结点的层次为1，则二叉树第i层最多有2^(i-1)(i&gt;1)个结点性质2：在高度为h的二叉树中，最多有2^h-1个结点（h&gt;=0)性质3：设一棵二叉树的叶子结点数为n0,2度结点数为n2，则n0=n2+1性质4：一颗具有n个结点的完全二叉树，其高度为h=[log以2为底数n为参数]+1；其中[]是高斯取整函数性质5：一颗具有n个结点的完全二叉树，对序号为i（0&lt;=i0，则i的父母结点序号为[(i+1)/2]2.若2i+1&lt;n，则i的左孩子结点序号为2i+1；否则无左孩子3.若2i+2&lt;n，则i的右孩子结点序号为2i+2，否则i无右孩子 二叉树的遍历规则孩子优先遍历二叉树的遍历是按照一定规则和次序访问二叉树中的所有结点，并且每个结点仅被访问一次，同时遍历二叉树访问结点的次序是线性的。1.先根次序：访问根结点，遍历左子树，遍历右子树（124536）2.中根次序：遍历左子树，访问根结点，遍历右子树（425136）3.后根次序：遍历左子树，遍历右子树，访问根结点（452631） 兄弟优先遍历该遍历是按照层次进行的，遍历历程是从根结点开始，逐层深入，从左至右依次访问完当前层的所有结点，在访问下一层 二叉树抽象数据类型和存储结构顺序存储结构二叉树的顺序存储结构仅适用于完全二叉树和满二叉树，如图所示。根据之前的性质，可以实现对应关系一一对应个。而对于非完全二叉树，如果采取顺序存储，可以将其补成一个完全二叉树，对于空结点利用特殊符号代替，但是会造成空间浪费，并且线性映射关系不明确 链式存储结构二叉链表采用两条链分别连接左右孩子结点，每个结点有三个域：data存储数据元素，left、right分别指向左右孩子结点三叉链表在二叉链表基础上增加一条链parent连接父母结点 二叉链表结点12345678910111213141516171819public class BinaryNode&lt;T&gt; &#123; public T data; //数据域，存储数据元素 public BinaryNode&lt;T&gt; left,right; //链域，分别指向左、右孩子结点 public BinaryNode(T data,BinaryNode&lt;T&gt; left,BinaryNode&lt;T&gt; right)&#123; this.data=data; this.left=left; this.right=right; &#125; public BinaryNode(T data)&#123; this(data,null,null); &#125; public BinaryNode()&#123; this(null,null,null); &#125;&#125; 抽象数据类型12345678910111213141516public interface BinaryTTree&lt;T&gt; &#123; boolean isEmpty(); //判断二叉树是否为空 int count(); //返回二叉树的结点个数 int height(); //返回二叉树的高度 void preOrder(); //先根次序遍历二叉树 void inOrder(); //中根次序遍历二叉树 void postOrder(); //后根次序遍历二叉树 void levelOrder(); //按层次遍历二叉树 BinaryNode&lt;T&gt; search(T key); //查找并返回首次出现关键字为key元素结点 BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; node); //返回node的父母结点 void insertRoot(T x); //插入元素x作为根结点 BinaryNode&lt;T&gt; insertChild(BinaryNode&lt;T&gt; p,T x,boolean leftChild); //插入孩子节点 void removeChild(BinaryNode&lt;T&gt; p,boolean leftChild); //删除p结点的左或右子树 void removeAll(); //删除二叉树&#125; 下面是其实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class BinaryTree&lt;T&gt; implements BinaryTTree&lt;T&gt;&#123; public BinaryNode&lt;T&gt; root; //根结点，结点结构为二叉链表 public BinaryTree()&#123; //构造空二叉树 this.root=null; &#125; public boolean isEmpty() &#123; //判断二叉树是否为空 return this.root==null; &#125; public int count() &#123; return count(root); &#125; public int count(BinaryNode&lt;T&gt; p)&#123; //返回以p结点为根的子树的结点个数 if(p==null) return 0; return 1+count(p.left)+count(p.right); &#125; public int height() &#123; return height(root); &#125; public int height(BinaryNode&lt;T&gt; p)&#123; if(p==null) return 0; int lh=height(p.left); //返回左子树高度 int rh=height(p.right); //返回右子树高度 return (lh&gt;=rh)?lh+1:rh+1; //当前子树高度为较高子树高度加1 &#125; public void preOrder() &#123; System.out.println("先根次序遍历二叉树: "); preOrder(root); System.out.println(); &#125; public void preOrder(BinaryNode&lt;T&gt; p)&#123; if(p!=null) &#123; System.out.println(p.data.toString()+" ");//访问当前结点 preOrder(p.left); //按先根次序遍历当前结点左子树，递归调用 preOrder(p.right); //按先根次序遍历当前结点右子树，递归调用 &#125; &#125; public void inOrder() &#123; System.out.println("中根次序遍历二叉树 : "); inOrder(root); System.out.println(); &#125; public void inOrder(BinaryNode&lt;T&gt; p)&#123; if(p!=null) &#123; inOrder(p.left); System.out.println(p.data.toString()+" "); inOrder(p.right); &#125; &#125; public void postOrder() &#123; System.out.println("后根次序遍历二叉树 : "); inOrder(root); System.out.println(); &#125; public void postOrder(BinaryNode&lt;T&gt; p)&#123; if(p!=null)&#123; postOrder(p.left); postOrder(p.right); System.out.println(p.data.toString()+" "); &#125; &#125; public void levelOrder() &#123; // TODO Auto-generated method stub &#125; public BinaryNode&lt;T&gt; search(T key) &#123; return search(root,key); &#125; public BinaryNode&lt;T&gt; search(BinaryNode&lt;T&gt; p,T key) &#123; if(p==null||key==null) return null; if(p.data.equals(key)) //查找成功，返回找到结点 return p; BinaryNode&lt;T&gt; find=search(p.left,key);//在左子树中查找，递归调用 if(find==null) find=search(p.right,key);//左子树中未找到，在右子树中继续递归查找 return find; &#125; public BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; node) &#123; if(root==null||node==null||node==root) return null; return getParent(root,node); &#125; public BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; p,BinaryNode&lt;T&gt; node) &#123; if(p==null) return null; if(p.left==node||p.right==node) return p; BinaryNode&lt;T&gt; find=getParent(p.left,node); if(find==null) find=getParent(p.right,node); return find; &#125; public void insertRoot(T x) &#123; root=new BinaryNode&lt;T&gt;(x, root, null); &#125; //插入元素x作为p结点的孩子，若leftChild为true,插入结点作为左孩子，否则作为右孩子 public BinaryNode&lt;T&gt; insertChild(BinaryNode&lt;T&gt; p,T x,boolean leftChild)&#123; if(p==null||x==null) return null; if(leftChild) &#123; p.left=new BinaryNode&lt;T&gt;(x, p.left, null);//插入x作为p的左孩子，p原左孩子变为x左孩子 return p.left; &#125; p.right=new BinaryNode&lt;T&gt;(x,null,p.right); //插入x结点作为p的右孩子 return p.right; &#125; public void removeChild(BinaryNode&lt;T&gt; p, boolean leftChild) &#123; if(p!=null) if(leftChild) p.left=null; else p.right=null; &#125; public void removeAll() &#123; this.root=null; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[优先队列与递归]]></title>
      <url>%2F2017%2F07%2F12%2Fsjjg_7%2F</url>
      <content type="text"><![CDATA[前言如果按照队列的特点，即先来先服务原则，在很多情况下不能实现相关设计，比如操作系统中的进程调度管理，就是按照优先级大小来进行调度 优先队列若一个队列中的每个元素都有一个优先级，每次出队的是具有优先级最高的元素，则称该队列为优先队列1234567891011121314151617181920212223242526public class PriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; implements QQueue&#123; private SortedSinglyLinkedList&lt;T&gt; list; //使用排序单链表存储队列元素 public PriorityQueue()&#123; //构造空队列 this.list=new SortedSinglyLinkedList&lt;T&gt;(); &#125; public boolean isEmpty() &#123; //判断队列是否为空 return list.isEmpty(); &#125; public void enqueue(Object x) &#123; //元素x入队，根据元素大小插入在单链表适当位置 list.insert(x); &#125; public Object dequeue() &#123;//出队，返回对头元素 return list.remove(0); &#125; public String toString()&#123; return list.toString(); &#125;&#125; 进程按优先级调度管理12345678910111213141516171819public class Process implements Comparable&lt;Process&gt;&#123; private String name; //进程名 private int priority; //优先级 public Process(String name, int priority) &#123; super(); this.name = name; this.priority = priority; &#125; public int compareTo(Process o) &#123;//比较两个进程的大小，约定进程排队次序的规则 return this.priority-o.priority; &#125;&#125; 递归从形式上，递归的定义可如下所示同时递归定义必须满足以下两个条件1.边界条件：至少有一条初始定义是非递归的。2.递归通式： 由已知函数值逐步递推计算出未知函数值 递归算法是指直接或者间接调用自身的算法如用递归算法求fibonacci数列1234567891011121314151617public class Factorial &#123; public static int factorial(int n) &#123; if(n&lt;0) throw new IllegalArgumentException("n="+n); if(n==0||n==1) return n; return factorial(n-1)+factorial(n-2); &#125; public static void main(String args[])&#123; for(int i=0;i&lt;=24;i++) System.out.print(factorial(i)+" "); &#125;&#125; 运行结果： 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 再如将之前的SinglyLinkenList类增加一个复制方法，采用递归法12345678910private Node&lt;T&gt; copy(Node&lt;T&gt; p)&#123; Node&lt;T&gt; q=null; //新结点 if(p!=null) //要复制的结点非空 &#123; q=new Node&lt;T&gt;(p.data,null); //相当于q.data=p.data，q.next=null q.next=copy(p.next);//递归，q1.data=p.next.data，q1.next=null，先返回q1，q.next=q1 //可以看成一棵二叉树 &#125; return q;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[顺序与链式队列]]></title>
      <url>%2F2017%2F07%2F11%2Fsjjg_6%2F</url>
      <content type="text"><![CDATA[前言队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行。特点是先进先出。 队列抽象数据类型其中，像队列中插入元素的过程称为入队（enqueue），删除元素的过程称为出队（dequeue），允许入队的一端称为队尾（rear），允许出队的一头称为对头（front），没有元素的队列称为空队列1234567public interface QQueue&lt;T&gt; &#123; boolean isEmpty(); //判断队列是否为空 void enqueue(T x); //元素x入队 T dequeue(); //出队，返回对头元素 &#125; 顺序队列顺序队列使用数组存储数据元素1.当队列空时，设置队头、队尾下标front=rear=-1，2.当第一个元素入队时，front=rear=0，同时改变两个下标3.进行入队、出队操作，front、rear随之变化4.当入队的元素个数（包括已出队元素）超出数组容量时，rear下标越界，数据溢出，但是，由于之前已有若干元素出队，数组前部以空出许多存储单元，所以这种溢出并不是因为存储空间不够而产生的，称为假溢出 所以顺序队列有两个缺点：假溢出和存储单元没有重复使用机制 顺序循环队列相比较顺序队列，有如下不同1.队头、队尾元素按照如下循环规律变化，其中length表示数组长度front=（front+1)%length;rear=(rear+1)%length;所以可以看出front和rear的取值范围为0~length-1； 2.约定rear是下一个入队元素位置，队列空条件是front==rear，即入队只改变rear，出队只改变front3.约定队列满条件是队列中仍然有一个空位置，即front==（rear+1）%length， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class SeqQueue&lt;T&gt; implements QQueue&lt;T&gt;&#123; private Object element[]; //存储队列数据元素的数组 private int front,rear; //分别为对头和队尾元素 public SeqQueue(int length)&#123; //构造容量为length的空队列 if(length&lt;64) length=64; this.element=new Object[Math.abs(length)]; this.front=this.rear=0; &#125; public SeqQueue()&#123; //构造默认容量空队列 this(64); &#125; public boolean isEmpty() &#123; //判断队列是否为空 return this.front==this.rear; &#125; public void enqueue(T x) &#123; //元素x入队，空对象不能入队 if(x==null) return; if(this.front==(this.rear+1)%this.element.length) //当队满时，扩充容量 &#123; Object[] temp=this.element; this.element=new Object[temp.length*2]; int i=this.front,j=0; while(i!=this.rear)&#123; //按照队列元素次序复制数组元素 this.element[j]=temp[i]; i=(i+1)%temp.length; j++; &#125; this.front=0; this.rear=j; &#125; this.element[this.rear]=x; this.rear=(this.rear+1)%this.element.length; &#125; public T dequeue() &#123; //出队，返回队头元素，若队列空则返回null if(isEmpty()) return null; T temp=(T)this.element[this.front]; this.front=(this.front+1)%this.element.length; //取得队头元素 return temp; &#125;&#125; 链式队列以不带头结点的单链表实现链式队列，设指针front和rear分别指向队头和队尾结点，初始空队列的状态设置为front=rear=null；队列空条件是front==null&amp;&amp;rear==null 12345678910111213141516171819202122232425262728293031323334public class LinkedQueue&lt;T&gt; implements QQueue&lt;T&gt;&#123; private Node&lt;T&gt; front,rear; //分别指向队头和队尾 public LinkedQueue()&#123; //构造空队列 this.front=this.rear=null; &#125; public boolean isEmpty() &#123; //判断队列是否为空 return this.front==null&amp;&amp;this.rear==null; &#125; public void enqueue(T x) &#123; //元素x入队，空对象入队 if(x==null) return; Node&lt;T&gt; q=new Node&lt;T&gt;(x,null); if(this.front==null) this.front=q; //空队入队 else this.rear.next=q; //插入在队尾之后 this.rear=q; &#125; public T dequeue() &#123; //出队，返回对头元素，若队列元素为空，返回null if(isEmpty()) return null; T temp=this.front.data; //取得队头元素 this.front=this.front.next; //删除队头结点 if(this.front==null) this.rear=null; return temp; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[栈]]></title>
      <url>%2F2017%2F07%2F10%2Fsjjg_5%2F</url>
      <content type="text"><![CDATA[前言栈是一种特殊的线性表，其特殊之处在于插入和删除操作的位置受到限制，而且插入和删除只允许在线性表的一端进行，特点是后进先出 栈抽象数据类型其中允许操作的一端为栈顶（top），不允许操作的一端为栈底（bottom），栈中插入元素的操作称为入栈（push），删除元素的操作为出栈（pop），没有元素的栈称为空栈 1234567public interface SStack&lt;T&gt; &#123; boolean isEmpty(); //判断是否为空栈 void push(T x); //元素x入栈 T pop(); //出栈，返回当前栈顶元素 T get(); //取栈顶元素，未出栈&#125; 顺序栈采用顺序存储结构的栈称为顺序栈12345678910111213141516171819202122232425262728293031323334353637383940414243public class SeqStack&lt;T&gt; implements SStack&lt;T&gt;&#123; private Object element[]; //存取栈数据元素的数组 private int top; //栈顶元素下标 public SeqStack(int size)&#123; //构造容量为size的空栈 this.element=new Object[Math.abs(size)]; this.top=-1; &#125; public SeqStack()&#123; //构造默认容量的空栈 this(64); &#125; public boolean isEmpty() &#123; //判断栈是否为空 return this.top==-1; &#125; public void push(T x) &#123; //元素x入栈，空对象不能入栈 if(x==null) return; if(this.top==element.length-1) //栈满，扩充栈容量 &#123; Object[] temp=this.element; this.element=new Object[temp.length*2]; for(int i=0;i&lt;temp.length;i++) this.element[i]=temp[i]; &#125; this.top++; this.element[this.top]=x; &#125; public T pop() &#123; //出栈 return this.top==-1?null:(T)this.element[this.top--]; &#125; public T get() &#123; //取栈顶元素 return this.top==-1?null:(T)this.element[this.top]; &#125;&#125; 如上，push（），pop（），get（）方法的时间复杂度为O（1），而需要扩充容量时，复杂度为O（n）； 链式栈采用链式存储结构的栈称为链式栈，这里采用单链表 12345678910111213141516171819202122232425262728293031public class LinkedStack&lt;T&gt; implements SStack&lt;T&gt;&#123; private Node&lt;T&gt; top; //栈顶结点 public LinkedStack()&#123; //构造空栈 this.top=null; &#125; public boolean isEmpty() &#123; //判断栈是否为空 return this.top==null; &#125; public void push(T x) &#123; if(x!=null) this.top=new Node(x, this.top); //头插入，x结点作为新的栈顶结点 &#125; public T pop() &#123; //出栈，返回栈顶元素 if(this.top==null) return null; T temp=this.top.data; this.top=this.top.next; return temp; &#125; public T get() &#123; return this.top==null?null:this.top.data; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[串之字符串]]></title>
      <url>%2F2017%2F07%2F09%2Fsjjg_4%2F</url>
      <content type="text"><![CDATA[前言串是由n(n&gt;=0)个字符组成的有限序列，它是一种特殊的线性表。而子串是指串s中任意连续字符组成的一个子序列组成的串。同时，串的比较通常由其字符编码的相关规则比较 常量字符串String字符串采用字符数组作为存储结构，并且采用顺序存储结构，不过String类一次性申请了固定的空间，同时由于其存储结构为最终型，所以string不提供删除，插入子串如下是模仿String类的部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public final class MyString implements Comparable&lt;MyString&gt;,Serializable&#123; private final char[] value; //字符数组，只能赋值一次 public MyString()&#123; //构造一个空串 this.value=new char[0]; &#125; public MyString(String original)&#123; //将字符串常量变成字符数组 this.value=original.toCharArray(); &#125; //以value数组中构造从begin开始的count个字符的字符串对象 public MyString(char[] value,int begin,int count)&#123; this.value=new char[count]; for(int i=begin;i&lt;begin+count;i++) this.value[i]=value[i]; &#125; //以value数组中字符构造字符串 public MyString(char[] value)&#123; this(value,0,value.length); &#125; public MyString(MyString str)&#123;//复制对象 this(str.value); &#125; public int length()&#123; //返回字符串长度 return this.value.length; &#125; public char charAt(int i)&#123; //返回第i个字符 if(i&lt;0||i&gt;=this.value.length) throw new StringIndexOutOfBoundsException(i); return this.value[i]; &#125; public String toString()&#123; return new String(this.value); &#125; public MyString concat(MyString str)&#123; //返回当前串与指定串str连接生成的新串 if(str==null||str.length()==0) //要连接的串为空时，返回当前串 return this; char[] buffer=new char[this.value.length+str.length()]; int i; for(i=0;i&lt;this.value.length;i++) //复制当前串 buffer[i]=this.value[i]; for(int j=0;j&lt;str.value.length;j++) //复制指定串 buffer[i+j]=str.value[j]; return new MyString(buffer); //以字符数组构造串 &#125; public int compareTo(MyString o) &#123; // TODO Auto-generated method stub return 0; &#125;&#125; 由上述模拟过程知道，有四种构造方法构造串对象 MyString s1=new MyString(); MyString s2=new MyString(“abc”); char[] letters={a,b,c,d} MyString s3=new MyString(“letters); MyString s4=new MyString(s3); 此外在数组复制时，java提供了两种方法 java.lang.System.arraycopy(value,0,this.value,0,value.length); this.value=java.util.Arrays.copyOf(value,value.length) 求字串 123456789101112131415161718public MyString substring(int begin,int end)&#123;//返回传中从begin到end-1的子串 if(begin&lt;0) begin=0; if(end&gt;this.value.length) end=this.value.length; if(begin&gt;end) throw new StringIndexOutOfBoundsException(end-begin); if(begin==0&amp;&amp;end==this.value.length) return this; char[] buffer=new char[end-begin]; for(int i=0;i&lt;buffer.length;i++) buffer[i]=this.value[i+begin]; return new MyString(buffer);&#125;public MyString substring (int begin)&#123;//返回串中序号从begin到末尾的子串 return substring(begin,this.value.length);&#125; 比较串相等与大小 12345678910111213141516171819202122public boolean equals(Object obj)&#123; if(this==obj) return true; if(obj instanceof MyString) &#123;MyString str=(MyString)obj; if(this.value.length==str.value.length)&#123; for(int i=0;i&lt;this.value.length;i++) if(this.value[i]!=str.value[i]) return false; return true;&#125;&#125;return false;&#125;//返回两个字符串之间的差值，返回0表示相等public int compareTo(MyString o) &#123; for(int i=0;i&lt;this.value.length&amp;&amp;i&lt;o.value.length;i++) if(this.value[i]!=o.value[i]) return this.value[i]-o.value[i]; //返回两串第一个不同字符的差值 return this.value.length-o.value.length;&#125; 变量字符串StringBuffer该字符数组的容量总是大于串长，并且能够修改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MyStringBuffer implements Serializable&#123; private char[] value; //字符数组 private int len; //串长度 public MyStringBuffer(int size)&#123; //构造指定容量的空串 this.value=new char[size&lt;16?16:size]; this.len=0; &#125; public MyStringBuffer()&#123; //以默认容量构造空串 this(16); &#125; public MyStringBuffer(String str)&#123; //以字符串常量构造对象 this(str.length()+16); &#125; public int length()&#123; return this.len; &#125; public synchronized char charAt(int i)&#123; if(i&lt;0||i&gt;=this.len) throw new StringIndexOutOfBoundsException(i); return this.value[i]; &#125; public void setCharAt(int i,char ch)&#123; if(i&lt;0||i&gt;=this.len) throw new StringIndexOutOfBoundsException(i); this.value[i]=ch; &#125; public synchronized MyStringBuffer insert(int i,MyStringBuffer str)&#123; if(i&lt;0) i=0; if(i&gt;this.len) i=this.len; if(str==null) return this; char temp[]=this.value; if(this.value.length-this.len&lt;str.len) //当前容量不足，自动扩充 &#123; this.value=new char[this.value.length+str.len*2]; for(int j=0;j&lt;i;j++) //复制当前串前i-1个字符 this.value[j]=temp[j]; &#125; for(int j=i;j&lt;this.len;j++) this.value[str.len+j]=temp[j];//从i开始向后移动j个字符 for(int j=0;j&lt;str.len;j++) //复制字符串str this.value[i+j]=str.value[j]; this.len+=str.len; return this; &#125; public synchronized MyStringBuffer delete(int begin,int end)&#123; if(begin&gt;0) begin=0; if(end&gt;this.len) end=this.len; if(begin&gt;end) throw new StringIndexOutOfBoundsException(end-begin); for(int i=0;i&lt;this.len-end;i++) //从end开始至串尾的子串向前移动 this.value[begin+1]=this.value[end+i]; this.len=end-begin; return this; &#125; public synchronized String toString()&#123; return new String(this.value,0,this.len); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线性表之双链表]]></title>
      <url>%2F2017%2F07%2F08%2Fsjjg_3%2F</url>
      <content type="text"><![CDATA[前言双链表的每个结点有两个地址域，分别指向它的前驱结点和后继结点 双链表双链表的结点声明如下12345678910111213141516public class DLinkNode&lt;T&gt; &#123; public T data; //数据元素 public DLinkNode&lt;T&gt; prev,next; //prev指向前驱结点，next指向后继结点 public DLinkNode(T data, DLinkNode&lt;T&gt; prev, DLinkNode&lt;T&gt; next) &#123; super(); this.data = data; this.prev = prev; this.next = next; &#125; public DLinkNode()&#123; this(null,null,null); &#125;&#125; 若带头结点的双链表为空双链表，则有head.next=null&amp;&amp;head.prev=null; 若p指向双链表中非两端的某个结点，则有p=p.next.prev=p.prev.next; 循环双链表如果双链表的最后一个结点的next链指向头结点，头结点的prev链指向最后一个结点，则称为循环双链表，对于空双链表有head.next=head&amp;&amp;head.prev=head下面是循环双链表CirDoublyLinkedList的实现类只有插入和删除和单链表不一样12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class CirDoublyLinkedList&lt;T&gt; implements LList&lt;T&gt;&#123; public DLinkNode&lt;T&gt; head; public CirDoublyLinkedList()&#123; this.head=new DLinkNode&lt;T&gt;(); this.head.prev=head; this.head.next=head; &#125; public void insert(int i, T x) &#123;//将x对象插入在序号为i的结点 if(x==null) return; DLinkNode&lt;T&gt; p=this.head; for(int j=0;p.next!=this.head&amp;&amp;j&lt;i;j++) //寻找插入位置 p=p.next; //循环停止时，p指向第i-1个结点 DLinkNode&lt;T&gt; q=new DLinkNode&lt;T&gt;(x,p,p.next);//插入在p结点之后 p.next.prev=q; p.next=q; &#125; public void append(T x) &#123; if(x==null) return; DLinkNode&lt;T&gt; q=new DLinkNode&lt;T&gt;(x,head.prev,head); head.prev.next=q; //插入在头结点之前，相当于尾插入 head.prev=q; &#125; public T remove(int i) &#123; if(i&gt;0) &#123; DLinkNode&lt;T&gt; p=this.head.next; for(int j=0;p!=head&amp;&amp;j&lt;i;j++) //定位到待删除结点 p=p.next; if(p!=head) &#123; T old=p.data; //获得原对象 p.prev.next=p.next; //删除p结点自己 p.next.prev=p.prev; return old; &#125; &#125; return null; &#125; public void removeAll() &#123; this.head.prev=head; this.head.next=head; &#125; 。。。其余方法和单链表一样]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线性表之单链表]]></title>
      <url>%2F2017%2F07%2F07%2Fsjjg_2%2F</url>
      <content type="text"><![CDATA[前言线性表的链式存储是用若干地址分散的存储单元存储数据元素，逻辑上相连的数据元素在物理位置上不一定相连，必须采用附加信息表示数据元素之间的关系，并且存储单元至少包含两部分-数据域和地址域 单链表单链表中结点只有一个地址并且指向后继结点 单链表结点类Node声明如下1234567891011121314public class Node&lt;T&gt; &#123; //单链表结点类 public T data; //数据域，保存数据元素 public Node&lt;T&gt; next; //地址域，引用后继结点 public Node(T data,Node&lt;T&gt; next)&#123; this.data=data; this.next=next; &#125; public Node()&#123; this(null,null); &#125;&#125; 由于java不支持指针类型，但提供引用方式保存包括地址在内的结构化信息通常通过node结点建立两个结点之间的链接，如p结点的下一个结点是q结点 Node p=new Node(‘A’,null); Node q=new Node(‘B’,null); p.next=q; 单链表的头指针head也是一个结点引用 Node head=null; 当head==null时，为空单链表 单链表的遍历操作 遍历单链表是指从第一个结点开始，沿着结点的next链，依次访问单链表中的每个结点，并且每个结点只访问一次 Node p=head;while(p!=null){ p=p.next;} 单链表的插入操作 对单链表进行插入操作，只要该表节点间的链接关系，不需要移动数据元素空表插入/头插入 if(head==null) head=new Node(x,null); //空表插入 else{ Node q=new Node(x,null); //头插入 q.next=head; } 中间插入 若p指向非空单链表的某个结点，在p结点之后插入q结点 &lt; Node q=new Node(x,null);q.next=p.next; //q的后继结点应是p的原后继结点p.next=q; //q作为p的后继结点 尾插入 单链表的删除操作 删除单链表的指定结点，只需改变结点的next域 头删除 head=head.next; 中间/尾删除 if(p.next!=null) p.next=p.next.next; 单链表实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139public class SinglyLinkenList&lt;T&gt; implements LList&lt;T&gt; &#123; public Node&lt;T&gt; head; //头指针 public SinglyLinkenList()&#123; //构造空链表 this.head=new Node&lt;T&gt;(); &#125; public SinglyLinkenList(T[] element)&#123;//尾插入构造单链表 this(); Node&lt;T&gt; rear=this.head; //指向单链表最后一个结点 for(int i=0;i&lt;element.length;i++)&#123; rear.next=new Node&lt;T&gt;(element[i],null); //尾插入 rear=rear.next; //指向新的链尾结点 &#125; &#125; public boolean isEmpty() &#123; return this.head.next==null; &#125; public int length() &#123; int i=0; Node&lt;T&gt; p=this.head.next; //p从单链表第一个结点开始 while(p!=null)&#123; //若单链表未结束 i++; p=p.next; //p的后继结点 &#125; return i; &#125; public String toString()&#123; String str="("; Node&lt;T&gt; p=this.head.next; while(p!=null)&#123; str+=p.data.toString(); if(p.next!=null) str+=","; //不是最后一个结点时加分隔符 p=p.next; &#125; return str+")"; &#125; public T get(int i) &#123; //返回第i个元素，若i指定序号无效，则返回null if(i&gt;=0) &#123; Node&lt;T&gt; p=this.head.next; for(int j=0;p!=null&amp;&amp;j&lt;i;j++) p=p.next; if(p!=null) return p.data; &#125; return null; &#125; //设置第i个元素值为x，若i指定序号无效则抛出序号越界异常 public void set(int i, T x) &#123; if(x==null) return; //不能设置空对象 if(i&gt;=0) &#123; Node&lt;T&gt; p=this.head.next; for(int j=0;p!=null&amp;&amp;j&lt;i;j++) p=p.next; if(p!=null) p.data=x; //p指向第i个节点 &#125; else throw new IndexOutOfBoundsException(i+""); &#125; public void insert(int i, T x) &#123;//将x对象插入在序号为i的结点前 if(x==null) return; Node&lt;T&gt; p=this.head; //p指向头结点 for(int j=0;p.next!=null&amp;&amp;j&lt;i;j++) //寻找插入位置 p=p.next; //循环停止时，p指向第i-1结点或最后一个结点 p.next=new Node&lt;T&gt;(x,p.next); &#125; //单链表最后添加对象 public void append(T x) &#123; insert(Integer.MAX_VALUE,x); &#125; public T remove(int i) &#123; if(i&gt;=0) &#123; Node&lt;T&gt; p=this.head; for(int j=0;p.next!=null&amp;&amp;j&lt;i;j++)//找到待删除的结点i的前驱结点i-1 p=p.next; if(p.next!=null) &#123; T old=p.next.data; //获取原对象 p.next=p.next.next; //删除p的后继结点 return old; &#125; &#125; return null; &#125; public void removeAll() &#123; this.head.next=null; &#125; public int indexOf(T key) &#123; // TODO Auto-generated method stub return 0; &#125; public boolean contain(T key) &#123; return this.search(key)!=null; &#125; public T search(T key) &#123; if(key==null) return null; Node&lt;T&gt; p=this.head.next; while(p!=null) &#123; if(p.data.equals(key)) return p.data; p=p.next; &#125; return null; &#125;&#125; 单链表求解约瑟夫环只需更改一处 //LList list=new seqList(number); LList list=new SinglyLinkenList(); 得到如下结果 初始化约瑟夫环:(5,0,2)删除B(A,C,D,E)删除D(A,C,E)删除A(C,E)删除E(C)最后的被赦免者是:C 此外单链表相比较于顺序表在插入和删除时只要改变少量结点的链，不需要移动数据元素，也避免了顺序表因存在空间不足扩充空间和复制元素的过程，提高了运行效率和空间利用率]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线性表之顺序表]]></title>
      <url>%2F2017%2F07%2F06%2Fsjjg_1%2F</url>
      <content type="text"><![CDATA[前言数据结构是指数据间存在的关系，通常包含三个方面。数据的逻辑结构（线性结构、树、图），数据的存储结构（顺序存储和链式存储），数据操作（对数据结构中的元素进行各种运算和处理），而通常所说的算法是建立在数据结构之上，读数据结构的操作需要用算法来描述。而算法的分析又主要包括时间代价和空间代价两方面 线性表的顺序表示和实现 数组是顺序存储的随机存取结构，占用一组连续的存储单元，通过下标识别元素，元素地址是下标的线性函数，一个下标能唯一确定一个元素 不妨构造一个顺序表接口类来模仿顺序表 12345678910111213public interface LList&lt;T&gt; &#123; boolean isEmpty(); //判断线性表是否为空 int length(); //返回线性表长度 T get(int i); //返回第i(i&gt;=0)个元素 void set(int i,T x); //设置第i个元素值为x void insert(int i,T x); //插入x作为第i个元素 void append(T x); //在线性表最后插入第i个元素 T remove(int i); //删除第i个元素并返回被删除对象 void removeAll(); //删除线性表所有元素 int indexOf(T key); //顺序查找关键字为key的元素，返回首次出现的位置 boolean contain(T key); //是否包含关键字 T search(T key); //顺序查找关键字为key的元素，返回首次出现的元素&#125; 下面是其实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class seqList&lt;T&gt; implements LList&lt;T&gt;&#123; private Object[] element; //存放线性表元素的一维数组 private int len; //顺序表长度，记载元素个数 public seqList(int size)&#123; //创建容量为size的空表 //若size&lt;0，java将抛出负数组长度异常 this.element=new Object[size]; this.len=0; &#125; public seqList()&#123; //创建默认容量的空表，这里是64 this(64); &#125; public boolean isEmpty() &#123; return this.len==0; &#125; public int length() &#123; return this.len; &#125; public T get(int i) &#123; //返回第i个元素（i&gt;=0),若i指定元素无效，则返回null if(i&gt;=0&amp;&amp;i&lt;this.len) return (T)this.element[i]; return null; &#125; //设置第i(i&gt;=0)个元素的值为x，若i指定序号无效则抛出序号越界异常 public void set(int i, T x) &#123; if(x==null) return; if(i&gt;=0&amp;&amp;i&lt;this.len) this.element[i]=x; else throw new IndexOutOfBoundsException(i+""); &#125;/** * 在顺序表元素ai位置插入元素x，首选必须将i到n个元素后移，空出一个位置，然后插入元素x */ public void insert(int i, T x) &#123; if(x==null) return ; //不能添加null if(this.len==element.length) //若数组满，则扩充顺序表容量 &#123; Object[] temp=this.element; this.element=new Object[temp.length*2]; //容量扩充2倍 for(int j=0;j&lt;temp.length;j++)&#123; this.element[i]=temp[i]; //复制数组元素 &#125; if(i&lt;0) //下标容错 i=0; if(i&gt;this.len) i=this.len; for(int j=this.len-1;j&gt;=i;j--) //元素后移，平均移动len/2 this.element[j+1]=this.element[j]; this.element[i]=x; this.len++; &#125; &#125; public void append(T x) &#123; insert(this.len,x); //在顺序表最后插入x对象 &#125; /** * 删除元素ai，必须将元素i+1到n向前移动 */ public T remove(int i) &#123; //删除成功返回被删除对象，否则返回null if(this.len==0||i&lt;0||i&gt;this.len) return null; T old=(T)this.element[i]; for(int j=i;j&lt;this.len-1;j++) //元素前移，平均移动len/2 this.element[j]=this.element[j+1]; this.element[this.len-1]=null; this.len--; return old; &#125; public void removeAll() &#123; this.len=0; &#125;//顺序查找关键字为key的元素，返回首次出现的位置，若查找不成功返回-1 public int indexOf(T key) &#123; if(key!=null) for(int i=0;i&lt;this.len;i++) if(this.element[i].equals(key)) return i; return -1; &#125; //判断线性表是否包含关键字为key元素 public boolean contain(T key) &#123; return this.indexOf(key)&gt;=0; &#125; //查找，返回首次出现的关键字为key的元素 public T search(T key) &#123; int find=this.indexOf(key); return find==-1?null:(T)this.element[find]; &#125;&#125; 约瑟夫环问题 问题描述：古代某法官要判决n个犯人的死刑，他有一条荒唐的法律：将犯人站成一个圆圈，从第s个人开始数起，每数到第d个犯人，就拉出来处决，在从下一个开始数d个，数到的人在处决。。。直到数到最后一个人就开始赦免 上面是假设n=5，s=1，d=2，并且起始位置是从第一个人开始数起，因为该圆圈可以看成顺序表进行模拟123456789101112131415161718192021public class Josephus &#123; public Josephus(int number,int start,int distance)&#123; seqList&lt;String&gt; list=new seqList&lt;String&gt;(number); //初始化顺序表 for(int i=0;i&lt;number;i++) //依次添加犯人，这里记为A,B.C,D,E list.append((char)('A'+i)+""); System.out.println("初始化约瑟夫环:"+'('+number+','+start+','+distance+')'); int i=start; //起始数起的人 while(list.length()&gt;1)&#123; //多于一个犯人时数起 i=(i+distance-1)%list.length(); System.out.print("删除"+list.remove(i).toString()+""); System.out.println(list.toString()); &#125; System.out.println("最后的被赦免者是:"+list.get(0).toString()); &#125; public static void main(String args[])&#123; new Josephus(5,0,2); &#125;&#125; 结果 初始化约瑟夫环:(5,0,2)删除B(A,C,D,E)删除D(A,C,E)删除A(C,E)删除E(C)最后的被赦免者是:C 顺序表的效率分析由之前的源码易看出，存取任何一个元素，即set（）、get（）方法的时间复杂度为O（1），而插入或者删除很耗时，不妨假设在第i个位置插入元素，并且概率为p{i},表长度为n；则平均移动次数为\sum{i=0}^n{(n-i)}*{p_i};如果插入元素的概率相同，即都是1/(n+1);最后求得时间复杂度为O(n);同理删除的时间复杂度也为O(n);所以得出一个结论:顺序表的动态操作效率极低 顺序表比较相等首先简单说一下深拷贝和浅拷贝，浅拷贝类似于只引用某个对象，和原对象指向相同的空间，而深拷贝是开辟了新空间并且复制原来对象的数据而两个顺序表的相等是指，他们对应的元素相等并且长度也相同12345678910111213141516public boolean equals(Object obj)&#123; if(this==obj) return true; if(obj instanceof seqList)&#123; seqList&lt;T&gt; list=(seqList&lt;T&gt;)obj; if(this.length()==list.length())&#123; for(int i=0;i&lt;this.length();i++) if(!(this.get(i).equals(list.get(i)))) return false; return true; &#125; &#125; return true; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shiro之会话管理]]></title>
      <url>%2F2017%2F07%2F05%2Fshiro_5%2F</url>
      <content type="text"><![CDATA[前言shiro提供了完整的会话功能，不依赖于底层容器，即直接使用shiro的会话管理可以直接替换掉web容器的会话管理 会话所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。 获取会话 Subject subject = SecurityUtils.getSubject();Session session = subject.getSession(); 获取当前会话的唯一标识 session.getId(); 获取当前Subject的主机地址 session.getHost(); 获取/设置当前Session的过期时间 session.getTimeout();session.setTimeout(毫秒); 获取会话的启动时间及最后访问时间 session.getStartTimestamp();session.getLastAccessTime(); 更新会话最后访问时间及销毁会话 session.touch();session.stop(); 当Subject.logout()时会自动调用stop方法来销毁会话 设置/获取/删除会话属性 session.setAttribute(“key”, “WORD”);session.getAttribute(“key”);session.removeAttribute(“key”); 会话管理器会话管理器管理着应用中所有subject的会话的创建、维护、删除、失效、验证等工作。它是shiro的核心，顶层组件SecurityManager直接继承了SessionManager，且提供了SessionsSecurityManager实现直接把会话管理委托给相应的SessionManager，DefaultSecurityManager及DefaultWebSecurityManager默认SecurityManager都继承了SessionsSecurityManager。 SecurityManager Session start(SessionContext context); //启动会话Session getSession(SessionKey key) throws SessionException; //根据会话Key获取会话 WebSessionManager boolean isServletContainerSessions();//是否使用Servlet容器的会话 ValidatingSessionManager void validateSessions();//验证所有会话是否过期 Shiro提供了三个默认实现： DefaultSessionManager：DefaultSecurityManager使用的默认实现，用于JavaSE环境； ServletContainerSessionManager：DefaultWebSecurityManager使用的默认实现，用于Web环境，其直接使用Servlet容器的会话； DefaultWebSessionManager：用于Web环境的实现，可以替代ServletContainerSessionManager，自己维护着会话，直接废弃了Servlet容器的会话管理。 全局会话时间在web.xml中设置(单位：分钟) 30 会话监听器会话监听器用于监听会话创建、过期及停止事件： 1234567891011121314public class MySessionListener1 implements SessionListener &#123; @Override public void onStart(Session session) &#123;//会话创建时触发 System.out.println("会话创建：" + session.getId()); &#125; @Override public void onExpiration(Session session) &#123;//会话过期时触发 System.out.println("会话过期：" + session.getId()); &#125; @Override public void onStop(Session session) &#123;//退出/会话过期时触发 System.out.println("会话停止：" + session.getId()); &#125; &#125; 如果只想监听某一个事件，可以继承SessionListenerAdapter实现： 123456public class MySessionListener2 extends SessionListenerAdapter &#123; @Override public void onStart(Session session) &#123; System.out.println("会话创建：" + session.getId()); &#125; &#125; 会话存储/持久化Shiro提供SessionDAO用于会话的CRUD //如DefaultSessionManager在创建完session后会调用该方法；如保存到关系数据库/文件系统/NoSQL数据库；即可以实现会话的持久化；返回会话ID；主要此处返回的ID.equals(session.getId())； Serializable create(Session session); //根据会话ID获取会话 Session readSession(Serializable sessionId) throws UnknownSessionException; //更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用 void update(Session session) throws UnknownSessionException; //删除会话；当会话过期/会话停止（如用户退出时）会调用 void delete(Session session); //获取当前所有活跃用户，如果用户量多此方法影响性能 Collection&lt;Session&gt; getActiveSessions(); AbstractSessionDAO提供了SessionDAO的基础实现，如生成会话ID等；CachingSessionDAO提供了对开发者透明的会话缓存的功能，只需要设置相应的CacheManager即可；MemorySessionDAO直接在内存中进行会话维护；而EnterpriseCacheSessionDAO提供了缓存功能的会话维护，默认情况下使用MapCache实现，内部使用ConcurrentHashMap保存缓存的会话。 如果自定义实现SessionDAO，继承CachingSessionDAO即可 123456789101112131415161718192021222324252627public class MySessionDAO extends CachingSessionDAO &#123; private JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate(); protected Serializable doCreate(Session session) &#123; Serializable sessionId = generateSessionId(session); assignSessionId(session, sessionId); String sql = "insert into sessions(id, session) values(?,?)"; jdbcTemplate.update(sql, sessionId, SerializableUtils.serialize(session)); return session.getId(); &#125; protected void doUpdate(Session session) &#123; if(session instanceof ValidatingSession &amp;&amp; !((ValidatingSession)session).isValid()) &#123; return; //如果会话过期/停止 没必要再更新了 &#125; String sql = "update sessions set session=? where id=?"; jdbcTemplate.update(sql, SerializableUtils.serialize(session), session.getId()); &#125; protected void doDelete(Session session) &#123; String sql = "delete from sessions where id=?"; jdbcTemplate.update(sql, session.getId()); &#125; protected Session doReadSession(Serializable sessionId) &#123; String sql = "select session from sessions where id=?"; List&lt;String&gt; sessionStrList = jdbcTemplate.queryForList(sql, String.class, sessionId); if(sessionStrList.size() == 0) return null; return SerializableUtils.deserialize(sessionStrList.get(0)); &#125; &#125; 会话验证Shiro提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话，Shiro提供了会话验证调度器SessionValidationScheduler来验证 12345678910111213141516171819202122//分页获取会话并验证 String sql = "select session from sessions limit ?,?"; int start = 0; //起始记录 int size = 20; //每页大小 List&lt;String&gt; sessionList = jdbcTemplate.queryForList(sql, String.class, start, size); while(sessionList.size() &gt; 0) &#123; for(String sessionStr : sessionList) &#123; try &#123; Session session = SerializableUtils.deserialize(sessionStr); Method validateMethod = ReflectionUtils.findMethod(AbstractValidatingSessionManager.class, "validate", Session.class, SessionKey.class); validateMethod.setAccessible(true); ReflectionUtils.invokeMethod(validateMethod, sessionManager, session, new DefaultSessionKey(session.getId())); &#125; catch (Exception e) &#123; //ignore &#125; &#125; start = start + size; sessionList = jdbcTemplate.queryForList(sql, String.class, start, size); &#125; sessionFactorysessionFactory是创建会话的工厂，根据相应的Subject上下文信息来创建会话；默认提供了SimpleSessionFactory用来创建SimpleSession会话。自定义一个session 123456789101112131415public class OnlineSession extends SimpleSession &#123; public static enum OnlineStatus &#123; on_line("在线"), hidden("隐身"), force_logout("强制退出"); private final String info; private OnlineStatus(String info) &#123; this.info = info; &#125; public String getInfo() &#123; return info; &#125; &#125; private String userAgent; //用户浏览器类型 private OnlineStatus status = OnlineStatus.on_line; //在线状态 private String systemHost; //用户登录时系统IP &#125; 自定义SessionFactory1234567891011121314151617public class OnlineSessionFactory implements SessionFactory &#123; @Override public Session createSession(SessionContext initData) &#123; OnlineSession session = new OnlineSession(); if (initData != null &amp;&amp; initData instanceof WebSessionContext) &#123; WebSessionContext sessionContext = (WebSessionContext) initData; HttpServletRequest request = (HttpServletRequest) sessionContext.getServletRequest(); if (request != null) &#123; session.setHost(IpUtils.getIpAddr(request)); session.setUserAgent(request.getHeader("User-Agent")); session.setSystemHost(request.getLocalAddr() + ":" + request.getLocalPort()); &#125; &#125; return session; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shiro之jstl标签]]></title>
      <url>%2F2017%2F07%2F04%2Fshiro_4%2F</url>
      <content type="text"><![CDATA[前言shiro提供了JSTL标签用于在页面进行权限控制 导入标签库 &lt;%@taglib prefix=”shiro” uri=”http://shiro.apache.org/tags“ %&gt; 各类标签guest标签 欢迎游客访问， 用户没有身份验证时显示相应信息，即游客访问信息 user标签 欢迎[]登录 用户已经身份验证/记住我登录后显示相应的信息。 authenticated标签 shiro:authenticated&gt; 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。 notAuthenticated标签 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证 principal标签 显示用户身份信息，默认调用Subject.getPrincipal()获取，即Primary Principal。 hasRole标签 用户[]拥有角色admin 如果当前Subject有角色将显示body体内容 hasAnyRoles标签 &lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt; &lt;/shiro:hasAnyRoles&gt; 如果当前Subject有任意一个角色（或的关系）将显示body体内容 lacksRole标签 如果当前Subject没有角色将显示body体内容 hasPermission标签 如果当前Subject有权限将显示body体内容。 lacksPermission标签 如果当前Subject没有权限将显示body体内容。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shiro之拦截器机制]]></title>
      <url>%2F2017%2F07%2F03%2Fshiro_3%2F</url>
      <content type="text"><![CDATA[前言Shiro使用了与Servlet一样的Filter接口进行扩展，还有拦截器是基于java的反射机制，如利用动态代理实现，而平时说的过滤器是基于回调函数的实现，在实现原理上有着本质的区别 拦截器介绍NameableFilter顾名思义，就是根据相应拦截器链组装拦截器的名字找到相应的拦截器实例 OncePerRequestFilter该拦截器用于控制一次请求只能走一次拦截器链，默认是开启拦截的 ShiroFilter是整个shiro的入口点，用于拦截需要安全控制的请求进行处理 AdviceFilter该拦截器非常类似于struct中拦截器，同时支持AOP拦截 boolean preHandle(ServletRequest request, ServletResponse response) throws Exceptionvoid postHandle(ServletRequest request, ServletResponse response) throws Exceptionvoid afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception; preHandler：类似于AOP中的前置增强；在拦截器链执行之前执行；如果返回true则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权） postHandle：类似于AOP中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）； afterCompletion：类似于AOP中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源（如解除Subject与线程的绑定之类的）； PathMatchingFilter提供了基于Ant风格的请求路径匹配功能及拦截器参数解析的功能，如“roles[admin,user]”自动根据“，”分割解析到一个路径参数配置并绑定到相应的路径： boolean pathsMatch(String path, ServletRequest request)boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception pathsMatch：该方法用于path与请求路径进行匹配的方法；如果匹配返回true； onPreHandle：在preHandle中，当pathsMatch匹配一个路径后，会调用opPreHandler方法并将路径绑定参数配置传给mappedValue；然后可以在这个方法中进行一些验证（如角色授权），如果验证失败可以返回false中断流程；默认返回true；也就是说子类可以只实现onPreHandle即可，无须实现preHandle。如果没有path与请求路径匹配，默认是通过的（即preHandle返回true）。 AccessControlFilter提供了访问控制的基础功能 abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception; boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception; abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception; isAccessAllowed：表示是否允许访问；mappedValue就是[urls]配置中拦截器参数部分，如果允许访问返回true，否则false； onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；如果返回false表示该拦截器实例已经处理了，将直接返回即可。 同时它还有一些扩展的功能 void setLoginUrl(String loginUrl) //身份验证时使用，默认/login.jspString getLoginUrl()Subject getSubject(ServletRequest request, ServletResponse response) //获取Subject实例boolean isLoginRequest(ServletRequest request, ServletResponse response)//当前请求是否是登录请求void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException //将当前请求保存起来并重定向到登录页面void saveRequest(ServletRequest request) //将请求保存起来，如登录成功后再重定向回该请求void redirectToLogin(ServletRequest request, ServletResponse response) //重定向到登录页面 拦截器链在web容器中，先执行shiro的filter链，再执行servlet容器的filter链，同时shiro的ProxiedFilterChain对Servlet容器的FilterChain进行了代理 FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain); 自定义拦截器通过自定义拦截器可以扩展一些功能，如动态url-角色/权限访问控制，根据Subject身份信息获取用户信息绑定到Request（即设置通用数据）、验证码验证、在线用户信息的保存等等 扩展OncePerRequestFilterOncePerRequestFilter保证一次请求只调用一次doFilterInternal12345678public class MyOncePerRequestFilter extends OncePerRequestFilter&#123; @Override protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123; System.out.println("once"); chain.doFilter(request, response); &#125;&#125; 对应的ini配置文件中 [filters]myFilter1=com.shiro.web.MyOncePerRequestFilter[urls]/**=myFilter1 其中[filters]声明拦截器，[urls]执行拦截器 扩展AdviceFilter123456789101112131415161718192021public class MyAdviceFilter extends AdviceFilter&#123; @Override protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123; System.out.println("pre"); return true; &#125; @Override protected void postHandle(ServletRequest request, ServletResponse response) throws Exception &#123; System.out.println("postHandle"); super.postHandle(request, response); &#125; @Override public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception &#123; System.out.println("afterCompletion"); super.afterCompletion(request, response, exception); &#125;&#125; preHandle：进行请求的预处理，然后根据返回值决定是否继续处理（true：继续过滤器链）；可以通过它实现权限控制； postHandle：执行完拦截器链之后正常返回后执行； afterCompletion：不管最后有没有异常，afterCompletion都会执行，完成如清理资源功能。 扩展PathMatchingFilter提供了url模式过滤的功能1234567891011public class MyPathMatchingFilter extends PathMatchingFilter&#123; @Override protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123; System.out.println("url matches,config is " + Arrays.toString((String[])mappedValue)); return true; &#125;&#125; preHandle：会进行url模式与请求url进行匹配，如果匹配会调用onPreHandle；如果没有配置url模式/没有url模式匹配，默认直接返回true； onPreHandle：如果url模式与请求url匹配，那么会执行onPreHandle，并把该拦截器配置的参数传入。默认什么不处理直接返回true。 扩展AccessControlFilter123456789101112131415public class MyAccessControlFilter extends AccessControlFilter&#123; @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123; System.out.println("isAccessAllowed"); return false; &#125; @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123; System.out.println("访问拒绝也不自己处理，继续拦截器链的执行"); return true; &#125;&#125; isAccessAllowed：即是否允许访问，返回true表示允许； onAccessDenied：表示访问拒绝时是否自己处理，如果返回true表示自己不处理且继续拦截器链执行，返回false表示自己已经处理了（比如重定向到另一个页面） 其中如果isAccessAllowed返回true，onAccessDenied将不执行，反之执行 默认拦截器Shiro内置了很多默认的拦截器，比如身份验证、授权等相关的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shiro之编码加密]]></title>
      <url>%2F2017%2F07%2F02%2Fshiro_2%2F</url>
      <content type="text"><![CDATA[前言在涉及数据在网络上的传输时，都要将明文数据加密传输，并且通常情况下的加密都是不可逆的 编码与解码shiro内部提供了base64和16进制字符串编码/解码的API支持，如下base64编码/解码 123456 String str="123456"; String base64Encoded=Base64.encodeToString(str.getBytes());//加密 System.out.println(base64Encoded); String str2=Base64.decodeToString(base64Encoded); //解密 System.out.println(str2); System.out.println(str.equals(str2)); 输出结果： MTIzNDU2123456true 16进制字符串编码/解码123456 String str="123456"; String base64Encoded = Hex.encodeToString(str.getBytes());//加密 System.out.println(base64Encoded); String str2 = new String(Hex.decode(base64Encoded.getBytes())); //解密 System.out.println(str2); System.out.println(str.equals(str2)); 输出结果： 313233343536123456true byte与string编码/解码12345 String str="123456"; byte[] str3=CodecSupport.toBytes(str, "utf-8"); //变成byte数组System.out.println(str3);String str4=CodecSupport.toString(str3, "utf-8"); //编程StringSystem.out.println(str4); 输出结果 [B@cd51c3123456 散列算法该算法是一种不可逆的算法，如MD5，SHA等，一般该算法最好需要提供一个salt（盐）来增加破解难度，一般情况下的盐被设置为 密码+用户名+盐，这样只有系统知道盐值，更难被破解 MD5散列1234 String str = "hello"; String salt = "world"; String md5 = new Md5Hash(str, salt,2).toString();System.out.println(md5); 这里的2是散列次数，即迭代多少次，这里是2次 556b1a232d4d63a2f3ab87c9535abe25 其它散列12345678 String str = "hello"; String salt = "world"; String sha1 = new Sha256Hash(str, salt).toString(); String SHA1=new Sha1Hash(str, salt).toString();String SHA512=new Sha512Hash(str, salt).toString();System.out.println(sha1);System.out.println(SHA1);System.out.println(SHA512); 相应的输入结果： 5715790a892990382d98858c4aa38d06171515753e64afa1cb7d643aa36f63b8d092ad76b1f04ff557abbb3d05f5b9037abf68a6606a8885d51bec8f6f39ee7d0badd504241c3704e777a51c21a9723e285fb9b8 通用散列1String simpleHash = new SimpleHash("SHA-1", str, salt).toString(); 其中第一个参数指定采用哪种算法输出结果： 5715790a892990382d98858c4aa38d0617151575 默认匹配Shiro提供了HashService，默认提供了DefaultHashService实现。先来看下它的构造函数1234567public DefaultHashService() &#123; this.algorithmName = "SHA-512";//默认算法SHA-512 this.iterations = 1; //生成Hash值的迭代次数，默认1 this.generatePublicSalt = false; //是否生成公盐，默认false this.rng = new SecureRandomNumberGenerator();//用于生成公盐 &#125; String hex = randomNumberGenerator.nextBytes().toHex();//随机生成一个盐 加密与解密Shiro还提供对称式加密/解密算法的支持，如AES、Blowfish等AES算法123456789101112AesCipherService aesCipherService = new AesCipherService(); aesCipherService.setKeySize(128);//设置key长度 //生成key Key key = aesCipherService.generateNewKey(); String text = "zwl"; //加密 String encrptText = aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex(); //解密 String text2 = new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes()); System.out.println(key.toString()); System.out.println(encrptText); System.out.println(text2); 而上面的key就相当于一把钥匙，只有了这把钥匙，就能解密输出结果： javax.crypto.spec.SecretKeySpec@176a4a316645482dff96d9c86c64adabc51dee5170232365a3c15dab941dc6b73c2eczwl Blowfish算法123456789101112BlowfishCipherService blowfishCipherService = new BlowfishCipherService(); blowfishCipherService.setKeySize(128); //生成key Key key = blowfishCipherService.generateNewKey(); String text = "zwl"; //加密 String encrptText = blowfishCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex(); //解密 String text2 = new String(blowfishCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes()); System.out.println(key.toString()); System.out.println(encrptText); System.out.println(text2); 输出结果： javax.crypto.spec.SecretKeySpec@d97afa5c8e7f6626884b7b429a1000286f4990a4zwl PasswordService/CredentialsMatcher在用户输入明文密码时，shiro默认的实现方式如下123456789public interface PasswordService &#123; //输入明文密码得到密文密码 String encryptPassword(Object plaintextPassword) throws IllegalArgumentException; &#125; public interface CredentialsMatcher &#123; //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密） boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info); &#125; Shiro默认提供了PasswordService实现DefaultPasswordService；CredentialsMatcher实现PasswordMatcher及HashedCredentialsMatcher 关于shiro的编码\加密是在是丰富多多彩，一般是学习中遇到采取查询相关的 一个对称加密的算法下面是在一个项目中使用到的工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161public class DesUtils &#123; /** 字符串默认键值 */ private static String strDefaultKey = "national"; /** 加密工具 */ private Cipher encryptCipher = null; /** 解密工具 */ private Cipher decryptCipher = null; /** * 将byte数组转换为表示16进制值的字符串， 如：byte[]&#123;8,18&#125;转换为：0813， 和public static byte[] * hexStr2ByteArr(String strIn) 互为可逆的转换过程 * * @param arrB * 需要转换的byte数组 * @return 转换后的字符串 * @throws Exception * 本方法不处理任何异常，所有异常全部抛出 */ public static String byteArr2HexStr(byte[] arrB) throws Exception &#123; int iLen = arrB.length; // 每个byte用两个字符才能表示，所以字符串的长度是数组长度的两倍 StringBuffer sb = new StringBuffer(iLen * 2); for (int i = 0; i &lt; iLen; i++) &#123; int intTmp = arrB[i]; // 把负数转换为正数 while (intTmp &lt; 0) &#123; intTmp = intTmp + 256; &#125; // 小于0F的数需要在前面补0 if (intTmp &lt; 16) &#123; sb.append("0"); &#125; sb.append(Integer.toString(intTmp, 16)); &#125; return sb.toString(); &#125; /** * 将表示16进制值的字符串转换为byte数组， 和public static String byteArr2HexStr(byte[] arrB) * 互为可逆的转换过程 * * @param strIn * 需要转换的字符串 * @return 转换后的byte数组 * @throws Exception * 本方法不处理任何异常，所有异常全部抛出 * */ public static byte[] hexStr2ByteArr(String strIn) throws Exception &#123; byte[] arrB = strIn.getBytes(); int iLen = arrB.length; // 两个字符表示一个字节，所以字节数组长度是字符串长度除以2 byte[] arrOut = new byte[iLen / 2]; for (int i = 0; i &lt; iLen; i = i + 2) &#123; String strTmp = new String(arrB, i, 2); arrOut[i / 2] = (byte) Integer.parseInt(strTmp, 16); &#125; return arrOut; &#125; /** * 默认构造方法，使用默认密钥 * * @throws Exception */ public DesUtils() throws Exception &#123; this(strDefaultKey); &#125; /** * 指定密钥构造方法 * * @param strKey * 指定的密钥 * @throws Exception */ public DesUtils(String strKey) throws Exception &#123; //Security.addProvider(new com.sun.crypto.provider.SunJCE()); Key key = getKey(strKey.getBytes()); encryptCipher = Cipher.getInstance("DES"); encryptCipher.init(Cipher.ENCRYPT_MODE, key); decryptCipher = Cipher.getInstance("DES"); decryptCipher.init(Cipher.DECRYPT_MODE, key); &#125; /** * 加密字节数组 * * @param arrB * 需加密的字节数组 * @return 加密后的字节数组 * @throws Exception */ public byte[] encrypt(byte[] arrB) throws Exception &#123; return encryptCipher.doFinal(arrB); &#125; /** * 加密字符串 * * @param strIn * 需加密的字符串 * @return 加密后的字符串 * @throws Exception */ public String encrypt(String strIn) throws Exception &#123; return byteArr2HexStr(encrypt(strIn.getBytes())); &#125; /** * 解密字节数组 * * @param arrB * 需解密的字节数组 * @return 解密后的字节数组 * @throws Exception */ public byte[] decrypt(byte[] arrB) throws Exception &#123; return decryptCipher.doFinal(arrB); &#125; /** * 解密字符串 * * @param strIn * 需解密的字符串 * @return 解密后的字符串 * @throws Exception */ public String decrypt(String strIn) throws Exception &#123; return new String(decrypt(hexStr2ByteArr(strIn))); &#125; /** * 从指定字符串生成密钥，密钥所需的字节数组长度为8位 不足8位时后面补0，超出8位只取前8位 * * @param arrBTmp * 构成该字符串的字节数组 * @return 生成的密钥 * @throws java.lang.Exception */ private Key getKey(byte[] arrBTmp) throws Exception &#123; // 创建一个空的8位字节数组（默认值为0） byte[] arrB = new byte[8]; // 将原始字节数组转换为8位 for (int i = 0; i &lt; arrBTmp.length &amp;&amp; i &lt; arrB.length; i++) &#123; arrB[i] = arrBTmp[i]; &#125; // 生成密钥 Key key = new javax.crypto.spec.SecretKeySpec(arrB, "DES"); return key; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识shiro]]></title>
      <url>%2F2017%2F07%2F01%2Fshiro_1%2F</url>
      <content type="text"><![CDATA[前言参考百度上说的Apache Shiro是一个强大易用的java安全框架，提供了认证、授权、加密和会话管理功能，可以为任何应用提供安全保障，而其主要为解决以下四个问题：1、 认证-用户身份识别，常被称为用户登录2、 授权-访问控制3、 密码加密-保护或隐藏数据防止被偷窥4、 会话管理-每用户相关的时间敏感的状态 架构以下是从其官网上截取的原理图 可以看出shiro的设计非常精妙，同时它不依赖于任何容器，即在java se和java ee中都可以使用，如果把shiro看做一个不透明的黑盒的话，即认证主体subject提供认证给security manager，其内部封装一些列细节方法去执行认证，这里的验证数据源可以是数据库的或者其他 下面将以用户的登录过程来模拟shiro的执行过程 身份认证流程token令牌1234567891011121314151617181920212223242526272829303132 @RequestMapping("login")public ModelAndView login(@RequestParam("username") String username, @RequestParam("password") String password) &#123; UsernamePasswordToken token = new UsernamePasswordToken(username, password); Subject subject = SecurityUtils.getSubject(); try &#123; subject.login(token); &#125; catch (IncorrectCredentialsException ice) &#123; // 捕获密码错误异常 ModelAndView mv = new ModelAndView("inner"); mv.addObject("message", "password error!"); return mv; &#125; catch (UnknownAccountException uae) &#123; // 捕获未知用户名异常 ModelAndView mv = new ModelAndView("inner"); mv.addObject("message", "username error!"); return mv; &#125; catch (ExcessiveAttemptsException eae) &#123; // 捕获错误登录过多的异常 ModelAndView mv = new ModelAndView("inner"); mv.addObject("message", "times error"); return mv; &#125; catch (AuthenticationException eae) &#123; // 捕获错误登录过多的异常 ModelAndView mv = new ModelAndView("inner"); mv.addObject("message", "times error"); return mv; &#125; TUserEntity user=tUserService.queryObject(username); subject.getSession().setAttribute("user", user); return new ModelAndView("index"); &#125; 这里该方法接收到前台传递过来的username和password信息，类比身份证，姓名是认证，但是身份证号码是作为认证的唯一凭证，只有身份证号码正确了，这个认证也就通过了，而这里的token可以理解为用户登录的令牌，里面记录着认证信息，然后交给shiro去验证 接下来就是执行登录动作了 SecurityUtils.setSecurityManager(securityManager); // 注入SecurityManagerSubject subject = SecurityUtils.getSubject(); // 获取Subject单例对象subject.login(token); // 登陆 其中SecurityManager是一个单例对象，即全局变量，接着SecurityUtils会自动绑定当前线程，获得subject主体，关于subject可以这样理解其包含两个信息:Principals： 身份，可以是用户名，邮件，手机号码等等，用来标识一个登陆主体身份；Credentials： 凭证，常见有密码，数字证书等等；最后就是登陆了，最后通过验证token是否合法返回不同结果 认证与授权根据流程图，接下来security manager开始执行一系列的认证手段了，其中最主要的就是AuthorizationInfo（角色权限认证），AuthenticationInfo（身份认证），可以简单这样理解，身份认证只是验证了这个subject的存在性，如果约定subject有某些权限，如管理员有删除或者访问某些url地址权限，而这个管理员就可以抽象为角色，也就是说权限是访问资源的权利集合，而角色是权限的集合 最后的realm域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色，权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源 一般情况下realm需要我们自定义去实现，因为shiro不知道哪些token是合法的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 public class OAuth2Realm extends AuthorizingRealm&#123; @Autowired private TUserService tUserService; /** * 提供用户信息返回权限信息 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; String username = (String) principals.getPrimaryPrincipal(); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); TUserEntity user=tUserService.queryObject(username); // 根据id查询当前用户拥有的角色 List&lt;TUserRoleEntity&gt; ture=tUserService.queryRole(user.getId()); Set&lt;TRoleEntity&gt; roles=new HashSet&lt;TRoleEntity&gt;(); for(TUserRoleEntity Tures:ture)&#123; roles.add(tUserService.queryObject(Tures.getRoleId())); &#125; Set&lt;String&gt; roleNames=new HashSet&lt;String&gt;(); for(TRoleEntity rolename : roles)&#123; roleNames.add(rolename.getRolename()); &#125; // 将角色名称提供给info authorizationInfo.setRoles(roleNames); return authorizationInfo; &#125; /** * 提供账户信息返回认证信息 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; String username=(String)token.getPrincipal(); // 获取用户名// String password = new String((char[])token.getCredentials()); 得到密码 UsernamePasswordToken t = (UsernamePasswordToken) token; //得到密码 String newPassword=new String(t.getPassword()); //根据用户名从数据库取出用户完整信息 TUserEntity tuserEntity=tUserService.queryObject(username); if(tuserEntity!=null)&#123; //若存在，将此用户存放到登录认证info中 return new SimpleAuthenticationInfo(tuserEntity.getUsername(),tuserEntity.getPassword(), ByteSource.Util.bytes("zwl"), getName()); &#125; return null; &#125; &#125; 该realm类的结果就是根据token的合法性验证返回不同结果给相应的controller，目前只是从宏观上看了一个全过程，shiro是非常强大的，它的功能远不止如此 缓存机制缓存的本质就是将原本只能存储在内存中的数据通过算法保存到硬盘上，再根据需求依次取出。可以把缓存理解为一个Map对象，通过put保存对象，再通过get取回对象。这里使用的是Ehcache缓存框架。具体代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache name="es"&gt; &lt;diskStore path="java.io.tmpdir"/&gt; &lt;!-- name:缓存名称。 maxElementsInMemory：缓存最大个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。 diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 maxElementsOnDisk：硬盘最大缓存个数。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 --&gt; &lt;defaultCache maxEntriesLocalHeap="1000" eternal="false" timeToIdleSeconds="3600" timeToLiveSeconds="3600" overflowToDisk="false"&gt; &lt;/defaultCache&gt; &lt;cache name="shiro-authenticationCache" maxEntriesLocalHeap="1000" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="600" overflowToDisk="false" statistics="true"&gt; &lt;/cache&gt; &lt;cache name="shiro-authorizationCache" maxEntriesLocalHeap="2000" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="600" overflowToDisk="false" statistics="true"&gt; &lt;/cache&gt; &lt;cache name="shiro-userCache" maxEntriesLocalHeap="2000" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="600" overflowToDisk="false" statistics="true"&gt; &lt;/cache&gt;&lt;/ehcache&gt; 其中可以指定缓存的路径，这里是临时路径 散列算法通常情况下散列和加密本质上都是一样的，即将一个Object变成一串无意义的字符串，不同点是经过散列的对象无法复原，是一个单向的过程，而加密是可以双向的，即加密与解密，所以如果忘记密码，只能进行修改密码操作，下面是在项目中用到的散列算法123456789101112private RandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator();private String algorithmName = "md5";private final int hashIterations = 2;public void encryptPassword(TUserEntity user) &#123; // User对象包含最基本的字段Username和Password String salt="zwl"; // 将用户的注册密码经过散列算法替换成一个不可逆的新密码保存进数据，散列过程使用了盐 String newPassword = new SimpleHash(algorithmName, user.getPassword(), ByteSource.Util.bytes("zwl"), hashIterations).toHex(); user.setPassword(newPassword);&#125; 其中algorithmName为指定运用何种算法，hashIterations为散列次数，也就是数学中的迭代，将前一个结果作为参数在运算一次，salt盐可以理解为有了盐，并且每个盐唯一确定一个散列值，最后产生的newPassword是经过如下类 public SimpleHash(String algorithmName, Object source, Object salt, int hashIterations) 四个参数分别标识算法名称，散列对象，散列使用的salt值，散列次数。 匹配匹配的功能就是用来匹配用户登录使用的令牌和数据库中保存的用户信息是否匹配。它的原始接口是CredentialsMatcher，一般情况下如果不自定义的话就会使用默认的实现类HashedCredentialsMatcher，如下是自定义的匹配1234567891011121314151617181920212223242526272829public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher&#123; // 声明一个缓存接口，这个接口是Shiro缓存管理的一部分，它的具体实现可以通过外部容器注入 private Cache&lt;String, AtomicInteger&gt; passwordRetryCache; public RetryLimitHashedCredentialsMatcher(CacheManager cacheManager) &#123; passwordRetryCache = cacheManager.getCache("passwordRetryCache"); &#125; @Override public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123; String username = (String) token.getPrincipal(); AtomicInteger retryCount = passwordRetryCache.get(username); if (retryCount == null) &#123; retryCount = new AtomicInteger(0); passwordRetryCache.put(username, retryCount); &#125; // 自定义一个验证过程：当用户连续输入密码错误5次以上禁止用户登录一段时间 if (retryCount.incrementAndGet() &gt; 5) &#123; throw new ExcessiveAttemptsException(); &#125; boolean match = super.doCredentialsMatch(token, info); if (match) &#123; passwordRetryCache.remove(username); &#125; return match; &#125; &#125; 一般情况下，匹配的异常的结果都会抛出相应的异常，如 DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等 而针对获得realm数据源的情况，会设置五张表，分别是用户表（存储用户名，密码，盐等）、角色表（角色名称，相关描述等）、权限表（权限名称，相关描述等）、用户-角色对应中间表（以用户ID和角色ID作为联合主键）、角色-权限对应中间表（以角色ID和权限ID作为联合主键），其中用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多 会话用户的一次登录即为一次会话，即session，Shiro也可以代替Tomcat等容器管理会话。而针对会话，可以处理的情况太多了，如记录用户信息和行为等等，比如保存用户信息 TUserEntity user=tUserService.queryObject(username); subject.getSession().setAttribute(“user”, user); ssm+shiro集成web.xml中的配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;!-- 修改 Servlet 版本--&gt; &lt;!-- 配置 DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:spring/spring-web.xml &lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:spring/spring-service.xml, classpath:spring/spring-dao.xml, classpath:spring/spring-shiro.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 添加 Shiro 相关配置(应该去官网查询相应的配置信息) --&gt; &lt;!-- The filter-name matches name of a 'shiroFilter' bean inside applicationContext.xml --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 其中主要关心的是web容器将将Shiro的配置文件交给Spring监听器初始化以及配置了shiro的过滤等这里shiro的配置都在spring-shiro.xml中配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 声明一个密码匹配器 --&gt; &lt;bean id="credentialsMatcher" class="com.hfsf.sys.oauth2.RetryLimitHashedCredentialsMatcher"&gt; &lt;!-- 设置该密码匹配器使用的算法是 md5 --&gt; &lt;property name="hashAlgorithmName" value="md5"/&gt; &lt;property name="hashIterations" value="2" /&gt; &lt;property name="storedCredentialsHexEncoded" value="true" /&gt; &lt;constructor-arg ref="ehCacheManager" /&gt; &lt;/bean&gt; &lt;!-- 声明一个自定义的 Realm --&gt; &lt;bean id="myRealm" class="com.hfsf.sys.oauth2.OAuth2Realm"&gt; &lt;!-- 将上面声明的密码匹配器注入到自定义 Realm 的属性中去 --&gt; &lt;property name="credentialsMatcher" ref="credentialsMatcher"/&gt; &lt;!-- 将自定义的权限匹配器注入到自定义 Realm 中 --&gt; &lt;property name="permissionResolver" ref="permissionResolver"/&gt; &lt;!-- 配置缓存相关 --&gt; &lt;!-- 启用缓存 --&gt; &lt;property name="cachingEnabled" value="true"/&gt; &lt;!-- 开启认证缓存--&gt; &lt;property name="authenticationCachingEnabled" value="true"/&gt; &lt;!-- 指定认证缓存的名字(与 ehcache.xml 中声明的相同) --&gt; &lt;property name="authenticationCacheName" value="shiro-authenticationCache"/&gt; &lt;!--开启授权缓存--&gt; &lt;property name="authorizationCachingEnabled" value="true"/&gt; &lt;!-- 指定授权缓存的名字(与 ehcache.xml 中声明的相同) --&gt; &lt;property name="authorizationCacheName" value="shiro-authorizationCache"/&gt; &lt;/bean&gt; &lt;!-- 自定义一个权限匹配器 --&gt; &lt;bean id="permissionResolver" class="com.hfsf.sys.oauth2.UrlPermissionResolver"/&gt; &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;!-- 如果认证不通过,浏览器通过 Get 方式请求到 /login 上 --&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;!-- override these for application-specific URLs if you like: &lt;property name="successUrl" value="/home.jsp"/&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; --&gt; &lt;!-- defined will be automatically acquired and available via its beanName in chain --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; /authc/admin = roles[admin] /authc/** = authc /** = anon &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 声明一个自定义的过滤器 --&gt; &lt;bean id="resourceCheckFilter" class="com.hfsf.common.xss.ResourceCheckFilter"&gt; &lt;!-- 为上面声明的自定义过滤器注入属性值 --&gt; &lt;property name="errorUrl" value="/unAuthorization"/&gt; &lt;/bean&gt; &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;!-- Single realm app. If you have multiple realms, use the 'realms' property instead. --&gt; &lt;!-- 设置安全管理器的安全数据源为自定义的 Realm --&gt; &lt;property name="realm" ref="myRealm"/&gt; &lt;!-- By default the servlet container sessions will be used. Uncomment this line to use shiro's native sessions (see the JavaDoc for more): --&gt; &lt;!-- &lt;property name="sessionMode" value="native"/&gt; --&gt; &lt;property name="cacheManager" ref="ehCacheManager"/&gt; &lt;/bean&gt; &lt;!-- 配置 shiro 的 ehcache 缓存相关,这个缓存只和 Realm 相关 --&gt; &lt;bean id="ehCacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt;&lt;/bean&gt; &lt;!-- 配置 Spring 的 EhCacheManagerFactoryBean ,须要 spring-context-support 的支持 --&gt; &lt;bean id="ehCacheManagerFactoryBean" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt; &lt;property name="configLocation" value="classpath:ehcache.xml"/&gt; &lt;/bean&gt; &lt;!-- 配置 Spring 的 EhCacheCacheManager,须要 spring-context-support 的支持 --&gt; &lt;bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager"&gt; &lt;property name="cacheManager" ref="ehCacheManagerFactoryBean"/&gt; &lt;/bean&gt;&lt;/beans&gt; 其中最主要的是filterChainDefinitions，这里声明了权限控制用户访问哪些url，而且访问是有顺序的，即执行了前者后者将不再执行，其中anon为匿名访问，authc为需要身份认证通过才可以访问，这里的内容较多，具体参考官方文档 最后只要通过前台页面提交数据，经过一系列流程，最终就可以完成权限控制了，事实上shiro的内容很多，而且很丰富，只有不断在实践中踩坑，学习，总结才能更好的认识和运用它]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式原则笔记]]></title>
      <url>%2F2017%2F05%2F11%2Fjd1%2F</url>
      <content type="text"><![CDATA[在编程语言中除了各种不同的设计模式外，它们也可以被抽出一些共性 开闭原则：一个软件实体应当对开展开放，对修改关闭（玉帝招安美猴王） 面向对象解释： 不予以更改的是抽象层，但是可以扩展的是实现层 对可变性的封装原则： 找到一个系统的可变因素，将之封装起来 继承应当是看做封装的方法，而不应该被认为是从一般对象方法到特殊对象的生成方法 里氏代换原则： 任何基类可以出现的地方，子类一定可以出现 两个类共同行为抽象到一个c类B继承A改为聚合B（白马与黑马，正方形与长方形） 依赖倒转原则： 要依赖于抽象，不要依赖于实现抽象类仅提供一个类型的部分实现，可以同时有抽象方法和具体方法具体类不是用来继承的如果两个具体类存在继承关系，要引入第三个类作为他们的共同的接口抽象类应该拥有尽可能多共同代码抽象类应当拥有尽可能少的数据 接口隔离原则： 应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口 角色的合理划分定制服务接口污染 合成/聚合复用原则： 要尽量使用合成/聚合，而不是继承关系达到复用的目的合成是值得聚合，聚合是引用的聚合Is-A 代表一个类是另一个类的一种，Has-A代表一个类是另一个类的角色，而不是另一个类的特殊类（人与角色） 迪米特法则： 一个软件实体应当尽可能少的与其他实体发生相互作用 java接口： 一些方法特征的集合没有接口会造成硬代码问题直接导致可插入性没有保证java接口用来声明一个新的类型单方法接口（如Runnable）标识接口（serialzable）常量接口]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[合并两个排序的链表]]></title>
      <url>%2F2017%2F04%2F23%2Foffer_13%2F</url>
      <content type="text"><![CDATA[问题描述输入两个单调递增的链表，输出两个链表合成后的链表，并且合并后的链表仍然是单调递增的 思路分析由于两个链表都是排序的，所以可先比较两个链表的头结点，从而确定合并后的第一个结点，之后在依次比较第二个结点，作为新的第二个结点，依次类推 码上有戏123456789101112131415public LinkNodes sortLink(LinkNodes l1,LinkNodes l2)&#123; if(l1==null)return l2; if(l2==null)return l1; LinkNodes phead=null; if(l1.data&lt;l2.data) &#123; phead=l1; phead.next=sortLink(l1.next,l2); &#125;else&#123; phead=l2; phead.next=sortLink(l1,l2.next); &#125; return phead; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[反转链表]]></title>
      <url>%2F2017%2F04%2F22%2Foffer_12%2F</url>
      <content type="text"><![CDATA[问题描述输入一个链表，反转链表后，输出链表的头结点 思路分析当我们遍历一次后，也就是遍历到尾节点时，其实也就完成了反转，在此过程中需要三个指针，一个指向当前遍历的前驱，由于反转，另一个是当前指针，还有一个是当前遍历的下一个指针，通过不断改变他们之间的关系来更改前后继关系 码上有戏123456789101112131415public LinkNodes reserve(LinkNodes head)&#123; LinkNodes reserveHead=null; LinkNodes curNode=head; LinkNodes pre=null; while(curNode!=null) &#123; LinkNodes nextNode=curNode.next; if(nextNode==null) reserveHead=curNode; curNode.next=pre; pre=curNode; curNode=nextNode; &#125; return reserveHead; &#125; 测试： public static void main(String[] args) { RefindNum rf=new RefindNum(); LinkNodes node1=new LinkNodes(1); LinkNodes node2=new LinkNodes(2); LinkNodes node3=new LinkNodes(3); LinkNodes node4=new LinkNodes(4); node1.next=node2; node2.next=node3; node3.next=node4; node4.next=null; LinkNodes phead=rf.reserve(node1); while(phead!=null){ System.out.println(phead.data); phead=phead.next; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[链表中倒数第K个节点]]></title>
      <url>%2F2017%2F04%2F22%2Foffer_11%2F</url>
      <content type="text"><![CDATA[问题描述输入一个链表，输出该链表中倒数第K个节点。同时，从1开始计数，即链表的尾节点是倒数第一个节点。例如：一个链表有6个节点，从头节点开始，他们的值依次是1、2、3、4、5、6.这个链表的倒数第三个节点是值为4的结点 思路分析首先想到的思路是，首先遍历该链表一次，就得到了该链表的长度，然后在遍历该链表一次，也就是倒数第k个节点就是顺数第总长度-k+1个位置的结点，但是从效率上说，遍历两次的时间复杂度为O（n*2); 码上有戏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class RefindNum &#123; public LinkNodes getReserve(LinkNodes head,int k)&#123; int count=1; LinkNodes node=head; if(node==null) return null; while(node.next!=null)&#123; count++; node=node.next; &#125; int i=1; node=head; while(k&lt;count&amp;&amp;i!=count-k+1)&#123; i++; node=node.next; &#125; if(k&lt;=count) return node; return null; &#125; public static void main(String[] args) &#123; RefindNum rf=new RefindNum(); LinkNodes node1=new LinkNodes(1); LinkNodes node2=new LinkNodes(2); LinkNodes node3=new LinkNodes(3); LinkNodes node4=new LinkNodes(4); node1.next=node2; node2.next=node3; node3.next=node4; node4.next=null; System.out.println(rf.getReserve(node1, 2).data); &#125;&#125;class LinkNodes&#123; int data; LinkNodes next; public LinkNodes(int data)&#123; this.data=data; &#125;&#125; 两个指针解法这种解法的思路，就是构造两个指针pre和behind，第一次使pre遍历到k-1位置，也就是第k个节点，此时在让behind指针从头开始遍历，由于pre和behind始终都相差k个位置，也就是说pre遍历到尾节点时，behind正好是倒数第k个节点，而此时的效率是很高的 码上有戏1234567891011121314151617181920public LinkNodes get(LinkNodes head,int k)&#123; LinkNodes pre=head; LinkNodes behind=null; if(pre==null||k&lt;0) return null; for(int i=0;i&lt;k-1;i++) &#123; if(pre.next!=null) pre=pre.next; else return null; &#125; behind=head; while(pre.next!=null) &#123; pre=pre.next; behind=behind.next; &#125; return behind; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[调整数组顺序是奇数位于偶数前面]]></title>
      <url>%2F2017%2F04%2F21%2Foffer_10%2F</url>
      <content type="text"><![CDATA[问题描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数和偶数与偶数之间的基本相对位置不变 思路分析首先想到的思路是从头开始遍历这个数组，如果遇到偶数就把这个数之后的所有数往前移动一位，这样数组就会流出一个空位，移动完毕后就把该偶数放到该空位，但是由于一次是遍历，一次是移位，所以导致时间复杂度为O（n*2) 码上有戏12345678910111213141516171819202122public int[] reOrderArray2(int[] array)&#123; if(array==null||array.length==0) return null; int i,j; for(i=1;i&lt;array.length;i++)&#123; int temp=array[i]; if(!isEven(array[i]))&#123; for(j=i-1;j&gt;=0&amp;&amp;isEven(array[j]);j--) &#123; array[j+1]=array[j]; &#125; array[j+1]=temp; &#125; &#125; return array; &#125; public boolean isEven(int i)&#123; if((i&amp;0x1)==0) return true; return false; &#125; 测试： Fib fib=new Fib(); int[] arr=fib.reOrderArray2(new int[]{3,5,6,7,8,9}); for(int i=0;i&lt;arr.length;i++) System.out.println(arr[i]); 另一种思路如果说不改变相对位置的话，就可以用两个指针操作，第一个指针指向偶数，第二个指针指向奇数，并且让第一个指针在第二个指针前面，就交换两个元素。当第一个指针在第二个指针后面就说明所有的奇数都移动到所有偶数前面了123456789101112131415public void reOrderArr(int[] array)&#123; if(array==null||array.length==0) return; int evenIndex=0; int oddIndex=array.length-1; while(evenIndex&lt;oddIndex) &#123; while(evenIndex&lt;oddIndex&amp;&amp;(array[evenIndex]&amp;0x1)!=0) evenIndex++; while(evenIndex&lt;oddIndex&amp;&amp;(array[oddIndex]&amp;0x1)==0) oddIndex--; if(evenIndex&lt;oddIndex) swap(array,evenIndex,oddIndex); &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数值的整数次方]]></title>
      <url>%2F2017%2F04%2F21%2Foffer_9%2F</url>
      <content type="text"><![CDATA[问题描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方 思路分析这里主要的问题就是幂的符号问题，共有三种情况，即正数，0，负数，当幂为0的时候直接返回1，当为正数的时候直接按正常的计算来，当为负数的时候要先把其转化为正数，然后返回结果的倒数就可以了 码上有戏12345678910111213141516171819202122public double powOfdouble(double base,int exp)&#123; double result=base; if(exp==0) return 1; if(exp&gt;0) &#123; for(int i=1;i&lt;exp;i++)&#123; result*=base; &#125; return result; &#125; else&#123; int absexp=-exp; for(int i=1;i&lt;absexp;i++) &#123; result*=base; &#125; System.out.println(result); return 1/result; &#125; &#125; 测试 Fib fib=new Fib();double a=fib.powOfdouble(0.5, -2);System.out.println(a);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二进制中1的个数]]></title>
      <url>%2F2017%2F04%2F20%2Foffer_8%2F</url>
      <content type="text"><![CDATA[问题描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。比如输入9，,9的二进制表示是1001,1的个数是2，所以输出2 思路分析如果一个数与该数减一的结果进行与运算，会把该数低位第一个1变成0，而高位不变，比如1100（12），减一后就变成1011（11），也就是说建议后，也就右边位1变0,0变1，与位操作后就是少了一个1，如1100&amp;1011，变成1000，一次类推，最终得到结果 码上有戏123456789public int Number(int n)&#123; int sum=0; while(n!=0) &#123; sum++; n=n&amp;(n-1); &#125; return sum; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用两个栈实现队列]]></title>
      <url>%2F2017%2F04%2F19%2Foffer_5%2F</url>
      <content type="text"><![CDATA[问题描述用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能 思路分析根据栈先进后出的特点，一个栈push元素后，另一个栈可push进它出栈的元素，这样存储的不就是原先顺序的元素吗，也就是原先栈顶元素现在在栈底 码上有戏12345678910111213141516171819202122232425262728293031323334public class CQueue&lt;T&gt; &#123; private Stack&lt;T&gt; stack1=new Stack&lt;&gt;(); private Stack&lt;T&gt; stack2=new Stack&lt;&gt;(); public void appendTail(T t)&#123; stack1.push(t); &#125; public T deleteHead() throws Exception&#123; if(stack2.isEmpty()) &#123; while(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; &#125; if(stack2.isEmpty())&#123; throw new Exception("队列为空！不能删除"); &#125; return stack2.pop(); &#125; public static void main(String[] args) throws Exception &#123; CQueue queue=new CQueue&lt;&gt;(); queue.appendTail(1); queue.appendTail(2); queue.appendTail(3); System.out.println(queue.deleteHead()); System.out.println(queue.deleteHead()); System.out.println(queue.deleteHead()); &#125;&#125; 两个队列实现一个栈有了上面的经验，我们发现，可以用同样的思想去实现两个队列实现一个栈，当然还是有点不一样的它的核心思想就是将一个队列的元素除队尾元素都放到另一个队列中，轮流操作就是栈了 码上有戏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private Queue&lt;T&gt; queue1=new ArrayBlockingQueue(10); private Queue&lt;T&gt; queue2=new ArrayBlockingQueue(10); private boolean flag=false; public void push(T t)&#123; if(queue2.isEmpty()) queue1.add(t); else if(queue1.isEmpty()) queue2.add(t); else&#123; return; &#125; &#125; public Queue pop()throws Exception&#123; int len; int count=1; if(queue2.isEmpty()) &#123; len=queue1.size(); while(!flag&amp;&amp;count&lt;len)&#123; queue2.add(queue1.poll()); count++; &#125; flag=true; queue1.poll(); count=1; return queue2; &#125; else if(queue1.isEmpty())&#123; len=queue2.size(); while(flag&amp;&amp;count&lt;len)&#123; queue1.add(queue2.poll()); count++; &#125; flag=false; queue2.poll(); count++; return queue1; &#125; else if(queue1.isEmpty()&amp;&amp;queue2.isEmpty())&#123; System.out.println("error"); return null; &#125; else&#123; &#125; return null; &#125; 测试： queue.push(“a”); queue.push(“b”); queue.push(“c”); System.out.println(queue.pop().toString()); System.out.println(queue.pop().toString()); queue.push(“d”); System.out.println(queue.pop().toString()); 结果： [a, b][a][a]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[斐波那契数列]]></title>
      <url>%2F2017%2F04%2F19%2Foffer_7%2F</url>
      <content type="text"><![CDATA[问题描述写一个函数，输入n，求斐波那契数列的第n项 思路分析这个数列是一个迭代的数列，所以用递归很容易求出来，但是会存在效率问题 码上有戏低效率解法12345678public long method1(int n)&#123; if(n==0) return 0; else if(n==1) return 1; else return method1(n-1)+method1(n-2); &#125; 此时利用递归会发现，最终会有很多重复的计算 非递归解法123456789101112131415161718public long method2(int n)&#123; long result=0; long preOne=0; long preTwo=1; if(n==0)&#123; return preOne; &#125; if(n==1)&#123; return preTwo; &#125; for(int i=2;i&lt;=n;i++) &#123; preOne=preTwo; preTwo=result; result=preOne+preTwo; &#125; return result; &#125; 该算法核心就是把每次数列的结果缓存，这样就不用重复计算了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[旋转数组的最小值]]></title>
      <url>%2F2017%2F04%2F19%2Foffer_6%2F</url>
      <content type="text"><![CDATA[问题描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减序列的一个旋转，输出旋转数组的一个最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1 思路分析这里有一个条件，就是观察发现，它是将原本有序的数组划分成两块，左边有序快依次递增并且总是大于右边有序块，所以很自然想到二分查找法，就是利用low，mid，high引用依次比较，mid值到底比左边还是右边大，也就是说不断缩小最小值的查找范围，然而还有一种情况就是low、mid。high三者值相等得情况，例如{1,0,1,1,1}，很显然mid不好确定范围，这属于特殊情况，可以采用顺序查找，找到数组中较小者，然后返回 码上有戏1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Findmin &#123; public int min(int[] arr)&#123; if(arr==null||arr.length-1&lt;0) return 0; int low=0; int high=arr.length-1; int mid=low; while(arr[low]&gt;=arr[high])&#123; mid=(low+high)/2; if(high-low==1)&#123; return arr[high]; &#125; if(arr[low]==arr[mid]&amp;&amp;arr[mid]==arr[high]) &#123; return search(arr,low,high); &#125; if(arr[mid]&gt;arr[low]) low=mid; else if(arr[mid]&lt;arr[high]) high=mid; &#125; return arr[mid]; &#125; private int search(int[] arr, int low, int high) &#123; int result=arr[high]; for(int i=low+1;i&lt;=high;i++) if(result&gt;arr[i]) &#123; result=arr[i]; &#125; return result; &#125; public static void main(String[] args) &#123; int minNumber=new Findmin().min(new int[]&#123;1,0,1,1,1&#125;); System.out.println(minNumber); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重建二叉树]]></title>
      <url>%2F2017%2F04%2F18%2Foffer_4%2F</url>
      <content type="text"><![CDATA[问题描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果都不含重复的数字。例如输入前序遍历{1,2,4,7,3,5,6,8}和中序遍历{4,7,2,1,5,3,8,6}，则重建二叉树并返回 思路分析由前序遍历很容易知道根结点是1，然后根据中序遍历知道左子树包含节点是4、7、2,右子树结点是5、3、8、6;又由前序遍历为2,4,7知道2是这三个节点的根结点，又中序为4,7,2知道4是2的左孩子，7是4的右孩子，右子树同理可判断 码上有戏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class ConstructBinaryTree &#123; public class TreeNode&#123; int data; TreeNode left; TreeNode right; TreeNode(int data)&#123; this.data=data; &#125; &#125; public TreeNode reConstructBinaryTree(int[] pre,int[] in)&#123; TreeNode root=constructCore(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; private TreeNode constructCore(int[] pre,int startPreOrder,int endPreOrder,int[] in,int startInOrder,int endInOrder) &#123; //根据前序遍历找到根结点的值 int rootValue=pre[startPreOrder]; TreeNode rootNode=new TreeNode(rootValue); rootNode.left=null; rootNode.right=null; //只有一个结点，那么该节点就是根结点，直接返回 if(startPreOrder==endPreOrder)&#123; if(startInOrder==endInOrder&amp;&amp;pre[startPreOrder]==in[startInOrder])&#123; return rootNode; &#125; &#125; //根据中序遍历的结果找到根结点 int rootOfInOrder=startInOrder; while(rootOfInOrder&lt;=endInOrder&amp;&amp;in[rootOfInOrder]!=rootValue)&#123; rootOfInOrder++; &#125; //异常处理 if(rootOfInOrder==endInOrder&amp;&amp;in[rootOfInOrder]!=rootValue)&#123; return null; &#125; //计算左子树的长度 int leftSubTreeLen=rootOfInOrder-startInOrder; //根据左子树的长度计算前序的遍历结果中左子树的最后一个结点的下标 int leftIndexOfPreOrderEnd=startPreOrder+leftSubTreeLen; //重建左子树 if(leftSubTreeLen&gt;0)&#123; rootNode.left=constructCore(pre,startPreOrder+1,leftIndexOfPreOrderEnd,in,startInOrder,rootOfInOrder-1); &#125; //重接右子树 if(leftSubTreeLen&lt;endPreOrder-startPreOrder)&#123; rootNode.right=constructCore(pre,leftIndexOfPreOrderEnd+1,endPreOrder,in,rootOfInOrder+1,endInOrder); &#125; return rootNode; &#125; public void outTraver(TreeNode root)&#123; if(root!=null)&#123; outTraver(root.left); outTraver(root.right); System.out.print(root.data+" "); &#125; &#125; public static void main(String[] args) &#123; int[] pre=&#123;1,2,4,7,3,5,6,8&#125;; int[] in=&#123;4,7,2,1,5,3,8,6&#125;; TreeNode root=new ConstructBinaryTree().reConstructBinaryTree(pre, in); new ConstructBinaryTree().outTraver(root); &#125;&#125; 最后拿到根结点然后输出后续遍历如下 7 4 2 5 8 6 3 1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二维数组中的查找]]></title>
      <url>%2F2017%2F04%2F17%2Foffer_3%2F</url>
      <content type="text"><![CDATA[题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排列。请完成一个函数，输入这样的一个一维数组和一个整数，判断数组中是否含有该整数。 思路分析查找的过程从二维数组的角上选取一个值判断，如右上角那个数，显然它是当前所在列的最小值，当前所在行的最大值，如果比它相等，那是最好的情况，如果比它大，那就说从的所在列下方寻找，可以排除那一行，依次类推，如果说比它小，那就排除那一列，从它的左边以此类推，直到找到或者不存在完成 码上有戏123456789101112131415161718192021222324252627282930313233public class Find &#123; public static boolean find(int arr[][],int target)&#123; boolean found=false; int rows=arr.length; int columns=arr[0].length; int row=0; int column=columns-1; while(row&lt;rows&amp;&amp;column&gt;=0)&#123; if(arr[row][column]==target)&#123; found=true; break; &#125; else if(arr[row][column]&gt;target)&#123; column--; &#125; else row++; &#125; return found; &#125; public static void main(String[] args) &#123; int[][] arr=new int[4][4]; arr[0]=new int[]&#123;1,2,8,9&#125;; arr[1]=new int[]&#123;2,4,9,12&#125;; arr[2]=new int[]&#123;4,7,10,13&#125;; arr[3]=new int[]&#123;6,8,11,15&#125;; boolean flag=Find.find(arr, 16); System.out.println(flag); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符串空格替换]]></title>
      <url>%2F2017%2F04%2F16%2Foffer_2%2F</url>
      <content type="text"><![CDATA[题目描述请实现一个函数，将一个字符串中的空格替换成”20%”,例如，当字符串为we are happy，则经过替换之后的字符串为we%20are%20happy； 思路分析这个首先让人想到的是java中不是有replaceAll（）方法（源码模拟在之前的数据结构中已总结），如果直接调用那就没意思了，或者使用stringBuffer的append（）方法，遇到空格在后面插入，这样做也可以，但是是不是也是体现不出我们的思考过程。另一种做法就是大概意思就是构造一个缓存数组temp，首先计算出原字符数组中的空格数，而temp的大小就是原数组长度加上空格数*2，同时先将原数组拷贝到新数组，多出的空间刚开始是空值，然后有两个索引，分别指向原数组末尾和新数组末尾，最后通过原数组末尾一个一个字符的从后向前比较，如果是空值的话，替换，否则将原数组的内容在新数组中向后移动至末尾，依次，知道原数组索引小于0为止，代码如下12345678910111213141516171819202122232425262728293031323334353637public class Buffer &#123; public String replaceSpace(StringBuffer s)&#123; String str=s.toString(); int blankCount=this.getBlankCount(str); int originLen=str.toCharArray().length; int newStrlen=blankCount*2+originLen; char[] newStr=new char[newStrlen]; System.arraycopy(str.toCharArray(), 0, newStr, 0, originLen); int strIndex=originLen-1; int newstrIndex=newStrlen-1; while(strIndex&gt;0&amp;&amp;strIndex!=newstrIndex) &#123; if(str.charAt(strIndex)==' ')&#123; newStr[newstrIndex--]='0'; newStr[newstrIndex--]='2'; newStr[newstrIndex--]='%'; &#125; else&#123; newStr[newstrIndex--]=newStr[strIndex]; &#125; strIndex--; &#125; return new String(newStr); &#125; public int getBlankCount(String s)&#123; int count=0; for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i)==' ') count++; &#125; return count; &#125; &#125; 测试类： String s=”we are happy”;StringBuffer sb=new StringBuffer(s);String str=new Buffer().replaceSpace(sb);System.out.println(str); 可以发现整个过程都是一层循环，所以它的时间复杂度为O(n); 其他解法replaceAll方法12String str=s.replaceAll("\\s", "20%"); System.out.println(str); 其中此方法需要传正则表达式，而\s表示空格，当然结果也能完成目的，但是考虑到String是不变字符串，也就是说它不能在原来字符数组上进行修改，需要另开内存空间，所以每次插入，都要向后移动n此，同时也要查找比较n词，显然时间复杂度就是O（n*2），来看看之前模拟的replaceAll方法123456789public MyString replaceAll(MyString pattern,MyString replacement)&#123; MyString temp=new MyString(this); int i=this.indexOf(pattern, 0); while(1!=-1) &#123; temp=temp.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length())); i=temp.indexOf(pattern, i+replacement.length());//从下一个字符开始继续寻找匹配 &#125; &#125; 显然此方法效率不高 stringBuffer方法1234567891011121314151617181920public String replace(String input)&#123; if(input==null)&#123; return null; &#125; StringBuffer str=new StringBuffer(); for(int i=0;i&lt;input.length();i++)&#123; if(input.charAt(i)==' ') &#123; str.append("%"); str.append("2"); str.append("0"); &#125; else&#123; str.append(String.valueOf(input.charAt(i))); &#125; &#125; return new String(str); &#125; 主要利用stringBuffer的可变性，同样只有一层循环，时间复杂度为O（n）；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从尾到头打印链表]]></title>
      <url>%2F2017%2F04%2F15%2Foffer_1%2F</url>
      <content type="text"><![CDATA[题目描述给定一个链表，从尾部到头部打印输出链表的值。 栈方式很自然，想到的第一个方法就是后进先出，那就是直接可用栈来模拟当然，因为题目要求使用链表，所以首先可确定结点结构，如下123456789101112131415public class Node&lt;T extends Object&gt; &#123; T data; public Node next; public Node(Node next)&#123; this.next=next; &#125; public Node(T data)&#123; this.data=data; &#125; public T getData()&#123; return this.data; &#125; 接下来就是栈方式1234567891011121314151617181920212223class LinkNode&#123; void Resver(Stack&lt;Node&gt; stack)&#123; while(!stack.isEmpty())&#123; System.out.println((stack.pop()).data); &#125; &#125; public static void main(String args[])&#123; Node A=new Node(1); Node B=new Node(2); Node C=new Node(3); A.next=B; B.next=C; C.next=null; LinkNode link=new LinkNode(); Stack stack=new Stack&lt;&gt;(); stack.push(A); stack.push(B); stack.push(C); link.Resver(stack); &#125; 会发现用利用栈的特点可以很快的非递归实现此功能 递归方式另一种想法就是利用递归树的特点，也就是说如果你有后继结点，就递归寻找后继结点，直到找到最后一个后继结点，然后打印结点值，就是想象成一棵斜数，然后后续遍历123456789101112131415161718192021222324Node TraverserHeadToTail(Node node)&#123; if(node!=null)&#123; if(node.next!=null)&#123; TraverserHeadToTail(node.next); &#125; System.out.println(node.data); return node; &#125; else &#123; System.out.println("null"); return null; &#125; &#125; public static void main(String args[])&#123; Node A=new Node(1); Node B=new Node(2); Node C=new Node(3); A.next=B; B.next=C; C.next=null; LinkNode link=new LinkNode(); link.TraverserHeadToTail(A); &#125; 可以发现递归的方式如此简便，注意这里的node返回的是根结点，因为它是后续遍历的最后一个结点啊 顺序表方式能不能把链表转换成顺序表了，大体思路是这样的，对链表做三次遍历，第一次遍历确定链表的长度，第二次遍历将每个结点的值按照结点顺序放到一个缓存中，第三次遍历，对该缓存遍历，然后将到放到另一个缓存数组中，不过是将前一个缓存按照倒序放到该数组中，最后将该倒序缓存放到集合中就可以了，代码如下12345678910111213141516171819202122232425262728293031323334353637ArrayList&lt;Integer&gt; ChangeToList(Node node)&#123; int len = 0,i=0; Node temp=node; while(node!=null)&#123; ++len; node=node.next; &#125; Integer[] nodes=new Integer[len]; while(temp!=null) &#123; nodes[i++]=(Integer) temp.data; temp=temp.next; &#125; Integer[] nodesTemp=new Integer[len]; for(int j=0;j&lt;nodes.length;j++) nodesTemp[len-j-1]=nodes[j]; ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;(); for(int k=0;k&lt;nodes.length;k++) list.add(k, nodesTemp[k]); return list; &#125; public static void main(String args[])&#123; Node A=new Node(1); Node B=new Node(2); Node C=new Node(3); A.next=B; B.next=C; C.next=null; LinkNode link=new LinkNode(); List&lt;Integer&gt; list=link.ChangeToList(A); for(Integer val:list) System.out.println(val); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shiro之通过数据库验证身份]]></title>
      <url>%2F2017%2F04%2F14%2Fshiro1%2F</url>
      <content type="text"><![CDATA[前言参考百度上说的Apache Shiro是一个强大易用的java安全框架，提供了认证、授权、加密和会话管理功能，可以为任何应用提供安全保障，而其主要为解决以下四个问题：1、 认证-用户身份识别，常被称为用户登录2、 授权-访问控制3、 密码加密-保护或隐藏数据防止被偷窥4、 会话管理-每用户相关的时间敏感的状态 身份认证流程以下是从其官网上截取的原理图 Subject认证主体其中认证主体包含两个信息:Principals： 身份，可以是用户名，邮件，手机号码等等，用来标识一个登陆主体身份；Credentials： 凭证，常见有密码，数字证书等等； Realm&amp;JDBC&amp;ReamlRealm：意思是域，Shiro从Reaml中获取验证数据；Realm有很多种类，例如常见的jdbc realm 码上有戏1.在eclipse中新建一个maven工程，并且配置pom.xml主要配置如下：12345678910111213141516171819202122232425262728293031323334&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 主要有shiro的核心包、日志包，数据源及数据库连接包 在resource包下新建jdbc_realm.ini用于配置从数据库中获取验证数据12345678910111213141516[main] //声明以下是代码片段//相当于new了一个jdbcRealm类jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm//声明一个数据源，这里用了c3p0dataSource=com.mchange.v2.c3p0.ComboPooledDataSource//声明驱动dataSource.driverClass=com.mysql.jdbc.Driver//声明url，其中localhost可更改为ip地址dataSource.jdbcUrl=jdbc:mysql://localhost:9806/db_shiro//配置数据库用户名、密码dataSource.user=rootdataSource.password=root//添加数据源jdbcRealm.dataSource=$dataSource//添加数据域securityManager.realms=$jdbcRealm 这里数据库中需要注意的是，数据库中的表名必须为users，并且字段必须为userName和password 在src/main/java文件下新建一个HelloWorld类，目前数据这里手动构造一个123456789101112131415161718192021222324252627282930313233343536package com.zwl.shiro;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;public class HelloWorld &#123; public static void main(String[] args) &#123; //读取配置文件，初始化SecurityManager工厂 Factory&lt;SecurityManager&gt; factory=new IniSecurityManagerFactory("classpath:jdbc_realm.ini"); //获取SecurityManager实例 SecurityManager securityManager=factory.getInstance(); //把SecurityManager实例绑定到SecurityUtils SecurityUtils.setSecurityManager(securityManager); //得到当前执行的用户 Subject currentUser=SecurityUtils.getSubject(); //创建token令牌，用户名/密码 UsernamePasswordToken token=new UsernamePasswordToken("admin", "123456"); try &#123; //身份认证 currentUser.login(token); System.out.println("身份认证成功！"); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); System.out.println("身份认证失败！"); &#125; // 退出 currentUser.logout(); &#125;&#125; 这里通过更改token来模拟验证数据是否正确 相关源代码，已放在github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[并发系列之四Guarded Suspension]]></title>
      <url>%2F2017%2F04%2F13%2Fthrd4%2F</url>
      <content type="text"><![CDATA[前言Guarded Suspension是指当现在并不适合马上执行某个操作时，就要求想要执行该操作的线程等待 Guarded Suspension首先模拟一个案例首先是表示请求的类1234567891011121314151617package com.zwl.utest3;public class Request &#123;private final String name;public Request(String name)&#123; this.name=name;&#125;public String getName()&#123; return name;&#125;public String toString()&#123; return "[ Request"+name+"]";&#125;&#125; 一次存放请求以待使用的类123456789101112131415161718192021222324252627package com.zwl.utest3;import java.util.LinkedList;public class RequestQueue &#123; //构造链表，用来保存请求 private final LinkedList queue=new LinkedList&lt;&gt;();//有请求将最早的请求取出，没有则等待 public synchronized Request getRequest()&#123; while(queue.size()&lt;=0)&#123; try&#123; wait(); &#125;catch(Exception e)&#123; &#125; &#125; return (Request) queue.removeFirst(); &#125;//增加一个请求 public synchronized void putRequest(Request request)&#123; queue.addLast(request); notifyAll(); &#125; &#125; 送出请求的类12345678910111213141516171819202122232425262728293031package com.zwl.utest3;import java.util.Random;public class ClientThread extends Thread &#123; //构造随机数，用来线程等待时间 private Random random; //存放请求 private RequestQueue requestQueue; public ClientThread(RequestQueue requestQueue,String name,long seed)&#123; super(name); this.requestQueue=requestQueue; this.random=new Random(seed); &#125; public void run()&#123;//不断调用putrequest（），并且打印相关信息 for(int i=0;i&lt;10000;i++)&#123; Request request=new Request("No ."+i); System.out.println(Thread.currentThread().getName()+" Request:"+request); requestQueue.putRequest(request); try &#123; Thread.sleep(random.nextInt(1000)); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125; &#125; 接收请求的类12345678910111213141516171819202122232425262728package com.zwl.utest3;import java.util.Random;public class ServerThread extends Thread &#123; private Random random; private RequestQueue requestQueue; public ServerThread(RequestQueue requestQueue,String name,long seed)&#123; super(name); this.requestQueue=requestQueue; this.random=new Random(seed); &#125; public void run()&#123; //不断调用getrequest（） for(int i=0;i&lt;10000;i++)&#123; Request request=requestQueue.getRequest(); System.out.println(Thread.currentThread().getName()+" Handlet:"+request); try &#123; Thread.sleep(random.nextInt(1000)); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125;&#125; 最后是测试123RequestQueue requestQueue=new RequestQueue(); new ClientThread(requestQueue, "A", 1314520l).start(); new ServerThread(requestQueue, "B", 5201314l).start(); 测试结果 A Request:[ RequestNo .0]B Handlet:[ RequestNo .0]A Request:[ RequestNo .1]B Handlet:[ RequestNo .1]A Request:[ RequestNo .2]B Handlet:[ RequestNo .2]…… 从测试结果可以看出，当发送请求时，接受并处理而其中的关键方法是getRequest（）中，当满足while里条件时，则调用wait，处于等待，直到收到通知，才从休息区出来，而这种一定要满足的条件，就称为Guarded Suspension的警戒条件 所以可将该模式抽象为如下GuardedObject（被防伪的对象）参与者：当线程执行guardMethod时，只要满足警戒条件，就马上执行，当不成立时，就开始等待，而条件的成立与否，是与参与者的状态变化有关guardMethod：防伪的方法stateChangingMethod：状态改变的方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[并发系列之三Immutable]]></title>
      <url>%2F2017%2F04%2F12%2Fthrd3%2F</url>
      <content type="text"><![CDATA[前言immutable是指永恒，不会改变的意思，就像java.lang.String类中，并没有提供任何改变字符串属性的方法 immutable Pattern首先模拟一个案例1234567891011121314151617181920212223package com.zwl.utest3;public final class Person &#123;//不允许修改的地址private final String address;//不允许修改的姓名private final String name;public Person(String name, String address) &#123; this.name = name; this.address = address;&#125;//有final就不会有set方法，控制外部对其的修改public String getAddress() &#123; return address;&#125;public String getName() &#123; return name;&#125;public String toString()&#123; return "[ Person: name="+name+ ",address="+address+"]";&#125;&#125; 下面是人的线程1234567891011121314151617181920package com.zwl.utest3;public class PersonThread extends Thread &#123; private Person person; public PersonThread(Person person) &#123; this.person = person; &#125; public void run()&#123; while(true)&#123; //得到线程的名并打印出人的信息 System.out.println(Thread.currentThread().getName()+"prints"+person); &#125; &#125; &#125; 测试类1234Person person=new Person("A1","AA"); new PersonThread(person).start(); new PersonThread(person).start(); new PersonThread(person).start(); 测试结果 Thread-2prints[ Person: name=A1,address=AA]Thread-2prints[ Person: name=A1,address=AA]Thread-2prints[ Person: name=A1,address=AA]Thread-2prints[ Person: name=A1,address=AA]Thread-2prints[ Person: name=A1,address=AA]Thread-2prints[ Person: name=A1,address=AA]以下一直重复 可以发现上面的字段都是final并且没有修改该字段的方法正因为如此，所以就不需要使用synchronized来限制，这在性能上就大大提高了 何时使用1.当实例产生后，状态不再变化时2.实例需要共享，而且访问很频繁时 当然，有时也需要变与不变的转换，就像StringBuffer是一个线程不安全的类，在它的构造器中有String作为参数，而在String类中也有StringBuffer作为参数另外像java中的基本类型boolean、int、long等都是immutable模式该模式最大的优点就是实例的状态不会改变，所以没必要进行保护]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[并发系列之二Single Threaded Execution]]></title>
      <url>%2F2017%2F04%2F11%2Fthrd2%2F</url>
      <content type="text"><![CDATA[前言Single Threaded Execution是指以一个线程执行，简单来说就是在多线程中限制同时只让一个线程运行 线程不安全首先来模拟一个线程不安全的例子1234567891011121314151617181920212223242526272829303132package com.zwl.utest2;public class Gate &#123; //记录走过门的人数，默认为0 private int count=0; //记录通过门的人的名字 private String name="nobody"; //记录通过门的人的地址 private String address="noplace"; //穿越这道门使用的方法 public void pass(String name,String address)&#123; this.name=name; this.address=address; count++; check(); &#125; //检查通过门的人的合法性，即人的名字和地址首字母是否相同 public void check()&#123; if(name.charAt(0)!=address.charAt(0))&#123; System.out.println("***broken***"+this.toString()); &#125; &#125; //打印出人数、姓名、地址 public String toString()&#123; return "No."+count+":"+name+" ,"+address; &#125; &#125; 目前上面的Gate类是线程不安全的1234567891011121314151617181920212223package com.zwl.utest2;//不断穿越门的行人public class UserThread extends Thread &#123;//用final限制门，姓名，地址不能重复private final Gate gate;private final String myaddress;private final String myname;public UserThread(Gate gate, String myname, String myaddress) &#123; super(); this.gate = gate; this.myname = myname; this.myaddress = myaddress;&#125;//发生错误，即行人不合法，则处于死循环，并且执行toString方法@Overridepublic void run() &#123; System.out.println(myname+" BEGIN");while(true)&#123; gate.pass(myname, myaddress);&#125;&#125;&#125; 测试类123456System.out.println("test begin:"); Gate gate=new Gate(); //构造三个行人 new UserThread(gate, "A1", "A2").start(); new UserThread(gate, "B1", "B2").start(); new UserThread(gate, "C1", "C2").start(); 测试结果（截取部分） test begin:B1 BEGINA1 BEGINbrokenNo.1305356:A1 ,A2brokenNo.1347999:B1 ,B2brokenNo.1357011:A1 ,A2brokenNo.1370176:B1 ,B2brokenNo.1377075:B1 ,B2 从结果来看，明显发生了错误，即出现了线程不安全，但是也有点不对劲 为什么会出错了 问题的出错地方就在Gate类中，因为其是线程不安全的，打个比方 线程A1 线程A2 this.name值 this.address值 count++ count++ 之前的值 之前的值 this.name=name A1 之前的值 this.name=name A2 之前的值 this.address=address A2 B2 this.address=address A1 B2 check（） check（） A1 B2 发生错误 以上只是发生错误的一种情况，事实上只有当数据量非常大时，极有可能发生错误，所以才会出现错误的结果，并且是在count达到大数量的时候出现的 那么如何修改了？ 因为发生在Gate类的pass和toString方法中，所以只要把这个两个方法声明为同步就可以了 public synchronized void pass(String name,String address){} public synchronized String toString(){} 对应的测试结果 test begin:A1 BEGINB1 BEGINC1 BEGIN 归纳single Threaded上面例子的解决方案就是该模式的一种应用，可以将其抽象为以下几个参与者SharedResource（共享资源）参与者：可有多个线程访问的类，如GateSafeMethod：从多个线程同时调用也不会发生问题UnsafeMethod：从多个线程同时调用会发生问题，需要防范的方法所以必须将上述不安全的方法加以同步锁，当时如果通过其他方法改变不安全方法中数据也会发生错误，就像大门上锁，但是窗户开着一样，所以有时也是一个隐患的问题 那么此种模式何时适用了？多线程时、数据可被多个线程访问的时候、状态可能变化的时候、需要确保安全性的时候 生命线与死锁使用该模式，可能会发生死锁的危险而死锁是指：两个线程分别获取了锁定，互相等待另一个线程解除锁定的线程。发生死锁时，哪个线程都无法继续执行下去，所以程序会失去生命线最经典的死锁问题就是汤勺与叉子模型，问题大概是这样的假设A与B同吃一碗面，盘子旁有一支汤勺与一支叉子，而吃面必须同时需要汤勺和叉子而现在叉子被其中一人假设是A拿走，而汤勺被B拿走，就会造成如下现象：A和B一直等待对方放下叉子（或者汤勺），即一直处于等待，僵持阶段，从而程序无法继续运行，故称为死锁现象 而只要上述模式达到下面的条件，就会出现死锁1.具有多个SharedResource参与者2.线程锁定一个SharedResource时，还没接触前就去锁定另一个SharedResource3.获取SharedResource参与者的顺序不固定 当然只要破坏上述三个条件之一就可以避免死锁的发生 下面就开始模拟死锁首先是表示餐具的类(这里只有叉子和汤勺)123456789101112package com.zwl.utest2;public class Tool &#123; private final String name; public Tool(String name)&#123; this.name=name; &#125; public String toString()&#123; return "["+name+"]"; &#125;&#125; 开始用餐的类1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zwl.utest2;public class EaterThread extends Thread &#123; //用餐者名字 private String name; //左手拿餐具 private final Tool lefthand; //右手拿餐具 private final Tool righthand; public EaterThread(String name, Tool lefthand, Tool righthand) &#123; super(); this.name = name; this.lefthand = lefthand; this.righthand = righthand; &#125; public void run()&#123; //不断吃 while(true)&#123; eat(); &#125; &#125; public void eat()&#123; //锁定左手获取餐具 synchronized (lefthand) &#123; //左手拿餐具 System.out.println(name+"takes up"+lefthand+"left."); //锁定右手拿餐具 synchronized (righthand) &#123; //右手拿餐具 System.out.println(name+" takes up"+righthand+"right."); //开吃 System.out.println(name+" is eating"); //右手放下餐具 System.out.println(name+" puts down"+righthand+"right."); &#125; //解除右手锁定锁，并且左手放下餐具 System.out.println(name+"puts down"+lefthand+"left."); &#125; //解除左手餐具的锁定 &#125; &#125; 测试类12345 System.out.println("test begin:");Tool spoon=new Tool("Spoon");Tool fork=new Tool("Fork");new EaterThread("A", spoon, fork).start();new EaterThread("B", fork, spoon).start(); 测试结果： test begin:Atakes up[Spoon]left.A takes up[Fork]right.A is eatingA puts down[Fork]right.Aputs down[Spoon]left.Atakes up[Spoon]left.A takes up[Fork]right.A is eatingA puts down[Fork]right.Aputs down[Spoon]left.重复。。直到Atakes up[Spoon]left.Btakes up[Fork]left.该处程序停止不动了，也就是a和b分别拿着汤勺和叉子，即处于死锁状态了。 一种最简单的方法就是改变顺序，即以相同顺序拿餐具即： Tool spoon=new Tool(“Spoon”); Tool fork=new Tool(“Fork”); new EaterThread(“A”, spoon, fork).start(); new EaterThread(“B”, spoon,fork).start(); 最后程序就会一直进行下去，不过这样的话，前面的共享资源就不存在了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[并发系列一之初识java线程]]></title>
      <url>%2F2017%2F04%2F10%2Fthrd1%2F</url>
      <content type="text"><![CDATA[前言曾在论坛中看过这样一句话，如果连多线程都不懂，别说自己学过java，可见多线程的重要性！ 何谓线程简单来说，就像我们在执行一个程序时，他总按照顺序执行，如果从头到尾都没有分叉，也就是说总是一个流程，那么就可以看做单线程，并且程序执行的主体只有一个，所以，我们把正在执行程序的主体称为线程 当然，平时我们说的最多的就是多线程，顾名思义就是由一个以上的线程所构成的程序，比如文件处理，io请求处理及网络客户端发出的请求等等都可以看做多线程 Thread类先看一个简单的例子123456789101112package com.zwl.utest1;import java.util.Date;public class Mythread extends Thread &#123; @Override public void run() &#123; for(int i=0;i&lt;700;i++)&#123; System.out.print("hello!"); &#125;&#125;&#125; 测试类12345Mythread m=new Mythread(); m.start(); for(int i=0;i&lt;900;i++)&#123; System.out.print("lol!"); &#125; 测试结果 lol!lol!lol!lol!lol!lol!。。hello!hello!hello!hello!hello!。。lol!lol!lol!lol!lol!lol! 然后在去认识上面程序，其中start方法会启动新的线程，然后再由这个新线程调用run方法，当然也可以直接调用run方法 那么两者有什么区别了？调用start方法会出现字符串交错，也就是并发，而run方法，就是等run方法执行完，在执行其它，显然不会出现交错现象当然数据量小的话，出现的结果很难有说服力，所以并发模拟尽量使用大数量 线程的启动 利用thread的子类的实例，启动线程正如前面模拟的程序，不过下面测试用两个线程12new Mythread().start（）;new Mythread().start（）; 显然两个线程操作两个对象，所以thread是线程安全的 利用Runnable接口123456789public class Mythread implements Runnable&#123; @Override public void run() &#123; for(int i=0;i&lt;700;i++)&#123; System.out.print("hello!"); &#125;&#125;&#125; 测试类123 Mythread m=new Mythread();new Thread(m).start();new Thread(m).start(); 这里主要向Runnable接口实现的实例作为参数传递给Thread，再启动线程，这里就有一个问题，因为不同线程操作一个对象，所以会造成线程不安全的问题，也就是脏数据 线程的暂时停止利用Thread的sleep方法可暂时停止线程当前的操作，如123456789101112131415 public class Mythread implements Runnable&#123; @Override public void run() &#123; for(int i=0;i&lt;5;i++)&#123; System.out.print("hello!"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;&#125; 这里的参数是ms，所以1000就是1s了 线程的共享互斥在程序里，多个线程可自由操作，就会造成一个线程还在执行，另一个线程就插进来执行，就会造成一些脏数据的产生如：123456789 private int count=1000;@Overridepublic void run() &#123; for(int i=0;i&lt;100;i++)&#123; count--; System.out.println("mythread"+(count)); &#125; &#125; 测试类：1234 Mythread m=new Mythread();new Thread(m).start();new Thread(m).start();new Thread(m).start(); 测试结果：（取部分） mythread999mythread997mythread996mythread995mythread994 显然出现了脏数据要想使数据正确，一种方法是加同步锁，即一个线程在执行该操作时，其余线程无锁，则必须等待，直到该线程执行结束或者被挂起，才释放锁，然后在门外等待的线程依次执行，加锁，重复上述步骤显然，就不会出现多个线程操作同一个对象了 java中通过声明synchronized关键字实现同步锁如： public synchronized void run() 则在执行run方法前加同步锁，控制线程，当然该关键字可以声明在任何方法前，包括静态方法另外，它还有另外一种声明方式 public void run() { synchronized (xx.class) { } 注意这里xx.class是操作该方法的那个类实现同步比如这里可以将 synchronized (this) {} 就是对本身这个类加锁控制了等同于上述的另一种写法 线程的协调如果有一个线程正在执行同步锁，而其他线程则要等待，这是典型的线程互斥现象假如当该空间有空余时则写入数据，无空闲时间则等待（等待）当该空间有空闲时，则通知等待的线程（通知） 这里是根据空间是否空闲为条件进行线程处理，java中通过wait（让线程等待），notify与notifyAll（启动等候中的线程） 我们可以把线程处于等待的地方形象的看做wait set（线程的休息室） wait-把线程放入休息室12345678910111213141516171819 private static int count=90; public synchronized int s() throws InterruptedException&#123; count--; System.out.println("ok:"+count); this.wait(); System.out.println("lockover"); return count;&#125;@Override public void run() &#123; try &#123; s(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 然后在测试中启动几个线程1234 Count m=new Count();new Thread(m).start();new Thread(m).start();new Thread(m).start(); 测试结果： ok:89ok:88ok:87 一般为obj.wait（），而obj是某个对象的实例，也就是说该线程在obj的休息区之后会自动释放锁，等待的线程开始执行 当然也有obj.wait（1000）；也可以设置在休息区等待的秒数，然后继续执行 测试结果： ok:89ok:88ok:87lockoverlockoverlockover notify方法-从休息区拿出线程一般为obj.notify（），即从obj的wait set里的线程中挑选一个，唤醒一个线程并退出该休息区当然，这里有一个顺序，召唤该线程的那个线程执行完，释放锁后，那个在休息区的线程在执行 obj.notifyAll（），即从线程区中拿出所有线程 最后需要说一下的是wait、notify、notifyAll是Object的类方法，也就是所有类都能使用 由此可看出多线程的确是一个复杂而且很重要的东西！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[集合中的线程安全问题]]></title>
      <url>%2F2017%2F04%2F07%2Fthread2%2F</url>
      <content type="text"><![CDATA[前言早在刚开始学习java se的时候，就遇到过这样问题，xxx是线程安全的，xxxx是线程不安全的，当时也是一脸蒙，只记住了结论。后来接触了单例才有一点了解 线程安全的：vector、hashtable、stringbuffer等 非线程安全的：arraylist、linkedlist、hashmap、StringBuilder等等 首先来模拟一个案例 测试集合类12345678910111213141516171819202122232425262728public static void test() &#123;// 用来测试的List List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); // 线程数量(1000) int threadCount = 1000; // 用来让主线程等待threadCount个子线程执行完毕 CountDownLatch countDownLatch = new CountDownLatch(threadCount); // 启动threadCount个子线程 for(int i = 0; i &lt; threadCount; i++) &#123; Thread thread = new Thread(new Mythread(list,countDownLatch)); thread.start(); &#125; try &#123; // 主线程等待所有子线程执行完成，再向下执行 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // List的size System.out.println(list.size()); &#125; 自定义线程1234567891011121314151617181920212223242526package com.zwl.test;import java.util.List;import java.util.concurrent.CountDownLatch;public class Mythread implements Runnable &#123; private List&lt;Object&gt; list; private CountDownLatch countDownLatch; public Mythread(List&lt;Object&gt; list,CountDownLatch countDownLatch)&#123; this.list = list; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; // 每个线程向List中添加100个元素 for(int i = 0; i &lt; 100; i++) &#123; list.add(new Object()); &#125; // 完成一个子线程 countDownLatch.countDown(); &#125;&#125; 测试类：12345678public static void main(String[] args) &#123; // 进行10次测试 for(int i = 0; i &lt; 10; i++) &#123; test(); &#125; &#125; 测试结果： 998739996899955100000100000100000100000Exception in thread “Thread-7516” java.lang.ArrayIndexOutOfBoundsException: 76327 at java.util.ArrayList.add(ArrayList.java:441) at com.zwl.test.Mythread.run(Mythread.java:20) at java.lang.Thread.run(Thread.java:744) 有时不会出现异常，但是list的长度不是最终期望的那样，显然是线程不安全的，这里是arraylist，同样将其换成linkedlist，也可以改变list，变成其它，得到同样线程不安全结果 测试结果： 10000099783100000999459989799996998799997110000099899 将其换成线程安全的，如 List list = new Vector(); 测试结果： 100000100000100000100000100000100000100000100000100000100000 当然集合中的线程不安全是多线程同时操作同一个对象，如果是不同类，就不存在线程安全问题 对于线程安全，一般通过线程同步来实现，即通过申明synchronized关键字 如，改一下之前的线程安全的例子number类 修改后的number类1234567891011121314151617package com.zwl.test;public class number &#123; private int num=0; public void count()&#123; num++; &#125; public int getnumber()&#123; return num; &#125;&#125; 然后是自定义线程12345678910111213141516171819202122public class Mythread implements Runnable &#123; private number num; private CountDownLatch countDownLatch; public Mythread(number num,CountDownLatch countDownLatch)&#123; this.num = num; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; for(int i = 0; i &lt; 100; i++) &#123; num.count(); &#125; // 完成一个子线程 countDownLatch.countDown(); &#125;&#125; 线程测试类123456789101112131415161718192021222324252627 public static void test() &#123; number num=new number(); // 线程数量(1000) int threadCount = 1000; // 用来让主线程等待threadCount个子线程执行完毕 CountDownLatch countDownLatch = new CountDownLatch(threadCount); for(int i = 0; i &lt; threadCount; i++) &#123; Thread thread = new Thread(new Mythread(num,countDownLatch)); thread.start(); &#125; try &#123; // 主线程等待所有子线程执行完成，再向下执行 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(num.getnumber()); &#125; 测试类：123456789public static void main(String[] args) &#123; // 进行10次测试 for(int i = 0; i &lt; 10; i++) &#123; test(); &#125; &#125; 测试结果： 1000001000001000001000009994099300100000100000100000100000 出现了线程不安全可以通过对方法声明同步 public synchronized void count(){} 最后输出的书都是同一个数 最后不得不说，线程安全是一个很复杂的问题，有时候不注意就会出现数据上的各种问题！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识线程安全与线程不安全]]></title>
      <url>%2F2017%2F04%2F06%2Fthread1%2F</url>
      <content type="text"><![CDATA[前言关于线程问题基本上贯穿学习的整个过程，像集合，servlet，structs，hibernate，spring等等，其都涉及到线程问题 线程安全什么是线程安全？如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全 不妨来一个实例首先是number类，里面有一个计数的全局和静态变量123456789101112131415161718192021package com.zwl.test;public class number &#123; private int num; private static int count; public void count()&#123; for(int i=1;i&lt;=10;i++)&#123; num+=i; &#125; System.out.println(Thread.currentThread().getName()+":"+num); &#125; public void countstatic()&#123; for(int i=1;i&lt;=10;i++)&#123; count+=i; &#125; System.out.println(Thread.currentThread().getName()+":"+count); &#125;&#125; 显然我们希望每个线程都能输出的结果是55就是线程安全 线面是测试类：12345678910111213141516171819202122package com.zwl.test;public class test &#123; public static void main(String[] args) &#123; Runnable runner=new Runnable() &#123; number num=new number(); @Override public void run() &#123; num.count(); System.out.println("statis:"); num.countstatic(); &#125; &#125;; for(int i=0;i&lt;10;i++)&#123; new Thread(runner).start(); &#125; &#125;&#125; 这里启动十个线程，依次通过run方法输出全局和静态变量的累加和，如果是线程安全的，则应该都是55 结果如下所示 Thread-0:55statis:Thread-0:55Thread-1:110statis:Thread-1:110Thread-2:165statis:Thread-2:165Thread-6:275statis:Thread-6:220Thread-3:385statis:Thread-4:220statis:Thread-3:275Thread-8:385statis:Thread-8:385Thread-4:330Thread-5:440statis:Thread-5:440Thread-7:495statis:Thread-7:495Thread-9:550statis:Thread-9:550 发现不是线程安全的 线程不安全线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据 对于上面的线程不安全可以进行如下修改 解决方法：将全局变量变成局部变量（静态变量暂时不讨论）1234567public void count()&#123; int num = 0; for(int i=1;i&lt;=10;i++)&#123; num+=i; &#125; System.out.println(Thread.currentThread().getName()+":"+num); &#125; 最后所有的线程都输出了55 或者将new 的number放到run里面，变成局部的12345678@Override public void run() &#123; number num=new number(); num.count(); System.out.println("statis:"); num.countstatic(); &#125; &#125;; 最后也能保证了线程安全了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识Linkedlist底层]]></title>
      <url>%2F2017%2F04%2F05%2Flinkedlist%2F</url>
      <content type="text"><![CDATA[前言LinkedList底层是基于双端链表实现的，也就是说它具有指向其前驱与后继的引用，而且，在插入与删除数据时效率极高 至于它继承谁和实现什么接口，直接看源码 public class LinkedList extends AbstractSequentialList implements List, Deque, Cloneable, java.io.Serializable 和ArrayList一样，从源码分析其add、get以及remove方法 add方法 首先通过MyEclipse进入LinkedList的源码 找到add（）方法 12345public boolean add(E e) &#123; //把e放在链表的最后一个位置 linkLast(e); return true; &#125; 找到linkLast（）方法 1234567891011121314151617181920212223242526272829303132333435/** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; //链表最后一个结点的引用 transient Node&lt;E&gt; first; //链表第一个结点的引用void linkLast(E e) &#123; //将l也指向最后一个结点 final Node&lt;E&gt; l = last; //调用Node（Node&lt;E&gt; prev，E element，Node&lt;e&gt; next）构造方法 //其中prev为前驱结点，element为对象元素，next为后继结点 //这里构造新节点，并且是作为尾节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //last结点指向newNode last = newNode; //如果l为空，则表示链表为空，直接把newNode作为首节点，否则放在l结点之后 if (l == null) first = newNode; else l.next = newNode; //链表的元素个数加一 size++; //链表发生结构性修改的次数，这里主要指添加及删除操作 modCount++; &#125; 以上便是add方法的源码，主要通过改变链表的前驱及后继引用来完成插入，可想而知，使用链表，使插入数据的速度异常快，相对顺序查找 get方法找到get方法 12345678public E get(int index) &#123; //检查index是否合法 checkElementIndex(index); //如果合法就返回该节点位置的值 return node(index).item; &#125; 找到checkElementIndex(int index)方法 12345private void checkElementIndex(int index) &#123; //检查index是否合法 if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; 找到isElementIndex(index)方法 1234//判断index是否存在于链表中private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size; &#125; 找到node(int index)方法 12345678910111213141516171819Node&lt;E&gt; node(int index) &#123; //index已在链表中 // assert isElementIndex(index); //从第一个位置开始寻找，知道找到index的位置，最后返回该节点的位置 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; //从最后一个位置开始往前寻找该节点 else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; linkedlist在查找时的效率非常低，就是因为它是从头或从尾部遍历链表，所以当数据量大时，造成效率低下 remove方法找到remove方法 1234567public E remove(int index) &#123; //检查index是否合法 checkElementIndex(index); return unlink(node(index)); &#125; 找到unlink(node(index))方法 1234567891011121314151617181920212223242526272829303132333435363738 E unlink(Node&lt;E&gt; x) &#123; // assert x != null; //保存x节点的值 final E element = x.item; //保存x节点的后继 final Node&lt;E&gt; next = x.next; //保存x节点的前驱 final Node&lt;E&gt; prev = x.prev; //如果前驱为空，则表明要移除的是第一个结点，在把first指向下一个节点 if (prev == null) &#123; first = next; &#125; else &#123; //否则把x前驱的后继指向x的后继，并把x前驱设置为null prev.next = next; x.prev = null; &#125; //如果后继为空，则表明要移除的是最后一个结点，在把last引用指向x的前驱 if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125;//把x结点的值设置为null，保证x没有任何引用了 x.item = null; //链表的size减一 size--; //链表的结构性修改次数加一 modCount++; //这里该节点移除之前以保存在element中，然后返回该节点 return element; &#125; 至此，简单把上面三个方法的源码简单过了一遍当然，还有一点不得不提的是LinkedList可以当做stack（栈），queue（队列）处理，因为它是双端链表，另外，在遍历时，有index &lt; (size &gt;&gt; 1)，即判断index与size/2比较，这样可以缩小范围，选择是从前遍历还是从后遍历，从而大大增加查找效率]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hibernate之四:反向工程]]></title>
      <url>%2F2017%2F04%2F04%2Fhbm4%2F</url>
      <content type="text"><![CDATA[前言在运用持久层框架时，先前我们都是先通过建立对象—映射文件—数据库的方法，倘若数据库中的表非常多和复杂时，我们可以改变下开发顺序，即从数据库自动生成映射文件和对象，这样涉及表之间的关系，级联或者主外键约束就自动生成，更方便。一般我们用hibernate的反向工程达到此目的。 不多说，先模拟一个案例。首先建立三张表user，picture，addr表，分别如下User表 Picture表 外键 这里的uid是外键对应user表的主键，并且只有当user的id删除时，对应uid相应的记录删除 Addr表 外键 通过myeclipse 提供 数据库浏览器连接到我们的mysql数据库 然后点击右键，选择new，出现如下界面 首先选择数据库，然后填写相关配置信息，其中Driver name随便取，添加jar包，然后点击test Driver，如股票成功，则表示与数据库连接成功，此外，可以选择保存密码，不然，后续操作一次，就要输入密码直接点击finish， 接下来在MyEclipse中创建一个web工程，通过工具自身引入hibernate，具体步骤如下 选择之前配置好的sshe 直接点结束，这样hibernate就引入了。 下面我们使用myeclipse提供的逆向工程，自动的创建对象类和对象关系映射文件选中要反向的表 注意我们可以事先在项目中新建一个包，用来存放映射对象和文件 最后点击finish，则自动生成了。 最后值得注意的是，这里只是模拟了三张表，有一对多和多对一关系，主外键及级联，这样就省得我们自己去配置了，因为hibernate的关系配置真的很麻烦！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hibernate之三:浅谈HQL和映射文件]]></title>
      <url>%2F2017%2F04%2F03%2Fhbm3%2F</url>
      <content type="text"><![CDATA[前言当我们想要精确的查找某一个数据库中的信息时，最理想的方法就是通过sql语句查询，一般hibernate中可以通过query接口来写语句进行查询，这个语句可以使sql，hql，当然推荐的是hql，事实上我认为hql和sql基本差不多 一：Query接口 Query接口类型的对象可以对数据库操作,它可以使用Hql和原生SQL(native Sql)对数据库操作.官方推荐使用Hql语句先来看一个例子 测试代码：1234@Test public void selectone()&#123; User u=(User)session.createQuery(" from User where id=1").uniqueResult(); System.out.println(u.getName());&#125; 分析：这里用了uniqueResult()方法 ，如果我们检索一个对象，明确知道最多只有一个对象，则建议使用该方法: 如果是取出集合对象，则使用如下方法：测试代码：123456@Testpublic void selectone()&#123; List&lt;User&gt; list=session.createQuery("from User").list(); for(User user : list)&#123; System.out.println(user.getName());&#125; 由此我们可以发现，使用list可以取出集合对象，同时方法里面写想要的hql语句 二：HQL简单语法 HQL是面向对象的查询语言，与SQL不同，HQL中的对象名是区分大小写的；HQL中查的是对象而不是表，并且支持多态；HQL主要通过Query来操作，Query的创建方式： Query q = session.createQuery(hql); 1：between.. and.. 测试代码： List list=session.createQuery(“from User where id between 0 and 2”).list(); 2：in /not in List list=session.createQuery(“from User where id in (1,2)”).list(); 其他如group by，having，聚集函数等都类似于sql语句，换汤不换药。 参数绑定： 先看例子： 1234567org.hibernate.Query query= session.createQuery("from User where id between ? and ?"); query.setInteger(0, 1); query.setInteger(1,2); List&lt;User&gt; list=query.list(); for(User user : list)&#123; System.out.println(user.getName()); &#125; 主要通过set与？的形式来注入参数，注意这里第一个？对应set的序号为0使用绑定参数的好处:1.可读性好.2.性能提高.3.防止sql注入 HQL语句远不止这些，这里只简单介绍了其中一些， 三：映射文件的配置 映射文件的内容繁多，这里只简单介绍其中一些常见属性。大体说来，映射文件主要对class的映射，还包括属性，属性又分为主键，普通属性和集合属性，甚至还有复合属性，每种属性都需要进行不同的配置。 先从入门程序中的例子说起： 其中：package : 表示该类在哪个包下，name : 表示类名 table 表示 该类和哪个表映射同时在class内部可以配置各种属性 主键： 主键就是持久化类中标识属性，用于唯一标识该对象，主要通过进行设置，有三个常用属性：name，column，type。 Name ：表示类的哪个属性是主键 必须指定Column：指定在数据库中主键对应的列明 不必须指定 Type：与数据库中对应字段类型一致 不必须指定例外：主键需指定主键生产策略，即generator，一般用于自增长，针对不同数据库，关键词不一样，由于是mysql，所以自增长选择increment以上的代码表示： 1234&lt;id name="id" type="java.lang.Integer"&gt; &lt;generator class="increment"&gt; &lt;/generator&gt; &lt;/id&gt; 普通属性： 使用标签，该标签必须指定name属性，用于标记持久化类的属性名称。一般有如下常见属性： Type，column，not-null（是否允许为空），lazy（是否支持延迟加载，默认为false不支持），代码如下： 123456&lt;property name="name" type="java.lang.String"&gt; &lt;column name="name" not-null="false"/&gt; &lt;/property&gt; &lt;property name="age" type="java.lang.Integer"&gt; &lt;column name="age" not-null="false"/&gt; &lt;/property&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hibernate之二:核心类和接口]]></title>
      <url>%2F2017%2F04%2F02%2Fhbm2%2F</url>
      <content type="text"><![CDATA[前言当我们对数据进行持久化操作时，必然涉及到hibernate的一些核心类，而这些类是我们在增删改查之前必然要引用和加载的先看总览图： 一般情况下，是由下向上看。 一 ：hibernate.cfg.xml文件①该文件主要用于指定各个参数,是hibernate核心文件 ②默认放在src目录下，也可以放在别的目录下。 ③指定连接数据库的驱动、用户名、密码、url、连接池.. ④指定对象关系映射文件的位置. ⑤也可使用hibernate.properties文件来替代该文件.(推荐使用hibernate.cfg.xml)。 如：入门程序代码：1234567891011121314&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="connection.url"&gt;jdbc:mysql://localhost:9806/sshe&lt;/property&gt; &lt;property name="connection.username"&gt;root&lt;/property&gt; &lt;property name="connection.password"&gt;&lt;/property&gt; &lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;!-- 配置数据库的方言/ --&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- 配置管理的对象映射文件 --&gt; &lt;mapping resource="com/zwl/bean/User.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 二：对象关系映射文件(*.hbm.xml) ①该文件主要作用是建立表和类的映射关系，是不可或缺的重要文件. ②一般放在其映射的类同一个目录下,但不是必须的。 ③命名方式一般是 类名.hbm.xml,但不是必须的。 ④示意图: 如：入门程序代码：1234567891011121314151617181920&lt;!-- package : 表示该类在哪个包下 --&gt;&lt;hibernate-mapping package="com.zwl.bean"&gt;&lt;!-- name : 表示类名 table 表示 该类和哪个表映射 --&gt; &lt;class name="User" table="user"&gt; &lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt; &lt;!-- name:表示类的哪个属性是主键 --&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;!-- 指定主键生成策略 --&gt; &lt;generator class="increment"&gt; &lt;/generator&gt; &lt;/id&gt; &lt;!-- property 里是普通属性 , column表示该属性映射到表中哪个字段 --&gt; &lt;property name="name" type="java.lang.String"&gt; &lt;column name="name" not-null="false"/&gt; &lt;/property&gt; &lt;property name="age" type="java.lang.Integer"&gt; &lt;column name="age" not-null="false"/&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 三：Configuration 类它的用处是: 读取hibernate.cfg.xml 管理对象关系映射文件 加载hibernate 的驱动,url ,用户.. 管理hibernate配置信息 创建的代码： Configuration cf=new Configuration().configure(); 四：SessionFactory （会话工厂）这是典型的工厂设计模式，其是用来生产session实例的，注意由于该工厂启动耗费内存，所以应该只被初始化一次，并且应该是线程安全的，所以应该用单例模式设计 归纳一下特点：1 缓存sql语句和某些数据 2.在应用程序初始化的时候创建,是一个重量级的类(吃内存),一般用单例模式保证一个应用中只需要一个 SessionFactory实例. 3.如果某个应用访问多个数据库，则要创建多个会话工厂实例,一般是一个数据库一个会话工厂实例. 4.通过SessionFactory接口可以获得Session(会话)实例 创建的代码： SessionFactory sf=cf.buildSessionFactory(); 五：Session 1.Session一个实例代表与数据库的一次操作(当然一次操作可以是crud组合) 2.Session实例通过SessionFactory获取，用完需要关闭。 3.Session是线程不同步的(不安全),因此要保证在同一线程中使用,可以用getCurrentSessiong()。 4.Session可以看做是持久化管理器,它是与持久化操作相关的接口 如图所示： 另外：有两种方式获得session1：通过openSession()获取sessionopenSession() 是获取一个新的session2 getCurrentSession () getCurrentSession () 获取和当前线程绑定的session,换言之，在同一个线程中，我们获取的session是同一session,这样可以利于事务控制 创建的代码： Session s=sf.getCurrentSession();//或者是: Session s=sf.openSession(); 如何选择原则:1.如果需要在同一线程中，保证使用同一个Session则，使用getCurrentSession()2.如果在一个线程中，需要使用不同的Session,则使用opentSession()通过 getCurrentSession() 获取的session在事务提交后，会自动关闭，通过openSession()获取的session则必须手动关闭如果是通过getCurrentSession() 获取 sesssion ,进行查询需要事务提交 Session(会话)接口的几个重要方法Session一般以对象的形式来操作 1保存一个对象(记录)—save方法 2删除一个对象(记录)—delete方法 3查询一个对象(记录)—get/load方法 4修改一个对象(记录)—update方法 如：入门程序中的代码 1234567891011Sava方法：User u=new User(); u.setId(1); u.setName("hello world"); u.setAge(21); session.save(u); t.commit();Delete方法：User u=(User)session.get(User.class, 1); session.delete(u); t.commit(); 一般情况下，我们从数据库中获取对象，可以通过session.get（或者session.load（）），那么他们有什么区别了？1、get()方法直接返回实体类,如果查不到数据则返回null。load()会 返回一个实体代理对象（当前这个对象可以自动转化为实体对象）， 但当代理对象被调用时，如果没有数据不存在，就会抛出个 org.hibernate.ObjectNotFoundException异常 这里：可以将get看做单例中的饿汉式，而load相当于懒汉式 load先到缓存(session缓存/二级缓存)中去查，如果没有则返回一个代理对象（不马上到DB中去找），等后面使用这个代理对象操作的时候，才到DB中查询,这就是我们常说的 load在默认情况下支持延迟加载（lazy） get先到缓存(session缓存/二级缓存)中去查，如果没有就到DB中去 查（即马上发出sql）。总之，如果你确定DB中有这个对象就用 load(),不确定就用get()（这样效率高） 这里有一点注意：默认lazy加载时不启用，所以如果要启用，则需要在映射文件中配置 六：Transaction(事务)接口 事务简单的说,就是一组对数据库的操作集合,它们要么全部成功,要么全部失败.这个可以保证数据的一致性,事务具有原子性。 创建的代码： Transaction ts=s.beginTransaction(); …ts.commit();s.close()； 注意：如果数据库的数据发生变化，一定需要数据提交 七：Criteria接口如入门程序的查询：1234List&lt;User&gt; list=session.createCriteria(User.class).list(); for(User user : list)&#123; System.out.println(user.getName()); &#125; 即通过面向对象的操作，返回该对象所有的集合]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hibernate之一:hello world]]></title>
      <url>%2F2017%2F04%2F01%2Fhbm1%2F</url>
      <content type="text"><![CDATA[前言对一个框架的直观认识，往往是从一个hello world程序开始的。Hibernate是一个完全的ORM（Object Relationship Mapping）对象映射框架。实现了JDBC轻量级的封装，使得在进行JDBC开发的时候可以直接使用面向对象的思维进行开发，说白了hibernate框架的作业就是在java对象和关系数据库中作了一个映射，使得程序员不用再使用各种SQL语句 Hibernate有如下几个特点： 1：完成了对JDBC的封装，不用再与各种connection打交道 2：是一个持久层框架，即对数据库进行持久化操作 3：是一个ORM框架，不用再与各种sql打交道 接下里就是hibernate入门程序，目的先有一个直观认识，不考虑其含义，只要把流程走一遍就完成了目的。这里用最简的方式完成入门程序 步骤一：创建一个java 工程 步骤二：建一个lib文件夹，并导入如下jar包，然后添加至项目中 步骤三：在src目录下创建一个hibernate.cfg.xml配置文件，并编写，同时添加mysql驱动包1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;!-- 该文件用于配置连接数据的种类,用户名，密码,ul ,驱动.. 连接池,二级缓存 --&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="connection.url"&gt;jdbc:mysql://localhost:9806/sshe&lt;/property&gt; &lt;property name="connection.username"&gt;root&lt;/property&gt; &lt;property name="connection.password"&gt;yourpassword&lt;/property&gt; &lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;!-- 配置数据库的方言/ --&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 简单说明一下：上面的配置文件指明了一些必要的数据库连接属性，通过这些属性，hibernate可以连接上数据库，可以配置不同的数据库，其中配置数据库的方言指明所配置的是用哪种数据库 步骤四：创建bean对象123456789package com.zwl.bean;public class User &#123; private int age; private int id; private String name;。。。此处省略set与get方法&#125; 这里注意：利用hibernate框架时，鼓励我们为每张表设置主键，即为每个对象设置一个id，在映射时与表的id对应 步骤五：创建数据库表，这个步骤也可以在步骤四之前进行。主要为id（主键，自增长），name、age 步骤六：编写表与对象的映射文件User.hbm.xml12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--该文件要清楚地表述出 类 和 表 的对应关系--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- package : 表示该类在哪个包下 --&gt;&lt;hibernate-mapping package="com.zwl.bean"&gt;&lt;!-- name : 表示类名 table 表示 该类和哪个表映射 --&gt; &lt;class name="User" table="user"&gt; &lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt; &lt;!-- name:表示类的哪个属性是主键 --&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;!-- 指定主键生成策略 --&gt; &lt;generator class="increment"&gt; &lt;/generator&gt; &lt;/id&gt; &lt;!-- property 里是普通属性 , column表示该属性映射到表中哪个字段 --&gt; &lt;property name="name" type="java.lang.String"&gt; &lt;column name="name" not-null="false"/&gt; &lt;/property&gt; &lt;property name="age" type="java.lang.Integer"&gt; &lt;column name="age" not-null="false"/&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 简单说明一下：上面已经简要说明了一些含义，这里先看做强加的概念，事实上这是比较完整的配置，当然这里并没有给出简化的配置。同时，该文件相当于在java对象和数据库表中作了一个映射，这样以后就可以通过操作java对象来间接操作表 另外，该映射文件一般放在与相应的java对象同处一个文件夹下，并且命名满足规范XXX.hbm.xml，其中xxx就是java对象名，最后还要在hibernate核心配置文件中声明该映射，即加入如下代码： 步骤六：就是进行测试，实现插入数据的crud操作 首先写一个工具类： 1234567891011121314151617181920package com.zwl.utils;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtils &#123; private static final SessionFactory sessionFactory=BuildSessionFactory(); private static SessionFactory BuildSessionFactory()&#123; try &#123; return new Configuration().configure().buildSessionFactory(); &#125; catch (Exception e) &#123; throw new ExceptionInInitializerError(e); &#125; &#125; public static SessionFactory getSessionFactory()&#123; return sessionFactory; &#125;&#125; 简单说明一下，这里采用单例模式，目的是为了不要每次都加载配置，不然太耗费内存 接下来是测试类，首先是增加功能 12345678910111213141516public class Usertest &#123; SessionFactory sessionFactory=HibernateUtils.getSessionFactory(); Session session=sessionFactory.openSession(); Transaction t=session.beginTransaction();@Testpublic void save()&#123; User u=new User(); u.setId(1); u.setName("hello world"); u.setAge(21); session.save(u); t.commit();&#125; 接下来是查询（遍历） 1234567//查询 @Test public void select()&#123; List&lt;User&gt; list=session.createCriteria(User.class).list(); for(User user : list)&#123; System.out.println(user.getName()); &#125; 最后是删除： 1234567//删除 @Test public void delete()&#123; User u=(User)session.get(User.class, 1); session.delete(u); t.commit(); &#125; 修改这里就先不说了。至此入门程序完成，意在了解hibernate的具体过程，有没有发现，到目前为止，我们都没有写sql语句，而都是对java对象进行操作，来操作表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2 之六:拦截器]]></title>
      <url>%2F2017%2F03%2F31%2Fstructs6%2F</url>
      <content type="text"><![CDATA[前言拦截器是structs2框架的核心功能，理解并使用拦截器有助于更灵活使用structs2.它像一个可插播的组件，围绕action和result进行，可以在方法调用之前、之后使用。通过structs2的工作流程，可以发现调用一个action之前之后有许多的拦截器，这些拦截器都通过后才可以执行具体的action。对与每一个拦截器来说，可以直接返回，从而终止余下的拦截器 以下，是structs工作原理图 从图中可以看出，从一个具体的请求到action需要经过多个拦截器，action处理完成后，后续的拦截器会据需执行，最终到浏览器中。大概其工作流程如下 上述的servlet filters图示与实际有点不一样，其他一样（图不是现在版本） 一 首先请求发送给StrutsPrepareAndExecuteFilter（web.xml配置那个） 二：StrutsPrepareAndExecuteFilter判断该请求是否是一个structs2请求，如果是则进入第3步 三：如果是structs2请求，则把请求交给ActionProxy，是action代理类，ActionProxy创建一个Actioninvocation实例，并进行初始化 在执行具体的action之前，actionProxy会设计相关拦截器的调用Action调用结束后，会根据structs.xml文件中action的result配置对象得到对应的返回结果。调用execute方法之后，执行后面的拦截器，把结果返回给浏览器 从整个请求处理过程来看，拦截器是处理的关键 下面将通过实现Interceptor接口来写一个简单的拦截器，该接口有三个方法，init（），destroy（），intercept（），init（）在拦截器实例创建之后，intercept方法之前调用，主要用于初始化拦截器所需要的资源，destroy主要销毁初始化分配的资源，intercept方法则是在action之前调用，可以通过invocation对象获取action状态，从而根据状态的不同进行需要的拦截操作 如下为一个简单的模拟案例 123456789101112131415161718192021222324252627import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;public class lanji implements Interceptor &#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void init() &#123; // TODO Auto-generated method stub &#125; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; long start=System.currentTimeMillis(); String result=invocation.invoke();//没有拦截，正常执行 long end=System.currentTimeMillis(); System.out.println(end-start); return result; &#125;&#125; 然后就需要在配置文件中配置首先申明该拦截器12345678&lt;interceptors&gt; &lt;interceptor name="lanji" class="com.zwl.pojo.lanji"&gt;&lt;/interceptor&gt; &lt;/interceptors&gt;在action中引用&lt;action name="ognlaction" class="com.zwl.action.ognlaction"&gt; &lt;interceptor-ref name="lanji"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; 注意必须要带上默认拦截器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2 之五:通用标签]]></title>
      <url>%2F2017%2F03%2F30%2Fstructs5%2F</url>
      <content type="text"><![CDATA[前言 Struts2框架为我们提供了许多标签，这些标签从总体上可以分为两类：通用标签和ui标签。而较常使用的是通用标签，通用标签又分为两类，数据标签和控制标签。数据标签用于访问值栈中的数据。控制标签用于控制呈现页面时数据执行流程。 不过使用structs2标签，需要在jsp首部加入如下代码 &lt;%@ taglib uri=”/struts-tags” prefix=”s” %&gt; 数据标签 主要用于访问actioncontext和值栈中的数据 一：property标签 格式： 如果value中的内容为object，则Struts2都会把它解析成ognl表达式 如果里面需要表示为字符串，则需要将内容用单引号括起来 1、 利用ognl表达式取值(例如：取值堆栈中的username值)1&lt;s:property value="username"/&gt; 2、 取值为字符串需要将内容用单引号括起来1&lt;s:property value="’username’"/&gt; 3、 设置默认值-default如果一个对象值取不到，则可以使用default设置一个默认值。1&lt;s:property value="admin" default=”管理员”/&gt; 4、 设定HTML-escape是否设置返回值为HTML原代码样式true：解析返回值的html代码 false:原封不动返回值1&lt;s:property value="'&lt;hr/&gt;'" escape="false"/&gt; 二、 set标签注：var 用于设定变量名 value 变量值(可以是ognl表达式)，也可以是字符串 scope 就是的作用范围 request session page application action(默认) 123456789&lt;li&gt;set 设定adminName值（默认为request 和 ActionContext）: &lt;s:set var="adminName"value="username" /&gt;&lt;/li&gt; &lt;li&gt;set 从request取值: &lt;s:property value="#request.adminName" /&gt;&lt;/li&gt;&lt;li&gt;set 从ActionContext取值: &lt;s:property value="#adminName" /&gt;&lt;/li&gt;&lt;li&gt;set 设定var，范围为ActionContext: &lt;s:set var="adminPassword" value="password"scope="session"/&gt;&lt;/li&gt;&lt;li&gt;set 使用#取值: &lt;s:property value="#adminPassword"/&gt; &lt;/li&gt;&lt;li&gt;set 从相应范围取值: &lt;s:property value="#session.adminPassword"/&gt; &lt;/li&gt; 控制标签 一： If elseif else12345age = &lt;s:property value="#parameters.age[0]" /&gt; &lt;br /&gt; &lt;s:set var="age" value="#parameters.age[0]" /&gt; &lt;s:if test="#age &lt; 0"&gt;wrong age!&lt;/s:if&gt; &lt;s:elseif test="#parameters.age[0] &lt; 20"&gt;too young!&lt;/s:elseif&gt; &lt;s:else&gt;yeah!&lt;/s:else&gt;&lt;br /&gt; 二：Iterator标签一般格式如下12 &lt;s:iterator value="值" var="x"&gt;&lt;s:property value="#x.username" /&gt; 这个格式将集合里的内容取出该属性一般有三个属性，id，status，value其中value属性指定迭代的集合，status属性可以获得迭代中一个状态信息（比如索引值，是否是奇偶数等）12345678&lt;s:iterator value="&#123;'aaa', 'bbb', 'ccc'&#125;" status="status"&gt; &lt;s:property/&gt; | 遍历过的元素总数：&lt;s:property value="#status.count"/&gt; | 遍历过的元素索引：&lt;s:property value="#status.index"/&gt; | 当前是偶数？：&lt;s:property value="#status.even"/&gt; | 当前是奇数？：&lt;s:property value="#status.odd"/&gt; | 是第一个元素吗？：&lt;s:property value="#status.first"/&gt; | 是最后一个元素吗？：&lt;s:property value="#status.last"/&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2 之四:OGNL表达式]]></title>
      <url>%2F2017%2F03%2F29%2Fstructs4%2F</url>
      <content type="text"><![CDATA[前言OGNL表达式的全称是 Object Graph Navigation Language，即 对象图导航语言，使用OGNL表达式可以使用简单的语法设置以及读取java对象的值 一般， 注意： value里的内容称为ognl表达式，由于其功能强大，涉及东西太多，只做部分总结 下面就先模拟一个案例，首先需要几个模拟的对象类首先是Dog类123456789private String name; public Dog(String name)&#123; this.name=name; &#125; public Dog()&#123;&#125;此处省略set。。get方法 然后是Cat类12345678private Dog friend; public String miaomiao() &#123; return "miaomiao"; &#125;此处省略set。。get方法 接着是user类123456789private String msg;public user()&#123;&#125;public user(String msg)&#123; this.msg=msg;&#125;此处省略set。。get方法 在配置文件中，仍然不变 12345678&lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;global-results&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="ognlaction" class="com.zwl.action.ognlaction"&gt; &lt;/action&gt; 下面是action，思路是在action中一点一点加入模拟代码，在相应的jsp中将值回显出来1234567public class ognlaction extends ActionSupport&#123; private String username; public String execute() throws Exception &#123; // TODO Auto-generated method stub return super.execute(); &#125; 下面所以属性的set与get方法都将省略。。首先是验证普通属性，对应jsp页面为 1：访问值栈中的action的普通属性: username = 2：访问值栈中对象的普通属性(get set方法)： 首先action增加 private user use;对应jsp为： 3访问值栈中对象中的成员对象的普通属性(get set方法) 首先action增加：private Cat cat;对应jsp为： 4访问值栈中对象的普通方法 5访问值栈中action的普通方法首先action增加：public String m() { return “hello”;}对应jsp为： 6 OGNL表达式语言访问静态方法，需要在Struts2.xml配置文件如下： 12&lt;constant name="struts.ognl.allowStaticMethodAccess" value="true"&gt;&lt;/constant&gt; 首先增加一个pojo类： 12345public class s &#123; public static String STR = "STATIC STRING"; public static String s() &#123; return "static method"; &#125;&#125; 对应jsp：1234&lt;li&gt;访问静态方法：&lt;s:property value="@com.zwl.pojo.s@s()"/&gt;&lt;/li&gt; &lt;li&gt;访问静态属性：&lt;s:property value="@com.zwl.pojo.s@STR"/&gt;&lt;/li&gt; &lt;li&gt;访问Math类的静态方法：&lt;s:property value="@@max(2,3)" /&gt;&lt;/li&gt; 注意使用@符号访问 7访问List中元素某个属性的集合中的特定值：首先action增加123456private List&lt;user&gt; users=new ArrayList&lt;&gt;();public ognlaction()&#123; users.add(new user("1")); users.add(new user("2")); users.add(new user("3")); &#125; 对应jsp为： 8：访问Set中某个元素首先action增加： private Set dogs = new HashSet(); 对应jsp为： 9：访问Map中某个元素首先action增加： private Map dogMap = new HashMap(); 访问Map中某个元素: 访问Map中所有的key: 访问Map中所有的value: 10：调试： 主要用来查看值栈。而值栈主要来存放对象的，类似于正常的栈， 以下为部分结果截图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2 之三:result返回结果]]></title>
      <url>%2F2017%2F03%2F28%2Fstructs3%2F</url>
      <content type="text"><![CDATA[前言Structs2中的result是作为返回结果的，当一个action处理完之后返回字符串的结果码。框架可以根据这个返回的字符串，映射到指定的页面。Result元素可以分为两部分：一是结果映射，一部分是返回结果类型 结果映射 Result有两个属性可以配置：name属性和type属性，其中name属性主要用来指定资源的逻辑名称，实际名称在标签内指定。Type属性就是result返回的类型，这两个属性不是必须的。其中默认情况下，name为success，type为dispatch（转发）另外，result标签还有一个子标签param，该标签可以为result指定实际资源位置，其中属性name为必填，而当type为dispatch时，param可以省略不写 针对上面，不妨先模拟一个案例12345 &lt;action name="helloworld" class="com.zwl.action.helloworld"&gt; &lt;result type="dispatcher"&gt;&lt;param name="location"&gt;/success.jsp&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; 这里的location是用于指示资源的位置，标签内的内容是参数的值 对应我们习惯写的形式为12345&lt;action name="helloworld" class="com.zwl.action.helloworld"&gt; &lt;result name="success"&gt;/success.jsp &lt;/result&gt; &lt;/action&gt; 结果类型： 常用的有四种，dispatch、redirect、redirectAction和chain，其中dispatch相当于转发，redirect相当于重定向，redirectAction也是重定向，但是它是重定向到某个action，而chain则是利用action的链式处理 第一种：dispatch 它是系统默认的结果类型，其有两个属性，localtion和parse，配置如下1234 &lt;result type="dispatcher"&gt;&lt;param name="location"&gt;/success.jsp&lt;/param&gt;&lt;param name="parse"&gt;true&lt;/param&gt; &lt;/result&gt; 其中parse是一个布尔类型，当为true时，表示解析localtion参数中的OGNL表达式，默认是true 第二种：redirect 当使用该类型时，框架后台会使用response对象的sendRedirect方法进行重定向，下面先简单对比一下重定向与转发的区别：一：重定向会发生两次请求，转发只会发生一次请求 重定向的时候，浏览器的地址栏会发生变化，而转发的地址栏是无变化的 重定向的实质是服务器告诉浏览器去另外的地方寻找资源，所以地址栏会发生变化，而转发则是在服务器内部发生的，所以地址栏不会发生变化 由于重定向是两次请求，所以第二次请求的会话保存的信息是无效的，而转发的时候会话仍然有效，因为请求不变 对于重定向中会话仍然有效的方法是在配置文件中使用OGNL表达式，将参数传递过去对于以上内容，不妨一个实例来的具体点 首先是上面的dispatch如之前的hello world入门程序，最终观察地址栏和参数是可以接收到的 当type为redirect时12345&lt;action name="helloworld" class="com.zwl.action.helloworld"&gt; &lt;result type="redirect"&gt;/success.jsp &lt;/result&gt; &lt;/action&gt; 观察地址栏是显示jsp的，但是参数是无法接收到的那么如何解决了？12345 &lt;action name="helloworld" class="com.zwl.action.helloworld"&gt; &lt;result name="success" type="redirect"&gt;/success.jsp?user=$&#123;use.msg&#125; &lt;/result&gt; &lt;/action&gt; 即带一个参数，注意此时的话，在success.jsp中值就不在值栈中了，因为不经过action，所以应该用如下方法取出123&lt;body&gt; &lt;s:property value="#parameters.user"/&gt; &lt;/body&gt; 第三种：redirectAction，其底层都是通过Response对象的sendRedirect方法进行重定向的，只不过它是重定向到某个action，所以如果一个action处理完之后还要交给另一个action据需处理，则使用该类型。它的结果类型有两个参数，actionName（指定需要重定向的action）和namespace（指定action所在的命名空间，如果没有指定该参数，框架会从默认的namespace中去寻找）1234567&lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;action name="helloworld" class="com.zwl.action.helloworld"&gt; &lt;result type="redirectAction"&gt; &lt;param name="actionName"&gt;helloworld1&lt;/param&gt; &lt;param name="namespace"&gt;/&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; 第四种：chain一样，也是跳转到某个action123&lt;action name="r3"&gt; &lt;result type="chain"&gt;r1&lt;/result&gt; &lt;/action&gt; 接下来，进行简单对比Redirect和redirectAciton都是客户端跳转，而dispatch和chain都是服务器端跳转 全局action：当有多个action都需要返回某个页面的时候，就可以用到全局结果即在同一个包下所有的action都共享该result，如下所示123456&lt;global-results&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="helloworld" class="com.zwl.action.helloworld"&gt; &lt;/action&gt; 仍然操作之前的步骤，结果仍能执行全局中的result NamespaceNamespace决定了action的访问路径，默认为“”，可以接收所有路径的action，如果没有找到相应的namespace时，则使用namespace为空的actionNamespace可以写为/，或者/xxx,或者/xxx/yyy，对应的action访问路径为/index.action、/xxx/index.action、或者/xxx/yyy/index.action.Namespace最好也用模块来进行命名 标签 是用来解决重名的问题，例如当系统的前台和后台都有一个action名叫hello，这时就需要用package来区分。 前台后台struts2中的package与java的package是相同的作用的 访问Web元素Action中的会话一般有三种request,session,application，但是他们都是map类型一般情况下有四种方式可以获得 方法一：ActionContext方式一般在Action类的构造方法、或execute()方法中获取如下案例： 1234567891011121314151617181920public class LoginAction1 extends ActionSupport&#123; private Map request; private Map session; private Map application; public LoginAction1() &#123; request=(Map) ActionContext.getContext().get("request"); session=ActionContext.getContext().getSession(); application=ActionContext.getContext().getApplication(); &#125; @Override public String execute() throws Exception &#123; request.put("r1", "r1"); session.put("s1", "s1"); application.put("a1", "a1"); return super.execute(); &#125; 然后在页面中可以通过标签或者java片段取出123&lt;s:property value="#request.r1"/&gt; | &lt;%=request.getAttribute("r1") %&gt; &lt;br /&gt; &lt;s:property value="#session.s1"/&gt; | &lt;%=session.getAttribute("s1") %&gt; &lt;br /&gt;&lt;s:property value="#application.a1"/&gt; | &lt;%=application.getAttribute("a1") %&gt; &lt;br/&gt; 方式二：Ioc(控制反转)—推荐使用让Action类实现RequestAware、SessionAware、ApplicationAware接口，然后重写他们的set方法(setRequest、setSession、setApplication)，通过依赖注入、控制反转(原来自己控制，现在由别人来控制值。) 12345678910111213141516171819202122public class LoginAction2 extends ActionSupport implements RequestAware,SessionAware, ApplicationAware &#123; private Map&lt;String, Object&gt; request; private Map&lt;String, Object&gt; session; private Map&lt;String, Object&gt; application; public String execute() &#123; request.put("r1", "r1"); session.put("s1", "s1"); application.put("a1", "a1"); return SUCCESS; &#125; @Override public void setRequest(Map&lt;String, Object&gt; request) &#123; this.request = request; &#125; @Override public void setSession(Map&lt;String, Object&gt; session) &#123; this.session = session; &#125; @Override public void setApplication(Map&lt;String, Object&gt; application) &#123; this.application = application; &#125; 方式三：获取原类型获取是的HttpServletRequest/HttpSession/ServletContext12345678private HttpServletRequest request; private HttpSession session; private ServletContext application; public LoginAction3() &#123; request = ServletActionContext.getRequest(); session = request.getSession(); application = session.getServletContext(); &#125; 一般情况下只用前三种，第四种就不说了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2 之二:action详解]]></title>
      <url>%2F2017%2F03%2F27%2Fstructs2%2F</url>
      <content type="text"><![CDATA[前言在structs2中，action是其核心功能，而使用structs2框架，主要都是围绕action进行，我们编写的action通常需要实现com.opensymphony.xwork2.Action接口，需要实现的方法时execute方法，但是在实际开发中，编写的action也可以不必实现action接口，而是直接创建一个普通的java类，并添加execute方法就可以，如入门程序的案例，还有一种方式就是继承ActionSupport类，其已经实现了action的execute方法，以上方式，后两者比较常用 接下来将在入门程序的基础上，来介绍action属性 一：action属性 Action中有一个映射框架，主要讲url映射到对应的action，action的配置主要在struts.xml文件中编写， 以下是action的几个常见属性 属性 是否必须 说明Name 是 action的名字，用于匹配请求的urlClass 否 action实现类的完整类名Method 否 调用action实现类中指定的方法 需要注意的是，action的name属性有规范，即不允许出现.或者/或者-，另外我们来看看如果只配置一个name属性，class怎么加载？理论上是框架会调用actionsupport类中的execute方法，该方法的实现仅仅是返回一个success，但是实际上去掉之后，入门程序中跳转正确，但是数据取不到，至少说明的确跳转正确， 下面对method属性进行说明由之前我们知道通常action的作用是完成一个功能点，但是如果同时又crud方法，显然创建四个action就太麻烦了，这时候就可以使用method属性，至于怎么用，先看一个实例。即对用户进行增删该查 首先是useraction.java 1234567891011121314151617181920212223242526import com.opensymphony.xwork2.ActionSupport;public class useraction extends ActionSupport&#123; //查询 public String selectall()&#123; return SUCCESS; &#125; //更新 public String update() &#123; return SUCCESS; &#125; //删除 public String delete() &#123; return SUCCESS; &#125; //添加 public String add()&#123; return SUCCESS; &#125;&#125; 这里注意一下，在action中并不一定非要需要写execute方法，也可以自己指定需要的方法，但是必须要在Struts.xml中做相应的配置，如下1234567891011121314&lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;action name="helloworld" class="com.zwl.action.useraction" method="selectall"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="helloworld1" class="com.zwl.action.useraction" method="update"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="helloworld2" class="com.zwl.action.useraction" method="delete"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="helloworld3" class="com.zwl.action.useraction" method="add"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 然后在前台页面写需要调用的action1234 &lt;form action="helloworld.action"&gt; &lt;input type="text" name="msg"/&gt; &lt;input type="submit"/&gt;&lt;/form&gt; 显然我们发现用此种方法思路清晰，但是太啰嗦，这就是有时需要动态调用action，简称DMI，先看一个例子，首先是useraction1.java123456789101112131415161718192021222324252627282930313233public class useraction1 extends ActionSupport&#123; private String msg; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; //查询 public String selectall()&#123; return "selectall"; &#125; //更新 public String update() &#123; return "update"; &#125; //删除 public String delete() &#123; return "delete"; &#125; //添加 public String add()&#123; return "add"; &#125; 这里我们可以通过自定义方法返回不同的值，然后通过result中name属性配置相应不同的值，来返回到不同的界面12345678910111213//这里是是否启用DMI方法，默认是关闭的&lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt; //这里是否启用开发者模式，这样就不用每次重启服务器 &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;action name="useraction1" class="com.zwl.action.useraction1"&gt; &lt;result name="selectall"&gt;/success.jsp&lt;/result&gt; &lt;result name="update"&gt;/success.jsp&lt;/result&gt; &lt;result name="delete"&gt;/success.jsp&lt;/result&gt; &lt;result name="add"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 好了，配置文件也配置好了，接下来就是在页面中调用DMI方法，一般的格式是actionname!xxx.action1234&lt;form action="useraction1!delete.action"&gt; &lt;input type="text" name="msg"/&gt; &lt;input type="submit"/&gt; &lt;/form&gt; 至此动态调用action已完成，接下来将是默认的action配置默认的action先看配置实例：123456&lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;default-action-ref name="helloworld"&gt;&lt;/default-action-ref&gt; &lt;action name="helloworld" class="com.zwl.action.useraction" method="selectall"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; 在表单中跳转到一个不存在的action时，则执行设置的默认action，这里需要注意的是每个namespace下，只能有一个默认的action，否则不知道执行那个默认的action 通配符映射 使用通配符，可以将配置量降到最低，不过一定要实现约定好命名规范，即约定优于配置原则在action配置中，表示所有，可以匹配任意的字符，而{数字}表示第几个通配符，如 _，{1}表示第一个，{2}表示第二个*接下来模拟一个案例，如下所示首先是action12345678910111213141516public class useractionsave extends ActionSupport&#123; private String msg; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public String save()&#123; return "save"; &#125;&#125; 配置文件12345678&lt;action name="useraction*" class="com.zwl.action.useraction&#123;1&#125;" method="&#123;1&#125;"&gt; &lt;result name="save"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;form action="useractionsave.action"&gt; &lt;input type="text" name="msg"/&gt; &lt;input type="submit"/&gt; &lt;/form&gt; 最后测试通过 最后介绍一下action的属性接受参数事实上action中有三种方法 方法一：在Action添加成员属性接受参数之前的案例都是采用这种方法的，就不多介绍了，不过值得注意的是，参数提交的名称必须和action的属性一致，并且要有set与get方法 方法二： 域模型(Domain Model)就是先创建一个对象，通过在action中操作其属性来传递参数，相应的先建立一个user对象12345678910111213141516171819202122232425public class user &#123;private String msg;public String getMsg() &#123; return msg;&#125;public void setMsg(String msg) &#123; this.msg = msg;&#125;然后是action private user use; public user getUse() &#123; return use; &#125; public void setUse(user use) &#123; this.use = use; &#125; public String save()&#123; return "save"; &#125; 这里需要注意的是前台参数传递，是action中引用对象的那个属性，其它都一样12345&lt;body&gt; &lt;form action="useractionsave.action"&gt; &lt;input type="text" name="use.msg"/&gt; &lt;input type="submit"/&gt; &lt;/form&gt; 方法三： ModelDriven接收参数使Action实现com.opensymphony.xwork2.ModelDriven(在实现接口时需要使用泛型，否则使用时需要转型)中利用其getModel()方法返回对象模型，从而获得传入的参数。 参数被传入至Action后，会被ModelDriven对象根据参数名自动赋值给User对象相应的属性而生成User对象，并且由getModel()返回。那么我们在Action中就可以利用这个对象了。注意：传入的参数名需要与对象模型中的成员属性一致。 这里在将上述案例中的action修改一下。123456789101112131415161718192021public class useractionsave extends ActionSupport implements ModelDriven&lt;user&gt;&#123;public String save()&#123; return "save"; &#125; private user use=new user(); public user getUse() &#123; return use; &#125; public void setUse(user use) &#123; this.use = use; &#125;@Overridepublic user getModel() &#123; // TODO Auto-generated method stub return use;&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2 之一:hello world]]></title>
      <url>%2F2017%2F03%2F26%2Fstructs1%2F</url>
      <content type="text"><![CDATA[前言Struts2框架是Apache基金组织下的一个开源框架，是基于MVC模式设计的web应用开发框架。它利用并扩展了java servlet API，鼓励开发者采用MVC架构。 当然本次不介绍strucs2的相关知识，只做一个快速入门案例，及环境搭建和将整个程序走一遍，最后完成hello world程序，也就是先有一个具体印象。 下载并解压struts2开发包，同时建立一个web工程 步骤一： 为了方便，建议直接将开发包中的app下的web-inf下的lib里的文件夹里的jar包全部导入到项目的lib文件夹里 步骤二：编写web.xml文件。一般情况下，我们将开发包中的web.xml复制下来，修改，并且放到web-inf目录下，保留下面内容 步骤三：编写action类，也就是接受前台传过来的数据并进行相应处理和转发123456789101112131415161718package com.zwl.action;public class helloworld &#123; private String msg; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public String execute()&#123; return "success"; &#125;&#125; 值得注意的是这里的msg要与前台表单里的name值一致，并且要有set和get方法，这样struct2就自动将前台表单输入的值赋给msg了，然后public String execute()，默认的转发方法，也就是说它返回的值要与result中的name属性设置的值一致，这样就可以跳转到相应界面了，当然这里要结合接下来的步骤才可以 步骤四：配置structs.xml文件，直接将文档中该文件拷到src目录下，修改为如下代码12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;action name="helloworld" class="com.zwl.action.helloworld"&gt; &lt;result name="success"&gt;success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 解释一下：package下name 和namespace就是为了区分重名，这里暂且不管，就按这种默认形式，action中name也就是我们表单提交的路径，class中是要加载的相应的action类，这里是helloworld，而result则是上述方法中返回的字符，里面为要跳转到success.jsp界面，因为这里是个入门程序，目的就是先具体体验。 步骤五：编写相应界面首先是：index.jsp123456&lt;body&gt; &lt;form action="helloworld.action"&gt; &lt;input type="text" name="msg"/&gt; &lt;input type="submit"/&gt; &lt;/form&gt; &lt;/body&gt; 这里结合一下步骤三，只要输入一个文本，后台通过反射机制，自动获得（只要满足标准）该值，并保存在栈中 然后是success.jsp1234&lt;%@ taglib uri="/struts-tags" prefix="s" %&gt;//因为用到structs标签，所以这是声明使用&lt;body&gt; &lt;s:property value="msg"/&gt;//取得后台传过来的输入的值 &lt;/body&gt; 测试：在浏览器中输入到index.jsp。填表单，最后跳转到success.jsp中并取出值 至此，hello world入门程序算是完成了至此，再把上述开发步骤总结一下： 1：准备jar包2：在web.xml中配置structs2的相关过滤器配置3： 开发action，针对不同的功能开发不同的action4：在structs.xml中添加上一步骤开发的action相应的配置（页面跳转等等）5：编写相应的页面 最后我们将整个过程抽象成一个结构图 上述的控制器就是web.xml配置的那个，仔细对比一下整个程序，基本上mvc框架的总体过程就是这样了，当然，这里只是一个入门程序，所以所有的配置都是最简的，只有一个目的，那就是hello world！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于struts2与easy ui的后台显示界面]]></title>
      <url>%2F2017%2F03%2F25%2Feasyui1%2F</url>
      <content type="text"><![CDATA[前言最近一直忙着做项目，已经好几天没写博客了。我认为提高自己的最好路径就是先把我知道的东西总结出来，再去从已知探索未知的东西，最后在总结下来。不多说，就用笔者最喜欢的struts2和easy ui来一个需求 利用easy ui的datagrid做一个后台界面（目前只是分页显示数据），并从数据库取出，大概如下界面 在此之前，先简单介绍一下easy ui的特点（和大部分ui基本一样）1.基于jquery 用户界面插件的集合；2.为一些当前用于交互的js 应用提供必要的功能；3.使用EasyUI 你不需要写很多的javascript 代码，通常只需要写HTML 标记来定义用户界面即可；4.支持HTML5；5.开发产品时可节省时间和资源；6.简单，但很强大；7.支持扩展，可根据自己的需求扩展控件；8.源代码加密 总之，在后台界面上easy ui是一个很好的选择 1.新建一个web工程 2.添加ssh整合jar包、gson.jar、mysql驱动包、easy ui的官方文档（ui文件夹）里面有五个文件必须引入（并且有顺序，否则无法引用） 1234567891011 //引入EasyUI 核心UI 文件CSS &lt;link rel="stylesheet" type="text/css" href="ui/themes/default/easyui.css" &gt; //引入EasyUI 图标文件&lt;link rel="stylesheet" type="text/css" href="ui/themes/icon.css" &gt;//引入jQuery 核心库&lt;script type="text/javascript" src="ui/jquery-1.8.0.min.js" &gt;&lt;/script&gt; //引入jQuery EasyUI 核心库&lt;script type="text/javascript" src="ui/jquery.easyui.min.js" &gt;&lt;/script&gt; //引入EasyUI 中文提示信息 &lt;script type="text/javascript" src="ui/locale/easyui-lang-zh_CN.js" &gt;&lt;/script&gt; 3.新建一个页面（先贴出代码）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 &lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;index&lt;/title&gt; //加载easy ui&lt;link rel="stylesheet" type="text/css" href="ui/themes/default/easyui.css" &gt; &lt;link rel="stylesheet" type="text/css" href="ui/themes/icon.css" &gt; &lt;script type="text/javascript" src="ui/jquery-1.8.0.min.js" &gt;&lt;/script&gt; &lt;script type="text/javascript" src="ui/jquery.easyui.min.js" &gt;&lt;/script&gt; &lt;script type="text/javascript" src="ui/locale/easyui-lang-zh_CN.js" &gt; &lt;/script&gt;&lt;script type="text/javascript"&gt;//页面初始化之前执行函数 $(function() &#123; //调用easy ui的datagrid组件，显示json数据，也可以通过html方式加载，这里使用js加载方式 $('#admin_yhgl_datagrid').datagrid(&#123; //远程加载的json格式数据 url: '$&#123;pageContext.request.contextPath&#125;/booksort!showdatagrid.action', //组件宽度 width : 1200, // 是否可伸缩 fitColumns : true, //js对象数组，从后台获得total（总记录）和ids（对象数据集合）然后显示出来 columns : [[&#123; //字段，与后台字段数据对应field : 'id', //标题title : '排名',//是否排序sortable:true,//宽度width:80,//是否居中align:'center',&#125;,&#123;field : 'barcode',title : '图书条形码',width:80,align:'center',&#125;,&#123;field : 'bookname',title : '图书名称',width:80,align:'center',&#125;,&#123;field : 'bookshelf',title : '书架',width:80,align:'center',&#125;,&#123;field : 'bookpublish',title : '出版社',width:80,align:'center',&#125;,&#123;field : 'bookauthor',title : '图书作者',width:80,align:'center',&#125;,&#123;field : 'bookprice',title : '定价',width:80,align:'center',&#125;,&#123;field : 'borrowtime',title : '借阅次数',width:80,align:'center',&#125;,]],//是否有分页插件pagination : true,//每页显示记录数pageSize : 5,//设置记录数多少的选项设置pageList : [5, 10, 15, 20],//排序的字段sortName : 'id', &#125;); &#125;);&lt;/script&gt;&lt;body&gt;//显示datagrid组件&lt;table id="admin_yhgl_datagrid"&gt;&lt;/table&gt;&lt;/body&gt; 目前还没有写后台，所以暂无数据加载显示 4 建表（为了方便直接截个图）然后随便加几个数据 5.编写pojo与映射文件 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Book &#123;private String barcode;private String bookauthor;private String bookname;private String bookprice;private String bookpublish;private String bookshelf;private String booktype;private int borrowtime;private int id;省略set与get方法&#125;//映射文件&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Mapping file autogenerated by MyEclipse Persistence Tools--&gt;&lt;hibernate-mapping package="com.pojo"&gt; &lt;class name="Book" table="book" &gt; &lt;id name="id" &gt; &lt;generator class="increment"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="bookname"&gt; &lt;/property&gt; &lt;property name="bookauthor"&gt; &lt;/property&gt; &lt;property name="barcode"&gt; &lt;/property&gt; &lt;property name="bookprice"&gt; &lt;/property&gt; &lt;property name="bookpublish"&gt; &lt;/property&gt; &lt;property name="bookshelf"&gt; &lt;/property&gt; &lt;property name="booktype"&gt; &lt;/property&gt; &lt;property name="borrowtime"&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 6.dao层service层接口123456789101112131415161718public interface Basedao&lt;T&gt; &#123; public List&lt;T&gt; find(String hql, int page, int rows); //分页时返回T对象集合 public Long count(String hql); //返回总记录数 &#125;public interface Basedaoservice &lt;T&gt;&#123;//Book的包装类，主要增加easy ui所需要的一些属性 public DataGrid datagrid(Tbook book); &#125; 7.编写工具类12345678910111213141516171819202122232425262728293031323334353637383940public class DataGrid &#123; private Long total = 0l; //总记录 private List rows = new ArrayList(); //datagrid需要的json数据加载数据 省略set与get方法&#125;public class Tbook &#123; private String barcode; private String bookauthor; private String bookname; private String bookprice; private String bookpublish; private String bookshelf; private String booktype; private int borrowtime; private int id; private String ids; //前台被选中行的字符转 private String order; //排序 private int page; //多少页 private int rows; private String sort; //排序名。。。。。&#125;public class Character &#123; public static HttpServletResponse Tojson() throws Exception&#123; HttpServletResponse response=ServletActionContext.getResponse(); HttpServletRequest request=ServletActionContext.getRequest(); request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("application/json; charset=utf-8"); //返回json数据 response.setHeader("Cache-Control", "no-cache"); //不要缓存 response.setHeader("Pragma", "no-cache"); PrintWriter out = response.getWriter(); return response; &#125; &#125; 8.实现类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Basedaoimpl&lt;T&gt; extends HibernateDaoSupport implements Basedao&lt;T&gt; &#123; @Override public List&lt;T&gt; find(String hql, int page, int rows) &#123; Query q=this.getSession().createQuery(hql); return q.setFirstResult((page-1)*rows).setMaxResults(rows).list(); &#125; @Override public Long count(String hql) &#123; Query q=this.getSession().createQuery(hql); return (Long) q.uniqueResult(); &#125;public class Basedaoserviceimpl&lt;T&gt; implements Basedaoservice&lt;T&gt; &#123; private Basedao&lt;T&gt; basedao; public Basedao&lt;T&gt; getBasedao() &#123; return basedao; &#125; public void setBasedao(Basedao&lt;T&gt; basedao) &#123; this.basedao = basedao; &#125; @Override public DataGrid datagrid(Tbook book) &#123; DataGrid dg=new DataGrid(); //查询所有的book数据 String hql="from Book b"; //排序sql if(book.getSort()!=null)&#123; hql += " order by " + book.getSort() + " " + book.getOrder(); &#125; //取出所有的book记录，放在集合汇总 List&lt;Book&gt; l=(List&lt;Book&gt;) basedao.find(hql, book.getPage(), book.getRows()); //查出所有记录数 String totalHql = "select count(*) " + hql; //将book对象集合一次加进Tbook包装类集合 List&lt;Tbook&gt; nl=new ArrayList&lt;Tbook&gt;(); if (l != null &amp;&amp; l.size() &gt; 0) &#123; for(Book t:l)&#123; Tbook u=new Tbook(); BeanUtils.copyProperties(t, u); nl.add(u); &#125; &#125; dg.setTotal(basedao.count(totalHql)); dg.setRows(nl); return dg; &#125;&#125; 9 action主题代码1234567891011121314151617181920212223242526272829303132public class booksort implements ModelDriven&lt;Tbook&gt; &#123; //利用modaldriven包装Tbook private Tbook book=new Tbook(); private Basedaoservice&lt;Book&gt; basedaoservice; public void showdatagrid() throws Exception&#123; HttpServletResponse response=Character.Tojson(); Gson gson=new Gson(); //创建gson对象 response.getWriter().write(gson.toJson(basedaoservice.datagrid(book))); //将对象转为json数据 &#125; public Basedaoservice&lt;Book&gt; getBasedaoservice() &#123; return basedaoservice; &#125; public void setBasedaoservice(Basedaoservice&lt;Book&gt; basedaoservice) &#123; this.basedaoservice = basedaoservice; &#125; @Override public Tbook getModel() &#123; // TODO Auto-generated method stub return book; &#125;&#125; 10 spring配置和structs配置（参考之前的博客）这里就不配置了，基本都是套路 至此就能加载数据了，当然easy ui在后台界面中的使用不仅方便而且强大，这也是笔者最喜欢使用easy ui的原因]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis 之四:mybatis整合spring]]></title>
      <url>%2F2017%2F03%2F24%2Fmybatis4%2F</url>
      <content type="text"><![CDATA[前言整合思路： 1、数据源信息交给spring管理2、sqlsessionfactory交给spring进行单例管理3、由spring来管理mapper代理的代理类 下面以根据用户id查询用户信息案例来搭建工程步骤一：建立java工程 步骤二：添加整合包（这里需要的jar包过多）Mysql的驱动包Mybatis的核心包和依赖包Mybatis和spring的整合包Spring的包dbcp数据库连接池包等等 步骤三：在src目录下建立sqlmapconfig.xml配置文件，里面暂时只有一个dtd文件声明1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;/configuration&gt; 步骤四：在src目录下建立applicationcontext.xml配置文件里面目前只配置一些重要连接数据库的信息，后面步骤将加入重要信息1234567891011121314151617181920212223242526272829303132333435&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 创建数据源 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:9806/sshe" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- SqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 指定mybatis的全局配置文件的路径 --&gt; &lt;property name="configLocation" value="SqlMapConfig.xml"&gt;&lt;/property&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 步骤五：创建pojo类123456public class User &#123;private int age;private int id;private String name;此处省略set与get方法。。&#125; 步骤六：创建mapper代理首先是UserMapper.xml1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.zwl.mapper.UserMapper"&gt; &lt;!-- 根据用户ID查询用户信息 --&gt; &lt;select id="findUserById" parameterType="int" resultType="com.zwl.pojo.User"&gt; SELECT * FROM user WHERE id =#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 接下来是mapper接口123public interface UserMapper &#123; public User findUserById(int id) throws Exception;&#125; 然后在sqlmapconfig.xml文件中声明代理文件123456&lt;configuration&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="com/zwl/mapper/UserMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 步骤七：spring中注入123456&lt;bean id="UserMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;!-- 设置代理类的接口 --&gt; &lt;property name="mapperInterface" value="com.zwl.mapper.UserMapper"&gt;&lt;/property&gt; &lt;!-- 依赖注入SqlSessionFactory --&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; 步骤八：测试类1234567891011121314151617181920public class test &#123; private ApplicationContext ctx;//在测试之前自动加载 @Before public void setUp() throws Exception &#123; ctx = new ClassPathXmlApplicationContext( "applicationContext.xml"); &#125; @Test public void testFindUserById() throws Exception &#123; UserMapper dao = (UserMapper) ctx.getBean("userMapper"); User user = dao.findUserById(1); System.out.println(user.getName()); &#125;&#125; 测试结果：取出数据库中的helloworld至此mybatis整合spring完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis 之三:映射文件]]></title>
      <url>%2F2017%2F03%2F23%2Fmybatis3%2F</url>
      <content type="text"><![CDATA[前言基本上我们对数据库的操作都在映射文件中编写，通过mapper代理方式简化配置，同时依据不同的参数和返回类型完成相关需求 一：parameterType输入参数简单类型：1234&lt;select id="findUserById" parameterType="int" resultType="com.zwl.pojo.User"&gt; SELECT * FROM user WHERE id =#&#123;id&#125; &lt;/select&gt; 参数是基本类型，在之前已演示 Pojo类型123456&lt;insert id="insertuser" parameterType="com.zwl.pojo.User"&gt;&lt;selectKey keyProperty="id" resultType="int" order="AFTER"&gt;select LAST_INSERT_ID()&lt;/selectKey&gt;insert into user values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)&lt;/insert&gt; 即参数类型是一个对象，如之前的添加操作 包装pojo类型即在类中包含另一个对象，如1234public class Uservo &#123;private User user;此处省略set。。get方法&#125; 配置文件中1234&lt;select id="findUserById" parameterType="com.zwl.pojo.Uservo" resultType="com.zwl.pojo.User"&gt; SELECT * FROM user WHERE id =#&#123;user.id&#125; &lt;/select&gt; 参数是包装类，注意参数是包装类的属性 Map 同传递pojo对象一样，map的key相当于pojo的属性1234&lt;select id="findUserById" parameterType="hashmap" resultType="com.zwl.pojo.User"&gt; SELECT * FROM user WHERE id =#&#123;id&#125; and name=#&#123;name&#125; &lt;/select&gt; 显然，参数是hashmap，其中#{id}与#{name}都是hashmap的key 接口文件123public interface UserMapper &#123; public User findUserById(HashMap&lt;String, Object&gt; id) throws Exception;&#125; 测试类：123456789UserMapper mapper=sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Object&gt; hm=new HashMap&lt;&gt;(); hm.put("id", 1); hm.put("name","helloworld"); User u=mapper.findUserById(hm); System.out.println(u.getAge()); sqlSession.close(); 输出映射Resulttype： 使用要求： 使用resultType进行结果映射时，需要查询出的列名和映射的对象的属性名一致，才能映射成功。如果查询的列名和对象的属性名全部不一致，那么映射的对象为空。如果查询的列名和对象的属性名有一个一致，那么映射的对象不为空，但是只有映射正确那一个属性才有值。 简单类型：resultType=”int”Pojo对象：resultType=”com.zwl.pojo.User” 如之前的案例Resultmap使用resultMap进行结果映射时，不需要查询的列名和映射的属性名必须一致。但是需要声明一个resultMap，来对列名和属性名进行映射12345&lt;resultMap type="com.zwl.pojo.User" id="Userresult"&gt; &lt;id column="id_" property="id"/&gt; &lt;result column="name_" property="name"/&gt; &lt;result column="age_" property="age"/&gt; &lt;/resultMap&gt; 其中id为查询结果中唯一列映射，result标签为映射结果中的普通列 1234&lt;select id="findUserById" parameterType="int" resultMap="Userresult" &gt; SELECT id id_,name name_,age age_ FROM user WHERE id =#&#123;id&#125; &lt;/select&gt; 其中resultmap必须与声明中的id保持一致，这样才能引用 接口：123public interface UserMapper &#123; public User findUserById(int id) throws Exception;&#125; 测试代码： 123User u=mapper.findUserById(1); System.out.println(u.getAge()); sqlSession.close(); mybatis与hibernate的区别及各自应用场景Mybatis技术特点：1、 通过直接编写SQL语句，可以直接对SQL进行性能的优化；2、 学习门槛低，学习成本低。只要有SQL基础，就可以学习mybatis，而且很容易上手；3、 由于直接编写SQL语句，所以灵活多变，代码维护性更好。4、 不能支持数据库无关性，即数据库发生变更，要写多套代码进行支持，移植性不好。 Hibernate技术特点：1、 标准的orm框架，程序员不需要编写SQL语句。2、 具有良好的数据库无关性，即数据库发生变化的话，代码无需再次编写。3、 学习门槛高，需要对数据关系模型有良好的基础，而且在设置OR映射的时候，需要考虑好性能和对象模型的权衡。4、 程序员不能自主的去进行SQL性能优化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis 之二:开发dao的两种方式]]></title>
      <url>%2F2017%2F03%2F22%2Fmybatis2%2F</url>
      <content type="text"><![CDATA[前言Dao层的开发，在mybatis中可以通过原始dao（一个接口和接口实现类），而在mybatis中可以更方便的通过mapper代理模式，当然需要满足一定的规范性原则 不多说，以一个增加user信息为例 一：首先在映射文件中写一个增加用户配置信息12345678&lt;!-- 添加用户 --&gt; &lt;!-- selectKey：查询主键，在标签内需要输入查询主键的sql --&gt; &lt;!-- order：指定查询主键的sql和insert语句的执行顺序，相当于insert语句来说 --&gt; &lt;!-- LAST_INSERT_ID：该函数是mysql的函数，获取自增主键的ID，它必须配合insert语句一起使用 --&gt; &lt;insert id="insertuser" parameterType="com.zwl.pojo.User"&gt; &lt;selectKey keyProperty="id" resultType="int" order="AFTER"&gt;select LAST_INSERT_ID()&lt;/selectKey&gt; insert into user values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt; 注意：这里的插入中原表中主键有自增长，所以需要先获得主键，在增加，这是一个插入语句 二：dao接口及其实现类1234567891011121314151617181920212223242526public interface userdao &#123;//添加user public void insertusers(User user) throws Exception;&#125;Dao接口实现类public class userdaoimpl implements userdao &#123; private SqlSessionFactory sqlSessionFactory; //通过构造函数注入sqlSessionFactory public userdaoimpl(SqlSessionFactory sqlSessionFactory)&#123; this.sqlSessionFactory=sqlSessionFactory; &#125; @Override public void insertusers(User user) throws Exception &#123;//通过线程安全方式获得sqlsession，实现增删该查操作 SqlSession sqlsession=sqlSessionFactory.openSession();//注意这里的test是映射文件中的namespace，insertuser是id用于标识 sqlsession.insert("test.insertuser", user);//添加操作需要提交事务 sqlsession.commit(); sqlsession.close(); &#125; 编写测试类12345678910111213141516//读取配置文件 //全局配置文件的路径 String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); //创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //创建user User u=new User(); u.setName("java"); u.setAge(18); //调用dao层方法，实现添加功能 userdao dao=new userdaoimpl(sqlSessionFactory); dao.insertusers(u); 这种原始dao方式，我们很熟悉，也很好理解，到时当方法多的时候，就会存在大量多余的重复编码问题 Mapper代理的开发模式即开发mapper接口（相当于dao接口）Mapper代理使用的是jdk的代理策略 还有一点是mapper代理最重要的，就是必须满足mapper代理的开发规范1 mapper接口的全限定名要和mapper映射文件的namespace值一致2 mapper接口的方法名称要和mapper映射文件的statement的id一致。3 mapper接口的方法参数类型要和mapper映射文件的statement的parameterType的值一致，而且它的参数是一个。4 mapper接口的方法返回值类型要和mapper映射文件的statement的resultType的值一致。 下面以入门程序的通过id查询user为例首先是修改映射文件，改名为UserMapper.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace：命名空间，对statement的信息进行分类管理 --&gt;&lt;!-- 注意：在mapper代理时，它具有特殊及重要的作用 --&gt;&lt;mapper namespace="com.zwl.mapper.UserMapper"&gt; &lt;!-- 根据用户ID查询用户信息 --&gt; &lt;!-- select：表示一个MappedStatement对象 --&gt; &lt;!-- id：statement的唯一标示 --&gt; &lt;!-- #&#123;&#125;：表示一个占位符？ --&gt; &lt;!-- #&#123;id&#125;：里面的id表示输入参数的参数名称，如果该参数是简单类型，那么#&#123;&#125;里面的参数名称可以任意 --&gt; &lt;!-- parameterType：输入参数的java类型 --&gt; &lt;!-- resultType：输出结果的所映射的java类型（单条结果所对应的java类型） --&gt; &lt;select id="findUserById" parameterType="int" resultType="com.zwl.pojo.User" &gt; select * from user where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 上述的namespace需要和mapper接口的全限定名一致然后是mapper接口开发（UserMapper.java） 1234567package com.zwl.mapper;import com.zwl.pojo.User;public interface UserMapper &#123; public User findUserById(int id) throws Exception;&#125; 接下来是在配置文件中声明映射文件123&lt;mappers&gt; &lt;mapper resource="com/zwl/mapper/UserMapper.xml" /&gt; &lt;/mappers&gt; 测试类：123456789101112131415String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); //创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); //通过mybatis的sqlsession来创建代理对象 UserMapper mapper=sqlSession.getMapper(UserMapper.class); User u=mapper.findUserById(1); System.out.println(u.getName()); sqlSession.close(); 最后的测试结果是取出数据库中id为1的helloworld 至此mapper代理开发dao完成，这里只给了一个简单的例子，总的来说，只要满足规范，就可以简化配置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis 之一:hello world]]></title>
      <url>%2F2017%2F03%2F21%2Fmybatis1%2F</url>
      <content type="text"><![CDATA[前言Mybatis就是一个封装了jdbc的持久层框架，它和hibernate都属于orm框架，但是具体说，hibernate是一个完全的orm框架，而mybatis是一个不完全的orm框架，mybatis只关注sql本身，而不需要关注如连接的创建，statement的创建等操作。Mybatis会将输入参数、输出结果进行映射。 不多说，先来一个入门程序，意在先从整体了解步骤一：创建一个java工程 步骤二：导入jar包，首先创建一个lib文件夹，在将包导入 步骤三：数据库中的表user 步骤四：创建pojo类，与数据库字段对应1234567891011121314151617181920212223242526package com.zwl.pojo;public class User &#123; private int age; private int id; private String name; public int getAge() &#123; return age; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 步骤五：创建全局配置文件（mybatis核心配置文件SqlMapConfig.xml，放在src目录下）12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置mybatis的环境信息，与spring整合，该信息由spring来管理 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源，采用mybatis连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:9806/sshe" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; 还没有映射文件 &lt;/mappers&gt;&lt;/configuration&gt; 简要说明一下，类似于hibernate核心配置文件，连接数据库，这里暂时还没有映射文件，后面步骤在加上 步骤六：映射文件（User.xml）这里是通过id查询返回对象12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace：命名空间，对statement的信息进行分类管理 --&gt;&lt;!-- 注意：在mapper代理时，它具有特殊及重要的作用 --&gt;&lt;mapper namespace="test"&gt; &lt;!-- 根据用户ID查询用户信息 --&gt; &lt;!-- select：表示一个MappedStatement对象 --&gt; &lt;!-- id：statement的唯一标示 --&gt; &lt;!-- #&#123;&#125;：表示一个占位符？ --&gt; &lt;!-- #&#123;id&#125;：里面的id表示输入参数的参数名称，如果该参数是简单类型，那么#&#123;&#125;里面的参数名称可以任意 --&gt; &lt;!-- parameterType：输入参数的java类型 --&gt; &lt;!-- resultType：输出结果的所映射的java类型（单条结果所对应的java类型） --&gt; &lt;select id="findUserById" parameterType="int" resultType="com.zwl.pojo.User"&gt; SELECT * FROM user WHERE id =#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 步骤七：在全局配置文件中声明映射文件（User.xml）123&lt;mappers&gt; &lt;mapper resource="com/zwl/pojo/User.xml" /&gt; &lt;/mappers&gt; 步骤八：测试类123456789101112131415161718192021222324252627282930313233343536package com.zwl.test;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import com.zwl.pojo.User;public class test &#123; @Test public void findUserByIdtest() throws Exception&#123; //读取配置文件 //全局配置文件的路径 String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); //创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); //调用SqlSession的增删改查方法 //第一个参数：表示statement的唯一标示 User u=sqlSession.selectOne("test.findUserById", 1); System.out.println(u.getName()); sqlSession.close(); &#125;&#125; 最后可将数据库中id为1的数据取出 至此，入门程序算是完成了，通过上面步骤发现，这里的不完全orm，还是得最后我们自己写sql，这样我们就可以面对复杂表关系时，自己优化了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring mvc之四:数据回显与json]]></title>
      <url>%2F2017%2F03%2F20%2Fspringmvc4%2F</url>
      <content type="text"><![CDATA[前言比较struts2与spring mvc实现机制：Struts2是基于过滤器实现的。Springmvc基于servlet实现。Servlet比过滤器快。 运行速度：Struts2是多列请求来了以后，struts2创建多少个对象：ActionContext，valuestack，UserAction，ActionSuport，ModelDrivenSpringmvc是单列 参数封装来分析：Struts基于属性进行封装。Springmvc基于方法封装。 页面回显： 查询所有构造一组list数据 12345678910111213141516171819202122232425@RequestMapping("userlist") //model 相当于application域对象 public String userlist(Model modal)&#123; List&lt;User&gt; list=new ArrayList&lt;&gt;(); User u1=new User(); u1.setId(1); u1.setSex("1"); u1.setAddress("lol"); u1.setUsername("1"); u1.setBirthday(new Date()); User u2=new User(); u2.setId(1); u2.setSex("1"); u2.setAddress("lol"); u2.setUsername("1"); u2.setBirthday(new Date()); list.add(u1); list.add(u2); modal.addAttribute("userlist", list); return "login"; &#125; 页面回显（利用jstl标签回显）12345678910111213141516171819202122232425262728&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;//声明此标签&lt;body&gt;&lt;table border="1" style="color: blue"&gt;&lt;tr&gt;&lt;td&gt;姓名&lt;/td&gt;&lt;td&gt;生日&lt;/td&gt;&lt;td&gt;性别&lt;/td&gt;&lt;td&gt;地址&lt;/td&gt;&lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt;&lt;c:forEach items="$&#123;userlist &#125;" var="user"&gt;&lt;tr&gt;&lt;td&gt;$&#123;user.username &#125;&lt;/td&gt;&lt;td&gt;$&#123;user.birthday &#125;&lt;/td&gt;&lt;td&gt;$&#123;user.sex &#125;&lt;/td&gt;&lt;td&gt;$&#123;user.address &#125;&lt;/td&gt;&lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/test/update?id=$&#123;user.id &#125;"&gt;delete&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt; &lt;/body&gt; 注意此处有个delete delete 利用？的方法，无疑将值显示的传过去，很不安全 测试：在浏览器中输入http://localhost:100/springmvc2/test/userlist.do 可以取出集合中的数据，同时delete中有显示id=参数传过去了 URL模版映射url模版映射是restfull软件架构Web.xml拦截方式：在rest目录下所有请求都被拦截，servlet可以拦截目录配置如下： 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; （）:匹配接受页面Url路径参数@Pathariable：（）里面参数注入后面参数里面 123456@RequestMapping("update/&#123;id&#125;") public String update(@PathVariable Integer id)&#123; System.out.println(id); return "redirect:/test/userlist.do"; &#125; 页面修改： delete 测试：同样输入相同地址，会发现href代参直接变成/参数 转发和重定向转发关键字：forward本类进行转发：本类方法与方法之间进行forward转发方式： return “forward : /test/userlist.do”; 跨类进行转发：转发方式：return ”forward：/items/userlist.do“；其中items是类前面的路径声明 重定向关键字：redirect本类进行重定向：本类方法与方法之间进行redirect重定向方式： return “redirect:/test/userlist.do”; 跨类进行重定向：转发方式：return ”redirect：/items/userlist.do“； @responseBody和@RequestBody@responseBody把后台pojo转换json对象，返回到页面。@RequestBody接受前台json数据，把json数据自动封装javaBean。 下面以一个实例说明这里ajax传递json数据用jquery来模拟 步骤一：导入jar包（jackson-core-asl-1.9.11.jar和jackson-mapper-asl-1.9.11.jar）加入jquery在springmvc.xml文件中声明对json数据的支持12345&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 页面传递ajax格式1234567891011121314151617181920212223242526272829&lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;function requestjson()&#123; //模拟了一个json格式数据 var jsonobj=JSON.stringify(&#123;"username":"11","sex":"man","address":"ok"&#125;); $.ajax(&#123; type:'POST', url:'&lt;%=path%&gt;/test/requestjson.do', //申明传递的是json格式 contentType:'application/json;charset=utf-8', //传递的数据 data:jsonobj, //如果成功，返回数据 success:function(data)&#123; alert(data.username); &#125; &#125;) &#125; &lt;/script&gt; &lt;body&gt; &lt;form action=""&gt; &lt;input type="text" name="username1" onclick="requestjson();"/&gt; &lt;/form&gt; &lt;/body&gt; 后台代码：123456@RequestMapping("requestjson") public @ResponseBody User requestjson(@RequestBody User user)&#123; System.out.println(user.getSex()); return user; &#125; 此处声明了接受的参数和返回的都是json数据格式 测试：在浏览器输入http://localhost:100/springmvc2/index.jsp通过点击文本，后台会打印参数，同时返回一个user对象给前台，并显示出来 pojo，后台返回json前台请求数据构造：key=value&amp;key=value.首先是页面123456789$.ajax(&#123; type:'POST', url:'&lt;%=path%&gt;/user/requestjson1.do', data:'username=lol&amp;address=zwl', success:function(data)&#123; alert(data.username); &#125; &#125;) 1234567后台代码：@RequestMapping("requestjson1") public @ResponseBody User requestjson1(User user)&#123; System.out.println(user.getAddress()); return user; &#125; 最后在springmvc中配置的前两个设配器，我们可以通过一个注解声明代替 不仅如此，它还自动包括了json数据格式声明等等即默认创建注解处理器映射器，注解处理器适配器。提供json格式支持。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring mvc之三:注解开发]]></title>
      <url>%2F2017%2F03%2F19%2Fspringmvc3%2F</url>
      <content type="text"><![CDATA[前言之前我们都是通过xml方式显示配置，会发现配置起来特别麻烦。当使用注解时，有时只需在相关类中做相关的声明，就能完成同样的工作。 不多说：先来一个注解开发例子 步骤一：首先创建一个web工程 步骤二：添加jar包 步骤三：配置web.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 默认加载方式 默认加载必须规范： * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml * 路径规范：必须在WEB-INF目录下面 --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 步骤四：配置springmvc-servlet.xml文件123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; &lt;!-- 扫描基本的父包，这样子类包被自动扫到执行 --&gt; &lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置注解处理器映射器 功能：寻找执行类Controller --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- 配置注解处理器适配器 功能：调用controller方法，执行controller --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;/bean&gt; &lt;!-- 配置sprigmvc视图解析器：解析逻辑试图 后台返回逻辑试图：index 视图解析器解析出真正物理视图：前缀+逻辑试图+后缀====/WEB-INF/jsps/index.jsp --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 这里简要说明一下，以上是注解最基本的配置，有扫描配置，两个基本配置和一个视图配置 步骤五：自定义controller类12345678910111213package com.zwl.control;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller //相当于&lt;bean class="Usercontrol"/&gt;并且声明这是一个controllerpublic class Usercontrol &#123; @RequestMapping("hello") //相当于需要访问的路径hello.do public String say()&#123; return "index" ; //放回到逻辑视图index.jsp &#125;&#125; 这是一个最简化的注解配置对应index.jsp123 &lt;body&gt;hello 盲僧 &lt;/body&gt; 测试：浏览器中输入http://localhost:100/springmvc2/hello.do 对应输出结果 hello 盲僧 RequestMapping它有三种方式，分别为 requestMapping(“hello”)requestMapping(“/hello.do”)requestMapping(value=”/hello.do”) 都能达到同样的效果，都是需要访问的路径如果在类前面添加此属性，则相当于映射路径在加一层123@Controller //&lt;bean class="Usercontrol"/&gt;@RequestMapping("/test")public class Usercontrol &#123;&#125; 即http://localhost:100/springmvc2/test/hello.do 另外，注意下里面还有个method配置，即按什么模式接受表单 @RequestMapping(value=”/hello.do”,method=RequestMethod.GET) 或者 @RequestMapping(value=”/hello.do”,method=RequestMethod.POST) 默认是两个都可以的 requestMapping(value=”/hello.do”,method={RequestMethod.POST, RequestMethod.GET}) 封装参数分析接受参数类型：基本类型，int，String等等基本类型。Pojo类型包装类型Springmvc参数封装：基于方法进行封装。 一：基本类型 封装int型参数页面123456 &lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath &#125;/ test/recieve.do" method="post"&gt;id：&lt;input type="text" name="id" id="id"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; &lt;/body&gt; 接受参数方法12345@RequestMapping("recieve") public String recieve(Integer id)&#123; System.out.println(id); return "login"; &#125; 注意这里的Integer id必须要与页面中的name=”id”一致才能正确接受参数 测试：在浏览器中输入http://localhost:100/springmvc2/index.jsp 然后输入id，后台即可接收到参数 接受字符转类型页面：1234&lt;form action="$&#123;pageContext.request.contextPath &#125;/ test/recievestr.do" method="post"&gt;id：&lt;input type="text" name="name" id="name"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; 接收参数方法：1234@RequestMapping("recievestr") public String recievestr(String name)&#123; System.out.println(name); return "login";&#125; 接受数组：分析：批量：checkbox复选框。Value必须有值页面：123456&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/recievearray.do" method="post"&gt;ID：&lt;input type="checkbox" name="ids" value="1" id="ids"&gt;ID：&lt;input type="checkbox" name="ids" value="2" id="ids"&gt;ID：&lt;input type="checkbox" name="ids" value="3" id="ids"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; 接受参数的方法12345@RequestMapping("recievearray") public String recievearray(Integer []ids)&#123; System.out.println(ids); return "login"; &#125; 接受pojo类页面：12345&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/recieveUser.do" method="post"&gt;姓名：&lt;input type="text" name="username" id="username"&gt;生日：&lt;input type="text" name="birthday" id="birthday"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; Pojo类123456public class User &#123; private String username; private Date birthday;此处省略set。Get方法&#125; 接受参数的方法：12345@RequestMapping("recieveUser") public String recievearray(User user)&#123; System.out.println(user.getUsername()); return "login"; &#125; 接受包装类型参数 包装pojo类 123456789101112131415161718public class Usercus &#123; private User user;此处省略set。Get方法。&#125;&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/usercus.do" method="post"&gt;姓名：&lt;input type="text" name="user.username" id="username"&gt;生日：&lt;input type="text" name="user.birthday" id="birthday"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt;接受参数的方法：@RequestMapping("usercus") public String usercus(Usercus user)&#123; System.out.println(user.getUser().getUsername()); return "login"; &#125; 接受集合类型参数 接受list集合首先在包装类中加入如下代码123456789101112131415161718192021private List&lt;User&gt; userlist;此处省略set，get方法然后是页面&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/recievelist.do" method="post"&gt;姓名：&lt;input type="text" name="userList[0].username" id="username"&gt;地址：&lt;input type="text" name="userList[0].address" id="address"&gt;姓名：&lt;input type="text" name="userList[1].username" id="username"&gt;地址：&lt;input type="text" name="userList[1].address" id="address"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt;接受参数方法：@RequestMapping("recievelist") public String recievelist(Usercus userlist) &#123; System.out.println(userlist.getUserlist().get(0).getUsername()); return "login"; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring mvc之二:处理器]]></title>
      <url>%2F2017%2F03%2F18%2Fspringmvc2%2F</url>
      <content type="text"><![CDATA[前言在spring mvc中，使用映射处理器可以把web请求映射到正确的处理器上，spring内置了很多映射器，而且我们也可以自定义处理器，映射处理器都能把请求传递到处理器执行链接上，并且处理器执行链接必须包含能处理该请求的处理器，而且处理器链接也能包含一系列拦截器 接下来就是一些常见的处理映射器 BeanNameUrlHandlerMapping 功能：寻找Controller 根据url请求去匹配bean的name属性url，从而获取Controller 这里注意：这是默认的映射器，也就是说我们不配置这个，也能自动执行这个 如：入门程序中的案例：12&lt;!-- 配置自定义Controler --&gt; &lt;bean id="mycontrol" name="/hello.do" class="com.zwl.control.mycontrol"&gt;&lt;/bean&gt; 即根据自定义的/hello.do，找到对应的mycontrol.java类 SimpleUrlHandlerMaping 功能：寻找Controller 根据浏览器url匹配简单url的key，key又Controller的id找到Controller如：在映射文件中配置1234567891011&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="zwl.do"&gt;mycontrol&lt;/prop&gt; &lt;prop key="slycmiaoxi.do"&gt;mycontrol&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置自定义Controler --&gt; &lt;bean id="mycontrol" class="com.zwl.control.mycontrol"&gt;&lt;/bean&gt; 测试：在浏览器输入http://localhost:100/springmvc1/zwl.do或者http://localhost:100/springmvc1/slycmiaoxi.do 输出结果： hello world 此外：这个映射器是把url进行集中配置 ControllerClassNameHandlerMapping功能：寻找Controller 根据类名（Mycontrol）类名.do来访问,类名首字母小写在配置文件中增加如下配置 12&lt;!-- 定义通过: 类名.do 形式来访问controller --&gt; &lt;bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"&gt;&lt;/bean&gt; 注意，这里并没有声明mycontrol.do和只有一个类mycontrol.java 测试：在浏览器输入http://localhost:100/springmvc1/mycontrol.do结果： hello world 事实上，以上三个映射器都可以同时存在 下面将是处理器适配器 SimpleControllerHandlerAdapter功能：执行controller 调用controller里面方法，返回modelAndView。 1234&lt;!-- 配置处理器适配器执行Controlelr ,springmvc默认的 SimpleControllerHandlerAdapter:执行Controller --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt; HttpRequestHandlerAdapter功能：执行controller首先新建一个类12345678910111213141516171819202122232425package com.zwl.control;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.HttpRequestHandler;public class httpcontrol implements HttpRequestHandler &#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); //给Request设置值，在页面进行回显 request.setAttribute("hello", "lol"); response.setCharacterEncoding("utf-8"); //跳转页面 request.getRequestDispatcher("/index.jsp").forward(request, response);; &#125;&#125; 然后在配置文件中配置123456789&lt;!-- HttpRequestHandlerAdapter负责执行实现接口HttpRequestHandler的后端 控制器。 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- 配置自定义HttpController --&gt; &lt;bean id="http" class="com.zwl.control.httpcontrol"&gt;&lt;/bean&gt; &lt;prop key="/zwl.do"&gt;http&lt;/prop&gt; 测试：在浏览器中输入：http://localhost:100/springmvc1/zwl.do 输出结果： lol 注意这两个处理器设配器可以共存！ 命令控制器Spring mvc通过命令设计模式接受页面参数。 自定义命令控制器首先新建一个pojo类123456789101112131415161718package com.zwl.pojo;public class User &#123;private int id;private String username;public int getId() &#123; return id;&#125;public String getUsername() &#123; return username;&#125;public void setId(int id) &#123; this.id = id;&#125;public void setUsername(String username) &#123; this.username = username;&#125;&#125; 自定义控制器12345678910111213141516171819202122232425262728293031323334package com.zwl.control;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.validation.BindException;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.config.MvcNamespaceHandler;import org.springframework.web.servlet.mvc.AbstractCommandController;import com.zwl.pojo.User;public class CommandController extends AbstractCommandController &#123; //指定参数绑定哪个pojo类 public CommandController()&#123; this.setCommandClass(User.class); &#125; @Override protected ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object command, BindException error) throws Exception &#123; //将命令对象强转成用户对象 User user=(User)command; ModelAndView mv=new ModelAndView(); mv.addObject("user",user); mv.setViewName("index"); return mv; &#125;&#125; 封装参数页面（这里是login.jsp）12345678 &lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath &#125;/command.do" method="post"&gt;姓名：&lt;input type="text" name="username" id="username"&gt;id：&lt;input type="text" name="id" id="id"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; &lt;/body&gt; 配置bean1&lt;bean name="/command.do" class="com.zwl.control.CommandController"&gt;&lt;/bean&gt; 回显数据：1234 &lt;body&gt; $&#123;user.username &#125; &lt;br&gt;$&#123;user.id &#125; &lt;br&gt; &lt;/body&gt; 测试：在浏览器中输入http://localhost:100/springmvc1/login.jsp到login.jsp然后分别将name输入中文和非中文，发现出现中文乱码 需要Spring编码过滤器：在web.xml配置12345678910111213&lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 然后输入中文，就没有乱码了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring mvc之一:hello world]]></title>
      <url>%2F2017%2F03%2F17%2Fspringmvc1%2F</url>
      <content type="text"><![CDATA[前言MVC模式是Model-View-Control的简写，而spring mvc主要负责c层，主要为封装web请求为一个数据对象、调用业务逻辑层来处理数据对象、返回处理数据结果及相应的视图给用户 简要概述spring mvc： SpringC层框架的核心是DispatcherServlet，它的作用是将请求分发给不同的后端处理器，springC层框架使用了后端控制器、映射处理器和视图解析器来共同完成c层的主要任务，真正的把业务层处理的数据结果和相应的视图拼成一个对象，即ModelAndView对象 下面以hello world为入门程序搭建环境步骤一：创建一个web工程 步骤二：导入相关jar包 步骤三：编写web.xml配置文件1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 简要说明一下：dispatcherservlet就是一个servlet，也是对请求进行转发的核心servlet。在这里即所有的.do的请求将首先被dispatcherservlet处理，而它要做的工作就是对请求进行分发（即把请求转发给具体的controller），可以简单的认为，他就是一个总控处理器，除此之外，它还能使用spring的其他功能同时注意一下上面的servlet-name默认加载方式 默认加载必须规范： * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml * 路径规范：必须在WEB-INF目录下面 步骤四：配置springmvc-servlet.xml12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; &lt;!-- 配置处理器映射器,springmvc默认的处理器映射器 BeanNameUrlHandlerMapping：根据bean(自定义Controler)的name属性的url去寻找hanler(Action:Controller) --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- 配置处理器适配器执行Controlelr ,springmvc默认的 SimpleControllerHandlerAdapter:执行Controller --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- 配置自定义Controler --&gt; &lt;bean id="mycontrol" name="/hello.do" class="com.zwl.control.mycontrol"&gt;&lt;/bean&gt; &lt;!-- 配置sprigmvc视图解析器：解析逻辑试图 后台返回逻辑试图：index 视图解析器解析出真正物理视图：前缀+逻辑试图+后缀--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 步骤五：自定义controller123456789101112131415161718192021222324252627package com.zwl.control;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;public class mycontrol implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123; //接受请求，参数，验证参数 //封装参数，调用业务方法 //返回视图 ModelAndView mv=new ModelAndView(); //设置页面回显数据 mv.addObject("hello","hello world"); //指定跳转的视图 //返回物理视图 mv.setViewName("index"); return mv; &#125;&#125; 步骤六：定义视图页面123&lt;body&gt; $&#123;hello&#125; &lt;/body&gt; 测试：在浏览器中输入http://localhost:100/springmvc1/hello.do 结果： hello world 简要分析入门程序的过程1 启动服务器，根据web.xml的配置加载前端控制器dispatcherservlet。在加载时，会完成一系列的初始化动作。 2 根据servlet的映射请求（上面的.do），并参照spingmvc-servlet.xml文件，把具体的请求分发给特定的后端处理器，如上面的mycontrol 3 后端控制器调用相应的逻辑层代码，完成处理并返回视图对象ModelAndView给前端处理器 4 前端处理器根据后端控制器返回的ModelAndView对象，返回一个相应的页面给客户端]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring之装配bean]]></title>
      <url>%2F2017%2F03%2F16%2Fspring2%2F</url>
      <content type="text"><![CDATA[前言在spring中，对象无需自己负责查找或创建与其关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象，例如一个消费系统需要信誉证件，但它不需要自己创建，它只负责自己两手空空，而容器就赋予它一个信用卡认证组件。 通常，我们将创建应用对象间相互协作关系的行为称为装配。这也是依赖注入的本质。 一：声明bean 首先我们假想一个选秀场景，该bean为一个表演接口 public interface Performe { public void perform();}很显然我们需要一些参赛者，而这些参赛者就需要spring帮我们创建了 二：创建spring配置 Spring是一个基于容器的框架，但是如果我们不对他进行任何配置，那么它就相当于一个空框架，一般情况下有采用XML或者注解式声明，这里都采用xml形式。12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;&lt;/beans&gt; 三：声明一个简单的bean 这次表演者可以使各种各样的人，首先是一个杂技师。12345678910111213141516public class Juggler implements Performe &#123; private int bigbang=5; public Juggler()&#123; &#125; public Juggler(int bigbang)&#123; this.bigbang=bigbang; &#125; @Override public void perform() &#123; System.out.println("it is "+bigbang); &#125;&#125; 主要打印出杂技师扔了多少块Bigbang； 接下来在spring中配置bean，123&lt;bean id="juggle" class="com.zwl.dao.Juggler"&gt;&lt;/bean&gt; 这是一个最简单的声明格式接下来就是加载spring上下文，进行测试 123Juggler hello=(Juggler) ApplicaionContextUtil.getApplicationContext().getBean("juggle"); hello.perform(); ApplicaionContextUtil.xml 12345678910private static ApplicationContext ac=null;private ApplicaionContextUtil()&#123; &#125;static&#123; ac=new ClassPathXmlApplicationContext("applicationContext.xml");&#125;public static ApplicationContext getApplicationContext()&#123; return ac;&#125; 测试结果： it is 5 四：通过构造器注入 有时候我们需要通过构造方法进行注入123&lt;bean id="juggle" class="com.zwl.dao.Juggler"&gt;&lt;constructor-arg value="66"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 因为Juggle有一个代参和无参构造函数，默认不配置constructor-arg则是默认构造函数，相反则是代参构造函数， 构造器注入对象引用 上面是注入的基本类型，如果是一个对象了？ 在Juggler类中增加如下代码12345678910private Helloworld helloworld; public Juggler(Helloworld helloworld)&#123; this.helloworld=helloworld; &#125;public void perform() &#123; System.out.println("it is "+bigbang); helloworld.sayhello(); &#125; 其中helloworld为入门时的程序 接下来就是配置文件123456789&lt;bean id="helloworld" class="com.zwl.spring.Helloworld"&gt;&lt;property name="name"&gt;&lt;value&gt;hello world!&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id="juggle" class="com.zwl.dao.Juggler"&gt;&lt;constructor-arg ref="helloworld"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 其中ref为注入另一个bean的id测试结果： it is 5it is hello world 五：bean的作用域 所有的spring bean默认都是单例，即它总是返回同一个bean实例，通过在bean中的scope属性进行设置，一般有如下属性 Singleton 在每一个spring容器中，一个bean定义只对应一个对象实例（默认） Prototype 允许bean的定义可以被实例化任意次（每次调用都创建一个实例） 另外还有request，session，global-session，一般只用前两者测试代码：123Helloworld hello=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld"); Helloworld hello1=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld"); System.out.println(hello==hello1); 当采用默认scope时，测试结果为true 当进行如下修改时1&lt;bean id="helloworld" class="com.zwl.spring.Helloworld" scope="prototype"&gt; 测试结果为false 另外在我们初始化和销毁bean时，需要在bean中配置1&lt;bean id="helloworld" class="com.zwl.spring.Helloworld" scope="prototype" init-method="sayhello" destroy-method="saybyb"&gt; 其中sayhello与saybyb都是该类中方法，当在调用该bean之前，调用init-method，而在该bean销毁前，即生命周期结束前实现destroy-method， 六：注入bean属性 通常，javabean的属性时私有的，同时拥有一组set与get方法取出该属性，spring可以借助set配置属性的值 注意，这里和利用构造器的注入差不多 如注入简单值12&lt;property name="name" value="hello world"&gt;&lt;/property&gt; 引用其他bean1&lt;property name="hello" ref="helloworld"&gt;&lt;/property&gt; 其中name中的值是该bean中的属性，名字要一致，而ref是该配置文件中的其他bean 七：装配集合 前面我们都是介绍单个对象的装配，对于复合类型该如何装配了 不妨模拟一个案例首相是一个Student类123456789101112131415package com.zwl.spring;public class Student &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 然后是School类，主要有的属性为集合，首先是list1234567891011121314public class School &#123; private List&lt;Student&gt; stulist; public List&lt;Student&gt; getStulist() &#123; return stulist; &#125; public void setStulist(List&lt;Student&gt; stulist) &#123; this.stulist = stulist; &#125; &#125; 配置的bean1234567&lt;bean id="stu" class="com.zwl.spring.Student"&gt;&lt;property name="name" value="hello"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="stu1" class="com.zwl.spring.Student"&gt;&lt;property name="name" value="world"&gt;&lt;/property&gt;&lt;/bean&gt; 简要说明一下，这里注入同一个类的不同bean，用于装入集合然后是配置school12345678&lt;bean id="sch" class="com.zwl.spring.School"&gt;&lt;property name="stulist"&gt;&lt;list&gt;&lt;ref bean="stu"/&gt;&lt;ref bean="stu1"/&gt;&lt;/list&gt;&lt;/property&gt;&lt;/bean&gt; 一般格式如下，属性下，配置和要引入的bean 测试代码1234School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch"); String name1=hello.getStulist().get(0).getName(); String name=hello.getStulist().get(1).getName(); System.out.println(name1+name); 测试结果: helloworld Set集合装配 首先在school类中加入如下属性12 private Set&lt;Student&gt; stuset;省略set与get方法 配置文件，添加如下：123456&lt;property name="stuset"&gt;&lt;set&gt;&lt;ref bean="stu"/&gt;&lt;ref bean="stu1"/&gt;&lt;/set&gt;&lt;/property&gt; 对应测试代码：123456School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch"); Iterator&lt;Student&gt; it=hello.getStuset().iterator(); while(it.hasNext())&#123; Student stu=it.next(); System.out.println(stu.getName()); &#125; 这里通过迭代器取出对象测试结果： helloworld Map集合装配 首先在school中添加如下属性：12private Map&lt;String, Student&gt; stumap;省略set与get方法。。 配置文件，添加如下123456&lt;property name="stumap"&gt;&lt;map&gt;&lt;entry key="11" value-ref="stu"&gt;&lt;/entry&gt;&lt;entry key="22" value-ref="stu1"&gt;&lt;/entry&gt;&lt;/map&gt;&lt;/property&gt; 其中，key为map的索引值，而value-ref为引用的bean测试代码：1234School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch"); String name=hello.getStumap().get("11").getName(); String name1=hello.getStumap().get("22").getName(); System.out.println(name+name1); 测试结果: helloworld]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring之hello world]]></title>
      <url>%2F2017%2F03%2F15%2Fspring1%2F</url>
      <content type="text"><![CDATA[前言 spring 是容器框架,用于配置bean,并维护bean之间关系的框架，而bean是java中的任何一种对象 javabean/service/action/数据源./dao, ioc(控制反转 inverse of control) di( dependency injection 依赖注入)，而spring的设计思想主要为单例和工厂模式，它能很好的解耦，简化开发，同时贯穿于各层。 不多说，先来一个入门案例，目的在先具体把握，最后在看细节 步骤一：创建一个web工程，同时引入两个jar包，一个是spring核心包（spring.jar）和日包（commons-logging.jar）及测试包junit； 步骤二：新建applicationContent.xml文件，该文件是spring的核心文件，先放在src目录下，里面暂时什么都不写 步骤三：编写helloworld类： 12345678910111213141516171819package com.zwl.spring;public class Helloworld &#123;private String name;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125; public void sayhello()&#123; System.out.println("it is "+name);&#125; &#125; 这里主要通过spring自动注入name为helloworld来演示 步骤四：配置applicationContent.xml文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;&lt;!-- bean元素的作用是，当我们的spring框架加载时候，spring就会自动的创建一个bean对象，并放入内存 ,相当于Helloworld helloworld=new Helloworld();helloworld.setName("helloworld!"); id:用于唯一标识该bean，class:相应的bean所处的位置--&gt;&lt;bean id="helloworld" class="com.zwl.spring.Helloworld"&gt;&lt;property name="name"&gt;&lt;value&gt;hello world!&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; 步骤五：编写工具类因为spring也是初始化加载很耗内存，所以同样采取单例模式初始化1234567891011121314151617181920package com.zwl.utils;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ApplicaionContextUtil &#123;private static ApplicationContext ac=null; private ApplicaionContextUtil()&#123; &#125; static&#123; //1.得到spring 的applicationContext对象(容器对象) ac=new ClassPathXmlApplicationContext("applicationContext.xml"); &#125; public static ApplicationContext getApplicationContext()&#123; return ac; &#125;&#125; 步骤六：编写测试类（用junit4）123456@Test public void test()&#123;//得到bean对象 Helloworld hello=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld"); hello.sayhello(); &#125; 测试结果： it is hello world ！ 至此helloworld程序完成，当然这只是一个初步的认识spring是什么，事实上spring的注入远不止如此简单，但至少有一点可以明确，通过spring，可以帮我们管理，特别是结合其他开源框架，达到解耦和高效的作用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代理模式（四）之模仿spring Aop及真实jdk的动态代理]]></title>
      <url>%2F2017%2F03%2F14%2Fdyproxy3%2F</url>
      <content type="text"><![CDATA[前言代理模式，尤其是动态代理，他从思想上改变了我们对编程的认识，可以想象一个切面我们在其中添加任何控制如事务、日志、权限等，而这也是面向切面编程的核心，更是spring Aop的核心，而设计才是实用的，框架和配置都是虚的，尤其当抛开jdk底层代码设计，才发现其中的来龙去脉和乐趣。 总之，动态代理设计模式的思想太强大了。接下来将用之前模拟的jdk动态代码和jdk本身自带的动态来模拟一个案例 大概物理情景是，添加一个打野信息接口和打野代理，利用InvocationHandler实现代理对具体打野的代理 首先是一个打野接口 123456package com.zwl.pr;public interface JungleInfo &#123; public void addJungle();&#125; 打野接口实现类123456789101112package com.zwl.pr;public class JungleInfoimpl implements JungleInfo &#123; @Override public void addJungle() &#123; System.out.println("Js is ganking"); System.out.println("Leesin is ganking"); &#125;&#125; 打野代理123456789101112131415161718192021222324252627package com.zwl.pr;import java.lang.reflect.Method;public class JungleHandler implements InvocationHandler &#123;private Object target; public JungleHandler(Object target) &#123; super(); this.target = target; &#125; @Override public void invoke(Object o, Method m) &#123; //控制之前的业务逻辑 System.out.println("JungleHandler is starting"); try &#123; m.invoke(target); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //控制之后的业务逻辑 System.out.println("JungleHandler is ending"); &#125;&#125; 为了方便这里只是打印了一个语句测试类123456 //被代理对象 JungleInfo jun=new JungleInfoimpl(); //代理类InvocationHandler invo=new JungleHandler(jun);JungleInfo jung=(JungleInfo) Proxy.newProxyInstance(JungleInfo.class, invo);jung.addJungle(); 输出结果： class com.zwl.pr.LeeSinTimeProxyJungleHandler is startingJs is gankingLeesin is gankingJungleHandler is ending 至此我们发现如果我们想在这个切面中再加一个控制，好办，再写一个handle类，代理其它handle类，达到切面控制效果。当然，以后只要实现InvocationHandler接口就能达到效果，而proxy底层都不需要知道 jdk的动态代理同样是上面的例子，知识代理handler需要改变 12345678910111213141516171819202122232425 package com.zwl.pr;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class JungleHandlers implements InvocationHandler &#123; private Object target; public JungleHandlers(Object target) &#123; super(); this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("Jdk is starting"); method.invoke(target, args); System.out.println("Jdk is ending"); return null; &#125;&#125; 其中Object proxy是指代理类，Method method是指被代理的方法，Object[] args为该方法的参数数组 接下来是测试类 1234 JungleInfo jun=new JungleInfoimpl();JungleHandlers invo=new JungleHandlers(jun);JungleInfo jung=(JungleInfo) Proxy.newProxyInstance(JungleInfo.class.getClassLoader(),new Class&lt;?&gt;[]&#123;JungleInfo.class&#125;, invo);jung.addJungle(); 其中jung将返回一个代理类的实例JungleInfo.class.getClassLoader()是类装载器，第二个参数是任何真实类拥有的全部接口的数组，第三个参数就是真实的handles 测试结果： Jdk is startingJs is gankingLeesin is gankingJdk is ending 至此，我们利用动态代理，就可以在不修改原来代码的基础上，就可以在原来代码的基础上做操作，而这恰恰就是AOP编程的核心]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代理模式（三）之模仿jdk底层动态代理实现]]></title>
      <url>%2F2017%2F03%2F13%2Fdyproxy2%2F</url>
      <content type="text"><![CDATA[前言在前面的基础上在做进一步的改进，前面我们是动态写死了方法，即自己指定了方法名，当然我们可以利用反射帮我们完成函数名的动态指定 首先是一个反射例子123456//拿到相应的类Method[] methods=com.zwl.pr.Jungle.class.getMethods(); for(Method method: methods)&#123; //循环输出该类的函数名，如public void ss();最后只输出ss System.out.println(method.getName()); &#125; 有了这个原理就可以对之前的proxy进行改造 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static Object newProxyInstance(Class interfac) throws Exception&#123; //动态拿到方法的代码 String methodStr = ""; String rt = "\r\n"; //将指定的动态接口类名拿到 Method[] methods = interfac.getMethods(); //循环添加方法 for(Method m : methods) &#123; methodStr += "@Override" + rt + "public void " + m.getName() + "() &#123;" + rt + " long start = System.currentTimeMillis();" + rt + " leesin." + m.getName() + "();" + rt + " long end = System.currentTimeMillis();" + rt + " System.out.println(\"time:\" + (end-start));" + rt + "&#125;"; &#125; String str= "package com.zwl.pr;" + rt + "public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt + "Jungle leesin;" + rt + "public LeeSinTimeProxy(Jungle leesin) &#123;" + rt + "super();" + rt + "this.leesin = leesin;" + rt + "&#125;" + rt + //这里循环动态输出方法 methodStr + "&#125;" ; //System.out.println(System.getProperty("user.dir")); //这里将动态生成的代理文件放到指定文件夹中，避免与bin里的.class文件冲突 String filename= "E:/src/com/zwl/pr/LeeSinTimeProxy.java"; File f=new File(filename); FileWriter fw=new FileWriter(f); fw.write(str); fw.flush(); fw.close(); //compile JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(filename); CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units); t.call(); fileMgr.close(); //load into memory and create an instance //更改到指定文件夹 URL[] urls = new URL[] &#123;new URL("file:/" + "E:/src/")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy"); System.out.println(c); Constructor ctr = c.getConstructor(Jungle.class); //返回任意一个类 Object jungle=ctr.newInstance(new LeeSin()); return jungle; &#125; 注意这里和之前做了几处修改 1.利用反射动态生成方法 2.更改编译后生成文件的目录 3.返回类型为object 4具体在代码里有注释 测试类： 12Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class); jungle.gank(); 输出结果 class com.zwl.pr.LeeSinTimeProxyLeeSin is ganking…gank time:1336time:1336 这里很明显发现方法都是固定的，如果想要方法都是动态生成的，则要进行进一步修改首先增加一个InvocationHandler动态生成类123public interface InvocationHandler &#123; public void invoke(Object o, Method m);&#125; 然后是具体的针对所有接口的时间处理类123456789101112131415161718192021222324252627public class TimeHandler implements InvocationHandler &#123; //代理类 private Object target; public TimeHandler(Object target) &#123; super(); this.target = target; &#125; @Override public void invoke(Object o, Method m) &#123; long start = System.currentTimeMillis(); try &#123; //指定代理类的动态方法 m.invoke(target); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println("time:" + (end-start)); &#125;&#125; 然后proxy里也要进行相应修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//参数分别为被代理对象与代理对象public static Object newProxyInstance(Class interfac,InvocationHandler h) throws Exception&#123; String methodStr = ""; String rt = "\r\n"; Method[] methods = interfac.getMethods(); //动态生成方法，其中this是指代理对象本身，而md是指方法名，这里的h是构造函数传的代理对象 for(Method m : methods) &#123; methodStr += "@Override" + rt + "public void " + m.getName() + "() &#123;" + rt + " try &#123;" + rt + " Method md = " + interfac.getName() + ".class.getMethod(\"" + m.getName() + "\");" + rt + " h.invoke(this, md);" + rt + " &#125;catch(Exception e) &#123;e.printStackTrace();&#125;" + rt + "&#125;"; &#125; String str= "package com.zwl.pr;" + rt + "import java.lang.reflect.Method;" + rt + "public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt + "com.zwl.pr.InvocationHandler h;" + rt + "public LeeSinTimeProxy(InvocationHandler h) &#123;" + rt + "super();" + rt + "this.h = h;" + rt + "&#125;" + rt + methodStr + "&#125;" ; //System.out.println(System.getProperty("user.dir")); String filename= "E:/src/com/zwl/pr/LeeSinTimeProxy.java"; File f=new File(filename); FileWriter fw=new FileWriter(f); fw.write(str); fw.flush(); fw.close(); //compile JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(filename); CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units); t.call(); fileMgr.close(); //load into memory and create an instance URL[] urls = new URL[] &#123;new URL("file:/" + "E:/src/")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy"); System.out.println(c); //返回代理类 Constructor ctr = c.getConstructor(InvocationHandler.class); Object jungle=ctr.newInstance(h); return jungle; &#125; 测试类： 123456//被代理对象LeeSin leesin=new LeeSin();//代理对象 InvocationHandler ivo=new TimeHandler(leesin); Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class,ivo); jungle.gank(); 对应生成的java文件123456789101112131415package com.zwl.pr;import java.lang.reflect.Method;public class LeeSinTimeProxy implements com.zwl.pr.Jungle&#123;com.zwl.pr.InvocationHandler h;public LeeSinTimeProxy(InvocationHandler h) &#123;super();this.h = h;&#125;@Overridepublic void gank() &#123; try &#123; Method md = com.zwl.pr.Jungle.class.getMethod("gank"); h.invoke(this, md); &#125;catch(Exception e) &#123;e.printStackTrace();&#125;&#125;&#125; 对应的测试结果 class com.zwl.pr.LeeSinTimeProxyLeeSin is ganking…gank time:2642time:2642]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代理模式（二）之初识动态代理]]></title>
      <url>%2F2017%2F03%2F12%2Fdyproxy1%2F</url>
      <content type="text"><![CDATA[前言之前我们通过静态代理可以在编译期创建一个代理对象，如果要求我们必须在运行时创建一个代理，如时间代理，如何做了？也就是说，需要写一个代理（proxy），然后我们只需要传入相关接口，它就可以主动生成代理对象 再一次使用之前的情景，即有一个打野对象接口和具体打野盲僧，然后编写一个针对打野的动态代理（proxy），只要传入（打野接口对象），就可以动态自动生成该java文件，并且载入内存并不jvm编译 下面就是其代码实现 Jungle（打野接口）1234public interface Jungle &#123; //打野gank方法 public void gank();&#125; LeeSin（盲僧）123456789101112131415161718192021public class LeeSin implements Jungle &#123; @Override public void gank() &#123; //gank开始时间 long starts=System.currentTimeMillis(); System.out.println("LeeSin is ganking..."); try &#123; //gank进行中 Thread.sleep(new Random().nextInt(10000)); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //gank结束时间 long ends=System.currentTimeMillis(); System.out.println("gank time:"+(ends-starts)); &#125;&#125; 如果想要动态生成一个事件代理（按常理应该新建一个代理类），按照动态思想，我们将该创建该类的所以涉及的代码赋给一个字符串12345678910111213141516171819202122232425String str= "package com.zwl.pr;" + "public class LeeSinTimeProxy implements Jungle &#123;" + "Jungle leesin;" + "public LeeSinTimeProxy(Jungle leesin) &#123;" + "super();" + "this.leesin = leesin;" + "&#125;" + "@Override" + "public void gank() &#123;" + "long starts=System.currentTimeMillis();" + "leesin.gank();" + "long ends=System.currentTimeMillis();" + " System.out.println(\"gank time:\"+(ends-starts));" + "&#125;" + "&#125;" ; 上面字符串就是创建该代理的代码，然后如果jvm能自动将其编译成.class并且载入内存，就是一个真的类了，按照这种思想，我们可以通过jvm提供的方法完成为了方便先把上述动态创建时间代理放在测试中（也就是main函数中）1.首先将代码格式修整一下，即加个换行，同时将字符写入时间代理文件中1234567891011121314151617181920212223242526272829303132333435363738394041 //换行，防止所有代码全部挤在一行String rt = "\r\n";//要动态生成的类的代码 String str= "package com.zwl.pr;" + rt + "public class LeeSinTimeProxy implements Jungle &#123;" + rt + "Jungle leesin;" + rt + "public LeeSinTimeProxy(Jungle leesin) &#123;" + rt + "super();" + rt + "this.leesin = leesin;" + rt + "&#125;" + rt + "@Override" + rt + "public void gank() &#123;" + rt + "long starts=System.currentTimeMillis();" + rt + "leesin.gank();" + rt + "long ends=System.currentTimeMillis();" + rt + " System.out.println(\"gank time:\"+(ends-starts));" + rt + "&#125;" + rt + "&#125;" ; //得到该项目的根路径 //System.out.println(System.getProperty("user.dir")); //该时间代理文件的完整路径，不存在则创建（第一次自动动态创建） String filename=System.getProperty("user.dir")+ "/src/com/zwl/pr/LeeSinTimeProxy.java"; //将字符写入该文件 File f=new File(filename); FileWriter fw=new FileWriter(f); fw.write(str); fw.flush(); fw.close(); 这里先一小段一小段的加，目前是已经在该包下生成一个LeeSinTimeProxy.java文件，并且里面有被写入的字符，但是纯粹只是一个文件，因为还没被编译和载入内存 2.进行编译123456789101112 //compile //得到java编译器，也就是javac了，至此我们可以最终将其编译，得到.class（二进制文件）JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); //管理编译文件，默认为空就行StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);//所有编译的文件，目前就一个，当然可以传入多个Iterable units = fileMgr.getJavaFileObjects(filename);//编译任务管理，目前传入上面两个参数，其余默认为空就行CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);//执行任务编译t.call();fileMgr.close(); 至此，在包下也动态生成了一个.class文件，而平常我们编译时都会在path路径下，jdk主动生成.class，而此时我们自己指定了位置 3.载入内存123456//指定载入内存的urlURL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir")+"/src")&#125;; URLClassLoader ul = new URLClassLoader(urls);//指定class文件载入 Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy"); System.out.println(c); 4.利用反射取出实例 1234567//反射取出类Constructor ctr = c.getConstructor(Jungle.class); //操作该类相应方法，此处是动态返回类 Jungle jubgle= (Jungle) ctr.newInstance(new LeeSin()); //调用gank方法 jubgle.gank(); 以下是结果： class com.zwl.pr.LeeSinTimeProxyLeeSin is ganking…gank time:7557gank time:7563 至此算是动态生成了时间代理，但是目前是很有局限性的，因为我们指定了一个特定接口，而不是泛指，当然通过这个例子，也算是初识了一把动态模式的魅力，当然它的最大魅力，在于制定任何接口，返回相应的代理类 在这里我们先将测试的类中代码移至Proxy类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Proxy &#123; //这里的interfac就是动态指定了任何接口代理，而且必须取它的名字，否则是执行其tostring方法 public static Object newProxyInstance(Class interfac) throws Exception&#123; String rt = "\r\n"; String str= "package com.zwl.pr;" + rt + "public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt + "Jungle leesin;" + rt + "public LeeSinTimeProxy(Jungle leesin) &#123;" + rt + "super();" + rt + "this.leesin = leesin;" + rt + "&#125;" + rt + "@Override" + rt + "public void gank() &#123;" + rt + "long starts=System.currentTimeMillis();" + rt + "leesin.gank();" + rt + "long ends=System.currentTimeMillis();" + rt + " System.out.println(\"gank time:\"+(ends-starts));" + rt + "&#125;" + rt + "&#125;" ; //System.out.println(System.getProperty("user.dir")); String filename=System.getProperty("user.dir")+ "/src/com/zwl/pr/LeeSinTimeProxy.java"; File f=new File(filename); FileWriter fw=new FileWriter(f); fw.write(str); fw.flush(); fw.close(); //compile JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(filename); CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units); t.call(); fileMgr.close(); //load into memory and create an instance URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir")+"/src")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy"); System.out.println(c); Constructor ctr = c.getConstructor(Jungle.class); Jungle jubgle= (Jungle) ctr.newInstance(new LeeSin()); jubgle.gank(); return null; &#125;&#125; 目前先不管错误，在做测试类123 LeeSin leesin=new LeeSin();Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class);jungle.gank(); 这里参数我们可以设置任何class接口，当然先不管错误，至少动态代理算是成功了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代理模式（一）之静态代理]]></title>
      <url>%2F2017%2F03%2F11%2Fstproxy%2F</url>
      <content type="text"><![CDATA[前言代理模式从定义上说就是给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用 一般情况下，我们可以通过继承或者聚合来实现代理，当然继承会造成类爆炸，而聚合则更灵活不多说，模拟一个静态代理的情景假设打野是一个接口，有gank方法，记录打野行为，打野具体对象盲僧，实现其gank的时间并记录下来，然后后续打野盲僧1、盲僧2分别记录打野具体对象的gank时间和gank日志（目前打野对象为LeeSin） Jungle（打野接口）1234public interface Jungle &#123; //打野gank方法 public void gank();&#125; LeeSin（盲僧）123456789101112131415161718192021public class LeeSin implements Jungle &#123; @Override public void gank() &#123; //gank开始时间 long starts=System.currentTimeMillis(); System.out.println("LeeSin is ganking..."); try &#123; //gank进行中 Thread.sleep(new Random().nextInt(10000)); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //gank结束时间 long ends=System.currentTimeMillis(); System.out.println("gank time:"+(ends-starts)); &#125;&#125; 接下来就是使用代理对象，比如用一个代理记录打野gank方法的时间不妨先用继承（与后面聚合比较会发现继承将造成类爆炸） 123456789101112//时间代理，记录gank时间public class LeeSin1 extends LeeSin &#123; @Override public void gank() &#123; long starts=System.currentTimeMillis(); super.gank(); long ends=System.currentTimeMillis(); System.out.println("gank time:"+(ends-starts)); &#125;&#125; 如果这时再有一个log代理，记录gank日志12345678910public class LeeSin2 extends LeeSin &#123; @Override public void gank() &#123; System.out.println("LeeSin starts ganking"); super.gank(); System.out.println("LeeSin ends ganking"); &#125;&#125; 如果这时说先记录日志在记录时间或者先记录时间在记录日志，这时就要写两个类列出主体代码（另一个调换位置）1234567891011@Overridepublic void gank() &#123; System.out.println("LeeSin starts ganking"); long starts=System.currentTimeMillis(); super.gank(); long ends=System.currentTimeMillis(); System.out.println("gank time:"+(ends-starts)); System.out.println("LeeSin ends ganking"); &#125; 可能目前代理类较少，还没有缺陷，如果是100个甚至更多，只要稍微要求下顺序或者其他，就要增加一个类，显然造成类爆炸，所以继承代理不可取 利用聚合代理（因为被代理类都是继承或者实现Jungle，所以可以用jungle代理，知识子类行为不同而已打野时间代理类1234567891011121314151617181920212223public class LeeSinTimeProxy implements Jungle &#123; //代理对象 Jungle leesin; public LeeSinTimeProxy(Jungle leesin) &#123; super(); this.leesin = leesin; &#125; @Override public void gank() &#123; long starts=System.currentTimeMillis(); leesin.gank(); long ends=System.currentTimeMillis(); System.out.println("gank time:"+(ends-starts)); &#125;&#125; 日志代理123456789101112131415161718192021public class LeeSinlogProxy implements Jungle &#123; Jungle leesin; public LeeSinlogProxy(Jungle leesin) &#123; super(); this.leesin = leesin; &#125; @Override public void gank() &#123; System.out.println("LeeSin starts ganking"); leesin.gank(); System.out.println("LeeSin ends ganking"); &#125;&#125; 测试类12345678public static void main(String[] args) &#123; LeeSin leesin=new LeeSin(); Jungle jungletime=new LeeSinTimeProxy(leesin); Jungle junglelog=new LeeSinlogProxy(jungletime); junglelog.gank(); &#125; 测试结果： LeeSin starts gankingLeeSin is ganking…gank time:1005gank time:1005LeeSin ends ganking 注意这里是日志代理时间，时间代理盲僧，如果更改顺序，只需改变被代理对象即可 至此我们可以简单归纳一下静态代理大概有抽象角色：如打野 ，代理角色（被聚合类的引用），以及真实角色 最后不得不提的是静态代理虽然简单，但是有很多局限性，比如它是在编译期由我们主动创建的，也就说在程序运行前已经存在在.class文件中了，如果代理类一旦多的话，代理内容就无法复用，新增方法时，代理对象也要跟着增加方法。 所以代理设计模式真正的魅力和强大之处而是动态代理！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[观察者设计模式]]></title>
      <url>%2F2017%2F03%2F10%2Fobserver%2F</url>
      <content type="text"><![CDATA[前言观察者模式从定义上说就是一种一对多的依赖关系，即当一个对象的状态发生改变时，其它依赖此对象的对象会得到通知并且做出相应的改变。一般有“推”模型和“拉”模型，前者是被观察者将所有信息通知所有人，而后者则是被观察者不主动提供信息，观察者主动索要信息 在这里还是以之前的例子为例 这是一个推模型，也就是被观察者根据状态发生改变时将所有信息都主动通知观察者其中：Jungle（打野）是被观察者，即如果有一些状态变化，如对方打野有动作则将通知observer（目前假定只有上路和adc）observer：观察者，用来监听被观察者并且根据相应的变化做出变化top：上单 adc：Adc LesSin：打野盲僧以下是相关代码： Jungle（被观察者） 12345678910public interface Jungle &#123; //增加观察者 public void addObserve(Observer obs); //删除观察者 public void deleteObserve(Observer obs); //通知观察者 public void notifyObserve(String msg); &#125; observer（观察者）123456public interface Observer &#123; //收到通知后状态变化 public void notifybyJungle(String msg);&#125; &#125; LeeSin1234567891011121314151617181920212223242526public class LeeSin implements Jungle &#123; //存放所有的观察者 List&lt;Observer&gt; list=new ArrayList&lt;Observer&gt;(); @Override public void addObserve(Observer obs) &#123; list.add(obs); &#125; @Override public void deleteObserve(Observer obs) &#123; list.remove(obs); &#125; @Override public void notifyObserve(String msg) &#123; for(Observer obs : list)&#123; obs.notifybyJungle(msg); &#125; &#125;&#125; top123456789101112131415161718192021public class top implements Observer &#123; //收到消息 public String newmsg; public String getNewmsg() &#123; return newmsg; &#125; public void setNewmsg(String newmsg) &#123; this.newmsg = newmsg; &#125; @Override public void notifybyJungle(String msg) &#123; newmsg=msg; System.out.println("上单收到:"+newmsg); &#125;&#125; Adc1234567891011121314151617181920public class Adc implements Observer &#123;public String newmsg; public String getNewmsg() &#123; return newmsg; &#125; public void setNewmsg(String newmsg) &#123; this.newmsg = newmsg; &#125; @Override public void notifybyJungle(String msg) &#123; newmsg=msg; System.out.println("adc收到:"+newmsg); &#125;&#125; 测试类123456789101112public static void main(String[] args) &#123; Jungle jungle=new LeeSin(); Observer obs1=new Adc(); Observer obs2=new top(); jungle.addObserve(obs1); jungle.addObserve(obs2); jungle.notifyObserve("敌方打野正在打小龙"); &#125; 下面是输出结果 adc收到:敌方打野正在打小龙上单收到:敌方打野正在打小龙 如果我们使用拉模型，即观察者主动向被观察者索要信息，那么上面程序将做部分修改 大体思路就是将Jungle（被观察者）的通知函数改为void即12345678910public interface Jungle &#123; //增加观察者 public void addObserve(Observer obs); //删除观察者 public void deleteObserve(Observer obs); //通知观察者 public void notifyObserve(); &#125; 相应的observer将更改为observer（观察者）123456public interface Observer &#123; //收到通知后状态变化 public void notifybyJungle(Jungle jungle);&#125; &#125; 对于推与拉模型，如果目标角色过于复杂，则优先使用推模式，反之则使用拉模式 观察者模式应用场景1、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变 2、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抽象工厂设计模式]]></title>
      <url>%2F2017%2F03%2F10%2Fabstractfactory%2F</url>
      <content type="text"><![CDATA[前言抽象工厂方法通俗的讲就是为创建一组相关或相互依赖的对象提供一组接口，无需指定他们的具体类。因此，他们通常为创建一族产品对象，并且该产品由不同等级划分。 这里还是以之前的例子为例，假设有一个产生top（上单）的机器，另一个产生Jungle（打野）的机器，同时top可以有ad（物理上单）和ap(法术上单)，同样，Jungle可以有ad和ap打野，现在需要一个工厂，可以同时产生仅含ad的打野和上单，另一个产生仅含ap的打野和上单，当然可以按照自己的组合打野 123456789101112public interface Jungle &#123; //gank能力强 public void gankenemy(); //本身足够灵活 public void flexible(); //打野不太伤 public void killbeast(); &#125; ad打野 123456789101112131415161718192021public class AdJungle implements Jungle &#123; @Override public void gankenemy() &#123; // TODO Auto-generated method stub &#125; @Override public void flexible() &#123; // TODO Auto-generated method stub &#125; @Override public void killbeast() &#123; // TODO Auto-generated method stub &#125;&#125; ap打野123456789101112131415161718192021public class ApJungle implements Jungle &#123; @Override public void gankenemy() &#123; // TODO Auto-generated method stub &#125; @Override public void flexible() &#123; // TODO Auto-generated method stub &#125; @Override public void killbeast() &#123; // TODO Auto-generated method stub &#125;&#125; 上单12345678910public interface Top &#123; //gank能力强 public void gankenemy(); //本身足够灵活 public void flexible(); //打野不太伤 public void killbeast();&#125; ad上单123456789101112131415161718192021public class AdTop implements Top &#123; @Override public void gankenemy() &#123; // TODO Auto-generated method stub &#125; @Override public void flexible() &#123; // TODO Auto-generated method stub &#125; @Override public void killbeast() &#123; // TODO Auto-generated method stub &#125;&#125; ap上单123456789101112131415161718192021public class ApTop implements Top &#123; @Override public void gankenemy() &#123; // TODO Auto-generated method stub &#125; @Override public void flexible() &#123; // TODO Auto-generated method stub &#125; @Override public void killbeast() &#123; // TODO Auto-generated method stub &#125;&#125; 生产打野和上单的工厂1234public interface AbstractFactory &#123;public Top factorytop();public Jungle factoryjungle();&#125; 生产ad打野和上单的工厂123456789101112131415public class AdFactory implements AbstractFactory &#123; @Override public Top factorytop() &#123; // TODO Auto-generated method stub return new AdTop(); &#125; @Override public Jungle factoryjungle() &#123; // TODO Auto-generated method stub return new AdJungle(); &#125;&#125; 生产ap打野和上单的工厂123456789101112131415public class ApFactory implements AbstractFactory &#123; @Override public Top factorytop() &#123; // TODO Auto-generated method stub return new ApTop(); &#125; @Override public Jungle factoryjungle() &#123; // TODO Auto-generated method stub return new ApJungle(); &#125;&#125; 通过上面例子，我们可以发现抽象工厂易于交换产品系列，通过按需改变具体工厂从而使用不同的产品配置，同时它也将创建实例的过程与客户端分类 当然它的缺点就是和简单工厂一样，如果要从sql server切换到mysql，需要重新实例很多次 最后对应工厂系列的设计模式，无论选择哪一个，最终的目的都是为了解耦！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工厂方法设计模式]]></title>
      <url>%2F2017%2F03%2F09%2Ffactory%2F</url>
      <content type="text"><![CDATA[前言工厂方法模式又被称为多态工厂模式，通俗的讲就是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中，因此，也属于创建型模式 这里Jungle的每个具体类都对应一个具体工厂下面就是以工厂方法创建它们，通过抽象工厂选择不同的具体子工厂，从而产生不同的具体打野类 打野接口12345678910111213//打野英雄public interface Jungle &#123; //gank能力强 public void gankenemy(); //本身足够灵活 public void flexible(); //打野不太伤 public void killbeast(); &#125; 工厂接口1234public interface junglefactor &#123;//产生打野public Jungle createjungle();&#125; 盲僧 123456789101112131415161718192021public class LeeSin implements Jungle &#123; @Override public void gankenemy() &#123; System.out.println("盲僧正在gank"); &#125; @Override public void flexible() &#123; System.out.println("盲僧太灵活了"); &#125; @Override public void killbeast() &#123; System.out.println("盲僧正在打野怪"); &#125;&#125; 剑圣 123456789101112131415161718192021public class Js implements Jungle &#123; @Override public void gankenemy() &#123; System.out.println("剑圣正在gank"); &#125; @Override public void flexible() &#123; System.out.println("js也灵活"); &#125; @Override public void killbeast() &#123; System.out.println("剑圣正在打野"); &#125;&#125; 盲僧工厂12345678910111213141516171819202122232425262728293031323334public class LeeSinFactory implements junglefactor &#123; @Override public Jungle createjungle() &#123; return new LeeSin(); &#125;&#125;``` 剑圣工厂``` styluspublic class JsFactory implements junglefactor &#123; @Override public Jungle createjungle() &#123; return new Js(); &#125;&#125;``` 测试类：``` styluspublic static void main(String[] args) &#123; // Jungle jungle= JungleFactory.createJungle("LeeSin"); // jungle.gankenemy(); junglefactor factory=new LeeSinFactory(); Jungle jubjle=factory.createjungle(); jubjle.flexible(); &#125; 这里通过多态，产生不同的工厂，从而产生不同的打野 工厂方法比较简单工厂模式 现在我们要是把打野对象由盲僧换成剑圣的话，利用简单工厂，那就要1234567Jungle jungle= JungleFactory.createJungle("Js");``` 如果是100或者更多的话，那就要重复上述代码那么多次但是如果采用工厂方法，只需要改一处```stylusjunglefactor factory=new JsFactory(); 显然对外扩展开放，对内修改关闭更好。而简单工厂则违背了该原则]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单工厂设计模式]]></title>
      <url>%2F2017%2F03%2F08%2Fsimplefactory%2F</url>
      <content type="text"><![CDATA[前言简单工厂模式又叫静态工厂设计模式。通俗的讲，就是通过专门定义一个类来负责建立其他类的实例，与此同时被创建的类都必须满足他们有共同的父类，所以，它是一种创建型模式。 这里Leesin（盲僧）与Js（剑圣）继承Jungle（打野），而JungleFactory（打野生产工厂）产生具体打野对象下面将以简单工厂创建他们，满足通过传入打野工厂不同的参数，产生不同的打野对象 打野接口 12345678910111213//打野英雄public interface Jungle &#123; //gank能力强 public void gankenemy(); //本身足够灵活 public void flexible(); //打野不太伤 public void killbeast(); &#125; 盲僧 123456789101112131415161718192021public class LeeSin implements Jungle &#123; @Override public void gankenemy() &#123; System.out.println("盲僧正在gank"); &#125; @Override public void flexible() &#123; System.out.println("盲僧太灵活了"); &#125; @Override public void killbeast() &#123; System.out.println("盲僧正在打野怪"); &#125;&#125; 剑圣 123456789101112131415161718192021public class Js implements Jungle &#123; @Override public void gankenemy() &#123; System.out.println("剑圣正在gank"); &#125; @Override public void flexible() &#123; System.out.println("js也灵活"); &#125; @Override public void killbeast() &#123; System.out.println("剑圣正在打野"); &#125;&#125; 打野工厂 12345678910111213141516171819public class JungleFactory &#123; public static Jungle createJungle(String Junglename)&#123; Jungle jungle=null; switch(Junglename)&#123; case "LeeSin": jungle=new LeeSin(); break; case "Js" : jungle=new Js(); break; default : break; &#125; return jungle; &#125;&#125; 下面是测试类 12345public static void main(String[] args) &#123; Jungle jungle= JungleFactory.createJungle("LeeSin"); jungle.gankenemy(); &#125; 当然，我们这里通过不同的参数，获得不同的打野英雄当然这个例子也很好理解简单工厂 事实上，我们知道如果我们一开始用的是sql server数据库，然后我们想换数据库，如果不用工厂模式，那么将替换许多东西，如果这时，使用简单工厂模式，就会使问题变简单许多。 利用简单工厂模式大概思路就是先创建一个抽象数据库(DBobject)，然后是具体实现类sql server与mysql类，然后再来一个生成数据库工厂(DBobjectFactory)通过传入不同的数据库参数，从而连接不同的数据库 至此我们发现，简单工厂的优点在于工厂类中包含了必要的逻辑判断，而且可以根据客户端的选择条件不同而动态的实例化相关的类 当然它的缺点也很明显，当我们创建的抽象实例过多时，显然高内聚就增多了，不利于维护了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[职责链设计模式]]></title>
      <url>%2F2017%2F03%2F07%2Ffilter%2F</url>
      <content type="text"><![CDATA[前言 职责链，通俗地讲就是把责任处理对象连城一条链，这样当一个处理对象不能及时处理的时候就会交给下一个处理对象直到被处理为止。就好比生活中，我们有事向学校请假，得找班主任签字同意，然后有些时候需要院里签字，甚至教务处，最后将假条交给同学，最后在给相应授课老师，可能这个例子还不太准确，但是总之经过一些列流程，最后才会处理。 当然，在程序中，最常见的就是过滤关键字了，首先模拟一下非web下的责任链 首先定义一个过滤接口 123public interface Filter &#123; String doFilter(String str);&#125; 接下来就是各式各样的过滤字敏感字过滤 123456789101112public class SesitiveFilter implements Filter &#123; @Override public String doFilter(String str) &#123; //第一个参数是非法字符，第二个参数是被替换的字符 String r = str.replace("瞎子", "李青") .replace("小学僧", "盲僧"); return r; &#125;&#125; 过滤html标签 1234567891011public class HTMLFilter implements Filter &#123; @Override public String doFilter(String str) &#123; //&lt;&gt;被替换成[] String r = str.replace('&lt;', '[') .replace('&gt;', ']'); return r; &#125;&#125; 过滤链:将过滤器串成一个链，并保存过滤后的字 12345678910111213141516171819202122public class FilterChain implements Filter &#123; //保存所有的具体过滤器 List&lt;Filter&gt; filters=new ArrayList&lt;Filter&gt;(); //过滤器串成链 public FilterChain addFilter(Filter f) &#123; this.filters.add(f); return this; &#125; //返回过滤后的字符 @Override public String doFilter(String str) &#123; String r=str; for(Filter f:filters)&#123; r=f.doFilter(r); &#125; return r; &#125;&#125; 测试： 123456789public static void main(String[] args) &#123; String msg = "因为一个英雄而爱上了lol，他就是瞎子，虽然我是小学僧，但是我还是只坚信我的&lt;我的信仰&gt;英雄！！"; FilterChain fc = new FilterChain(); fc.addFilter(new SesitiveFilter()) .addFilter(new HTMLFilter()); String result=fc.doFilter(msg); System.out.println(result); &#125; 输出结果: 因为一个英雄而爱上了lol，他就是李青，虽然我是盲僧，但是我还是只坚信我的[我的信仰]英雄！！ Web下责任链当然一般情况下，都是过滤web环境下的字符，大概思路跟非web下差不多 首先需要建立request和response对象，即接收和响应 123456789101112131415161718192021public class Request &#123;String requestStr;public String getRequestStr() &#123; return requestStr;&#125;public void setRequestStr(String requestStr) &#123; this.requestStr = requestStr;&#125; &#125;public class Response &#123; String responseStr; public String getResponseStr() &#123; return responseStr; &#125; public void setResponseStr(String responseStr) &#123; this.responseStr = responseStr; &#125;&#125; 然后是Filter接口 123public interface Filter &#123; void doFilter(Request request, Response response, FilterChain chain);&#125; 紧接着是filterchain类 123456789101112131415161718192021222324252627public class FilterChain implements Filter &#123; //存放各种filter List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(); //控制filter的索引 int index = 0; //添加filter public FilterChain addFilter(Filter f) &#123; this.filters.add(f); return this; &#125; //filter链，特别注意这里有一个迭代，与具体filter里的迭代相呼应//主要是依次先取出request的接受字符过滤，然后在倒叙依次取完response的响应过滤,而这恰恰是struts2框架原理的核心，当然spring mvc(直接基于servlet)也类似，都是基于拦截或者过滤实现的 @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; // 过滤器取完退出if(index == filters.size()) return ; //依次取出过滤器 Filter f = filters.get(index); index ++; f.doFilter(request, response, chain); &#125;&#125; 然后就是具体的filter了（这里就是web中的真实拦截顺序了） 123456789101112public class SesitiveFilter implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; // TODO Auto-generated method stub request.requestStr = request.requestStr.replace("瞎子", "李青") .replace("小学僧", "盲僧") ; chain.doFilter(request, response, chain); response.responseStr += "SesitiveFilterresponse"; &#125;&#125; 另一个filter 12345678910111213public class HTMLFilter implements Filter &#123; @Override public void doFilter(Request request, Response response,FilterChain chain) &#123; // TODO Auto-generated method stub request.requestStr = request.requestStr.replace('&lt;', '[') .replace('&gt;', ']') ; chain.doFilter(request, response, chain); response.responseStr += "HTMLFilterresponse"; &#125;&#125; 先附一张structs2原理图，来对比一下上述过滤过程主要关注action invocation中部分 测试类: 12345678910111213141516public static void main(String[] args) &#123; String msg = "因为一个英雄而爱上了lol，他就是瞎子，虽然我是小学僧，但是我还是只坚信我的&lt;我的信仰&gt;英雄！！"; Request request = new Request(); request.setRequestStr(msg); Response response = new Response(); response.setResponseStr("response"); FilterChain fc = new FilterChain(); fc.addFilter(new HTMLFilter()) .addFilter(new SesitiveFilter()) ; fc.doFilter(request, response, fc); System.out.println(request.getRequestStr()); System.out.println(response.getResponseStr()); &#125; 结果: 因为一个英雄而爱上了lol，他就是李青，虽然我是盲僧，但是我还是只坚信我的[我的信仰]英雄！！response–SesitiveFilterresponse–HTMLFilterresponse 最后归纳一下责任链设计模式的一般形式分别为客户端、处理者和具体处理者]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[迭代器设计模式]]></title>
      <url>%2F2017%2F03%2F06%2Fiterator%2F</url>
      <content type="text"><![CDATA[前言 为什么会有迭代器？当我们想要 遍历取出集合一组数据时，一般都是用for里面套着i循环，或者使用for（对象 x :某个集合)的形式取出，不过因为集合类型的不同，取出的形式也不同，但是当我们想要一种统一的方法去遍历集合时，就可以用迭代器去实现，说了那么多，不如来一个直观的例子。 这里模仿Arraylist集合中的迭代器实现过程，其中Iterator:执行递增遍历的接口Collection:一些集合的上层接口Arraylist: 目前只实现了add、size及迭代器ArrayListIterator: 用于Arraylist的迭代器 Iterator接口 123456public interface Iterator &#123;//取得下一个元素Object next();//检查有没有下一个元素boolean hasNext();&#125; Collection接口 12345public interface Collection &#123;public void add(Object o);//增加一个对象public int size();//返回长度Iterator iterator();//内聚迭代器&#125; Arraylist类（这里ArrayListIterator是其内部类） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.zwl.iterator;public class ArrayList implements Collection&#123;//默认都是初始化为10的Object objects[]=new Object[10];//默认集合长度都为0的int index=0;//增加方法public void add(Object o)&#123;//集合长度动态增长，每次都使其长度增加2倍，并且创建一个增长后的新数组//将旧数组先copy给新数组，在指向旧数组的引用//同时保证每添加一个对象，集合长度自增长，这样就不会出现越界情况 if(index==objects.length)&#123; Object newobjects[]=new Object[objects.length*2]; System.arraycopy(objects, 0, newobjects, 0, objects.length); objects=newobjects; &#125; objects[index]=o; index++;&#125;//返回集合长度public int size()&#123; return index;&#125;//统一迭代器方法@Overridepublic Iterator iterator() &#123; // TODO Auto-generated method stub return new ArrayListIterator();&#125;//内部类，返回arraylist的专有迭代器private class ArrayListIterator implements Iterator&#123; //取集合中对象的索引 private int currentIndex=0; //取出集合中当前索引的一个对象 @Override public Object next() &#123; Object o = objects[currentIndex]; currentIndex ++; return o; &#125;//判断集合是否含有下一个元素 @Override public boolean hasNext() &#123;//索引值超出集合长度，集合中元素取完 if(currentIndex&gt;=index) return false; else return true; &#125; &#125;&#125; 测试类： 123456789101112131415public static void main(String[] args) &#123; Collection al=new ArrayList(); for(int i=0;i&lt;15;i++)&#123; al.add(new Object()); &#125; System.out.println(al.size()); Iterator it=al.iterator(); while(it.hasNext())&#123; Object o=it.next(); System.out.println(o+" "); &#125; &#125; 至此，可以归纳一下迭代器设计模式的一般形式 其中：1：Iterator(迭代器) 参与者： 定义访问和遍历元素的接口（如Iterator) 2.ConcreteIterator(具体迭代器)参与者实现迭代器的接口(如ArrayListIterator) 3.Aggregate(聚合)参与者定义建立Iterator参与者的接口(如Collection) 4.ConcreteAggregate（具体聚合）参与者实现Aggregate所定义的接口（如Arraylist） 最后不得不提的是，无论一个集合实现的结果如何，都能使用iterator，此外，我们通过改变iterato，来增加各种iterator，如反向遍历，双向遍历（即，增加一个previous方法），只要注意一下currentInde和index就可以了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jquery之ajax]]></title>
      <url>%2F2017%2F03%2F05%2Fjqajax%2F</url>
      <content type="text"><![CDATA[前言ajax ：异步请求，浏览器地址栏不改变，进行局部刷新 首先先来看一下ajax在浏览器与服务器之间的传输过程 ajaxjquery中有多种ajax请求，根据应用场景不同，选择的ajax不同 $.ajax(…) 最底层ajax请求，编写最复杂，完成功能最全的 load() 、$.get() 、$.post() $.getJSON() 可以完成js“跨域”请求域名：域名+端口+项目，js默认不能跨域请求 $.getScript() 动态加载js文件。 回调函数 json解析 下面将对上面部分进行模拟首先是有一个按钮 1&lt;input type="button" value="发送ajax" /&gt; 然后在js中操作 1234 // 请求路径，我这里是请求到一个servletvar url = "getajaxname";// 请求参数，采用jsonvar params = &#123;"username":"盲僧", "password":"我的最爱"&#125;; 接下来就是利用不同形式的ajax发送请求1 load()函数 ，必须使用jquery对象 * * 格式：load(url, [data], [callback]) * 参数1：url ，请求路径 * 参数2：data，请求参数 * 参数3：callback，回调函数 * * 如果没有请求参数，发送的GET请求 * * 如果有请求参数，发送的POST请求。请求没有中文乱码 * * 回调函数的参数 * 参数1：data，响应数据。load()永远获得字符串，如果需要使用，必须手动转换json对象。 * 12345$(this).load(url,params,function(data)&#123; //转换json对象 var jsonData = eval("("+data+")"); alert(jsonData.value); &#125;); 后台servlet，这里利用gson.jar包回送json数据 1234567891011121314151617public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html,charset=utf-8"); PrintWriter out = response.getWriter(); String name= request.getParameter("username"); String age= request.getParameter("password"); System.out.println(name); System.out.println(age); /*out.println("ajax ok");*/ JsonObject json=new JsonObject(); json.addProperty("value", "ok"); response.getWriter().write(json.toString()); out.flush(); out.close(); &#125; 我们可以通过火狐里的firebug进行测试和观察 2 $.get() 全局函数，发送get请求 * * 格式：jQuery.get(url, [data], [callback], [type]) * * 参数4：type ，返回内容格式，xml, html, script, json, text, _default。 * * GET请求不适合发送中文数据，存放请求的中文乱码。 * 必须手动解码 new String(username.getBytes(&quot;ISO-8859-1&quot;) ,&quot;UTF-8&quot;) * * 响应数据，如果使用 application/json;charset=UTF-8 ，jQuery自动将数据转换json对象。 * * 响应数据，如果使用 text/html;charset=UTF-8 ，回调函数获得字符串数据，需要手动转换。 * 使用“参数4”，设置&quot;json&quot;，jQuery将字符串 转换成 json对象 123$.get(url,params,function(data)&#123; alert(data.value); &#125;,"json"); 将servlet中post中代码copy到get中，但是后台接受的是乱码 3 $.post() 全局函数，发送post请求 * * 格式：jQuery.post(url, [data], [callback], [type]) 123$.post(url,params,function(data)&#123; alert(data.value); &#125;,"json") 4 $.ajax() 底层功能最强大的 * * 格式：jQuery.ajax([settings]) * 参数settings：设置所有的参数 * url:发送请求的地址 * data:发送到服务器的数据,请求参数 * type:请求方式 (&quot;POST&quot; 或 &quot;GET&quot;)， * success:成功的回调函数，success(data, textStatus, jqXHR) * error:请求失败时调用此函数 * dataType:预期服务器返回的数据类型 * &quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理。 * &quot;html&quot;: 返回纯文本 HTML 信息；包含的script标签会在插入dom时执行。 * &quot;script&quot;: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了&quot;cache&quot;参数。&apos;&apos;&apos;注意：&apos;&apos;&apos;在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载) * &quot;json&quot;: 返回 JSON 数据 。 * &quot;jsonp&quot;: JSONP 格式。使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 * &quot;text&quot;: 返回纯文本字符串 */ 123456789101112$.ajax(&#123; "url":url, "data":params, "type":"POST", "success":function(data)&#123; alert(data.value); &#125;, "error":function()&#123; alert("服务器繁忙，请稍后重试"); &#125;, "dataType":"json"&#125;); 一般情况下，我都会选择使用.ajax前后台交互，因为它功能相对较多，其次我们也可以选择适合我们的属性用。 当然后面的ajax，平时也没用到过，所以就不介绍了，当然api是最好的资料，google是最好的老师。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识原生态ajax]]></title>
      <url>%2F2017%2F03%2F04%2Fajax%2F</url>
      <content type="text"><![CDATA[前言1 Ajax是一种网页开发技术，（Asynchronous Javascript+XML）异步JavaScript和xml，2 Ajax是异步交互，局部刷新3 Ajax是减少服务器压力4 Ajax能提高用户体验 Ajax交互与传统交互比较传统交互：网页整体刷新（同步），服务器压力大，用户体验不好 Ajax交互：局部刷新，服务器压力小，用户体验好 不妨先来一个实例，先从整体把握，在细节看首先是jsp页面： 12345&lt;div style="text-align: center;"&gt; &lt;div&gt; &lt;input type="button" value="ajax异步交互" onclick="loadname()"/&gt;&amp;nbsp;&amp;nbsp;&lt;input type="text" name="name" id="name"/&gt; &lt;/div&gt;&lt;/div&gt; 有个按钮事件，用于验证ajax 12345678910111213&lt;script type="text/javascript"&gt; function loadname()&#123; var xmlHttp; if(window.XMLHttpRequest)&#123; xmlHttp=new XMLHttpRequest(); &#125; else&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; xmlHttp.open("post", "getajaxname?name=666&amp;age=16", true); xmlHttp.send(); &#125; &lt;/script&gt; 这段作用是利用ajax异步向后台传了两个参数name=666与age=16，路径是getajaxname为一个servlet路径，通过post方式 后台servlet 123456789101112public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html,charset=utf-8"); PrintWriter out = response.getWriter(); String name= request.getParameter("name"); String age= request.getParameter("age"); System.out.println(name); System.out.println(age); out.flush(); out.close(); &#125; 这里接受前台传来的参数并打印出来 123456789101112Web.xml文件&lt;servlet&gt; &lt;servlet-name&gt;getajaxname&lt;/servlet-name&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;servlet-class&gt;com.zwl.servlet.getajaxname&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;getajaxname&lt;/servlet-name&gt; &lt;url-pattern&gt;/getajaxname&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 主要是映射一个servlet 至此入门程序算是完成，下面将对上述部分进行分析 创建XMLHttpRequest对象所有现代浏览器均支持XMLHttpRequest 对象（IE5 和IE6 使用ActiveXObject）XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。创建语法： 1234567var xmlHttp; if(window.XMLHttpRequest)&#123; xmlHttp=new XMLHttpRequest(); &#125; else&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; XMLHttpRequest 对象请求后台open(method,url,async)规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或POSTurl：文件在服务器上的位置async：true（异步）或false（同步） send(string)将请求发送到服务器。string：仅用于POST 请求 语法： 12xmlHttp.open("post", "getajaxname?name=666&amp;age=16", true);xmlHttp.send(); 有时候需要将参数封装在一个函数中首先得声明setRequestHeader(header,value) 向请求添加HTTP 头。header: 规定头的名称value: 规定头的值创建语法： 1xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded"); 将入门程序部分代码修改如下： 123xmlHttp.open("post", "getajaxname", true); xmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded"); xmlHttp.send("name=666&amp;age=16"); XMLHttpRequest 对象响应服务器现在在前面的代码基础上添加几行代码 12345678alert("readystate:"+xmlHttp.readyState+" status:"+xmlHttp.status); xmlHttp.onreadystatechange=function()&#123; alert("readystate:"+xmlHttp.readyState+" status:"+xmlHttp.status); &#125;; xmlHttp.open("post", "getajaxname", true); xmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded"); xmlHttp.send("name=666&amp;age=16"); 先分析一下onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当readyState 改变时，就会触发onreadystatechange 事件。readyState 属性存有XMLHttpRequest 的状态信息。 下面是XMLHttpRequest 对象的三个重要的属性：onreadystatechange存储函数（或函数名）每当readyState 属性改变时，就会调用该函数。 readyState存有XMLHttpRequest 的状态。从0 到4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status200: “OK”404: 未找到页面 执行上面程序就会发现相应值的变化 接下来在后台加入返回的信息public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html,charset=utf-8&quot;); PrintWriter out = response.getWriter(); //向前台返回一个信息 out.println(&quot;ajax ok&quot;); out.flush(); out.close(); } 页面：根据前面的状态码，进行接收参数 123if(xmlHttp.readyState==4 &amp;&amp; xmlHttp.status==200)&#123; document.getElementById("name").value=xmlHttp.responseText; &#125; responseText 获得字符串形式的响应数据 最后会发现表单被自动填充]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识git]]></title>
      <url>%2F2017%2F03%2F03%2Fgit%2F</url>
      <content type="text"><![CDATA[gitgit是linux之父Linus的第二个伟大的作品，它是分布式版本控制系统，即每个人可以通过clone将工作建立在本地库中 对比之前我们是通过hexo d的提交给远程仓库的master branch，当然我们也可以git提交或者clone到本地。 远程仓库代码clone到本地 首先需要生成公钥与仓库连接首先添加用户名1git config --global user.name "yourname" 其次添加e-mail 1git config --global user.email "youreamil" 默认在administrator目录下生成.ssh并在下生成两个文件id_rsa和id_rsa.pub秘钥， 生成公钥 1ssh-keygen -C "youremail" 这时候我们可以在.ssh文件下用 ls -al显示所有文件（因为.ssh是隐藏的，我是新建了一个.ssh） 2 配置公钥在setting中的ssh and GPG keys中新建ssh key将id_rsa.pub中的内容辅助进去最后用ssh -T git@github.com检查公钥是否配置成功 3 初始化.git在本地新建任意一个文件，在该路径下，初始化为本地仓库1git init 提交文件到缓存区 1git add filename（.表示所有文件） 查看状态 1git status 本地提交，即完成提交至远程仓库的准备 1git commit -m "words" 查看commit记录 1git log 远程最新的代码更新到本地 1git pull origin master 本地代码推到远程仓库，实现本地与远程仓库的同步 1git push origin master 这里我是先将我的一个仓库先clone到本地 1git clone 仓库地址 然后在该仓库目录下执行add和commit，最后在push提交到远程仓库，如果没有远程仓库，可先关联 1git remote add origin 仓库 再push 3.其他常用命令查看当前项目有哪些远程仓库可以执行 1git remote -v 建立分支查看分支（branch） 1git branch 默认都是master，并且master提交新建分支 1git branch name 切换分支` 1git checkout name 删除分支 1git branch -d name 如果我们想要传送另一个分支到远程仓库只需在push中 git push origin branch master 当然git的命令太多了，只总结了学习过程中实验到的 接下来如果将别人代码clone到本地，一般先fork，在利用clone]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssm三大框架整合]]></title>
      <url>%2F2017%2F03%2F02%2Fssm%2F</url>
      <content type="text"><![CDATA[前言 ssm三大框架整合主要指的是spring mvc+mybatis+spring，利用mvc分层思想实现解耦，其中spring mvc负责业务控制和跳转，mybatis负责持久层，spring管理各层，下面将以一个通过id查询用户信息功能搭建整合环境 建立一个web工程 导入ssm整合的相关jar包，包括spring(包含springmvc)，mybatis，mybatis-spring整合。数据库驱动，jstl，c3p0管理数据源，log4j.由于整合包过多，可以自行到网上下载 配置核心文件初始化Web.xml配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;springmvc19_day01_01&lt;/display-name&gt; //配置中文乱码过滤器 &lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; //启用spring监听 &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; //启动spring mvc &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 默认加载方式 默认加载必须规范： * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml * 路径规范：必须在WEB-INF目录下面 --&gt; &lt;/servlet&gt; //spring mvc 过滤文件 &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; //rest格式拦截，主要用在提交带参数问题 &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 加载springmvc-servlet.xml文件 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; //自动扫面根路径以下的所有包，就不要显示配置bean了 &lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt; //默认创建注解处理器映射器，注解处理器适配器。提供json格式支持。 &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 配置sprigmvc视图解析器：解析逻辑视图 后台返回逻辑试图：index 视图解析器解析出真正物理视图：前缀+逻辑试图+后缀====/WEB-INF/jsps/index.jsp --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 加载spring配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; //自动扫面根路径以下的所有包，就不要显示配置bean了 &lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt; &lt;!-- 第一步：配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:mysql端口/你的项目"&gt;&lt;/property&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="user" value="你的用户名"&gt;&lt;/property&gt; &lt;property name="password" value="你的密码"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 第二步：创建sqlSessionFactory。生产sqlSession，即产生会话 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置mybatis接口代理开发 * 接口类名和映射文件必须同名 * 接口类和映射文件必须在同一个目录 下 * 映射文件namespace名字必须是接口的全类路径名 * 接口的方法名必须和映射Statement的ｉｄ一致 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zwl.dao"&gt;&lt;/property&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 第三步：事务 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="save*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!-- 配置拦截service --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.zwl.service.*.*(..))"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 以上三个包都必须在web-inf下 编写接口代码首先是pojo类 12345public class User &#123; private String name; //用户名 private String pwd; //密码 private int uid; //用户id此处省略set、get方法。&#125; 然后利用mapper代理模式开发dao层首先是Usermapper.xml 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.zwl.dao.Usermapper"&gt; &lt;!-- 根据用户ID查询用户信息 --&gt; &lt;select id="findUserById" parameterType="int" resultType="com.zwl.pojo.User"&gt; SELECT * FROM users WHERE uid =#&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 然后是接口 123public interface Usermapper &#123; public User findUserById(int id) throws Exception;&#125; 编写service层这里用到spring注解依赖注入 12345public interface Userservice &#123; public User finduserbyid(Integer id) throws Exception; &#125; 实现类： 1234567891011121314//声明业务层为注解，为控制层依赖注入服务@Servicepublic class Userserviceimpl implements Userservice &#123; //通过注解注入dao层组件 @Resource private Usermapper usermapper; @Override public User finduserbyid(Integer id) throws Exception &#123; User user=usermapper.findUserById(id); return user; &#125;&#125; 控制层 1234567891011121314151617181920212223242526272829//注解自动在spring中注入该bean@Controller//请求路径，放在开头，请求url，controller前必须加入该映射路径@RequestMapping("/user")public class Usercontrol &#123; //自动注入bean @Resource private Userservice userservice;//请求路径，放在方法前，为请求url，到时根据这个找到类里相应方法 @RequestMapping("toadd") public String toadd()&#123;//返回视图，在配置文件中已经配置了前缀和后缀，所以返回到index.jsp return "index"; &#125; @RequestMapping("uid") //这里的参数id必须和前台提交的参数name相同，才能接收到 public void finduserbyid(Integer id) &#123; try &#123; User u=userservice.finduserbyid(id); System.out.println(u.getName()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 页面index.jsp 1234&lt;form action="$&#123;pageContext.request.contextPath &#125;/user/uid.do" method="post"&gt;id：&lt;input type="text" name="id" id="id"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; 数据库里面字段必须为uid，name和password，和pojo类相对应，并且里面有数据 最后我们可以在浏览器输入http：//localhost:端口/项目名/user/toadd.do到index.jsp页面，最后通过输入id，后台输出用户信息 至此ssm整合完成，会发现它比ssh2更方便，特别是注解开发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh三大框架整合]]></title>
      <url>%2F2017%2F03%2F01%2Fssh%2F</url>
      <content type="text"><![CDATA[前言ssh三大框架整合主要指的是structs2+hibernate+spring，利用mvc分层思想实现解耦，其中structs2负责业务控制和跳转，hibernate负责持久层，spring管理各层 ssh下面将以一个简单的登录功能搭建整合环境 首先建立一个web工程，取名ssh2 导入jar包，由于ssh2整合包过多，可以自行官网下载 导入相关配置文件Spring核心文件：applicationcontent.xml放在web-inf下web工程核心文件：web.xml也放在web-inf下structs2核心文件：structs.xml放在src目录下里面暂时什么都不配置 数据库为了方便，设置三个字段，id（int）、name（varchar）、age（int），其中id为主键，且是自增长的 配置核心文件初始化Web.xml配置 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; //启动structs2框架 &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt; &lt;/filter&gt;//允许后缀名为.action或者.jsp的请求通过 &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt;//启动spring监听，即开启spring框架 &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; Applicationcontent.xml文件配置（目前没有实现任何功能，给出原始配置） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beansxmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt; &lt;!-- 定义数据源 ，即连接数据库所需的配置--&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName"&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property name="url"&gt; &lt;value&gt;jdbc:mysql://localhost:mysql端口/数据库名&lt;/value&gt; &lt;/property&gt; &lt;property name="username"&gt; &lt;value&gt;你的用户名&lt;/value&gt; &lt;/property&gt; &lt;property name="password"&gt; &lt;value&gt;你的密码&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- 定义SessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; &lt;property name="dataSource"&gt; &lt;ref bean="dataSource"/&gt; &lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt;//hibernate的方言，决定用哪个数据库 &lt;prop key="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/prop&gt; //是否启动显示sql语句 &lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;//声明hibernate的映射文件，目前没有，后续步骤在此处加上 &lt;property name="mappingResources"&gt; &lt;list&gt; &lt;value&gt;&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义HibernateTemplate，相当于纯hibernate的session --&gt; &lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt; &lt;property name="sessionFactory"&gt; &lt;ref bean="sessionFactory"/&gt; &lt;/property&gt; &lt;/bean&gt; 省略具体的业务代码注入配置&lt;/beans&gt; Structs.xml文件配置 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;//防止乱码&lt;constant name="struts.i18n.encoding" value="utf-8"/&gt;&lt;/struts&gt;目前该文件里面什么功能都没配置，只是个声明 编写业务代码按照mvc思想，先从持久层开始，即编写hibernate的orm对象user.java 123456public class User &#123; private int age; private int id; private String name;此处省略set。Get方法&#125; 映射文件User.hbm.xml 12345678910111213&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.zwl.pojo"&gt;&lt;class name="User" &gt;&lt;id name="id"&gt;&lt;generator class="increment"&gt;&lt;/generator&gt;&lt;/id&gt;&lt;property name="name"&gt;&lt;/property&gt;&lt;property name="age"&gt;&lt;/property&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt; 注意这里普通属性有时为了方便，只要声明一个name，其他属性hibernate会自动识别并补充 接下来要在spring中声明该映射文件 12345&lt;property name="mappingResources"&gt; &lt;list&gt; &lt;value&gt;com/zwl/pojo/User.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 至此，持久层完成 接下来是dao层 123456789101112131415161718192021222324252627282930public interface dengludao &#123;//登录功能public User denglu(User u);&#125;Dao层的实现类import org.springframework.orm.hibernate3.support.HibernateDaoSupport;import com.zwl.pojo.User;public class dengludaoimpl extends HibernateDaoSupport implements dengludao&#123; //这里用了spring提供的操作hibernate的模板方法 @Override public User denglu(User u) &#123; //find里可以写sql语句 List&lt;User&gt; list=this.getHibernateTemplate().find("select user from User as user where user.id=?",u.getId()); if(list.size()==0)&#123; return null;&#125; else&#123; return (User) list.get(0); &#125; &#125;&#125; 接下来要在spring中注入到组件&lt;!-- 配置DAO组件 --&gt; &lt;bean id="dengludao" class="com.zwl.dao.dengludaoimpl"&gt; &lt;property name="hibernateTemplate"&gt; &lt;ref bean="hibernateTemplate"/&gt; &lt;/property&gt; &lt;/bean&gt; 接下来是业务层： 首先是接口 123456789101112131415161718192021222324252627282930public interface dengluservice &#123;public boolean isdenglu(User u);&#125;然后是实现类public class dengluserviceimpl implements dengluservice&#123; //引用dao层组建 private dengludao denglu; public dengludao getDenglu() &#123; return denglu; &#125; public void setDenglu(dengludao denglu) &#123; this.denglu = denglu; &#125; @Override public boolean isdenglu(User u) &#123; if(denglu.denglu(u)!=null) return true; else&#123; return false; &#125; &#125;&#125;接下来就要在spring中注入业务层组件&lt;!-- 配置业务逻辑组件 --&gt; &lt;bean id="dengluservice" class="com.zwl.dao.dengluserviceimpl"&gt; &lt;property name="denglu"&gt; &lt;ref bean="dengludao"/&gt; &lt;/property&gt; &lt;/bean&gt; 表现层首先是两个页面Index.Jsp主要提交表单 12345&lt;form action="userdenglu.action" method="post"&gt; id:&lt;input name="id" type="text"&gt; &lt;br/&gt; &lt;input type="submit"/&gt; &lt;/form&gt; Success.jsp主要就是一句success提示 控制层 123456789101112131415public class userdenglu extends ActionSupport&#123; private dengluservice dengluservic; private int id;省略set与get方法。。 @Override public String execute() throws Exception &#123; User u=new User(); u.setId(id);//如果id存在，返回成功 if(dengluservic.isdenglu(u))&#123; return SUCCESS; &#125; return ERROR; &#125; 接下来需要在spring中注入action 123456&lt;!-- 配置userdengluAction --&gt; &lt;bean id="userdenglu" class="com.zwl.action.userdenglu"&gt; &lt;property name="dengluservic"&gt; &lt;ref bean="dengluservice"/&gt; &lt;/property&gt; &lt;/bean&gt; 同时在structs.xml中配置跳转 1234&lt;action name="userdenglu" class="userdenglu"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;result name="error"&gt;/error.jsp&lt;/result&gt; &lt;/action&gt; 最后通过在浏览器输入到index.jsp，然后输入id，数据库中可以预先插入数据，最后跳转，如果成功则跳到success.jsp，否则产生错误 至此：ssh2框架环境搭建成功，最后提醒的是，这只是一个框架环境，我们可以在此基础上按照mvc思想，可以进行我们想要功能的开发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于java的execl导入数据库和取数据至页面]]></title>
      <url>%2F2017%2F02%2F28%2Fexecl%2F</url>
      <content type="text"><![CDATA[前言在踩了许多坑之后，急需总结一下来提高自己，当然探索未知的过程也是自我能力的提升 POIakarta POI 是apache的子项目，它提供了一组操纵Windows文档的Java API，一般我们使用HSSF接口来操作execl对象，从而实现用纯Java代码来读取、写入、修改Excel文件 我们可以到其官网下载最新poi文档 进入正题首先我们定义一个需求，上传本地一个execl表（里面含有数据），提交给服务器，然后跳转到另一个界面（显示execl表中内容） 环境准备MyEclipse。ssh整合包，mysql，poi的相关包（去官网下载，导入poi-3.7-20101029.jar，poi-examples-3.7-20101029.jar，poi-ooxml-3.7-20101029.jar，poi-ooxml-schemas-3.7-20101029.jar，poi-scratchpad-3.7-20101029.jar） 首先是建一个pojo类，主要与execl表中对应的字段相对应为了方便，这里只有id，name，password字段 12345678package com.zwl.pojo;public class User &#123; private int id; private String name; private String password; 省略set..get方法 2.execl表中写数据 id name password 1 java lol 2 c 3.写读取execl表格的工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.zwl.util;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFCell;import com.zwl.pojo.User;public class ReadExcel &#123; //将execl表中的数据读取出，并与pojo类对应，最后放在集合中 public List&lt;User&gt; readXls(String path) throws IOException &#123; //execl表的全路径,并保存在输入流 InputStream is = new FileInputStream(path); //HSSFWorkbook excell 文档对象介绍 HSSFWorkbook hssfWorkbook = new HSSFWorkbook(is); User user=null; List&lt;User&gt; list=new ArrayList&lt;User&gt;(); // 循环工作表Sheet for (int numSheet = 0; numSheet &lt; hssfWorkbook.getNumberOfSheets(); numSheet++) &#123; // HSSFSheet excell的表单 HSSFSheet hssfSheet = hssfWorkbook.getSheetAt(numSheet); if (hssfSheet == null) &#123; continue; &#125; // 循环行Row for (int rowNum = 1; rowNum &lt;= hssfSheet.getLastRowNum(); rowNum++) &#123; //HSSFRow excell的行 HSSFRow hssfRow = hssfSheet.getRow(rowNum); if (hssfRow != null) &#123; User u = new User(); //HSSFCell excell的格子单元 //这里取出每一行的数据，依次分别添加到pojo对象中，最后放在集合中 HSSFCell no = hssfRow.getCell(0); HSSFCell name = hssfRow.getCell(1); HSSFCell age = hssfRow.getCell(2); int i=(int)Double.parseDouble(getValue(no)); u.setId(i); u.setName(getValue(name)); u.setPassword(getValue(age)); list.add(u); &#125; &#125;&#125; return list; &#125; @SuppressWarnings("static-access") private String getValue(HSSFCell hssfCell) &#123; if (hssfCell.getCellType() == hssfCell.CELL_TYPE_BOOLEAN) &#123; // 返回布尔类型的值 return String.valueOf(hssfCell.getBooleanCellValue()); &#125; else if (hssfCell.getCellType() == hssfCell.CELL_TYPE_NUMERIC) &#123; // 返回数值类型的值 return String.valueOf(hssfCell.getNumericCellValue()); &#125; else &#123; // 返回字符串类型的值 return String.valueOf(hssfCell.getStringCellValue()); &#125; &#125; &#125; 4.上传execl页面，这里只有主体部分 12345//上传至后台的uploadaction，同时规定只能上传execl文件，并且这里的myFile要与后台action中属性对应 &lt;form action="upload.action" enctype="multipart/form-data" method="post"&gt; &lt;input id="share_box" type="file" name="myFile" accept="excel/*"&gt;&lt;hr/&gt; &lt;input id="submit" type="submit" name="" value="分享"&gt; &lt;/form&gt; 5.action编写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class upload extends ActionSupport &#123; private File myFile; //上传的图片文件 private String myFileContentType; //文件类型 private String myFileFileName; //文件名 省略set与get方法 @Override public String execute() throws Exception &#123; //创建一个输入流 InputStream is = new FileInputStream(myFile); //设置文件保存目录 String photoPath = ServletActionContext.getServletContext().getRealPath(""); //建立该文件 File filePhotoPath = new File(photoPath); //该用户第一次上传则创建 /*if(!filePhotoPath.isDirectory()) &#123; filePhotoPath.mkdir(); &#125;*/ //解决中文文件名问题，将中文文件转化为uuid码 String extension = FilenameUtils.getExtension(this.getMyFileFileName()); //上传到服务器的execl表的全路径 String s=photoPath+'\\'+filename; System.out.println(s); //设置目标文件 File tofile = new File(photoPath,filename); //使用输出流来包装目标文件 OutputStream os = new FileOutputStream(tofile); //通过字节输入 byte[] buffer = new byte[1024]; int length = 0; while((length = is.read(buffer)) &gt; 0) &#123; os.write(buffer, 0, length); &#125; //关闭输入流 is.close(); //关闭输出流 os.close(); //引用读取execl表类 ReadExcel rs=new ReadExcel(); //取出execl表中的内容 List&lt;User&gt; list=rs.readXls(s); //将execl表中取出的数据放在session中，以便在下个界面显示数据 Map session = ServletActionContext.getContext().getSession(); session.put("stu", list); return super.execute(); &#125;&#125; 6.structs配置文件编写 1234567891011121314151617//spring中注入bean&lt;bean id="upload" class="com.zwl.action.upload"&gt; &lt;/bean&gt;//strucs.xml文件，其中涉及文件上传，必须有拦截栈的设置，ok.jsp为显示execl表格信息 &lt;action name="upload" class="upload"&gt; &lt;result name="success"&gt;/ok.jsp&lt;/result&gt; &lt;result name="input"&gt;/ok.jsp&lt;/result&gt; &lt;!-- 配置fileUpload拦截器 --&gt; &lt;interceptor-ref name="fileUpload"&gt; &lt;!-- 配置允许上传文件类型 这里是execl文件格式允许上传--&gt; &lt;param name="allowedTypes"&gt;application/excel,application/vnd.ms-excel&lt;/param&gt; &lt;!-- 配置允许上传文件大小最大值 --&gt; &lt;param name="maximumSize"&gt;5120000&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; 7.取出信息在页面显示通过标签循环取出session中的数据12345&lt;s:iterator value="#session.stu" id="cri"&gt;id:&lt;s:property value="#cri.id" escape="false"/&gt;&lt;br/&gt;name:&lt;s:property value="#cri.name" escape="false"/&gt;&lt;br/&gt;password:&lt;s:property value="#cri.password" escape="false"/&gt;&lt;br/&gt;&lt;/s:iterator&gt; 至此我们可以本地上传execl，然后取出表中内容在另一个页面显示信息 导入数据库同样关键在于通过execl路径，通过工具包取出表中内容（存在集合中），将该集合循环取出放在数据库即可9.后台插入数据到数据库的接口 1234567891011121314151617181920212223242526272829303132333435//映射文件hibernate-mapping package="com.zwl.pojo"&gt; &lt;class name="User" table="user" &gt; &lt;id name="id" &gt; &lt;generator class="increment"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="name"&gt; &lt;/property&gt; &lt;property name="password"&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;//dao层public interface dengludao &#123; public void insert(User u);&#125;//sercive层public interface dengluservice &#123;public void isinsert(User u);&#125;//实现类//dao层实现类@Override public void insert(User u) &#123; this.getHibernateTemplate().save(u); &#125;//service层实现类private dengludao denglu;@Override public void isinsert(User u) &#123; denglu.insert(u); &#125; 当然最后还得在spring中注入 10.最后在action中修改一下 12345678910111213//首先增加组件（spring中注入）private dengluservice dengluservic;省略set与get// 在execute中末尾增加如下代码 for(User u : list)&#123; //循环取出execl表中数据 User ss=new User(); ss.setId(u.getId()); ss.setName(u.getName()); ss.setPassword(u.getPassword()); //循环插入到数据库 dengluservic.isinsert(ss); &#125; 最后只要我们上传execl文件，就可以先插入数据库，再在另一个页面显示信息了，注意这里有些地方笔者只给出主体代码，其次有些spring中要注入bean，这里省略了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识Arraylist底层]]></title>
      <url>%2F2017%2F02%2F27%2Farraylist%2F</url>
      <content type="text"><![CDATA[前言ArrayList也叫数组列表，底层使用的是数组实现的，严格来说是动态数组。 一般情况下，一个问题的认识都是由具体到抽象，先看一个入门案例： 1234567891011ArrayList&lt;String&gt; al=new ArrayList&lt;&gt;(); al.add("hello"); al.add("world"); al.add("lol"); System.out.println(al.size()); System.out.println(al.get(0)); System.out.println(al.get(1)); System.out.println(al.get(2)); al.remove(1); System.out.println(al.size()); System.out.println(al.get(1)); 测试结果：3 hello world lol 2这个例子也很好理解，大概流程是先创建集合，在依次加入数据，依次取出和大小，在删除其中一个，在看大小和删除的数据是否存在，好了，入门程序就到这了，运用这几个方法我们可以把它复杂化运用到我们以后想要的上面。 至此下面将开始简单介绍一下add，get，remove方法的源码分析。（当然我们也可以通过设置断点追踪源码） add方法在此之前，先介绍一下源码中的几个静态常量 123private static final int DEFAULT_CAPACITY=10;//数组为空默认的最小分配数组容量private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//默认空数组private int size;//数组长度，初始化默认为0； 下面就是add方法 123456public boolean add(E e) &#123;//保证数组容量的容量始终够用 ensureCapacityInternal(size + 1); //size是elementData数组中元素的个数，初始为0 elementData[size++] = e; return true;&#125; 首先进入第一个方法分析： 12345678910111213141516171819202122232425262728293031323334353637383940private void ensureCapacityInternal(int minCapacity) &#123;//如果数组没有元素，给数组一个默认大小，会选择实例化时的值与默认大小较大者 if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //保证容量够用 ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123;//数组发生size更改的次数，默认为0 modCount++; //如果数组长度小于默认的容量10，则调用扩大数组大小的方法 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125;//数组长度的上限 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) &#123; // 保证数组容量扩大一倍 int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 得到扩大容量后的新数组 elementData = Arrays.copyOf(elementData, newCapacity); &#125;private static int hugeCapacity(int minCapacity) &#123;//返回新数组的大小 if (minCapacity &lt; 0) throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 至此算是把add方法的底层分析了一遍，我们现在是不是可以假象一个简单例子来模拟流程 12ArrayList&lt;String&gt; al=new ArrayList&lt;&gt;(); al.add("hello"); 大概执行流程，数组为空，分配一个默认大小为10的容量，容量动态扩充，然后size变化，最后将值赋给数组，说了这么多，还是有点，总之，可以自己模拟数据，然后进行断点调试，就大概了解其过程了。 get方法在此之前先补充一下arraylist的构造函数，如下 1234567891011121314//如果构造函数不指定大小，则将默认空对象给数组对象public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA; &#125; //指定初始化数组大小public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity]; &#125; 下面就来看一看get方法的执行过程 123456789101112public E get(int index) &#123;//判断index是否合法 rangeCheck(index); //得到相应的数组数据 return elementData(index); &#125;private void rangeCheck(int index) &#123;//判断数组是否越界 if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; 可以看到它的执行过程就这两步 remove方法这里先说明一下，由于删除操作会改变size，所以每次删除都需要把元素向前移动一个位置，然后把最后一个位置设置为null，一次删除操作完成 123456789101112131415161718192021public E remove(int index) &#123; //判断index是否合法 rangeCheck(index);// size更改的次数 modCount++;//保存待删除的位置的元素 E oldValue = elementData(index); //要移动的元素个数 int numMoved = size - index - 1; //如果index不是最后一个元素，则从第index+1到最后一个位置，依次向前移动一个位置 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //元素的size-1并且最后一个元素位置设为null elementData[--size] = null; return oldValue; &#125; public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 很遗憾：断点调试中没有源码，因为其是native，是其他语言编写的，这里只做简单介绍从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的源数组到 dest 引用的目标数组，数组组件的一个子序列被复制下来。被复制的组件的编号等于 length 参数。源数组中位置在 srcPos 到 srcPos+length-1 之间的组件被分别复制到目标数组中的 destPos 到 destPos+length-1 位置。 最后不得不提的是因为arraylist是动态增长的，即容量增产幅度遵循size/2+1，即默认为10，所以依次为：10,16,25.。。。。这就造成arraylist是线程不安全的，多线程中产生问题，参考单例模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于servlet的验证码和md5加密]]></title>
      <url>%2F2017%2F02%2F26%2Fmd5%2F</url>
      <content type="text"><![CDATA[前言验证码通俗的讲就是为了防止机器人自动注册无限制，而md5加密则将明文密码转化为一个32位字符串 验证码这里是基于servlet的，也就是说通过java代码随机生成一个你设置的位数的字符串，然后将其保存在session中，以便后续是通过ajax传给前台验证或者是后台验证首先是生成验证码的类,这里我放在了com.ltw.tools包下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class yanzhengma extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 7.禁止浏览器缓存随机图片 response.setDateHeader("Expires", -1); response.setHeader("Cache-Control", "no-cache"); response.setHeader("Pragma", "no-cache"); // 6.通知客户机以图片方式打开发送过去的数据 response.setHeader("Content-Type", "image/jpeg"); // 1.在内存中创建一副图片 BufferedImage image = new BufferedImage(60, 30, BufferedImage.TYPE_INT_RGB); // 2.向图片上写数据 Graphics g = image.getGraphics(); // 设背景色 g.setColor(Color.BLACK); g.fillRect(0, 0, 60, 30); // 3.设置写入数据的颜色和字体 g.setColor(Color.RED); g.setFont(new Font(null, Font.BOLD, 20)); // 4.向图片上写数据 String num = makeNum(); //这句话就是把随机生成的数值，保存到session，//通过session就可以直接去到随即生成的验证码了 request.getSession().setAttribute("checkcode", num); g.drawString(num, 0, 20); // 5.把写好数据的图片输出给浏览器 ImageIO.write(image, "jpg", response.getOutputStream()); &#125; //该函数时随机生成7位数字 public String makeNum() &#123; Random r = new Random(); //9999999 可以生成7位 String num = r.nextInt(99999) + ""; StringBuffer sb = new StringBuffer(); //如果不够4位，前面补零 for (int i = 0; i &lt; 5 - num.length(); i++) &#123; sb.append("0"); &#125; num = sb.toString() + num; return num; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;&#125;&#125; 这里需要注意的是随机生成的数字放在session的checkcode中，通过设置r.nextInt(xxx)，xxx表示生成几位，如9999，则为四位验证码，然后在for循环中改成设置的位即可接下来将验证码映射成资源文件，在web.xml中设置 123456789&lt;servlet&gt; &lt;servlet-name&gt;yanzhengma&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ltw.tools.yanzhengma&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;yanzhengma&lt;/servlet-name&gt; &lt;url-pattern&gt;/yanzhengma&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 这样该类就被映射成一个资源，然后在页面中直接取资源 1234&lt;input type="text" name="yanzhenma" placeholder="请输入验证码" required="required"&gt;&lt;!-- 验证码，后台已将该.java映射为文件 --&gt; &lt;img src='/项目名/yanzhengma' style="width:400px;height: 50px;" &gt; &lt;input id="submit" type="submit" value="登录"&gt; 如果这里我们需要在前台输入验证码验证，可以通过ajax传值验证。然后在写一个servlet用来将checkcode转换为json传给前台 1234567891011121314151617181920public class dengluyanzhen extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;&#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String code = (String) request.getSession().getAttribute("checkcode"); //获得验证码 response.setContentType("text/html; charset=UTF-8"); response.setHeader("Cache-Control", "no-cache"); response.setHeader("Pragma", "no-cache"); PrintWriter out = response.getWriter(); StringBuffer sb = new StringBuffer(); sb.append(code); out.write(sb.toString()); //转化为json格式将验证码返回给前端 out.close(); &#125;&#125; 然后在前台，还是上面那个页面增加如下代码 123456789101112131415161718192021222324 &lt;script type="text/javascript"&gt;$(function()&#123; /* 利用ajax异步传值，result获得后台传过来的json数据，即验证码 */ var result = ""; $.ajax(&#123; url:'&lt;%=path%&gt;/dengluyanzhen', type:"POST", dataType:"json", async:true,//关闭异步加载,这样只有加载完成才进行下一步 success:function (data) &#123; result = data; &#125; &#125;); $("#submit").click(function () &#123; var num1=$("[name='yanzhenma']").val(); if(result!=num1)&#123; alert("您输入的验证码不一致！请重新输入"); return false; window.location.href="error.jsp"; &#125; &#125;); &#125;);&lt;/script&gt; MD5加密主要是一个算法 12345678910111213141516171819202122public class MD5 &#123; public final static String MD5(String s) &#123; char hexDigits[] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9','a', 'b', 'c', 'd', 'e', 'f' &#125;; try &#123; byte[] strTemp = s.getBytes(); MessageDigest mdTemp = MessageDigest.getInstance("MD5"); mdTemp.update(strTemp); byte[] md = mdTemp.digest(); int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(str); &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; 如果我们想要将一个字符加密，直接调用该类的静态方法即可，如MD5.MD5(users.getPwd())。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于struts2的二维码]]></title>
      <url>%2F2017%2F02%2F25%2Ferweima%2F</url>
      <content type="text"><![CDATA[前言前段时间因为一些原因要做一个二维码，故此google了许多，当然是在踩了许多坑之后，找到了适合自己的方法，故在此将其总结一下，来提高自己 什么是二维码总的来说就是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，最后通过相关设备读取。 zxingzxing是google的一个开源源码，主要用于java生成和解析的条形码，二维码，通过引用相关jar包，实现其中的相关接口来开发，这里我引用的是QRCode.jar主要是生成二维码 需求案例假设我们通过扫描二维码将数据库中的信息取出来并显示在另一个页面 环境准备MyEclipse、mysql数据库（这里建了一张简单表，有id、name、password）、ssh整合包（事实上，我们可以单独使用struts2，只不过耗时一些），QRCode.jar包，jquery-1.8.3.js,gson.jar 二维码工具包这里主要有三个类，一个是图像本身类（包含其本身一些属性）、二维码处理类（包括生成和解析图像二维码），最后一个是将本地图片通过调用处理类转化为二维码。这里我将其放在com.zwl.util包下（以下是相关代码） 123456789101112131415161718public class QRCodeImageBean implements QRCodeImage&#123; BufferedImage bufImg; public QRCodeImageBean(BufferedImage bufImg) &#123; this.bufImg = bufImg; &#125; public int getHeight() &#123; return bufImg.getHeight(); &#125; public int getPixel(int x, int y) &#123; return bufImg.getRGB(x, y); &#125; public int getWidth() &#123; return bufImg.getWidth(); &#125; &#125; 生成和解析二维码类public class QRCode { /** * 解析二维码(QRCode) * @param imgPath * @return content（返回二维码内容） */ public static String decoderQRCode(String imgPath) { // QRCode 二维码图片的文件 File imageFile = new File(imgPath); BufferedImage bufImg = null; String content = null; try { bufImg = ImageIO.read(imageFile); QRCodeDecoder decoder = new QRCodeDecoder(); content = new String(decoder.decode(new QRCodeImageBean(bufImg)), &quot;utf-8&quot;); } catch (IOException e) { System.out.println(&quot;Error: &quot; + e.getMessage()); e.printStackTrace(); } catch (DecodingFailedException dfe) { System.out.println(&quot;Error: &quot; + dfe.getMessage()); dfe.printStackTrace(); } return content; } /** * 生成二维码(QRCode)图片 * @param content 存储内容 * @param imgPath 图片路径 * @param imgType 图片类型 */ public static void encoderQRCode(String content, String imgPath, String imgType) { encoderQRCode(content, imgPath, imgType, 7); } /** * 生成二维码(QRCode)图片 * @param content 存储内容 * @param imgPath 图片路径 * @param imgType 图片类型 * @param size 二维码尺寸 */ public static void encoderQRCode(String content, String imgPath, String imgType, int size) { try { BufferedImage bufImg = qRCodeCommon(content, imgType, size); File imgFile = new File(imgPath); // 生成二维码QRCode图片 ImageIO.write(bufImg, imgType, imgFile); } catch (Exception e) { e.printStackTrace(); } } /** * 生成二维码(QRCode)图片的公共方法 * @param content 存储内容 * @param imgType 图片类型 * @param size 二维码尺寸 * @return */ private static BufferedImage qRCodeCommon(String content, String imgType, int size) { BufferedImage bufImg = null; try { Qrcode qrcodeHandler = new Qrcode(); // 设置二维码排错率，可选L(7%)、M(15%)、Q(25%)、H(30%)，排错率越高可存储的信息越少，但对二维码清晰度的要求越小 qrcodeHandler.setQrcodeErrorCorrect(&apos;M&apos;); qrcodeHandler.setQrcodeEncodeMode(&apos;B&apos;); // 设置设置二维码尺寸，取值范围1-40，值越大尺寸越大，可存储的信息越大 qrcodeHandler.setQrcodeVersion(size); // 获得内容的字节数组，设置编码格式 byte[] contentBytes = content.getBytes(&quot;utf-8&quot;); // 图片尺寸 int imgSize = 67 + 12 * (size - 1); bufImg = new BufferedImage(imgSize, imgSize, BufferedImage.TYPE_INT_RGB); Graphics2D gs = bufImg.createGraphics(); // 设置背景颜色 gs.setBackground(Color.WHITE); gs.clearRect(0, 0, imgSize, imgSize); // 设定图像颜色&gt; BLACK gs.setColor(Color.BLACK); // 设置偏移量，不设置可能导致解析出错 int pixoff = 2; // 输出内容&gt; 二维码 if (contentBytes.length &gt; 0 &amp;&amp; contentBytes.length &lt; 800) { boolean[][] codeOut = qrcodeHandler.calQrcode(contentBytes); for (int i = 0; i &lt; codeOut.length; i++) { for (int j = 0; j &lt; codeOut.length; j++) { if (codeOut[j][i]) { gs.fillRect(j * 3 + pixoff, i * 3 + pixoff, 3, 3); } } } } else { throw new Exception(&quot;QRCode content bytes length = &quot; + contentBytes.length + &quot; not in [0, 800].&quot;); } gs.dispose(); bufImg.flush(); } catch (Exception e) { e.printStackTrace(); } return bufImg; } } 最后一个类是本地生成二维码图片 1234567public static void main(String[] args) &#123; String imgPath = "C:/Users/Administrator/Desktop/img/xiazi.jpg"; QRCode handler = new QRCode(); String qrCon = handler.decoderQRCode(imgPath); String encoderContent = "http://192.168.43.44:100/librarytest/success1.jsp?id=2"; handler.encoderQRCode(encoderContent, imgPath, "png"); &#125; 其中imgPath是本地你想将某个图片生成二维码的那个图片qrCon为解析后的二维码内容，我这里就是一个url地址encoderContent：设置二维码的内容，这里为url带个参数，扫描后就会跳转到相应界面这里的参数想要取出，可以先将内容取出，在通过string类中的方法将字符创相应位置字符取出即可至此，工具类算是有了，接下来就是结合具体配置 后台方法首先是web.xml（启用struts2和spring） 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 然后是applicationContext.xml（为了方便直接将所有方法都注入了）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beansxmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt; &lt;!-- 定义数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName"&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property name="url"&gt; &lt;value&gt;jdbc:mysql://localhost:msql端口/项目&lt;/value&gt; &lt;/property&gt; &lt;property name="username"&gt; &lt;value&gt;你的用户名&lt;/value&gt; &lt;/property&gt; &lt;property name="password"&gt; &lt;value&gt;你的密码&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义SessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; &lt;property name="dataSource"&gt; &lt;ref bean="dataSource"/&gt; &lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="mappingResources"&gt; &lt;list&gt; &lt;value&gt;com/zwl/pojo/User.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义HibernateTemplate --&gt; &lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt; &lt;property name="sessionFactory"&gt; &lt;ref bean="sessionFactory"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置DAO组件 --&gt; &lt;bean id="returnuserdao" class="com.zwl.impl.returnuserdaoimpl"&gt; &lt;property name="hibernateTemplate"&gt; &lt;ref bean="hibernateTemplate"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置业务逻辑组件 --&gt; &lt;bean id="returnuserservice" class="com.zwl.impl.returnuserserviceimpl"&gt; &lt;property name="userdao"&gt; &lt;ref bean="returnuserdao"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置userdengluAction --&gt; &lt;bean id="userreturn" class="com.zwl.action.userreturn"&gt; &lt;property name="returnuser"&gt; &lt;ref bean="returnuserservice"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; pojo类（与数据库映射那个类） 123456public class User &#123; private int id; private String name; private String password;省略set与get方法。。&#125; 映射文件 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.zwl.pojo"&gt; &lt;class name="User" table="user" &gt; &lt;id name="id" &gt; &lt;generator class="increment"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="name"&gt; &lt;/property&gt; &lt;property name="password"&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 接口接下来就是接口编写 dao层1234public interface returnuserdao &#123;//通过id返回Userpublic User returnuserbyid(int id);&#125; service层 123public interface returnuserservice &#123;public User returnuser(int id); &#125; 分别得实现类 1234567891011121314151617181920212223242526public class returnuserdaoimpl extends HibernateDaoSupport implements returnuserdao &#123; @Override public User returnuserbyid(int id) &#123; List list=this.getHibernateTemplate().find(" from User user where user.id = '" + id + "'"); if(list.size()==0)&#123; return null; &#125;else&#123; return (User)list.get(0); &#125; &#125;&#125;public class returnuserserviceimpl implements returnuserservice&#123; private returnuserdao userdao; public returnuserdao getUserdao() &#123; return userdao; &#125; public void setUserdao(returnuserdao userdao) &#123; this.userdao = userdao; &#125; @Override public User returnuser(int id) &#123; // TODO Auto-generated method stub return userdao.returnuserbyid(id); &#125;&#125; 这里只有两个页面，一个只有二维码，另一个是扫描后跳转的页面并且可以从数据库中取出相关信息 1234567891011121314151617181920212223242526272829303132333435 &lt;figure&gt;&lt;figcaption&gt;图书1扫码:&lt;/figcaption&gt;&lt;img src="img/dl.gif"&gt;你本地生成的二维码图片&lt;/figure&gt;``` 接下来是通过ajax从后台异步加载数据，当然是在你扫码后，直接将数据显示在表单中``` stylus &lt;script type="text/javascript"&gt; $(function()&#123; /* 通过ajax异步提交表单 */$.ajax(&#123; /* 提交路径 */ url : '$&#123;pageContext.request.contextPath&#125;/userreturn!userreturn.action', data:params, type:"POST", dataType:"json", /* 提交成功后，并得到后台返回的数据 */ success : function(r) &#123; /* 解析后台json格式，并得到对象 */ $("#id").val(r.id); $("#name").val(r.name); $("#password").val(r.password);&#125;&#125;); &#125;); &lt;/script&gt; &lt;body&gt; &lt;form action="" method="post"&gt; id :&amp;nbsp;&lt;input id="id" name="id" type="text"/&gt;&lt;br/&gt; name :&amp;nbsp;&lt;input id="name" name="name" type="text"/&gt;&lt;br/&gt; password :&amp;nbsp;&lt;input id="password" name="password" type="text"/&gt;&lt;br/&gt; &lt;/form&gt; &lt;/body&gt; Action类接下来就是action的编写首先是 QRCodeAction 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class QRCodeAction extends ActionSupport &#123; private static final long serialVersionUID = 1L; // 封装上传文件域的属性 private File image; // 封装上传文件类型的属性 private String imageContentType; // 封装上传文件名的属性 private String imageFileName; private String message; private String content; 此处省略属性的set与get方法。。 /** * 生成二维码 * @return String * */ public String encoderQRCode()&#123; String realpath = ServletActionContext.getServletContext().getRealPath("/file"); SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss"); String imgName = sdf.format(new Date()) + ".png"; String imgPath= realpath+"/"+imgName; QRCode.encoderQRCode(content, imgPath, "png"); message = imgName; return Action.SUCCESS; &#125; /** * 获取二维码 * @return String * */ public String decoderQRCode() &#123; try &#123; String realpath = ServletActionContext.getServletContext().getRealPath("/img"); File savefile = new File(new File(realpath), imageFileName); if (!savefile.getParentFile().exists()) savefile.getParentFile().mkdirs(); FileUtils.copyFile(image, savefile); message = QRCode.decoderQRCode(realpath+"/"+imageFileName); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Action.SUCCESS; &#125; 然后是我们需要的userreturnaction（主要后台信息通过json格式传给前台） 1234567891011121314151617181920212223242526272829303132public class userreturn &#123; private returnuserservice returnuser; //通过用户id查询用户信息 private String img; //接受二维码图片的名字 省略set与get方法。。 //解析二维码，入库查询，并返回用户信息 public void userreturn() throws Exception &#123; HttpServletResponse response=ServletActionContext.getResponse(); HttpServletRequest request=ServletActionContext.getRequest(); response.setCharacterEncoding("UTF-8"); response.setContentType("application/json; charset=utf-8"); //返回json数据 response.setHeader("Cache-Control", "no-cache"); //不要缓存 response.setHeader("Pragma", "no-cache"); PrintWriter out = response.getWriter(); System.out.println("被扫描的二维码图片的名字:"+img); QRCode qrcode=new QRCode(); String path=qrcode.decoderQRCode("E:/newday/librarytest/WebRoot/img/"+img);//二维码图片地址 System.out.println("二维码解析的内容:"+path); int id=Integer.parseInt(path.substring(path.length()-1)); System.out.println("用户的id号:"+id); User user=returnuser.returnuser(id); System.out.println("用户的姓名:"+user.getName()); System.out.println("用户的密码:"+user.getPassword()); JsonObject json=new JsonObject(); json.addProperty("id", id); json.addProperty("name", user.getName()); json.addProperty("password", user.getPassword()); response.getWriter().write(json.toString()); &#125;&#125; 注意在页面中需要jquery-1.8.3.js包，同时此处json格式转换用的是gson.jar包最后就是struts.xml配置 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;&lt;constant name="struts.i18n.encoding" value="utf-8"/&gt;&lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt; &lt;constant name="struts.devMode" value="false" /&gt; &lt;constant name="struts.i18n.encoding" value="UTF-8"/&gt; &lt;constant name="struts.multipart.maxSize" value="10701096"/&gt;&lt;!-- 上传文件最大值 --&gt; &lt;constant name="struts.multipart.saveDir" value="/tmp"/&gt;&lt;!-- 上传文件设置属性 --&gt; &lt;constant name="struts.custom.i18n.resources" value="global" /&gt; &lt;constant name="struts.action.extension" value="action"&gt;&lt;/constant&gt; &lt;package namespace="/" name="struct2" extends="struts-default"&gt; &lt;action name="userreturn" class="userreturn" method="userreturn"&gt; &lt;/action&gt; &lt;/package&gt; &lt;package name="QRCode" extends="json-default"&gt; &lt;action name="qRCodeAction_*" class="com.zwl.action.QRCodeAction" method="&#123;1&#125;" &gt; &lt;result type="json"&gt; &lt;param name="root"&gt;message&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 最后打开含有二维码那个页面，然后扫一扫就可以跳转到含数据的界面，当然笔者之前遇到了几个问题，首先是图片地址在action中要正确，不然出现null，其次这是只能一个二维码并且含参数id的，只能有一个action，当然可以优化。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用nat123搭建本地服务器]]></title>
      <url>%2F2017%2F02%2F24%2Fnat123%2F</url>
      <content type="text"><![CDATA[前言这是笔者去年第一次将web项目通过外网访问，当然结果很美好，过程很艰难，当时也是第一次用文档记录了探索过程，当然也是在google老师的帮助下，诚然学习最大的乐趣就是通过自己忘我的想尽一切办法最后solve的那种快感进入正题 1 因为要把服务器架在自己的机子上，所以可以选择花生壳和nat123，于是当时百度了一堆关于该技术，充其量只是了解了概念，然后修改tomcat配置文件，先将默认的8080端口改为100（按理讲应该改为80，之后注意中讲为什么），然后将root文件夹全部删掉，当然还有一部（但是我配置了只要一输入域名就是空白页，所以我舍弃了这一步）配置域名与tomcat项目的映射 1&lt;Context path="" debug="0" docBase="你项目的决定路径" reloadable="true"&gt;&lt;/Context&gt; 2 tomcat部分算是完成了，之后我选择了用nat123，建议去官网下载最新版本，注册，登录然后按照百度步骤，懒得写了就截个图吧 注意应用类型我们选80（http）网站，毕竟这是相对来说最佳选择，内网端口（默认可以写80）我选择了100（之后一定要打开和开放端口，后面再说），内网地址，命令行中输入ipconfig查看ip4就是内网，当然也可以用localhost等等（因为他们在tomcat配置，或者在c盘的一个文件中为他们设置了常量，百度就能找到c盘那个源码，tomcat不多说就在配置里面，很好找），其他配置不动，然后保存 这样就有了域名 在打开nav123客户端，出现笑脸，如图等表示映射正常， 然后下面才是最恐怖的地方了（出现各种问题） 1 如果你内网和tomcat选择的是80端口，注意80端口默认不打开的，先开启控制面板-系统与安全-windows防火墙-高级设置-入站规则-新建规则-端口-80-下一步。。-完成， 然后在用netstat –a看看有没有80端口，假设有了，然后以为顺利 了，结果点击客户端的设置，发现最上面出现无公网连接，也就是说内网的80端口不能映射外网，这下麻烦了，好吧，据需钻研解决方案。试着其中一个靠谱的，说路由器配置中没有开放外网，好吧 先在计算机中输入192.168.1.1（这是电信的），打开路由器（然后简单去了解了一下路由器）先开启dmz主机，指派一个特定内网ip（那个机子对外开放），然后 在虚拟服务中打开相应端口80（暂且不是100），然后自以为一切顺利，在点开客户端那个设置或打开命名行输入ipconfig，都显示自己的公网了，相当于一道闸门打开了，当然也找不出问题了，结果又出现将域名输入出现错误。 结果觉得可能是80端口被封（可是已经在客户端能做的范围内把80打开了，最好的解释是要去电信局备案，才能在服务器端解封80端口），也就是说，80端口我们用不了了） 居然一时用不了，就用其他端口吧，就100吧，把之前所有的80开放改为100，然后在打开网页（注意：tomcat没有配置项目初始化，自己指定），然后在用手机或者其他机子试一次，即域名+项目名，结果成功了，但是网速不行啊（又头疼了~~）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单例设计模式]]></title>
      <url>%2F2017%2F02%2F23%2Fdanli%2F</url>
      <content type="text"><![CDATA[前言在介绍单例设计模式之前，先简单介绍一下java的内存分析，可以帮助我们更好的了解相关内容。在此之前，先简单介绍几个相关概念 Stack（栈）存放基本数据类型的数据和对象的引用及存放变量，如果存放的是基本数据类型（非static），直接将变量名和值存入stack中，如果是引用，只将变量名存入栈，然后指向它new的对象（存放在堆中） Heap（堆）存放new产生的数据 静态域存放在对象中用static定义的静态成员（基本类型） 常量池存放所有数据 案例下面将模拟几个实例先说明在证明。（此外注意String不是基本数据类型）上面给出了一个实例，意在了解内存分配，接下来将以String为例说明 12345678String str="abc";String str1="abc";String str2=str;String str3=new String("abc");String str4=new String("abc");String str5=str3;static String str6="abc";static String str7=new String("abc"); 对应的测试内存地址是否相等 123 System.out.println(str==str1);System.out.println(str==str2);System.out.println(str1==str2); 测试结果 true true true说明String 是引用类型，而且上面方法产生的变量都只在栈中并且都是同一个地址 12 System.out.println(str==str3);System.out.println(str3==str4); 测试结果：false false说明：new 之后的对象地址存放在堆中，同时堆中每个new之后的对象地址都是不一样的 1234 System.out.println(str==str6);System.out.println(str3==str6);System.out.println(str6==str7);System.out.println(str3==str7); 测试结果：true false false false说明：String类型的静态变量存放在栈中，而new之后的静态变量存放在堆中 关于内存分配，比较复杂，这里只简单验证其中一些，其他可以自己设计案例模拟 单例顾名思义就是指唯一的对象实例具体点说就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例只存在一个，通常其结构如下所示。入门案例：首先是单例类 1234567891011package com.zwl.pojo;public class Singleton &#123; private static Singleton singleton=new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 测试用junit4进行测试 12345678@Testpublic void test1()&#123; System.out.println("start test.."); Singleton obj1=Singleton.getInstance(); Singleton obj2=Singleton.getInstance(); System.out.println(obj1==obj2); System.out.println("end test..");&#125; 测试结果：start test.. true end test..说明，obj1与obj2是同一个实例，间接说明了单例的特性 至此我们对单例有了一个初步的形式上的认识了，那么它的特点是什么了？主要为三点一：单例类确保自己只有一个实例（构造函数私有：不被外部实例化，也不被继承）二：单例类必须自己创建自己的实例三：单例类必须为其他对象提供唯一的实例 说到单例就必然涉及到多线程，不多说，先模拟一个多线程来说明单例中存在的并发问题。友情提醒一下，上面用的是饿汉式创建单例，就一开始就创建了一个实例，显然浪费内存，接下来将用懒汉式创建单例主体类代码： 1234567891011private static Singleton singleton; private Singleton()&#123; &#125; public static Singleton getInstance() &#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; return singleton; &#125; 下面将用三个线程模拟，两个线程调用单例类，第三个线程启动前两个线程，测试用junit 123456789101112131415161718192021222324public class thread1 implements Runnable&#123; Singleton singleton; public Singleton getSingleton() &#123; return singleton; &#125; public void setSingleton(Singleton singleton) &#123; this.singleton = singleton; &#125; @Override public void run() &#123; singleton=Singleton.getInstance(); &#125;&#125; public class Thread2 implements Runnable&#123; Singleton singleton; public Singleton getSingleton() &#123; return singleton; &#125; public void setSingleton(Singleton singleton) &#123; this.singleton = singleton; &#125; @Override public void run() &#123; singleton=Singleton.getInstance(); &#125;&#125; 简单说明一下，这两个线程目的是调用单例类（注意如果是单例，决不允许出现不同实例）先贴出测试类： 123 thread3 t=new thread3();Thread tt=new Thread(t);tt.start(); 这里我们通过控制第三个线程来构造并发，(这里采用数学中的极限思想) 123456789101112131415public class thread3 implements Runnable&#123; thread1 t1=new thread1(); Thread2 t2=new Thread2(); Thread t=new Thread(t1); Thread t3=new Thread(t2); @Override public void run() &#123; long start=System.currentTimeMillis(); t.start(); t3.start(); long end=System.currentTimeMillis(); System.out.println(end-start); //并发的时间间隔 System.out.println(t1.getSingleton()); System.out.println(t2.getSingleton()); &#125; 测试结果：0 null null多次运行，又出现另一种结果：6com.zwl.pojo.Singleton@8fdcd1null和其他不同步结果说明在很短的时间间隔类，一个居然已经有了实例，而另一个居然是空，显然不是单例，想想倘若在此时去操作该单例，可能就会是静态类发生变化，也就是并发问题了。 很自然。那么怎么去解决了，一种很通用的方法就是加锁实现同步 双锁机制12345678910111213public static Singleton getInstance() &#123; if(singleton==null) &#123; synchronized(Singleton.class) &#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; &#125; &#125; return singleton; &#125; Synchronized关键字，声明使该线程在某处同步，也就是一个线程先占用，另一个线程被阻塞，显然如果不为空，就直接返回对象，对应第二个线程也就不执行if语句了，达到单例效果，可以想象如果为计数变量，同样可以通过二次加锁实现同步 但是实际还是出现不同步，原因是jvm的一个bug，它允许无序写入线程，导致不同步，当然我们可以通过申明volatile关键字。 为什么就可以解决双重解锁的bug了？原因是volatile保证原子性，顺序性，即在双重加锁前保证多线程实现顺序性，举个例子吧，现在有两个线程t1和t2，分别执行b，c操作，如果乱序写入，可能出现t1正在操作b还没完成，t2操作c，致使单例失败，所以需要保证顺序性。经过不断的测试，发现完全同步，只不过时间间隔为0，和null，null，至少是同步了~ 接下来简单比较一下饿汉式和懒汉式的区别从速度和反应时间上，饿汉式加载好，从资源利用率上懒汉式好，饿汉式很明显不会出现多线程并发问题，所以是线程安全的，而懒汉式则是非线程安全的 关于单例模式的应用，笔者在当初学习过程中，遇到很多，学习总是一个不断压缩与重新认识的过程，像sql工具类，hibernate的懒加载，mybatis及 spring中的一些配置等等，往往把握不好，就会出现错误，这里只列举一些工具类，因为它是笔者接触的第一个单例应用。 12345678910111213141516Private static Connection connection;Private sqlhelper()&#123;&#125;； public static Connection mysqlconn() throws Exception &#123; try &#123; // 加载驱动 Class.forName("com.mysql.jdbc.Driver"); // 连接数据库 connection = DriverManager.getConnection( "jdbc:mysql://localhost:3306/software", "root", ""); System.out.println("获得数据库"); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return connection; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[window分区导致双系统无引导界面]]></title>
      <url>%2F2017%2F02%2F22%2Ffenqu%2F</url>
      <content type="text"><![CDATA[先简单介绍一下情境，笔者电脑上装的是双系统，而且bios上设置了system password（当然，已经忘记了是多少了），然后心血来潮在阿里云买了一个学生优惠的服务器，安装了mysql+tomcat7+jdk，在电脑上d盘已经装了linux，在c盘上分了一个分区，那么问题来了，当再次打开电脑时，无引导界面，取而代之的是 然后google了许多解决方案，当然是在彩果许多坑之后找到了适合自己的解决方案，毕竟一个问题的解决总不是一帆风顺的。 进入正题 如果我们要重装系统，肯定得用到bios设置，那么问题来了，如果你设置了密码，并且密码忘记了，那怎么办? 一种办法是通过硬件，通过把电池正负极按照网上说的折腾一下，就可以恢复bios出厂设置，显然这种方法有极大风险，可能会损坏硬件（具体参考google）或者用相关修复工具，但是笔者的电脑都无引导界面，尴尬了~ 还有一种办法就是在你输入3次错误的密码时会出现如下错误代码 然后就是在这里面设置，如下图，输入上述的错误代码，就出现了bios密码， 当然，笔者电脑里有许多宝贵的数据，不可能也不愿意重装系统，经过google一番，发现是分区导致引导盘不能引导，只需要找到该分区，在llinux上重新修复就行了 首先在页面中输入如下lsgrub rescue&gt; ls出现如下（基本都差不多）hd0，（hd0，nsdoc9），（hd0，nsdoc8），（hd0，nsdoc7），（hd0，nsdoc6），（hd0，nsdoc5），（hd0，nsdoc2），（hd0，nsdoc1） 然后通过ls 如上的分区循环一遍，如ls （hd0，nsdoc9）/上述有一个会出现详细信息，他就是安装linux那个分区，其余都是unknown filesystem，当然如果出现bad filesystem那是你没加/如下图： 接下来设置root引导盘 set root=(hd0，nsdoc6）这里设置的是上述找到分区的那个盘set prefix=(hd0，nsdoc6）/boot/grub/ 然后可以用set验证一下 set会出现上述设置的信息 最后执行下述命令 insmod normal在输入normal，就会自动跳转到引导界面，我们选择ubuntu进入，在里面进行修复即可 进入linux系统打开终端，先更新grub，即输入 sudo update-grub ok后在输入 sudo grub-install /dev/sda结束后，我们就可以重启电脑，一切都ok了。进入电脑后笔者做的第一件事就是备份数据，毕竟要给自己留条后路，如果遇到更复杂的情况就后悔莫及了。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阿里云服务器上搭建javaweb站点]]></title>
      <url>%2F2017%2F02%2F21%2Fdajianserver%2F</url>
      <content type="text"><![CDATA[事实上笔者在去年8月份的时候就已经在自己电脑上通过nat123搭建了一台服务器，即p2p，自己的电脑作为服务器，但是这很不安全，而且每次别人通过外网访问，电脑必须打开而且开着服务器，由于是免费的，导致别人访问网速跟不上等等，最近阿里云有学生9.9元购买服务器，所以笔者买了一个，也很有兴趣将笔者之前写的两个网站部署上，结果很美好，但过程很坑，所以就需要总结来提高自己进入正题笔者也是google了许多例子和前人的经验找到适合自己的方法 首先需要租一台云服务器，我选择了阿里云 注意这里操作系统有四个选项，笔者发现只有第四个符合自己（貌似是自定义），然后按照步骤，其中有些需要注意 安全组，这里暂时可以选择默认的第一个，因为后面如果在搭建web时需要一些端口（如mysql默认3306端口改掉，tomcat8080端口换成80等等），到时可以在后台操作） 关于镜像选择，因为笔者是window7，而且还是32位的，相对64位只能有不大于4g的内存， 这里的密码就是之后在本地机子上远程登录这个服务器所要的密码 ok至此，成功租了一台服务器，这时你会收到一条短信，里面有你这台服务器的公网地址 然后笔者就开始着手在本机上登录该服务器，当然是为了搭建javaweb准备的 在本机上准备javaweb需要的环境 在本机上新建一个分区用来放上述软件供服务器远程使用（其实也可以不用分区，直接复制也行，毕竟笔者被分区坑了，导致后来的双系统引导界面消失） 本机上登录远程连接可以用运行-mstsc-直接进入到如下界面其中计算机就是你的公网地址，如果你是新建了一个分区，那么就点选项在本地资源的详细信息中就新建的那个分区勾上，笔者这里是x盘（如果没有的话就直接连接） 后面什么证书，安全啊先不管了，应该是进入远程服务器了 接下来就是将mysql，jdk等复制到c盘中，因为只有一个盘，后续就是安装配置了 安装jdk，笔者的是jdk1.6（注意jdk版本不同，后续运行高版本会出像版本错误，笔者已吃过亏），配置环境变量 安装tomcat，配置tomcat环境变量，注意上述不需要自定义文件夹，因为只有一个c盘，tomcat默认端口是8080 安装mysql，这里面需要注意的是里面有端口设置，可以选择默认的3306或者自定义，然后就是用户与密码设置 可以使用可视化数据库工具，这里笔者使用了navicat至此算是搭建了一个简单web环境，可以先测试一下拷贝一个已经被编译过的web项目，启动tomcat与mysql，然后利用localhost:8080/项目名访问，如果出现界面就表示以上配置成功 接下来需要买一个域名 成功后点击解析，在里面找到新手设置，点进去点击设置网站解析，然后输入公网，即可。 在远程服务器中，找到tomcat下conf下的server.xml文件，如果我们不想要8080端口并且输入域名时不想要端口的话，就先把8080端口改成80 Connector port=”80” protocol=”HTTP/1.1” connectionTimeout=”20000” redirectPort=”8443” /&gt; 3.然后找到host Host name=”你刚刚解析的域名” appBase=”webapp” unpackWARs=”true” autoDeploy=”true”&gt; &lt;Context path=”” docBase=”/项目名” debug=”0” reloadable=”true” 注意这里appBase是放项目的站点，context内的docBase是你的项目名，目前我们只是一个tomcat运行一个域名执行一个项目然后打开C:\Windows\System32\drivers\etc下的host文件增加如下设置 127.0.0.1 localhost ::1 localhost192.168.1.11 刚刚的域名 保存，然后重启服务器，可能会发现会遇到一些问题，如80端口被占用，80端口未开放等等，假设未被占有（如果占用，google上有解决方法），如果未开放，这里我们就需要在云服务器上进行端口开放设置 进入我们购买的云服务器，点击安全组，选中一个实例，点击配置，选择公网入方向，按照步骤开放想要的端口 至此只要输入域名就可以访问了。 当然，如果我们想要一个tomcat上配置多个域名，每个域名运行各自不同的项目，那如何做了，经过踩坑后，大概如下步骤 可以选择在tomcat下新建一个站点，类似于原来的webapp，然后在server.xml中进行配置一个新host Host name=”第二个域名” appBase=”新创建的站点” unpackWARs=”true” autoDeploy=”true”&gt; &lt;Context path=”” docBase=”/第二个项目名” debug=”0” reloadable=”true” 2.然后在hosts文件汇总加入第二个域名 127.0.0.1 localhost ::1 localhost192.168.1.11 刚刚的域名192.168.1.11 第二个域名 最后重启服务器。笔者在这里遇到了一个很奇怪的坑，同一服务器下的项目出现奇怪的jar包冲突，只要删掉xerces包就行了（当然是在远程服务器上才产生冲突的）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初步搭建hexo博客]]></title>
      <url>%2F2017%2F02%2F20%2Fhexo1%2F</url>
      <content type="text"><![CDATA[博客是一种能够更好提高自己的途径，关于利用hexo搭建博客，笔者是一路google一路踩坑，才完成的，当然关于这方面的搭建，实在太多了，笔者也只是稍微总结一下 首先在github上注册一个账号 创建代码库（repository），一般以yourname/youname.github.io setting中选择主题 购买一个域名（这里以笔者在阿里云买的为例） 点击域名里的解析注意CNAME为你的仓库名，其他套用6.回到setting中在Custom domain下填写你刚才的域名，然后在code中会出现一个CNAME文件7.yourname.gthub.io访问你的博客，目前应该只是一个默认主页 接下来就是本地安装hexo与github page联系起来 1.官网安装node.js（注意是32位还是64位） 2安装git（在过程中会有一项自带环境变量设置，选中，不然后面无法识别git） 3安装hexo（以笔者的在e:/blog下为例） 在git bush中 1npm install hexo-cli -g 然后在输入 1npm install hexo --save 然后利用 hexo -v 验证安装是否成功 4.然后在要创建的目录下初始化hexo hexo init 5安装所需的组件和依赖组件 npm install 笔者当时一下子全部安装了很多扩展组件如: npm install hexo-deployer-git –save 在看看目录下应该产生如下目录 6 生成静态文件 hexo g 7 启动服务器，进行本地预览访问 hexo s 然后在浏览器中打开http://localhost:4000/，会出现一个默认的hexo主页 8 Hexo与github page 联系首先是配置Git个人信息 git config –global user.name “用户名”git config –global user.email “邮箱地址” 9 生成密钥 sh-keygen -t rsa -C “邮箱地址” 这里笔者遇到一个坑，默认是在administrator目录下生成一个.ssh文件夹里面包含结果没有，所以自己在该目录下创建一个.ssh文件夹 10 配置Deployment（以笔者的为例） deploy: type: gitrepository: http://github.com/slycmiaoxi/slycmiaoxi.github.io.gitbranch: master 这里的repository是git上对应的use ssh进行clone的 11 登录到git的use ssh将.ssh文件下的id_rsa.pub里的内容复制到改里面 12 写文章上传 hexo new post “article title” 新建一个文章，默认放再_post下 hexo clean 清空public里的文件，该文件夹是上传到git上 hexo g 生成到public文件夹中 hexo d 部署，此过程要输入用户名和密码， 笔者在hexo d过程中曾出现一致无权限，后来在google老师的指引下需要设置用户名和密码，在.ssh文件下生成known_hosts文件，如果没有遇到，那是比较幸运了 目前还是默认的主题，显然不好看，其次编写文章需要markdown语言，笔者使用的是小书匠，因为其组件丰富，操作简单 13 更换主题 首先需要cd到你的hexo根目录，然后 git clone https://github.com/iissnan/hexo-theme-next themes/next 我选择的是next主题，因为其功能，配置方面相对较强大，当然在主题配置方面一路是坑，这里推荐去next官网看配置，大部分都涉及到 如果我们启用next主题，只要在_config.yml（站配置文件中）找到theme，将默认的改成next即可， 另一方面，在theme文件夹下的next文件夹下的_config.yml(主题配置文件）进行主题的配置，当然里面其他文件也是可以配置的，当然google是最好的帮手 最后主题也配置好了，只需要输入yourname.github.io就可以访问你的博客了 当然笔者是一路踩坑过来，很多google也不一定适合自己，只有自己探索过的才是最适合自己的。 最后需要说一下，多说老是注册异常，后来干脆选择友言代替，总之theme里面有很多需要探索的，google是最好的老师]]></content>
    </entry>

    
  
  
</search>
