<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[并发系列之四Guarded Suspension]]></title>
      <url>http://www.myzwl.win/2017/04/13/thrd4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Guarded Suspension是指当现在并不适合马上执行某个操作时，就要求想要执行该操作的线程等待</p>
<h4 id="Guarded-Suspension"><a href="#Guarded-Suspension" class="headerlink" title="Guarded Suspension"></a>Guarded Suspension</h4><p>首先模拟一个案例<br>首先是表示请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public class Request &#123;</div><div class="line">private final String name;</div><div class="line"></div><div class="line">public Request(String name)&#123;</div><div class="line">	this.name=name;</div><div class="line">&#125;</div><div class="line">public String getName()&#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String toString()&#123;</div><div class="line">	return "[ Request"+name+"]";</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一次存放请求以待使用的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.LinkedList;</div><div class="line"></div><div class="line">public class RequestQueue &#123;</div><div class="line"></div><div class="line">  //构造链表，用来保存请求</div><div class="line">	private final LinkedList queue=new LinkedList&lt;&gt;();</div><div class="line">//有请求将最早的请求取出，没有则等待</div><div class="line">	public synchronized Request getRequest()&#123;</div><div class="line">		while(queue.size()&lt;=0)&#123;</div><div class="line">			try&#123;</div><div class="line">				wait();</div><div class="line">			&#125;catch(Exception e)&#123;</div><div class="line">				</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return (Request) queue.removeFirst();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//增加一个请求</div><div class="line">	public synchronized void putRequest(Request request)&#123;</div><div class="line">		queue.addLast(request);</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>送出请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class ClientThread extends Thread &#123;</div><div class="line">  //构造随机数，用来线程等待时间</div><div class="line">	private Random random;</div><div class="line">	//存放请求</div><div class="line">	private RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	public ClientThread(RequestQueue requestQueue,String name,long seed)&#123;</div><div class="line">		super(name);</div><div class="line">		this.requestQueue=requestQueue;</div><div class="line">		this.random=new Random(seed);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">//不断调用putrequest（），并且打印相关信息</div><div class="line">		for(int i=0;i&lt;10000;i++)&#123;</div><div class="line">			Request request=new Request("No ."+i);</div><div class="line">			System.out.println(Thread.currentThread().getName()+" Request:"+request);</div><div class="line">			requestQueue.putRequest(request);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(random.nextInt(1000));</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO: handle exception</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接收请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class ServerThread extends Thread &#123;</div><div class="line">	private Random random;</div><div class="line">	private RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	public ServerThread(RequestQueue requestQueue,String name,long seed)&#123;</div><div class="line">		super(name);</div><div class="line">		this.requestQueue=requestQueue;</div><div class="line">		this.random=new Random(seed);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">	//不断调用getrequest（）</div><div class="line">		for(int i=0;i&lt;10000;i++)&#123;</div><div class="line">			Request request=requestQueue.getRequest();</div><div class="line">			System.out.println(Thread.currentThread().getName()+" Handlet:"+request);</div><div class="line">			</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(random.nextInt(1000));</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO: handle exception</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后是测试<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RequestQueue requestQueue=new RequestQueue();</div><div class="line">		new ClientThread(requestQueue, "A", 1314520l).start();</div><div class="line">		new ServerThread(requestQueue, "B", 5201314l).start();</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>A Request:[ RequestNo .0]<br>B Handlet:[ RequestNo .0]<br>A Request:[ RequestNo .1]<br>B Handlet:[ RequestNo .1]<br>A Request:[ RequestNo .2]<br>B Handlet:[ RequestNo .2]<br>……</p>
</blockquote>
<p>从测试结果可以看出，当发送请求时，接受并处理<br>而其中的关键方法是getRequest（）中，当满足while里条件时，则调用wait，处于等待，直到收到通知，才从休息区出来，而这种一定要满足的条件，就称为Guarded Suspension的警戒条件</p>
<p>所以可将该模式抽象为如下<br>GuardedObject（被防伪的对象）参与者：当线程执行guardMethod时，只要满足警戒条件，就马上执行，当不成立时，就开始等待，而条件的成立与否，是与参与者的状态变化有关<br>guardMethod：防伪的方法<br>stateChangingMethod：状态改变的方法</p>
]]></content>
      
        <categories>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发系列之三Immutable]]></title>
      <url>http://www.myzwl.win/2017/04/11/thrd3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>immutable是指永恒，不会改变的意思，就像java.lang.String类中，并没有提供任何改变字符串属性的方法</p>
<h4 id="immutable-Pattern"><a href="#immutable-Pattern" class="headerlink" title="immutable Pattern"></a>immutable Pattern</h4><p>首先模拟一个案例<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public final class Person &#123;</div><div class="line">//不允许修改的地址</div><div class="line">private final String address;</div><div class="line">//不允许修改的姓名</div><div class="line">private final String name;</div><div class="line">public Person(String name, String address) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.address = address;</div><div class="line">&#125;</div><div class="line">//有final就不会有set方法，控制外部对其的修改</div><div class="line">public String getAddress() &#123;</div><div class="line">	return address;</div><div class="line">&#125;</div><div class="line">public String getName() &#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String toString()&#123;</div><div class="line">	return "[ Person: name="+name+ ",address="+address+"]";</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是人的线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public class PersonThread extends Thread &#123;</div><div class="line"></div><div class="line">	private Person person;</div><div class="line"></div><div class="line">	public PersonThread(Person person) &#123;</div><div class="line">		this.person = person;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">		while(true)&#123;</div><div class="line">		//得到线程的名并打印出人的信息</div><div class="line">			System.out.println(Thread.currentThread().getName()+"prints"+person);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person person=new Person("A1","AA");</div><div class="line">	new PersonThread(person).start();</div><div class="line">	new PersonThread(person).start();</div><div class="line">	new PersonThread(person).start();</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>以下一直重复</p>
</blockquote>
<p>可以发现上面的字段都是final并且没有修改该字段的方法<br>正因为如此，所以就不需要使用synchronized来限制，这在性能上就大大提高了</p>
<h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><p>1.当实例产生后，状态不再变化时<br>2.实例需要共享，而且访问很频繁时</p>
<p>当然，有时也需要变与不变的转换，就像StringBuffer是一个线程不安全的类，在它的构造器中有String作为参数，而在String类中也有StringBuffer作为参数<br>另外像java中的基本类型boolean、int、long等都是immutable模式<br>该模式最大的优点就是实例的状态不会改变，所以没必要进行保护</p>
]]></content>
      
        <categories>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发系列之二Single Threaded Execution]]></title>
      <url>http://www.myzwl.win/2017/04/11/thrd2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Single Threaded Execution是指以一个线程执行，简单来说就是在多线程中限制同时只让一个线程运行</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>首先来模拟一个线程不安全的例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class Gate &#123;</div><div class="line"></div><div class="line">    //记录走过门的人数，默认为0</div><div class="line">	private int count=0;</div><div class="line">	//记录通过门的人的名字</div><div class="line">	private String name="nobody";</div><div class="line">	//记录通过门的人的地址</div><div class="line">	private String address="noplace";</div><div class="line">	</div><div class="line">	//穿越这道门使用的方法</div><div class="line">	public  void pass(String name,String address)&#123;</div><div class="line">		this.name=name;</div><div class="line">		this.address=address;</div><div class="line">		count++;</div><div class="line">		check();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//检查通过门的人的合法性，即人的名字和地址首字母是否相同</div><div class="line">	public void check()&#123;</div><div class="line">		if(name.charAt(0)!=address.charAt(0))&#123;</div><div class="line">			System.out.println("***broken***"+this.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//打印出人数、姓名、地址</div><div class="line">	public  String toString()&#123;</div><div class="line">		return "No."+count+":"+name+" ,"+address;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>目前上面的Gate类是线程不安全的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">//不断穿越门的行人</div><div class="line">public class UserThread extends Thread &#123;</div><div class="line">//用final限制门，姓名，地址不能重复</div><div class="line">private final Gate gate;</div><div class="line">private final String myaddress;</div><div class="line">private final String myname;</div><div class="line">public UserThread(Gate gate, String myname, String myaddress) &#123;</div><div class="line">	super();</div><div class="line">	this.gate = gate;</div><div class="line">	this.myname = myname;</div><div class="line">	this.myaddress = myaddress;</div><div class="line">&#125;</div><div class="line">//发生错误，即行人不合法，则处于死循环，并且执行toString方法</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">	System.out.println(myname+" BEGIN");</div><div class="line">while(true)&#123;</div><div class="line">	gate.pass(myname, myaddress);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">System.out.println("test begin:");</div><div class="line">	Gate gate=new Gate();</div><div class="line">	//构造三个行人</div><div class="line">	new UserThread(gate, "A1", "A2").start();</div><div class="line">	new UserThread(gate, "B1", "B2").start();</div><div class="line">	new UserThread(gate, "C1", "C2").start();</div></pre></td></tr></table></figure></p>
<p>测试结果（截取部分）</p>
<blockquote>
<p>test begin:<br>B1 BEGIN<br>A1 BEGIN<br><strong><em>broken</em></strong>No.1305356:A1 ,A2<br><strong><em>broken</em></strong>No.1347999:B1 ,B2<br><strong><em>broken</em></strong>No.1357011:A1 ,A2<br><strong><em>broken</em></strong>No.1370176:B1 ,B2<br><strong><em>broken</em></strong>No.1377075:B1 ,B2</p>
</blockquote>
<p>从结果来看，明显发生了错误，即出现了线程不安全，但是也有点不对劲</p>
<h4 id="为什么会出错了"><a href="#为什么会出错了" class="headerlink" title="为什么会出错了"></a>为什么会出错了</h4><blockquote>
<p>问题的出错地方就在Gate类中，因为其是线程不安全的，打个比方<br>    线程A1                  线程A2           this.name值            this.address值<br>   count++                  count++            之前的值                  之前的值<br> this.name=name                                  A1                     之前的值<br>                           this.name=name        A2                     之前的值<br>                           this.address=address  A2                       B2<br> this.address=address                            A1                       B2<br>  check（）                  check（）           A1                        B2</p>
</blockquote>
<p>  发生错误</p>
<p>  以上只是发生错误的一种情况，事实上只有当数据量非常大时，极有可能发生错误，所以才会出现错误的结果，并且是在count达到大数量的时候出现的<br>  那么如何修改了？<br>  因为发生在Gate类的pass和toString方法中，所以只要把这个两个方法声明为同步就可以了</p>
<blockquote>
<p>public synchronized void pass(String name,String address){}<br>  public synchronized String toString(){}</p>
</blockquote>
<p>  对应的测试结果</p>
<blockquote>
<p>test begin:<br>A1 BEGIN<br>B1 BEGIN<br>C1 BEGIN</p>
</blockquote>
<h4 id="归纳single-Threaded"><a href="#归纳single-Threaded" class="headerlink" title="归纳single Threaded"></a>归纳single Threaded</h4><p>上面例子的解决方案就是该模式的一种应用，可以将其抽象为以下几个参与者<br>SharedResource（共享资源）参与者：可有多个线程访问的类，如Gate<br>SafeMethod：从多个线程同时调用也不会发生问题<br>UnsafeMethod：从多个线程同时调用会发生问题，需要防范的方法<br>所以必须将上述不安全的方法加以同步锁，当时如果通过其他方法改变不安全方法中数据也会发生错误，就像大门上锁，但是窗户开着一样，所以有时也是一个隐患的问题</p>
<p>那么此种模式何时适用了？<br>多线程时、数据可被多个线程访问的时候、状态可能变化的时候、需要确保安全性的时候</p>
<h4 id="生命线与死锁"><a href="#生命线与死锁" class="headerlink" title="生命线与死锁"></a>生命线与死锁</h4><p>使用该模式，可能会发生死锁的危险<br>而死锁是指：两个线程分别获取了锁定，互相等待另一个线程解除锁定的线程。发生死锁时，哪个线程都无法继续执行下去，所以程序会失去生命线<br>最经典的死锁问题就是汤勺与叉子模型，问题大概是这样的<br>假设A与B同吃一碗面，盘子旁有一支汤勺与一支叉子，而吃面必须同时需要汤勺和叉子<br>而现在叉子被其中一人假设是A拿走，而汤勺被B拿走，就会造成如下现象：<br>A和B一直等待对方放下叉子（或者汤勺），即一直处于等待，僵持阶段，从而程序无法继续运行，故称为死锁现象</p>
<p>而只要上述模式达到下面的条件，就会出现死锁<br>1.具有多个SharedResource参与者<br>2.线程锁定一个SharedResource时，还没接触前就去锁定另一个SharedResource<br>3.获取SharedResource参与者的顺序不固定</p>
<p>当然只要破坏上述三个条件之一就可以避免死锁的发生</p>
<p>下面就开始模拟死锁<br>首先是表示餐具的类(这里只有叉子和汤勺)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class Tool &#123;</div><div class="line"></div><div class="line">	private final String name;</div><div class="line">	public Tool(String  name)&#123;</div><div class="line">		this.name=name;</div><div class="line">	&#125;</div><div class="line">	public String toString()&#123;</div><div class="line">		return "["+name+"]";</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>开始用餐的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class EaterThread extends Thread &#123;</div><div class="line">    </div><div class="line">    //用餐者名字</div><div class="line">	private String name;</div><div class="line">	//左手拿餐具</div><div class="line">	private final Tool lefthand;</div><div class="line">	//右手拿餐具</div><div class="line">	private final Tool righthand;</div><div class="line">	public EaterThread(String name, Tool lefthand, Tool righthand) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.lefthand = lefthand;</div><div class="line">		this.righthand = righthand;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">	  //不断吃</div><div class="line">		while(true)&#123;</div><div class="line">			eat();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void eat()&#123;</div><div class="line">		 //锁定左手获取餐具</div><div class="line">		synchronized (lefthand) &#123;</div><div class="line">		 //左手拿餐具</div><div class="line">			System.out.println(name+"takes up"+lefthand+"left.");</div><div class="line">		 //锁定右手拿餐具</div><div class="line">			synchronized (righthand) &#123;</div><div class="line">		 //右手拿餐具</div><div class="line">				System.out.println(name+" takes up"+righthand+"right.");</div><div class="line">		 //开吃</div><div class="line">				System.out.println(name+" is eating");</div><div class="line">		 //右手放下餐具</div><div class="line">				System.out.println(name+" puts down"+righthand+"right.");</div><div class="line">			&#125;</div><div class="line">		 //解除右手锁定锁，并且左手放下餐具</div><div class="line">			System.out.println(name+"puts down"+lefthand+"left.");</div><div class="line">		&#125;</div><div class="line">		//解除左手餐具的锁定</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   System.out.println("test begin:");</div><div class="line">Tool spoon=new Tool("Spoon");</div><div class="line">Tool fork=new Tool("Fork");</div><div class="line">new EaterThread("A", spoon, fork).start();</div><div class="line">new EaterThread("B", fork, spoon).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>test begin:<br>Atakes up[Spoon]left.<br>A takes up[Fork]right.<br>A is eating<br>A puts down[Fork]right.<br>Aputs down[Spoon]left.<br>Atakes up[Spoon]left.<br>A takes up[Fork]right.<br>A is eating<br>A puts down[Fork]right.<br>Aputs down[Spoon]left.<br>重复。。直到<br>Atakes up[Spoon]left.<br>Btakes up[Fork]left.<br>该处程序停止不动了，也就是a和b分别拿着汤勺和叉子，即处于死锁状态了。</p>
</blockquote>
<p>一种最简单的方法就是改变顺序，即以相同顺序拿餐具<br>即：</p>
<blockquote>
<p>Tool spoon=new Tool(“Spoon”);<br>    Tool fork=new Tool(“Fork”);<br>    new EaterThread(“A”, spoon, fork).start();<br>    new EaterThread(“B”, spoon,fork).start();</p>
</blockquote>
<p>最后程序就会一直进行下去，不过这样的话，前面的共享资源就不存在了！</p>
]]></content>
      
        <categories>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发系列一之初识java线程]]></title>
      <url>http://www.myzwl.win/2017/04/10/thrd1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>曾在论坛中看过这样一句话，如果连多线程都不懂，别说自己学过java，可见多线程的重要性！</p>
<h4 id="何谓线程"><a href="#何谓线程" class="headerlink" title="何谓线程"></a>何谓线程</h4><p>简单来说，就像我们在执行一个程序时，他总按照顺序执行，如果从头到尾都没有分叉，也就是说总是一个流程，那么就可以看做单线程，并且程序执行的主体只有一个，所以，我们把正在执行程序的主体称为线程</p>
<p>当然，平时我们说的最多的就是多线程，顾名思义就是由一个以上的线程所构成的程序，比如文件处理，io请求处理及网络客户端发出的请求等等都可以看做多线程</p>
<h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>先看一个简单的例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest1;</div><div class="line"></div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">public class Mythread extends Thread &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;700;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mythread m=new Mythread();</div><div class="line">	  m.start();</div><div class="line">	  for(int i=0;i&lt;900;i++)&#123;</div><div class="line">	  System.out.print("lol!");</div><div class="line">	  &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>lol!lol!lol!lol!lol!lol!。。hello!hello!hello!hello!hello!。。lol!lol!lol!lol!lol!lol!</p>
</blockquote>
<p>然后在去认识上面程序，其中start方法会启动新的线程，然后再由这个新线程调用run方法，<br>当然也可以直接调用run方法</p>
<p>那么两者有什么区别了？<br>调用start方法会出现字符串交错，也就是并发，而run方法，就是等run方法执行完，在执行其它，显然不会出现交错现象<br>当然数据量小的话，出现的结果很难有说服力，所以并发模拟尽量使用大数量</p>
<h4 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h4><ol>
<li>利用thread的子类的实例，启动线程<br>正如前面模拟的程序，不过下面测试用两个线程<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new Mythread().start（）;</div><div class="line">new Mythread().start（）;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>显然两个线程操作两个对象，所以thread是线程安全的</p>
<ol>
<li>利用Runnable接口<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Mythread implements Runnable</div><div class="line">&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;700;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      Mythread m=new Mythread();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>这里主要向Runnable接口实现的实例作为参数传递给Thread，再启动线程，这里就有一个问题，因为不同线程操作一个对象，所以会造成线程不安全的问题，也就是脏数据</p>
<h4 id="线程的暂时停止"><a href="#线程的暂时停止" class="headerlink" title="线程的暂时停止"></a>线程的暂时停止</h4><p>利用Thread的sleep方法可暂时停止线程当前的操作，如<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">      public class Mythread implements Runnable</div><div class="line">&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;5;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>这里的参数是ms，所以1000就是1s了</p>
<h4 id="线程的共享互斥"><a href="#线程的共享互斥" class="headerlink" title="线程的共享互斥"></a>线程的共享互斥</h4><p>在程序里，多个线程可自由操作，就会造成一个线程还在执行，另一个线程就插进来执行，就会造成一些脏数据的产生<br>如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">       private int count=1000;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">	for(int i=0;i&lt;100;i++)&#123;</div><div class="line">		count--;</div><div class="line">		System.out.println("mythread"+(count));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     Mythread m=new Mythread();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：（取部分）</p>
<blockquote>
<p>mythread999<br>mythread997<br>mythread996<br>mythread995<br>mythread994</p>
</blockquote>
<p>显然出现了脏数据<br>要想使数据正确，一种方法是加同步锁，即一个线程在执行该操作时，其余线程无锁，则必须等待，直到该线程执行结束或者被挂起，才释放锁，然后在门外等待的线程依次执行，加锁，重复上述步骤<br>显然，就不会出现多个线程操作同一个对象了</p>
<p>java中通过声明synchronized关键字实现同步锁<br>如：</p>
<blockquote>
<p>public synchronized void run()</p>
</blockquote>
<p>则在执行run方法前加同步锁，控制线程，当然该关键字可以声明在任何方法前，包括静态方法<br>另外，它还有另外一种声明方式</p>
<blockquote>
<p>public  void run() {<br>        synchronized (xx.class) {<br>        }</p>
</blockquote>
<p>注意这里xx.class是操作该方法的那个类实现同步比如这里可以将</p>
<blockquote>
<p>synchronized (this) {}</p>
</blockquote>
<p>就是对本身这个类加锁控制了等同于上述的另一种写法</p>
<h4 id="线程的协调"><a href="#线程的协调" class="headerlink" title="线程的协调"></a>线程的协调</h4><p>如果有一个线程正在执行同步锁，而其他线程则要等待，这是典型的线程互斥现象<br>假如当该空间有空余时则写入数据，无空闲时间则等待（等待）<br>当该空间有空闲时，则通知等待的线程（通知）</p>
<p>这里是根据空间是否空闲为条件进行线程处理，java中通过wait（让线程等待），notify与notifyAll（启动等候中的线程）</p>
<p>我们可以把线程处于等待的地方形象的看做wait set（线程的休息室）</p>
<h4 id="wait-把线程放入休息室"><a href="#wait-把线程放入休息室" class="headerlink" title="wait-把线程放入休息室"></a>wait-把线程放入休息室</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">	private static int count=90;</div><div class="line">	</div><div class="line">public synchronized int s() throws InterruptedException&#123;</div><div class="line">	count--;</div><div class="line">	System.out.println("ok:"+count);</div><div class="line">	this.wait();</div><div class="line">	System.out.println("lockover");</div><div class="line">	return count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">	public  void run() &#123;	</div><div class="line">				try &#123;</div><div class="line">					s();</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>然后在测试中启动几个线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     Count m=new Count();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>ok:89<br>ok:88<br>ok:87</p>
</blockquote>
<p>一般为obj.wait（），而obj是某个对象的实例，也就是说该线程在obj的休息区<br>之后会自动释放锁，等待的线程开始执行</p>
<p>当然也有obj.wait（1000）；也可以设置在休息区等待的秒数，然后继续执行</p>
<p>测试结果：</p>
<blockquote>
<p>ok:89<br>ok:88<br>ok:87<br>lockover<br>lockover<br>lockover</p>
</blockquote>
<h4 id="notify方法-从休息区拿出线程"><a href="#notify方法-从休息区拿出线程" class="headerlink" title="notify方法-从休息区拿出线程"></a>notify方法-从休息区拿出线程</h4><p>一般为obj.notify（），即从obj的wait set里的线程中挑选一个，唤醒一个线程并退出该休息区<br>当然，这里有一个顺序，召唤该线程的那个线程执行完，释放锁后，那个在休息区的线程在执行</p>
<p>obj.notifyAll（），即从线程区中拿出所有线程</p>
<p>最后需要说一下的是wait、notify、notifyAll是Object的类方法，也就是所有类都能使用</p>
<p>由此可看出多线程的确是一个复杂而且很重要的东西！！</p>
]]></content>
      
        <categories>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[集合中的线程安全问题]]></title>
      <url>http://www.myzwl.win/2017/04/07/thread2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早在刚开始学习java se的时候，就遇到过这样问题，xxx是线程安全的，xxxx是线程不安全的，当时也是一脸蒙，只记住了结论。后来接触了单例才有一点了解</p>
<p>线程安全的：<br>vector、hashtable、stringbuffer等</p>
<p>非线程安全的：<br>arraylist、linkedlist、hashmap、StringBuilder等等</p>
<p>首先来模拟一个案例</p>
<p>测试集合类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static void test()  &#123;</div><div class="line">// 用来测试的List  </div><div class="line">   List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();  </div><div class="line">   </div><div class="line">   // 线程数量(1000)  </div><div class="line">   int threadCount = 1000;  </div><div class="line">   </div><div class="line">// 用来让主线程等待threadCount个子线程执行完毕  </div><div class="line">   CountDownLatch countDownLatch = new CountDownLatch(threadCount);  </div><div class="line">   </div><div class="line">    // 启动threadCount个子线程  </div><div class="line">   for(int i = 0; i &lt; threadCount; i++)  </div><div class="line">   &#123;  </div><div class="line">       Thread thread = new Thread(new Mythread(list,countDownLatch));  </div><div class="line">       thread.start();  </div><div class="line">   &#125;  </div><div class="line">   try  </div><div class="line">   &#123;  </div><div class="line">       // 主线程等待所有子线程执行完成，再向下执行  </div><div class="line">       countDownLatch.await();  </div><div class="line">   &#125;  </div><div class="line">   catch (InterruptedException e)  </div><div class="line">   &#123;  </div><div class="line">       e.printStackTrace();  </div><div class="line">   &#125;  </div><div class="line">   // List的size  </div><div class="line">   System.out.println(list.size());  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>自定义线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line">import java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line">public class Mythread implements Runnable &#123;</div><div class="line">	private List&lt;Object&gt; list;  </div><div class="line">	</div><div class="line">	private CountDownLatch countDownLatch; </div><div class="line">	public Mythread(List&lt;Object&gt; list,CountDownLatch countDownLatch)&#123;</div><div class="line">		  this.list = list; </div><div class="line">		  this.countDownLatch = countDownLatch;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		// 每个线程向List中添加100个元素  </div><div class="line">        for(int i = 0; i &lt; 100; i++)  </div><div class="line">        &#123;  </div><div class="line">            list.add(new Object());  </div><div class="line">        &#125;  </div><div class="line">     // 完成一个子线程  </div><div class="line">        countDownLatch.countDown();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">	 </div><div class="line">	 // 进行10次测试  </div><div class="line">        for(int i = 0; i &lt; 10; i++)  </div><div class="line">        &#123;  </div><div class="line">            test();  </div><div class="line">        &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>99873<br>99968<br>99955<br>100000<br>100000<br>100000<br>100000<br>Exception in thread “Thread-7516” java.lang.ArrayIndexOutOfBoundsException: 76327<br>    at java.util.ArrayList.add(ArrayList.java:441)<br>    at com.zwl.test.Mythread.run(Mythread.java:20)<br>    at java.lang.Thread.run(Thread.java:744)</p>
</blockquote>
<p>有时不会出现异常，但是list的长度不是最终期望的那样，显然是线程不安全的，<br>这里是arraylist，同样将其换成linkedlist，也可以改变list，变成其它，得到同样线程不安全结果</p>
<p>测试结果：</p>
<blockquote>
<p>100000<br>99783<br>100000<br>99945<br>99897<br>99996<br>99879<br>99971<br>100000<br>99899</p>
</blockquote>
<p>将其换成线程安全的，如</p>
<blockquote>
<p>List<object> list = new Vector<object>(); </object></object></p>
</blockquote>
<p>测试结果：</p>
<blockquote>
<p>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000</p>
</blockquote>
<p>当然集合中的线程不安全是多线程同时操作同一个对象，如果是不同类，就不存在线程安全问题</p>
<p>对于线程安全，一般通过线程同步来实现，即通过申明synchronized关键字</p>
<p>如，改一下之前的线程安全的例子number类</p>
<p>修改后的number类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class number &#123;</div><div class="line"></div><div class="line">	private int num=0; </div><div class="line"></div><div class="line">	public  void count()&#123;</div><div class="line">	</div><div class="line">		num++;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int getnumber()&#123;</div><div class="line">		return num;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是自定义线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Mythread implements Runnable &#123;</div><div class="line">	private number num;</div><div class="line">	</div><div class="line">	private CountDownLatch countDownLatch; </div><div class="line">	public Mythread(number num,CountDownLatch countDownLatch)&#123;</div><div class="line">		  this.num = num; </div><div class="line">		  this.countDownLatch = countDownLatch;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123; </div><div class="line">        for(int i = 0; i &lt; 100; i++)  </div><div class="line">        &#123;  </div><div class="line"> </div><div class="line">        	num.count();</div><div class="line">        	</div><div class="line">        &#125;  </div><div class="line">     // 完成一个子线程  </div><div class="line">        countDownLatch.countDown();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> public static void test()  &#123;</div><div class="line"></div><div class="line">   </div><div class="line">   number num=new number();</div><div class="line">   // 线程数量(1000)  </div><div class="line">   int threadCount = 1000;  </div><div class="line">   </div><div class="line">// 用来让主线程等待threadCount个子线程执行完毕  </div><div class="line">   CountDownLatch countDownLatch = new CountDownLatch(threadCount);  </div><div class="line">   </div><div class="line">   for(int i = 0; i &lt; threadCount; i++)  </div><div class="line">   &#123;  </div><div class="line">       Thread thread = new Thread(new Mythread(num,countDownLatch));  </div><div class="line">       thread.start();  </div><div class="line">   &#125;  </div><div class="line">   try  </div><div class="line">   &#123;  </div><div class="line">       // 主线程等待所有子线程执行完成，再向下执行  </div><div class="line">       countDownLatch.await();  </div><div class="line">   &#125;  </div><div class="line">   catch (InterruptedException e)  </div><div class="line">   &#123;  </div><div class="line">       e.printStackTrace();  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line">   System.out.println(num.getnumber());  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		 </div><div class="line">		 // 进行10次测试  </div><div class="line">	        for(int i = 0; i &lt; 10; i++)  </div><div class="line">	        &#123;  </div><div class="line">	            test();  </div><div class="line">	        &#125;  </div><div class="line">	 &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>100000<br>100000<br>100000<br>100000<br>99940<br>99300<br>100000<br>100000<br>100000<br>100000</p>
</blockquote>
<p>出现了线程不安全<br>可以通过对方法声明同步</p>
<blockquote>
<p>public synchronized void count(){}</p>
</blockquote>
<p>最后输出的书都是同一个数</p>
<p>最后不得不说，线程安全是一个很复杂的问题，有时候不注意就会出现数据上的各种问题！！！</p>
]]></content>
      
        <categories>
            
            <category> 学习进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识线程安全与线程不安全]]></title>
      <url>http://www.myzwl.win/2017/04/06/thread1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于线程问题基本上贯穿学习的整个过程，像集合，servlet，structs，hibernate，spring等等，其都涉及到线程问题</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>什么是线程安全？<br>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>线程安全问题都是由全局变量及静态变量引起的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全</p>
<p>不妨来一个实例<br>首先是number类，里面有一个计数的全局和静态变量<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class number &#123;</div><div class="line"></div><div class="line">	private int num;</div><div class="line">	private static int count;</div><div class="line">	</div><div class="line">	public void count()&#123;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			num+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+num);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void countstatic()&#123;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			count+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+count);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然我们希望每个线程都能输出的结果是55就是线程安全</p>
<p>线面是测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class test &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	</div><div class="line">		Runnable runner=new Runnable() &#123;</div><div class="line">			number num=new number();</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				num.count();</div><div class="line">				System.out.println("statis:");</div><div class="line">				num.countstatic();</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			new Thread(runner).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里启动十个线程，依次通过run方法输出全局和静态变量的累加和，如果是线程安全的，则应该都是55</p>
<p>结果如下所示</p>
<blockquote>
<p>Thread-0:55<br>statis:<br>Thread-0:55<br>Thread-1:110<br>statis:<br>Thread-1:110<br>Thread-2:165<br>statis:<br>Thread-2:165<br>Thread-6:275<br>statis:<br>Thread-6:220<br>Thread-3:385<br>statis:<br>Thread-4:220<br>statis:<br>Thread-3:275<br>Thread-8:385<br>statis:<br>Thread-8:385<br>Thread-4:330<br>Thread-5:440<br>statis:<br>Thread-5:440<br>Thread-7:495<br>statis:<br>Thread-7:495<br>Thread-9:550<br>statis:<br>Thread-9:550</p>
</blockquote>
<p>发现不是线程安全的</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
<p>对于上面的线程不安全可以进行如下修改</p>
<p>解决方法：将全局变量变成局部变量（静态变量暂时不讨论）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void count()&#123;</div><div class="line">		int num = 0;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			num+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+num);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>最后所有的线程都输出了55</p>
<p>或者将new 的number放到run里面，变成局部的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">			public void run() &#123;</div><div class="line">				number num=new number();</div><div class="line">				num.count();</div><div class="line">				System.out.println("statis:");</div><div class="line">				num.countstatic();</div><div class="line">			&#125;</div><div class="line">		&#125;;</div></pre></td></tr></table></figure></p>
<p>最后也能保证了线程安全了</p>
]]></content>
      
        <categories>
            
            <category> 学习进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Linkedlist底层]]></title>
      <url>http://www.myzwl.win/2017/04/05/linkedlist/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LinkedList底层是基于双端链表实现的，也就是说它具有指向其前驱与后继的引用，而且，在插入与删除数据时效率极高</p>
<p>至于它继承谁和实现什么接口，直接看源码</p>
<blockquote>
<p>public class LinkedList<e> extends AbstractSequentialList<e><br> implements List<e>, Deque<e>, Cloneable, java.io.Serializable</e></e></e></e></p>
</blockquote>
<p> 和ArrayList一样，从源码分析其add、get以及remove方法</p>
<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p> 首先通过MyEclipse进入LinkedList的源码</p>
<p> 找到add（）方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line"> //把e放在链表的最后一个位置</div><div class="line">       linkLast(e);</div><div class="line">       return true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到linkLast（）方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line">    * Pointer to last node.</div><div class="line">    * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line">    *            (last.next == null &amp;&amp; last.item != null)</div><div class="line">    */</div><div class="line">   transient Node&lt;E&gt; last; //链表最后一个结点的引用</div><div class="line"></div><div class="line">   transient Node&lt;E&gt; first; //链表第一个结点的引用</div><div class="line"></div><div class="line"></div><div class="line">void linkLast(E e) &#123;</div><div class="line">       //将l也指向最后一个结点</div><div class="line">       final Node&lt;E&gt; l = last;</div><div class="line"></div><div class="line">       //调用Node（Node&lt;E&gt; prev，E element，Node&lt;e&gt; next）构造方法</div><div class="line">       //其中prev为前驱结点，element为对象元素，next为后继结点</div><div class="line">       //这里构造新节点，并且是作为尾节点</div><div class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line"></div><div class="line">       //last结点指向newNode</div><div class="line">       last = newNode;</div><div class="line"></div><div class="line">       //如果l为空，则表示链表为空，直接把newNode作为首节点，否则放在l结点之后</div><div class="line">       if (l == null)</div><div class="line">           first = newNode;</div><div class="line">       else</div><div class="line">           l.next = newNode;</div><div class="line"></div><div class="line">        //链表的元素个数加一</div><div class="line">       size++;</div><div class="line"></div><div class="line">       //链表发生结构性修改的次数，这里主要指添加及删除操作</div><div class="line">       modCount++;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>以上便是add方法的源码，主要通过改变链表的前驱及后继引用来完成插入，可想而知，使用链表，使插入数据的速度异常快，相对顺序查找</p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>找到get方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line"></div><div class="line">     //检查index是否合法</div><div class="line">       checkElementIndex(index);</div><div class="line"></div><div class="line">     //如果合法就返回该节点位置的值</div><div class="line">       return node(index).item;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到checkElementIndex(int index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void checkElementIndex(int index) &#123;</div><div class="line">    //检查index是否合法</div><div class="line">       if (!isElementIndex(index))</div><div class="line">           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到isElementIndex(index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//判断index是否存在于链表中</div><div class="line">private boolean isElementIndex(int index) &#123;</div><div class="line">       return index &gt;= 0 &amp;&amp; index &lt; size;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到node(int index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Node&lt;E&gt; node(int index) &#123;</div><div class="line">    //index已在链表中</div><div class="line">    // assert isElementIndex(index);</div><div class="line">    //从第一个位置开始寻找，知道找到index的位置，最后返回该节点的位置</div><div class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        for (int i = 0; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        return x;</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    //从最后一个位置开始往前寻找该节点</div><div class="line">    else &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        for (int i = size - 1; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>linkedlist在查找时的效率非常低，就是因为它是从头或从尾部遍历链表，所以当数据量大时，造成效率低下</p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><p>找到remove方法</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public E remove(int index) &#123;</div><div class="line">      //检查index是否合法</div><div class="line">        checkElementIndex(index);</div><div class="line"></div><div class="line"></div><div class="line">        return unlink(node(index));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>找到unlink(node(index))方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> E unlink(Node&lt;E&gt; x) &#123;</div><div class="line">        // assert x != null;</div><div class="line">        //保存x节点的值</div><div class="line">        final E element = x.item;</div><div class="line">        //保存x节点的后继</div><div class="line">        final Node&lt;E&gt; next = x.next;</div><div class="line">        //保存x节点的前驱</div><div class="line">        final Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">       //如果前驱为空，则表明要移除的是第一个结点，在把first指向下一个节点</div><div class="line">        if (prev == null) &#123;</div><div class="line">            first = next;</div><div class="line">        &#125; else &#123;</div><div class="line">        	//否则把x前驱的后继指向x的后继，并把x前驱设置为null</div><div class="line">            prev.next = next;</div><div class="line">            x.prev = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"> //如果后继为空，则表明要移除的是最后一个结点，在把last引用指向x的前驱</div><div class="line">        if (next == null) &#123;</div><div class="line">            last = prev;</div><div class="line">        &#125; else &#123;</div><div class="line">            next.prev = prev;</div><div class="line">            x.next = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">//把x结点的值设置为null，保证x没有任何引用了</div><div class="line">        x.item = null;</div><div class="line"></div><div class="line"> //链表的size减一</div><div class="line">        size--;</div><div class="line"></div><div class="line">   //链表的结构性修改次数加一</div><div class="line">        modCount++;</div><div class="line"></div><div class="line">   //这里该节点移除之前以保存在element中，然后返回该节点</div><div class="line">        return element;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>至此，简单把上面三个方法的源码简单过了一遍<br>当然，还有一点不得不提的是LinkedList可以当做stack（栈），queue（队列）处理，因为它是双端链表，另外，在遍历时，有index &lt; (size &gt;&gt; 1)，即判断index与size/2比较，这样可以缩小范围，选择是从前遍历还是从后遍历，从而大大增加查找效率</p>
]]></content>
      
        <categories>
            
            <category> 学习进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hibernate之四:反向工程]]></title>
      <url>http://www.myzwl.win/2017/04/04/hbm4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在运用持久层框架时，先前我们都是先通过建立对象—映射文件—数据库的方法，倘若数据库中的表非常多和复杂时，我们可以改变下开发顺序，即从数据库自动生成映射文件和对象，这样涉及表之间的关系，级联或者主外键约束就自动生成，更方便。一般我们用hibernate的反向工程达到此目的。</p>
<p>不多说，先模拟一个案例。<br>首先建立三张表user，picture，addr表，分别如下<br>User表<br><img src="/images/imgs3/1.gif" alt="Alt text"></p>
<p>Picture表<br><img src="/images/imgs3/2.gif" alt="Alt text"></p>
<p>外键<br><img src="/images/imgs3/3.gif" alt="Alt text"></p>
<p>这里的uid是外键对应user表的主键，并且只有当user的id删除时，对应uid相应的记录删除</p>
<p>Addr表<br><img src="/images/imgs3/4.gif" alt="Alt text"></p>
<p>外键<br><img src="/images/imgs3/5.gif" alt="Alt text"></p>
<p>通过myeclipse 提供 数据库浏览器连接到我们的mysql数据库<br><img src="/images/imgs3/6.gif" alt="Alt text"></p>
<p>然后点击右键，选择new，出现如下界面<br><img src="/images/imgs3/7.gif" alt="Alt text"></p>
<p>首先选择数据库，然后填写相关配置信息，其中Driver name随便取，添加jar包，然后点击test Driver，如股票成功，则表示与数据库连接成功，此外，可以选择保存密码，不然，后续操作一次，就要输入密码<br>直接点击finish，</p>
<p>接下来在MyEclipse中创建一个web工程，通过工具自身引入hibernate，具体步骤如下<br><img src="/images/imgs3/8.gif" alt="Alt text"></p>
<p><img src="/images/imgs3/9.gif" alt="Alt text"></p>
<p>选择之前配置好的sshe</p>
<p><img src="/images/imgs3/10.gif" alt="Alt text"></p>
<p>直接点结束，这样hibernate就引入了。</p>
<p>下面我们使用myeclipse提供的逆向工程，自动的创建对象类和对象关系映射文件<br>选中要反向的表<br><img src="/images/imgs3/11.gif" alt="Alt text"></p>
<p>注意我们可以事先在项目中新建一个包，用来存放映射对象和文件<br><img src="/images/imgs3/12.gif" alt="Alt text"></p>
<p>最后点击finish，则自动生成了。<br><img src="/images/imgs3/13.gif" alt="Alt text"></p>
<p>最后值得注意的是，这里只是模拟了三张表，有一对多和多对一关系，主外键及级联，这样就省得我们自己去配置了，因为hibernate的关系配置真的很麻烦！！</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hibernate之三:浅谈HQL和映射文件]]></title>
      <url>http://www.myzwl.win/2017/04/03/hbm3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们想要精确的查找某一个数据库中的信息时，最理想的方法就是通过sql语句查询，一般hibernate中可以通过query接口来写语句进行查询，这个语句可以使sql，hql，当然推荐的是hql，事实上我认为hql和sql基本差不多</p>
<p>一：Query接口<br>    Query接口类型的对象可以对数据库操作,它可以使用Hql和原生SQL(native Sql)对数据库操作.官方推荐使用Hql语句<br>先来看一个例子</p>
<p>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">	public void selectone()&#123;</div><div class="line">	User u=(User)session.createQuery(" from User where id=1").uniqueResult();</div><div class="line">	System.out.println(u.getName());&#125;</div></pre></td></tr></table></figure></p>
<p>分析：这里用了uniqueResult()方法 ，如果我们检索一个对象，明确知道最多只有一个对象，则建议使用该方法:</p>
<p>如果是取出集合对象，则使用如下方法：<br>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void selectone()&#123;		</div><div class="line">List&lt;User&gt; list=session.createQuery("from User").list();</div><div class="line">     for(User user : list)&#123;</div><div class="line">	System.out.println(user.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此我们可以发现，使用list可以取出集合对象，同时方法里面写想要的hql语句</p>
<p>二：HQL简单语法<br>  HQL是面向对象的查询语言，与SQL不同，HQL中的对象名是区分大小写的；HQL中查的是对象而不是表，并且支持多态；HQL主要通过Query来操作，Query的创建方式：</p>
<blockquote>
<p>Query q = session.createQuery(hql);</p>
</blockquote>
<p>1：between.. and..<br>  测试代码：</p>
<blockquote>
<p>List<user> list=session.createQuery(“from User where id between 0 and 2”).list();</user></p>
</blockquote>
<p>2：in /not in</p>
<blockquote>
<p>List<user> list=session.createQuery(“from User where id in (1,2)”).list();</user></p>
</blockquote>
<p>其他如group by，having，聚集函数等都类似于sql语句，换汤不换药。</p>
<p>参数绑定：<br> 先看例子：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">org.hibernate.Query query= session.createQuery("from User where id between ? and ?");</div><div class="line">	      query.setInteger(0, 1);</div><div class="line">	      query.setInteger(1,2);</div><div class="line">	      List&lt;User&gt; list=query.list();</div><div class="line">	      for(User user : list)&#123;</div><div class="line">	  		System.out.println(user.getName());</div><div class="line">	  	&#125;</div></pre></td></tr></table></figure>
<p>主要通过set与？的形式来注入参数，注意这里第一个？对应set的序号为0<br>使用绑定参数的好处:<br>1.可读性好.<br>2.性能提高.<br>3.防止sql注入</p>
<p>HQL语句远不止这些，这里只简单介绍了其中一些，</p>
<p>三：映射文件的配置<br> 映射文件的内容繁多，这里只简单介绍其中一些常见属性。大体说来，映射文件主要对class的映射，还包括属性，属性又分为主键，普通属性和集合属性，甚至还有复合属性，每种属性都需要进行不同的配置。</p>
<p> 先从入门程序中的例子说起：</p>
<blockquote>
<p> <hibernate-mapping package="com.zwl.bean"></hibernate-mapping></p>
<class name="User" table="user">

</class></blockquote>
<p>其中：package : 表示该类在哪个包下，name : 表示类名 table 表示 该类和哪个表映射<br>同时在class内部可以配置各种属性</p>
<p>主键：<br> 主键就是持久化类中标识属性，用于唯一标识该对象，主要通过<id>进行设置，有三个常用属性：name，column，type。<br>  Name  ：表示类的哪个属性是主键   必须指定<br>Column：指定在数据库中主键对应的列明  不必须指定<br>  Type：与数据库中对应字段类型一致  不必须指定<br>例外：主键需指定主键生产策略，即generator，一般用于自增长，针对不同数据库，关键词不一样，由于是mysql，所以自增长选择increment<br>以上的代码表示：</id></p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;id name=<span class="string">"id"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;generator class=<span class="string">"increment"</span>&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div></pre></td></tr></table></figure>
<p>普通属性：<br>  使用<property>标签，该标签必须指定name属性，用于标记持久化类的属性名称。一般有如下常见属性：<br> Type，column，not-null（是否允许为空），lazy（是否支持延迟加载，默认为false不支持），<br>代码如下：</property></p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"name"</span> type=<span class="string">"java.lang.String"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"name"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"age"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"age"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hibernate之二:核心类和接口]]></title>
      <url>http://www.myzwl.win/2017/04/02/hbm2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们对数据进行持久化操作时，必然涉及到hibernate的一些核心类，而这些类是我们在增删改查之前必然要引用和加载的<br>先看总览图：<br><img src="/images/imgs2/26.gif" alt="Alt text"></p>
<p>一般情况下，是由下向上看。</p>
<p>一 ：hibernate.cfg.xml文件<br>①该文件主要用于指定各个参数,是hibernate核心文件<br>    ②默认放在src目录下，也可以放在别的目录下。<br>    ③指定连接数据库的驱动、用户名、密码、url、连接池..<br>    ④指定对象关系映射文件的位置.<br>    ⑤也可使用hibernate.properties文件来替代该文件.(推荐使用<br>hibernate.cfg.xml)。<br>  如：入门程序代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;hibernate-configuration&gt;</div><div class="line">	&lt;session-factory&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.driver_class"</span>&gt;com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span>&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.url"</span>&gt;jdbc:mysql:<span class="comment">//localhost:9806/sshe&lt;/property&gt;</span></div><div class="line">		&lt;property name=<span class="string">"connection.username"</span>&gt;root&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.password"</span>&gt;&lt;/property&gt;</div><div class="line">		&lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt;</div><div class="line">		&lt;property name=<span class="string">"show_sql"</span>&gt;true&lt;/property&gt;</div><div class="line">		&lt;!-- 配置数据库的方言/ --&gt;</div><div class="line">		&lt;property name=<span class="string">"dialect"</span>&gt;org<span class="selector-class">.hibernate</span><span class="selector-class">.dialect</span><span class="selector-class">.MySQL5InnoDBDialect</span>&lt;/property&gt;</div><div class="line">		 &lt;!-- 配置管理的对象映射文件 --&gt;</div><div class="line">		&lt;mapping resource=<span class="string">"com/zwl/bean/User.hbm.xml"</span>/&gt;</div><div class="line">	&lt;/session-factory&gt;</div><div class="line">&lt;/hibernate-configuration&gt;</div></pre></td></tr></table></figure></p>
<p>二：对象关系映射文件(*.hbm.xml)</p>
<p>  ①该文件主要作用是建立表和类的映射关系，是不可或缺的重要文件.<br>  ②一般放在其映射的类同一个目录下,但不是必须的。<br>  ③命名方式一般是 类名.hbm.xml,但不是必须的。<br>  ④示意图:<br><img src="/images/imgs2/27.gif" alt="Alt text"></p>
<p>如：入门程序代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;!-- package : 表示该类在哪个包下 --&gt;</div><div class="line">&lt;hibernate-mapping package=<span class="string">"com.zwl.bean"</span>&gt;</div><div class="line">&lt;!-- name : 表示类名 <span class="selector-tag">table</span> 表示 该类和哪个表映射 --&gt;</div><div class="line">	&lt;class name=<span class="string">"User"</span> table=<span class="string">"user"</span>&gt;</div><div class="line">		&lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt;</div><div class="line">		&lt;!-- name:表示类的哪个属性是主键 --&gt;</div><div class="line">		&lt;id name=<span class="string">"id"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;!-- 指定主键生成策略 --&gt;</div><div class="line">		&lt;generator class=<span class="string">"increment"</span>&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div><div class="line">		&lt;!-- property 里是普通属性 , column表示该属性映射到表中哪个字段 --&gt;</div><div class="line">		&lt;property name=<span class="string">"name"</span> type=<span class="string">"java.lang.String"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"name"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"age"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"age"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>三：Configuration 类<br>它的用处是:</p>
<ol>
<li>读取hibernate.cfg.xml</li>
<li>管理对象关系映射文件 <mapping resource="””"></mapping></li>
<li>加载hibernate 的驱动,url ,用户..</li>
<li>管理hibernate配置信息</li>
</ol>
<p>创建的代码：</p>
<blockquote>
<p>Configuration cf=new Configuration().configure();</p>
</blockquote>
<p>四：SessionFactory （会话工厂）<br>这是典型的工厂设计模式，其是用来生产session实例的，注意由于该工厂启动耗费内存，所以应该只被初始化一次，并且应该是线程安全的，所以应该用单例模式设计</p>
<p>归纳一下特点：<br>1 缓存sql语句和某些数据</p>
<p>2.在应用程序初始化的时候创建,是一个重量级的类(吃内存),一般<br>用单例模式保证一个应用中只需要一个 SessionFactory实例.</p>
<p>3.如果某个应用访问多个数据库，则要创建多个会话工厂实例,一般<br>是一个数据库一个会话工厂实例.</p>
<p>4.通过SessionFactory接口可以获得Session(会话)实例</p>
<p>创建的代码：</p>
<blockquote>
<p>SessionFactory sf=cf.buildSessionFactory();</p>
</blockquote>
<p>五：Session<br> 1.Session一个实例代表与数据库的一次操作<br>(当然一次操作可以是crud组合)</p>
<p> 2.Session实例通过SessionFactory获取，用完<br>需要关闭。</p>
<p> 3.Session是线程不同步的(不安全),因此要保证<br>在同一线程中使用,可以用getCurrentSessiong()。</p>
<p> 4.Session可以看做是持久化管理器,它是与持久<br>化操作相关的接口</p>
<p>如图所示：<br><img src="/images/imgs2/28.gif" alt="Alt text"></p>
<p>另外：有两种方式获得session<br>1：通过openSession()获取session<br>openSession() 是获取一个新的session<br>2 getCurrentSession ()<br>  getCurrentSession () 获取和当前线程绑定的session,换言之，在同一个线程中，我们获取的session是同一session,这样可以利于事务控制</p>
<p>创建的代码：</p>
<blockquote>
<p>Session s=sf.getCurrentSession();<br>//或者是: Session s=sf.openSession();</p>
</blockquote>
<p>如何选择<br>原则:<br>1.如果需要在同一线程中，保证使用同一个Session则，使用getCurrentSession()<br>2.如果在一个线程中，需要使用不同的Session,则使用opentSession()<br>通过 getCurrentSession() 获取的session在事务提交后，会自动关闭，通过openSession()获取的session则必须手动关闭<br>如果是通过getCurrentSession() 获取 sesssion ,进行查询需要事务提交</p>
<p>Session(会话)接口的几个重要方法<br>Session一般以对象的形式来操作<br>    1保存一个对象(记录)—save方法<br>    2删除一个对象(记录)—delete方法<br>    3查询一个对象(记录)—get/load方法<br>    4修改一个对象(记录)—update方法</p>
<p>如：入门程序中的代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Sava方法：User u=new User();</div><div class="line">	   u.setId(1);</div><div class="line">	  u.setName("hello world");</div><div class="line">	  u.setAge(21);</div><div class="line">	 session.save(u);</div><div class="line">	 t.commit();</div><div class="line"></div><div class="line"></div><div class="line">Delete方法：User u=(User)session.get(User.class, 1);</div><div class="line">		    session.delete(u);</div><div class="line">		    t.commit();</div></pre></td></tr></table></figure>
<p>一般情况下，我们从数据库中获取对象，可以通过session.get（或者session.load（）），那么他们有什么区别了？<br>1、get()方法直接返回实体类,如果查不到数据则返回null。load()会<br>    返回一个实体代理对象（当前这个对象可以自动转化为实体对象），<br>    但当代理对象被调用时，如果没有数据不存在，就会抛出个<br>    org.hibernate.ObjectNotFoundException异常</p>
<p>这里：可以将get看做单例中的饿汉式，而load相当于懒汉式</p>
<ol>
<li><p>load先到缓存(session缓存/二级缓存)中去查，如果没有则返回一个<br>代理对象（不马上到DB中去找），等后面使用这个代理对象操作的时<br>候，才到DB中查询,这就是我们常说的 load在默认情况下支持延迟加<br>载（lazy）</p>
</li>
<li><p>get先到缓存(session缓存/二级缓存)中去查，如果没有就到DB中去<br> 查（即马上发出sql）。总之，如果你确定DB中有这个对象就用<br> load(),不确定就用get()（这样效率高）</p>
</li>
</ol>
<p>这里有一点注意：默认lazy加载时不启用，所以如果要启用，则需要在映射文件中配置</p>
<blockquote>
 <class name="User" table="user" lazy="true">

</class></blockquote>
<p>六：Transaction(事务)接口<br>    事务简单的说,就是一组对数据库的操作集合,它们要么全部成功,要<br>么全部失败.这个可以保证数据的一致性,事务具有原子性。</p>
<p>创建的代码：</p>
<blockquote>
<p>Transaction ts=s.beginTransaction();<br> …<br>ts.commit();s.close()； </p>
</blockquote>
<p>注意：如果数据库的数据发生变化，一定需要数据提交</p>
<p>七：Criteria接口<br>如入门程序的查询：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;User&gt; list=session.createCriteria(User.class).list();</div><div class="line">		for(User user : list)&#123;</div><div class="line">			System.out.println(user.getName());</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>即通过面向对象的操作，返回该对象所有的集合</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hibernate之一:hello world]]></title>
      <url>http://www.myzwl.win/2017/04/01/hbm1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对一个框架的直观认识，往往是从一个hello world程序开始的。Hibernate是一个完全的ORM（Object Relationship Mapping）对象映射框架。实现了JDBC轻量级的封装，使得在进行JDBC开发的时候可以直接使用面向对象的思维进行开发，说白了hibernate框架的作业就是在java对象和关系数据库中作了一个映射，使得程序员不用再使用各种SQL语句</p>
<p>Hibernate有如下几个特点：<br>  1：完成了对JDBC的封装，不用再与各种connection打交道<br> 2：是一个持久层框架，即对数据库进行持久化操作<br> 3：是一个ORM框架，不用再与各种sql打交道</p>
<p>接下里就是hibernate入门程序，目的先有一个直观认识，不考虑其含义，只要把流程走一遍就完成了目的。这里用最简的方式完成入门程序</p>
<p>步骤一：创建一个java 工程</p>
<p>步骤二：建一个lib文件夹，并导入如下jar包，然后添加至项目中<br><img src="/images/imgs2/25.gif" alt="Alt text"></p>
<p>步骤三：在src目录下创建一个hibernate.cfg.xml配置文件，并编写，同时添加mysql驱动包<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</div><div class="line">	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</div><div class="line">	"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;</div><div class="line">&lt;!-- 该文件用于配置连接数据的种类,用户名，密码,ul ,驱动.. 连接池,二级缓存 --&gt;</div><div class="line">&lt;hibernate-configuration&gt;</div><div class="line">	&lt;session-factory&gt;</div><div class="line">		&lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;</div><div class="line">		&lt;property name="connection.url"&gt;jdbc:mysql://localhost:9806/sshe&lt;/property&gt;</div><div class="line">		&lt;property name="connection.username"&gt;root&lt;/property&gt;</div><div class="line">		&lt;property name="connection.password"&gt;yourpassword&lt;/property&gt;</div><div class="line">		&lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt;</div><div class="line">		&lt;property name="show_sql"&gt;true&lt;/property&gt;</div><div class="line">		&lt;!-- 配置数据库的方言/ --&gt;</div><div class="line">		&lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;</div><div class="line">	&lt;/session-factory&gt;</div><div class="line">&lt;/hibernate-configuration&gt;</div></pre></td></tr></table></figure></p>
<p>简单说明一下：上面的配置文件指明了一些必要的数据库连接属性，通过这些属性，hibernate可以连接上数据库，可以配置不同的数据库，其中配置数据库的方言指明所配置的是用哪种数据库</p>
<p>步骤四：创建bean对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.zwl.bean;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line"></div><div class="line">	private int age;</div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">。。。此处省略set与get方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里注意：利用hibernate框架时，鼓励我们为每张表设置主键，即为每个对象设置一个id，在映射时与表的id对应</p>
<p>步骤五：创建数据库表，这个步骤也可以在步骤四之前进行。<br>主要为id（主键，自增长），name、age</p>
<p>步骤六：编写表与对象的映射文件User.hbm.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!--该文件要清楚地表述出 类 和 表 的对应关系--&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</div><div class="line">	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">	"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line">&lt;!-- package : 表示该类在哪个包下 --&gt;</div><div class="line">&lt;hibernate-mapping package="com.zwl.bean"&gt;</div><div class="line">&lt;!-- name : 表示类名 table 表示 该类和哪个表映射 --&gt;</div><div class="line">	&lt;class name="User" table="user"&gt;</div><div class="line">		&lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt;</div><div class="line">		&lt;!-- name:表示类的哪个属性是主键 --&gt;</div><div class="line">		&lt;id name="id" type="java.lang.Integer"&gt;</div><div class="line">		&lt;!-- 指定主键生成策略 --&gt;</div><div class="line">		&lt;generator class="increment"&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div><div class="line">		&lt;!-- property 里是普通属性 , column表示该属性映射到表中哪个字段 --&gt;</div><div class="line">		&lt;property name="name" type="java.lang.String"&gt;</div><div class="line">		&lt;column name="name" not-null="false"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="age" type="java.lang.Integer"&gt;</div><div class="line">		&lt;column name="age" not-null="false"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>简单说明一下：上面已经简要说明了一些含义，这里先看做强加的概念，事实上这是比较完整的配置，当然这里并没有给出简化的配置。同时，该文件相当于在java对象和数据库表中作了一个映射，这样以后就可以通过操作java对象来间接操作表<br> 另外，该映射文件一般放在与相应的java对象同处一个文件夹下，并且命名满足规范XXX.hbm.xml，其中xxx就是java对象名，最后还要在hibernate核心配置文件中声明该映射，即加入如下代码：</p>
<blockquote>
 <mapping resource="com/zwl/bean/User.hbm.xml">

</mapping></blockquote>
<p> 步骤六：就是进行测试，实现插入数据的crud操作</p>
<p> 首先写一个工具类：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utils;</div><div class="line"></div><div class="line">import org.hibernate.SessionFactory;</div><div class="line">import org.hibernate.cfg.Configuration;</div><div class="line"></div><div class="line">public class HibernateUtils &#123;</div><div class="line">    private static final SessionFactory sessionFactory=BuildSessionFactory();</div><div class="line">    </div><div class="line">    private static SessionFactory BuildSessionFactory()&#123;</div><div class="line">    	try &#123;</div><div class="line">			return new Configuration().configure().buildSessionFactory();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			throw new ExceptionInInitializerError(e);</div><div class="line">		&#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	public static SessionFactory getSessionFactory()&#123;</div><div class="line">		return sessionFactory;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单说明一下，这里采用单例模式，目的是为了不要每次都加载配置，不然太耗费内存</p>
<p>接下来是测试类，首先是增加功能<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Usertest &#123;</div><div class="line"></div><div class="line">	SessionFactory sessionFactory=HibernateUtils.getSessionFactory();</div><div class="line">	Session session=sessionFactory.openSession();</div><div class="line">	Transaction t=session.beginTransaction();</div><div class="line"></div><div class="line">@Test</div><div class="line">public void save()&#123;</div><div class="line">	User u=new User();</div><div class="line">	u.setId(1);</div><div class="line">	u.setName("hello world");</div><div class="line">	u.setAge(21);</div><div class="line">	</div><div class="line">	session.save(u);</div><div class="line">	t.commit();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来是查询（遍历）<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//查询</div><div class="line">	@Test</div><div class="line">	public void select()&#123;</div><div class="line">		List&lt;User&gt; list=session.createCriteria(User.class).list();</div><div class="line">		for(User user : list)&#123;</div><div class="line">			System.out.println(user.getName());</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>最后是删除：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//删除</div><div class="line">	@Test</div><div class="line">	public void delete()&#123;</div><div class="line">		User u=(User)session.get(User.class, 1);</div><div class="line">		session.delete(u);</div><div class="line">		t.commit();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>修改这里就先不说了。<br>至此入门程序完成，意在了解hibernate的具体过程，有没有发现，到目前为止，我们都没有写sql语句，而都是对java对象进行操作，来操作表</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之六:拦截器]]></title>
      <url>http://www.myzwl.win/2017/03/31/structs6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拦截器是structs2框架的核心功能，理解并使用拦截器有助于更灵活使用structs2.它像一个可插播的组件，围绕action和result进行，可以在方法调用之前、之后使用。通过structs2的工作流程，可以发现调用一个action之前之后有许多的拦截器，这些拦截器都通过后才可以执行具体的action。对与每一个拦截器来说，可以直接返回，从而终止余下的拦截器</p>
<p>以下，是structs工作原理图<br><img src="/images/imgs2/24.gif" alt="Alt text"></p>
<p>从图中可以看出，从一个具体的请求到action需要经过多个拦截器，action处理完成后，后续的拦截器会据需执行，最终到浏览器中。大概其工作流程如下</p>
<p>上述的servlet filters图示与实际有点不一样，其他一样（图不是现在版本）</p>
<p>一 首先请求发送给StrutsPrepareAndExecuteFilter（web.xml配置那个）</p>
<p>二：StrutsPrepareAndExecuteFilter判断该请求是否是一个structs2请求，如果是则进入第3步</p>
<p>三：如果是structs2请求，则把请求交给ActionProxy，是action代理类，ActionProxy创建一个Actioninvocation实例，并进行初始化</p>
<p>在执行具体的action之前，actionProxy会设计相关拦截器的调用<br>Action调用结束后，会根据structs.xml文件中action的result配置对象得到对应的返回结果。调用execute方法之后，执行后面的拦截器，把结果返回给浏览器</p>
<p>从整个请求处理过程来看，拦截器是处理的关键</p>
<p>下面将通过实现Interceptor接口来写一个简单的拦截器，<br>该接口有三个方法，init（），destroy（），intercept（），init（）在拦截器实例创建之后，intercept方法之前调用，主要用于初始化拦截器所需要的资源，destroy主要销毁初始化分配的资源，intercept方法则是在action之前调用，可以通过invocation对象获取action状态，从而根据状态的不同进行需要的拦截操作<br> 如下为一个简单的模拟案例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import com.opensymphony.xwork2.ActionInvocation;</div><div class="line">import com.opensymphony.xwork2.interceptor.Interceptor;</div><div class="line"></div><div class="line">public class lanji implements Interceptor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void destroy() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void init() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String intercept(ActionInvocation invocation) throws Exception &#123;</div><div class="line">		long start=System.currentTimeMillis();</div><div class="line">		String result=invocation.invoke();//没有拦截，正常执行</div><div class="line">		long end=System.currentTimeMillis();</div><div class="line">		System.out.println(end-start);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就需要在配置文件中配置<br>首先申明该拦截器<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;interceptors&gt;</div><div class="line">		&lt;interceptor name=<span class="string">"lanji"</span> class=<span class="string">"com.zwl.pojo.lanji"</span>&gt;&lt;/interceptor&gt;</div><div class="line">		&lt;/interceptors&gt;</div><div class="line">在action中引用</div><div class="line">&lt;action name=<span class="string">"ognlaction"</span> class=<span class="string">"com.zwl.action.ognlaction"</span>&gt;</div><div class="line">  &lt;interceptor-ref name=<span class="string">"lanji"</span>&gt;&lt;/interceptor-ref&gt;</div><div class="line">			 &lt;interceptor-ref name=<span class="string">"defaultStack"</span>&gt;&lt;/interceptor-ref&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>注意必须要带上默认拦截器</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之五:通用标签]]></title>
      <url>http://www.myzwl.win/2017/03/30/structs5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> Struts2框架为我们提供了许多标签，这些标签从总体上可以分为两类：通用标签和ui标签。而较常使用的是通用标签，通用标签又分为两类，数据标签和控制标签。数据标签用于访问值栈中的数据。控制标签用于控制呈现页面时数据执行流程。</p>
<p> 不过使用structs2标签，需要在jsp首部加入如下代码</p>
<blockquote>
<p> &lt;%@ taglib uri=”/struts-tags” prefix=”s” %&gt;</p>
</blockquote>
<p>数据标签<br> 主要用于访问actioncontext和值栈中的数据</p>
<p>一：property标签</p>
<blockquote>
<p>格式：<s:property value="””default=””" escape="”true|false”/"></s:property></p>
</blockquote>
<p>如果value中的内容为object，则Struts2都会把它解析成ognl表达式<br>     如果里面需要表示为字符串，则需要将内容用单引号括起来</p>
<p>1、  利用ognl表达式取值(例如：取值堆栈中的username值)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"username"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>2、  取值为字符串<br>需要将内容用单引号括起来<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"’username’"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>3、  设置默认值-default<br>如果一个对象值取不到，则可以使用default设置一个默认值。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"admin"</span> default=”管理员”/&gt;</div></pre></td></tr></table></figure></p>
<p>4、  设定HTML-escape<br>是否设置返回值为HTML原代码样式<br>true：解析返回值的html代码　false:原封不动返回值<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"'&lt;hr/&gt;'"</span> escape=<span class="string">"false"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>二、 set标签<br>注：var　用于设定变量名<br>     value 变量值(可以是ognl表达式)，也可以是字符串<br>         scope 就是的作用范围 request session page application action(默认)</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;li&gt;set 设定adminName值（默认为request 和 ActionContext）: &lt;s:set var=<span class="string">"adminName"</span>value=<span class="string">"username"</span> /&gt;&lt;/li&gt;</div><div class="line">      </div><div class="line">&lt;li&gt;set 从request取值: &lt;s:property value=<span class="string">"#request.adminName"</span> /&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;set 从ActionContext取值: &lt;s:property value=<span class="string">"#adminName"</span> /&gt;&lt;/li&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;li&gt;set 设定var，范围为ActionContext: &lt;s:set var=<span class="string">"adminPassword"</span> value=<span class="string">"password"</span>scope=<span class="string">"session"</span>/&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;set 使用#取值: &lt;s:property value=<span class="string">"#adminPassword"</span>/&gt; &lt;/li&gt;</div><div class="line">&lt;li&gt;set 从相应范围取值: &lt;s:property value=<span class="string">"#session.adminPassword"</span>/&gt; &lt;/li&gt;</div></pre></td></tr></table></figure>
<p>控制标签<br> 一： If  elseif  else<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">age = &lt;s:property value=<span class="string">"#parameters.age[0]"</span> /&gt; &lt;br /&gt;</div><div class="line">     &lt;s:set var=<span class="string">"age"</span> value=<span class="string">"#parameters.age[0]"</span> /&gt;</div><div class="line">     &lt;s:<span class="keyword">if</span> test=<span class="string">"#age &lt; 0"</span>&gt;wrong age!&lt;/s:<span class="keyword">if</span>&gt;</div><div class="line">     &lt;s:elseif test=<span class="string">"#parameters.age[0] &lt; 20"</span>&gt;too young!&lt;/s:elseif&gt;</div><div class="line">     &lt;s:<span class="keyword">else</span>&gt;yeah!&lt;/s:<span class="keyword">else</span>&gt;&lt;br /&gt;</div></pre></td></tr></table></figure></p>
<p>二：Iterator标签<br>一般格式如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> &lt;s:iterator value=<span class="string">"值"</span> var=<span class="string">"x"</span>&gt;</div><div class="line">&lt;s:property value=<span class="string">"#x.username"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>这个格式将集合里的内容取出<br>该属性一般有三个属性，id，status，value<br>其中value属性指定迭代的集合，status属性可以获得迭代中一个状态信息（比如索引值，是否是奇偶数等）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;s:iterator value="&#123;'aaa', 'bbb', 'ccc'&#125;" status="status"&gt;</div><div class="line">          &lt;s:property/&gt; |</div><div class="line">          遍历过的元素总数：&lt;s:property value="#status.count"/&gt; |</div><div class="line">          遍历过的元素索引：&lt;s:property value="#status.index"/&gt; |</div><div class="line">          当前是偶数？：&lt;s:property value="#status.even"/&gt; |</div><div class="line">          当前是奇数？：&lt;s:property value="#status.odd"/&gt; |</div><div class="line">          是第一个元素吗？：&lt;s:property value="#status.first"/&gt; |</div><div class="line">          是最后一个元素吗？：&lt;s:property value="#status.last"/&gt;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之四:OGNL表达式]]></title>
      <url>http://www.myzwl.win/2017/03/29/structs4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OGNL表达式的全称是 Object Graph Navigation Language，即 对象图导航语言，使用OGNL表达式可以使用简单的语法设置以及读取java对象的值</p>
<p>一般， <s:property value="””">　注意：  value里的内容称为ognl表达式，由于其功能强大，涉及东西太多，只做部分总结</s:property></p>
<p>下面就先模拟一个案例，首先需要几个模拟的对象类<br>首先是Dog类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private String name;</div><div class="line">   </div><div class="line">	public Dog(String name)&#123;</div><div class="line">		this.name=name;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Dog()&#123;&#125;</div><div class="line">此处省略set。。get方法</div></pre></td></tr></table></figure></p>
<p>然后是Cat类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private Dog friend;</div><div class="line">	</div><div class="line">	public String miaomiao()</div><div class="line">	&#123;</div><div class="line">		return "miaomiao";</div><div class="line">	&#125;</div><div class="line">此处省略set。。get方法</div></pre></td></tr></table></figure></p>
<p>接着是user类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private String msg;</div><div class="line"></div><div class="line">public user()&#123;&#125;</div><div class="line"></div><div class="line">public user(String msg)&#123;</div><div class="line">	this.msg=msg;</div><div class="line">&#125;</div><div class="line">此处省略set。。get方法</div></pre></td></tr></table></figure></p>
<p>在配置文件中，仍然不变</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">  &lt;global-results&gt;</div><div class="line">  &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">  &lt;/global-results&gt;</div><div class="line">  </div><div class="line">  &lt;action name=<span class="string">"ognlaction"</span> class=<span class="string">"com.zwl.action.ognlaction"</span>&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure>
<p>下面是action，思路是在action中一点一点加入模拟代码，在相应的jsp中将值回显出来<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class ognlaction extends ActionSupport&#123;</div><div class="line">  private String username;</div><div class="line">	public String execute() throws Exception &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return super.execute();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下面所以属性的set与get方法都将省略。。<br>首先是验证普通属性，对应jsp页面为</p>
<p>1：<li>访问值栈中的action的普通属性:</li></p>
<blockquote>
<p>username = <s:property value="username"> </s:property></p>
</blockquote>
<p>2：访问值栈中对象的普通属性(get set方法)：</p>
<blockquote>
<p>首先action增加 private user use;<br>对应jsp为：<s:property value="use.msg"></s:property></p>
</blockquote>
<p>3访问值栈中对象中的成员对象的普通属性(get set方法)</p>
<blockquote>
<p>首先action增加：private Cat cat;<br>对应jsp为：<s:property value="cat.friend.name"></s:property></p>
</blockquote>
<p>4访问值栈中对象的普通方法<br><s:property value="cat.miaomiao()"></s:property></p>
<p>5访问值栈中action的普通方法<br>首先action增加：public String m() {<br>             return “hello”;}<br>对应jsp为：<s:property value="m()"></s:property></p>
<p>6 OGNL表达式语言访问静态方法，需要在Struts2.xml配置文件如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;constant name=<span class="string">"struts.ognl.allowStaticMethodAccess"</span> value=<span class="string">"true"</span>&gt;&lt;/constant&gt;</div></pre></td></tr></table></figure>
<p>首先增加一个pojo类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class s &#123;</div><div class="line">	 public static String STR = "STATIC STRING";  </div><div class="line">	  public static String s() &#123;</div><div class="line">	     return "static method";  &#125;&#125;</div></pre></td></tr></table></figure>
<p>对应jsp：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;li&gt;访问静态方法：&lt;s:property value=<span class="string">"@com.zwl.pojo.s@s()"</span>/&gt;&lt;/li&gt;</div><div class="line">       &lt;li&gt;访问静态属性：&lt;s:property value=<span class="string">"@com.zwl.pojo.s@STR"</span>/&gt;&lt;/li&gt;</div><div class="line">       &lt;li&gt;访问Math类的静态方法：&lt;s:property value=<span class="string">"@@max(2,3)"</span> /&gt;&lt;/li&gt;</div></pre></td></tr></table></figure></p>
<p>注意使用@符号访问</p>
<p>7访问List中元素某个属性的集合中的特定值：<br>首先action增加<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private List&lt;user&gt; users=new ArrayList&lt;&gt;();</div><div class="line">public ognlaction()&#123;</div><div class="line">		users.add(new user("1"));</div><div class="line">		users.add(new user("2"));</div><div class="line">		users.add(new user("3"));</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>对应jsp为：<s:property value="users[0].msg"></s:property></p>
<p>8：访问Set中某个元素<br>首先action增加：</p>
<blockquote>
<p>private Set<dog> dogs = new HashSet<dog>();</dog></dog></p>
</blockquote>
<p>对应jsp为：<s:property value="dogs[1]"></s:property></p>
<p>9：访问Map中某个元素<br>首先action增加：</p>
<blockquote>
<p>private Map<string, dog=""> dogMap = new HashMap<string, dog="">();<br>  <li>访问Map中某个元素:<s:property value="dogMap['dog101']"></s:property></li><br>               <li>访问Map中所有的key:<s:property value="dogMap.keys"></s:property></li><br>       <li>访问Map中所有的value:<s:property value="dogMap.values"></s:property></li></string,></string,></p>
</blockquote>
<p>  10：调试：   <s:debug></s:debug><br>主要用来查看值栈。而值栈主要来存放对象的，类似于正常的栈，</p>
<p>以下为部分结果截图：<br><img src="/images/imgs2/23.gif" alt="Alt text"></p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之三:result返回结果]]></title>
      <url>http://www.myzwl.win/2017/03/28/structs3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Structs2中的result是作为返回结果的，当一个action处理完之后返回字符串的结果码。框架可以根据这个返回的字符串，映射到指定的页面。Result元素可以分为两部分：一是结果映射，一部分是返回结果类型</p>
<p>结果映射<br>  Result有两个属性可以配置：name属性和type属性，其中name属性主要用来指定资源的逻辑名称，实际名称在标签内指定。Type属性就是result返回的类型，这两个属性不是必须的。其中默认情况下，name为success，type为dispatch（转发）<br>另外，result标签还有一个子标签param，该标签可以为result指定实际资源位置，其中属性name为必填，而当type为dispatch时，param可以省略不写</p>
<p>针对上面，不妨先模拟一个案例<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;result type=<span class="string">"dispatcher"</span>&gt;</div><div class="line">&lt;param name=<span class="string">"location"</span>&gt;/success.jsp&lt;/param&gt;</div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>这里的location是用于指示资源的位置，标签内的内容是参数的值</p>
<p>对应我们习惯写的形式为<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;result name=<span class="string">"success"</span>&gt;</div><div class="line">/success<span class="selector-class">.jsp</span></div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>结果类型：<br> 常用的有四种，dispatch、redirect、redirectAction和chain，其中dispatch相当于转发，redirect相当于重定向，redirectAction也是重定向，但是它是重定向到某个action，而chain则是利用action的链式处理</p>
<p>第一种：dispatch<br> 它是系统默认的结果类型，其有两个属性，localtion和parse，配置如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> &lt;result type=<span class="string">"dispatcher"</span>&gt;</div><div class="line">&lt;param name=<span class="string">"location"</span>&gt;/success.jsp&lt;/param&gt;</div><div class="line">&lt;param name=<span class="string">"parse"</span>&gt;true&lt;/param&gt;</div><div class="line">  &lt;/result&gt;</div></pre></td></tr></table></figure></p>
<p>其中parse是一个布尔类型，当为true时，表示解析localtion参数中的OGNL表达式，默认是true</p>
<p>第二种：redirect<br>  当使用该类型时，框架后台会使用response对象的sendRedirect方法进行重定向，下面先简单对比一下重定向与转发的区别：<br>一：重定向会发生两次请求，转发只会发生一次请求<br>      重定向的时候，浏览器的地址栏会发生变化，而转发的地址栏是无变化的<br>      重定向的实质是服务器告诉浏览器去另外的地方寻找资源，所以地址栏会发生变化，而转发则是在服务器内部发生的，所以地址栏不会发生变化<br>      由于重定向是两次请求，所以第二次请求的会话保存的信息是无效的，而转发的时候会话仍然有效，因为请求不变<br>      对于重定向中会话仍然有效的方法是在配置文件中使用OGNL表达式，将参数传递过去<br>对于以上内容，不妨一个实例来的具体点</p>
<p>首先是上面的dispatch<br>如之前的hello world入门程序，最终观察地址栏和参数是可以接收到的</p>
<p>当type为redirect时<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;result type=<span class="string">"redirect"</span>&gt;</div><div class="line">/success<span class="selector-class">.jsp</span></div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>观察地址栏是显示jsp的，但是参数是无法接收到的<br>那么如何解决了？<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;action name="helloworld" class="com.zwl.action.helloworld"&gt;</div><div class="line">  &lt;result name="success" type="redirect"&gt;</div><div class="line">/success.jsp?user=$&#123;use.msg&#125;</div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>即带一个参数，注意此时的话，在success.jsp中值就不在值栈中了，因为不经过action，所以应该用如下方法取出<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;s:property value=<span class="string">"#parameters.user"</span>/&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>第三种：redirectAction，<br>其底层都是通过Response对象的sendRedirect方法进行重定向的，只不过它是重定向到某个action，所以如果一个action处理完之后还要交给另一个action据需处理，则使用该类型。<br>它的结果类型有两个参数，actionName（指定需要重定向的action）和namespace（指定action所在的命名空间，如果没有指定该参数，框架会从默认的namespace中去寻找）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">   &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">   &lt;result type=<span class="string">"redirectAction"</span>&gt;</div><div class="line">   &lt;param name=<span class="string">"actionName"</span>&gt;helloworld1&lt;/param&gt;</div><div class="line">   &lt;param name=<span class="string">"namespace"</span>&gt;/&lt;/param&gt;</div><div class="line">   &lt;/result&gt;</div><div class="line">   &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>第四种：chain<br>一样，也是跳转到某个action<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"r3"</span>&gt;</div><div class="line">        &lt;result type=<span class="string">"chain"</span>&gt;r1&lt;/result&gt;</div><div class="line">        &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>接下来，进行简单对比<br>Redirect和redirectAciton都是客户端跳转，<br>而dispatch和chain都是服务器端跳转</p>
<p>全局action：<br>当有多个action都需要返回某个页面的时候，就可以用到全局结果<br>即在同一个包下所有的action都共享该result，如下所示<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;global-results&gt;</div><div class="line">  &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">  &lt;/global-results&gt;</div><div class="line">  </div><div class="line">  &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>仍然操作之前的步骤，结果仍能执行全局中的result</p>
<p>Namespace<br>Namespace决定了action的访问路径，默认为“”，可以接收所有路径的action，如果没有找到相应的namespace时，则使用namespace为空的action<br>Namespace可以写为/，或者/xxx,或者/xxx/yyy，对应的action访问路径为/index.action、/xxx/index.action、或者/xxx/yyy/index.action.<br>Namespace最好也用模块来进行命名</p>
<p><package>标签</package></p>
<p><package>是用来解决重名的问题，例如当系统的前台和后台都有一个action名叫hello，这时就需要用package来区分。    前台<package name="front">后台<package name="back"><br>struts2中的package与java的package是相同的作用的</package></package></package></p>
<p>访问Web元素<br>Action中的会话一般有三种request,session,application，但是他们都是map类型<br>一般情况下有四种方式可以获得</p>
<p>方法一：ActionContext方式<br>一般在Action类的构造方法、或execute()方法中获取<br>如下案例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class LoginAction1 extends ActionSupport&#123;</div><div class="line">  private Map request;</div><div class="line">  private Map session;</div><div class="line">  private Map application;</div><div class="line"></div><div class="line">  public LoginAction1() &#123;</div><div class="line">	  request=(Map) ActionContext.getContext().get("request");</div><div class="line">	  session=ActionContext.getContext().getSession();</div><div class="line">	  application=ActionContext.getContext().getApplication();</div><div class="line">  &#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public String execute() throws Exception &#123;</div><div class="line">	       request.put("r1", "r1");</div><div class="line">	       session.put("s1", "s1");</div><div class="line">	       application.put("a1", "a1");</div><div class="line"></div><div class="line">		return super.execute();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>然后在页面中可以通过标签或者java片段取出<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value="#request.r1"/&gt; | &lt;%=request.getAttribute("r1") %&gt; &lt;br /&gt;</div><div class="line">    &lt;s:property value="#session.s1"/&gt; | &lt;%=session.getAttribute("s1") %&gt; &lt;br /&gt;</div><div class="line">&lt;s:property value="#application.a1"/&gt; | &lt;%=application.getAttribute("a1") %&gt; &lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>方式二：Ioc(控制反转)—推荐使用<br>让Action类实现RequestAware、SessionAware、ApplicationAware接口，然后重写他们的set方法(setRequest、setSession、setApplication)，通过依赖注入、控制反转(原来自己控制，现在由别人来控制值。)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class LoginAction2 extends ActionSupport implements RequestAware,SessionAware, ApplicationAware &#123;</div><div class="line">    private Map&lt;String, Object&gt; request;</div><div class="line">    private Map&lt;String, Object&gt; session;</div><div class="line">    private Map&lt;String, Object&gt; application;</div><div class="line">  public String execute() &#123;</div><div class="line">       request.put("r1", "r1");</div><div class="line">       session.put("s1", "s1");</div><div class="line">       application.put("a1", "a1");</div><div class="line">       return SUCCESS;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void setRequest(Map&lt;String, Object&gt; request) &#123;</div><div class="line">       this.request = request;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void setSession(Map&lt;String, Object&gt; session) &#123;</div><div class="line">       this.session = session;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void setApplication(Map&lt;String, Object&gt; application) &#123;</div><div class="line">       this.application = application;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方式三：获取原类型<br>获取是的HttpServletRequest/HttpSession/ServletContext<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private HttpServletRequest request;</div><div class="line">    private HttpSession session;</div><div class="line">    private ServletContext application;</div><div class="line">    public LoginAction3() &#123;</div><div class="line">       request = ServletActionContext.getRequest();</div><div class="line">       session = request.getSession();</div><div class="line">       application = session.getServletContext();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>一般情况下只用前三种，第四种就不说了</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之二:action详解]]></title>
      <url>http://www.myzwl.win/2017/03/27/structs2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在structs2中，action是其核心功能，而使用structs2框架，主要都是围绕action进行，我们编写的action通常需要实现com.opensymphony.xwork2.Action接口，需要实现的方法时execute方法，但是在实际开发中，编写的action也可以不必实现action接口，而是直接创建一个普通的java类，并添加execute方法就可以，如入门程序的案例，还有一种方式就是继承ActionSupport类，其已经实现了action的execute方法，以上方式，后两者比较常用</p>
<p>接下来将在入门程序的基础上，来介绍action属性</p>
<p> 一：action属性<br>  Action中有一个映射框架，主要讲url映射到对应的action，action的配置主要在struts.xml文件中编写，</p>
<p>  以下是action的几个常见属性</p>
<blockquote>
<p>属性       是否必须       说明<br>Name       是           action的名字，用于匹配请求的url<br>Class        否           action实现类的完整类名<br>Method     否            调用action实现类中指定的方法</p>
</blockquote>
<p>需要注意的是，action的name属性有规范，即不允许出现.或者/或者-，另外我们来看看如果只配置一个name属性，class怎么加载？<br>理论上是框架会调用actionsupport类中的execute方法，该方法的实现仅仅是返回一个success，但是实际上去掉之后，入门程序中跳转正确，但是数据取不到，至少说明的确跳转正确，</p>
<p>下面对method属性进行说明<br>由之前我们知道通常action的作用是完成一个功能点，但是如果同时又crud方法，显然创建四个action就太麻烦了，这时候就可以使用method属性，至于怎么用，先看一个实例。<br>即对用户进行增删该查</p>
<p>首先是useraction.java</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import com.opensymphony.xwork2.ActionSupport;</div><div class="line"></div><div class="line">public class useraction extends ActionSupport&#123;</div><div class="line"></div><div class="line">	//查询</div><div class="line">	public String selectall()&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//更新</div><div class="line">	public String update()</div><div class="line">	&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//删除</div><div class="line">	public String delete()</div><div class="line">	&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//添加</div><div class="line">	public String add()&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里注意一下，在action中并不一定非要需要写execute方法，也可以自己指定需要的方法，但是必须要在Struts.xml中做相应的配置，如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">       &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"selectall"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">        &lt;action name=<span class="string">"helloworld1"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"update"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">        &lt;action name=<span class="string">"helloworld2"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"delete"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">        &lt;action name=<span class="string">"helloworld3"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"add"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">&lt;/package&gt;</div></pre></td></tr></table></figure></p>
<p>然后在前台页面写需要调用的action<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> &lt;<span class="selector-tag">form</span> action=<span class="string">"helloworld.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>显然我们发现用此种方法思路清晰，但是太啰嗦，这就是有时需要动态调用action，简称DMI，<br>先看一个例子，<br>首先是useraction1.java<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class useraction1 extends ActionSupport&#123;</div><div class="line"></div><div class="line">	private String msg;</div><div class="line">	</div><div class="line">	public String getMsg() &#123;</div><div class="line">		return msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setMsg(String msg) &#123;</div><div class="line">		this.msg = msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">		//查询</div><div class="line">		public String selectall()&#123;</div><div class="line">			return "selectall";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//更新</div><div class="line">		public String update()</div><div class="line">		&#123;</div><div class="line">			return "update";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//删除</div><div class="line">		public String delete()</div><div class="line">		&#123;</div><div class="line">			return "delete";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//添加</div><div class="line">		public String add()&#123;</div><div class="line">			return "add";</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们可以通过自定义方法返回不同的值，然后通过result中name属性配置相应不同的值，来返回到不同的界面<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里是是否启用DMI方法，默认是关闭的</span></div><div class="line">&lt;constant name=<span class="string">"struts.enable.DynamicMethodInvocation"</span> value=<span class="string">"true"</span> /&gt; </div><div class="line"><span class="comment">//这里是否启用开发者模式，这样就不用每次重启服务器</span></div><div class="line">    &lt;constant name=<span class="string">"struts.devMode"</span> value=<span class="string">"true"</span> /&gt;</div><div class="line">    </div><div class="line">    &lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">     &lt;action name=<span class="string">"useraction1"</span> class=<span class="string">"com.zwl.action.useraction1"</span>&gt;</div><div class="line">     &lt;result name=<span class="string">"selectall"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;result name=<span class="string">"update"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;result name=<span class="string">"delete"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;result name=<span class="string">"add"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;/action&gt;</div><div class="line">&lt;/package&gt;</div></pre></td></tr></table></figure></p>
<p>好了，配置文件也配置好了，接下来就是在页面中调用DMI方法，一般的格式是actionname!xxx.action<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"useraction1!delete.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>至此动态调用action已完成，接下来将是默认的action配置<br>默认的action<br>先看配置实例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">    &lt;default-action-ref name=<span class="string">"helloworld"</span>&gt;&lt;/default-action-ref&gt;</div><div class="line"></div><div class="line">   &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"selectall"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>在表单中跳转到一个不存在的action时，则执行设置的默认action，这里需要注意的是每个namespace下，只能有一个默认的action，否则不知道执行那个默认的action</p>
<p>通配符映射<br> 使用通配符，可以将配置量降到最低，不过一定要实现约定好命名规范，即约定优于配置原则<br>在action配置中，<em>表示所有，可以匹配任意的字符，而{数字}表示第几个通配符，如
</em>_<em>，{1}表示第一个</em>，{2}表示第二个*<br>接下来模拟一个案例，如下所示<br>首先是action<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class useractionsave extends ActionSupport&#123;</div><div class="line">   </div><div class="line">	private String msg;</div><div class="line"></div><div class="line">	public String getMsg() &#123;</div><div class="line">		return msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setMsg(String msg) &#123;</div><div class="line">		this.msg = msg;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String save()&#123;</div><div class="line">		return "save";</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"useraction*"</span> class=<span class="string">"com.zwl.action.useraction&#123;1&#125;"</span> method=<span class="string">"&#123;1&#125;"</span>&gt;</div><div class="line">  &lt;result name=<span class="string">"save"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div><div class="line"></div><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"useractionsave.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>最后测试通过</p>
<p>最后介绍一下action的属性接受参数<br>事实上action中有三种方法</p>
<p>方法一：在Action添加成员属性接受参数<br>之前的案例都是采用这种方法的，就不多介绍了，不过值得注意的是，参数提交的名称必须和action的属性一致，并且要有set与get方法</p>
<p>方法二： 域模型(Domain Model)<br>就是先创建一个对象，通过在action中操作其属性来传递参数，相应的先建立一个user对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class user &#123;</div><div class="line">private String msg;</div><div class="line"></div><div class="line">public String getMsg() &#123;</div><div class="line">	return msg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setMsg(String msg) &#123;</div><div class="line">	this.msg = msg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">然后是action</div><div class="line">	private user use;</div><div class="line">	</div><div class="line">	public user getUse() &#123;</div><div class="line">		return use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setUse(user use) &#123;</div><div class="line">		this.use = use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String save()&#123;</div><div class="line">		return "save";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要注意的是前台参数传递，是action中引用对象的那个属性，其它都一样<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;<span class="selector-tag">form</span> action=<span class="string">"useractionsave.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"use.msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>方法三： ModelDriven接收参数<br>使Action实现com.opensymphony.xwork2.ModelDriven<user>(在实现接口时需要使用泛型，否则使用时需要转型)中利用其getModel()方法返回对象模型，从而获得传入的参数。</user></p>
<p>参数被传入至Action后，会被ModelDriven对象根据参数名自动赋值给User对象相应的属性而生成User对象，并且由getModel()返回。那么我们在Action中就可以利用这个对象了。<br>注意：传入的参数名需要与对象模型中的成员属性一致。</p>
<p>这里在将上述案例中的action修改一下。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class useractionsave extends ActionSupport implements ModelDriven&lt;user&gt;&#123;</div><div class="line">public String save()&#123;</div><div class="line">		return "save";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private user use=new user();</div><div class="line">	</div><div class="line">public user getUse() &#123;</div><div class="line">		return use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setUse(user use) &#123;</div><div class="line">		this.use = use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public user getModel() &#123;</div><div class="line">	// TODO Auto-generated method stub</div><div class="line">	return use;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struts2 之一:hello world]]></title>
      <url>http://www.myzwl.win/2017/03/26/structs1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Struts2框架是Apache基金组织下的一个开源框架，是基于MVC模式设计的web应用开发框架。它利用并扩展了java servlet API，鼓励开发者采用MVC架构。</p>
<p>当然本次不介绍strucs2的相关知识，只做一个快速入门案例，及环境搭建和将整个程序走一遍，最后完成hello world程序，也就是先有一个具体印象。</p>
<p>下载并解压struts2开发包，同时建立一个web工程</p>
<p>步骤一：<br> 为了方便，建议直接将开发包中的app下的web-inf下的lib里的文件夹里的jar包全部导入到项目的lib文件夹里</p>
<p>步骤二：编写web.xml文件。<br>一般情况下，我们将开发包中的web.xml复制下来，修改，并且放到web-inf目录下，保留下面内容<br><img src="/images/imgs2/21.gif" alt="Alt text"></p>
<p>步骤三：编写action类，也就是接受前台传过来的数据并进行相应处理和转发<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.zwl.action;</div><div class="line"></div><div class="line">public class helloworld &#123;</div><div class="line"></div><div class="line">	private String msg;</div><div class="line"></div><div class="line">	public String getMsg() &#123;</div><div class="line">		return msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setMsg(String msg) &#123;</div><div class="line">		this.msg = msg;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String execute()&#123;</div><div class="line">		return "success";</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>值得注意的是这里的msg要与前台表单里的name值一致，并且要有set和get方法，这样struct2就自动将前台表单输入的值赋给msg了，然后public String execute()，默认的转发方法，也就是说它返回的值要与result中的name属性设置的值一致，这样就可以跳转到相应界面了，当然这里要结合接下来的步骤才可以</p>
<p>步骤四：配置structs.xml文件，<br>直接将文档中该文件拷到src目录下，修改为如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE struts PUBLIC</div><div class="line">	"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</div><div class="line">	"http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</div><div class="line"></div><div class="line">&lt;struts&gt;</div><div class="line"></div><div class="line">    &lt;package name="default" namespace="/" extends="struts-default"&gt;</div><div class="line">       &lt;action name="helloworld" class="com.zwl.action.helloworld"&gt;</div><div class="line">       &lt;result name="success"&gt;success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">    &lt;/package&gt;</div><div class="line">&lt;/struts&gt;</div></pre></td></tr></table></figure></p>
<p>解释一下：package下name 和namespace就是为了区分重名，这里暂且不管，就按这种默认形式，action中name也就是我们表单提交的路径，class中是要加载的相应的action类，这里是helloworld，而result则是上述方法中返回的字符，里面为要跳转到success.jsp界面，因为这里是个入门程序，目的就是先具体体验。</p>
<p>步骤五：编写相应界面<br>首先是：index.jsp<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;<span class="selector-tag">form</span> action=<span class="string">"helloworld.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>这里结合一下步骤三，只要输入一个文本，后台通过反射机制，自动获得（只要满足标准）该值，并保存在栈中</p>
<p>然后是success.jsp<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib uri="/struts-tags" prefix="s" %&gt;//因为用到structs标签，所以这是声明使用</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;s:property value="msg"/&gt;//取得后台传过来的输入的值</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入到index.jsp。填表单，最后跳转到success.jsp中并取出值</p>
<p>至此，hello world入门程序算是完成了<br>至此，再把上述开发步骤总结一下：</p>
<p>1：准备jar包<br>2：在web.xml中配置structs2的相关过滤器配置<br>3：  开发action，针对不同的功能开发不同的action<br>4：在structs.xml中添加上一步骤开发的action相应的配置（页面跳转等等）<br>5：编写相应的页面</p>
<p>最后我们将整个过程抽象成一个结构图<br><img src="/images/imgs2/22.gif" alt="Alt text"></p>
<p>上述的控制器就是web.xml配置的那个，仔细对比一下整个程序，基本上mvc框架的总体过程就是这样了，当然，这里只是一个入门程序，所以所有的配置都是最简的，只有一个目的，那就是hello world！</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于struts2与easy ui的后台显示界面]]></title>
      <url>http://www.myzwl.win/2017/03/25/easyui1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一直忙着做项目，已经好几天没写博客了。我认为提高自己的最好路径就是先把我知道的东西总结出来，再去从已知探索未知的东西，最后在总结下来。不多说，就用笔者最喜欢的struts2和easy ui来一个需求</p>
<p>利用easy ui的datagrid做一个后台界面（目前只是分页显示数据），并从数据库取出，大概如下界面<br><img src="/images/imgs2/19.gif" alt="Alt text"></p>
<p>在此之前，先简单介绍一下easy ui的特点（和大部分ui基本一样）<br>1.基于jquery 用户界面插件的集合；<br>2.为一些当前用于交互的js 应用提供必要的功能；<br>3.使用EasyUI 你不需要写很多的javascript 代码，通常只需要写HTML 标记来定义用<br>户界面即可；<br>4.支持HTML5；<br>5.开发产品时可节省时间和资源；<br>6.简单，但很强大；<br>7.支持扩展，可根据自己的需求扩展控件；<br>8.源代码加密</p>
<p>总之，在后台界面上easy ui是一个很好的选择</p>
<p>1.新建一个web工程</p>
<p>2.添加ssh整合jar包、gson.jar、mysql驱动包、easy ui的官方文档（ui文件夹）<br>里面有五个文件必须引入（并且有顺序，否则无法引用）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//引入EasyUI 核心UI 文件CSS</span></div><div class="line">  &lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"ui/themes/default/easyui.css"</span> &gt;</div><div class="line">   <span class="comment">//引入EasyUI 图标文件</span></div><div class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"ui/themes/icon.css"</span> &gt;</div><div class="line"><span class="comment">//引入jQuery 核心库</span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"ui/jquery-1.8.0.min.js"</span> &gt;&lt;/script&gt;</div><div class="line">   <span class="comment">//引入jQuery EasyUI 核心库</span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"ui/jquery.easyui.min.js"</span> &gt;&lt;/script&gt;</div><div class="line">   <span class="comment">//引入EasyUI 中文提示信息</span></div><div class="line">   &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"ui/locale/easyui-lang-zh_CN.js"</span> &gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>3.新建一个页面（先贴出代码）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"> &lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;</div><div class="line">&lt;%</div><div class="line">String path = request.getContextPath();</div><div class="line">String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";</div><div class="line">%&gt;</div><div class="line"></div><div class="line">&lt;!DOCTYPE HTML&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;base href="&lt;%=basePath%&gt;"&gt;</div><div class="line">    </div><div class="line">    &lt;title&gt;index&lt;/title&gt;</div><div class="line">    //加载easy ui</div><div class="line">&lt;link rel="stylesheet" type="text/css" href="ui/themes/default/easyui.css" &gt;</div><div class="line">	&lt;link rel="stylesheet" type="text/css" href="ui/themes/icon.css" &gt;</div><div class="line">	&lt;script type="text/javascript" src="ui/jquery-1.8.0.min.js" &gt;&lt;/script&gt;</div><div class="line">	&lt;script type="text/javascript" src="ui/jquery.easyui.min.js" &gt;&lt;/script&gt;</div><div class="line">    &lt;script type="text/javascript" src="ui/locale/easyui-lang-zh_CN.js" &gt;</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line"></div><div class="line">//页面初始化之前执行函数</div><div class="line">	$(function() &#123;</div><div class="line">		</div><div class="line">	 //调用easy ui的datagrid组件，显示json数据，也可以通过html方式加载，这里使用js加载方式</div><div class="line">		$('#admin_yhgl_datagrid').datagrid(&#123;</div><div class="line">			   </div><div class="line">			    //远程加载的json格式数据</div><div class="line">				  url: '$&#123;pageContext.request.contextPath&#125;/booksort!showdatagrid.action',</div><div class="line">				//组件宽度</div><div class="line">                  width : 1200,</div><div class="line">				// 是否可伸缩 	</div><div class="line">			    fitColumns : true,</div><div class="line">		//js对象数组，从后台获得total（总记录）和ids（对象数据集合）然后显示出来	</div><div class="line">columns : [[</div><div class="line">&#123;</div><div class="line">	//字段，与后台字段数据对应</div><div class="line">field : 'id',</div><div class="line"> //标题</div><div class="line">title : '排名',</div><div class="line">//是否排序</div><div class="line">sortable:true,</div><div class="line">//宽度</div><div class="line">width:80,</div><div class="line">//是否居中</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">field : 'barcode',</div><div class="line">title : '图书条形码',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">field : 'bookname',</div><div class="line">title : '图书名称',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'bookshelf',</div><div class="line">title : '书架',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'bookpublish',</div><div class="line">title : '出版社',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">field : 'bookauthor',</div><div class="line">title : '图书作者',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'bookprice',</div><div class="line">title : '定价',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'borrowtime',</div><div class="line">title : '借阅次数',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">]],</div><div class="line"></div><div class="line">//是否有分页插件</div><div class="line">pagination : true,</div><div class="line">//每页显示记录数</div><div class="line">pageSize : 5,</div><div class="line">//设置记录数多少的选项设置</div><div class="line">pageList : [5, 10, 15, 20],</div><div class="line">//排序的字段</div><div class="line">sortName : 'id',</div><div class="line">			</div><div class="line">		&#125;);</div><div class="line">		</div><div class="line">		</div><div class="line">		&#125;);</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">//显示datagrid组件</div><div class="line">&lt;table id="admin_yhgl_datagrid"&gt;</div><div class="line">&lt;/table&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>目前还没有写后台，所以暂无数据加载显示</p>
<p>4 建表（为了方便直接截个图）<br><img src="/images/imgs2/20.gif" alt="Alt text"><br>然后随便加几个数据</p>
<p>5.编写pojo与映射文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class Book &#123;</div><div class="line">private String barcode;</div><div class="line">private String bookauthor;</div><div class="line">private String bookname;</div><div class="line">private String bookprice;</div><div class="line">private String bookpublish;</div><div class="line">private String bookshelf;</div><div class="line">private String booktype;</div><div class="line">private int borrowtime;</div><div class="line">private int id;</div><div class="line"></div><div class="line">省略set与get方法&#125;</div><div class="line"></div><div class="line">//映射文件</div><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line">&lt;!-- </div><div class="line">    Mapping file autogenerated by MyEclipse Persistence Tools</div><div class="line">--&gt;</div><div class="line">&lt;hibernate-mapping package="com.pojo"&gt;</div><div class="line">    &lt;class name="Book" table="book" &gt;</div><div class="line">        &lt;id name="id" &gt;</div><div class="line">            &lt;generator class="increment"&gt;&lt;/generator&gt;</div><div class="line">        &lt;/id&gt;</div><div class="line">        &lt;property name="bookname"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookauthor"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">      &lt;property name="barcode"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookprice"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookpublish"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookshelf"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="booktype"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="borrowtime"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure>
<p>6.dao层service层接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public interface Basedao&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	</div><div class="line">	public List&lt;T&gt; find(String hql, int page, int rows);                             //分页时返回T对象集合</div><div class="line">	</div><div class="line">	</div><div class="line">	public Long count(String hql);                                                   //返回总记录数</div><div class="line">	</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface Basedaoservice &lt;T&gt;&#123;</div><div class="line"></div><div class="line">//Book的包装类，主要增加easy ui所需要的一些属性</div><div class="line">	public DataGrid datagrid(Tbook book);</div><div class="line">	</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>7.编写工具类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class DataGrid &#123;</div><div class="line"></div><div class="line">	private Long total = 0l;                   //总记录</div><div class="line">	private List rows = new ArrayList();       //datagrid需要的json数据加载数据</div><div class="line">	省略set与get方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Tbook &#123;</div><div class="line">       private String barcode;</div><div class="line">	private String bookauthor;</div><div class="line">	private String bookname;</div><div class="line">	private String bookprice;</div><div class="line">	private String bookpublish;</div><div class="line">	private String bookshelf;</div><div class="line">	private String booktype;</div><div class="line">	private int borrowtime;</div><div class="line">	private int id;</div><div class="line">	private String ids;          //前台被选中行的字符转</div><div class="line">	private String order;        //排序</div><div class="line">	private int page;            //多少页</div><div class="line">	private int rows;</div><div class="line">	private String sort;         //排序名</div><div class="line">。。。。。</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Character &#123;</div><div class="line"></div><div class="line">	public static HttpServletResponse Tojson() throws Exception&#123;</div><div class="line">		HttpServletResponse response=ServletActionContext.getResponse();</div><div class="line">		HttpServletRequest request=ServletActionContext.getRequest();</div><div class="line">		request.setCharacterEncoding("utf-8");</div><div class="line">		response.setCharacterEncoding("UTF-8");</div><div class="line">		response.setContentType("application/json; charset=utf-8");          //返回json数据</div><div class="line">	        response.setHeader("Cache-Control", "no-cache");                 //不要缓存</div><div class="line">	        response.setHeader("Pragma", "no-cache");  </div><div class="line">		PrintWriter out = response.getWriter();</div><div class="line">		return response;</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>8.实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class Basedaoimpl&lt;T&gt; extends HibernateDaoSupport  implements Basedao&lt;T&gt; &#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	public List&lt;T&gt; find(String hql, int page, int rows) &#123;</div><div class="line">	</div><div class="line">		Query q=this.getSession().createQuery(hql);</div><div class="line">		</div><div class="line">		return q.setFirstResult((page-1)*rows).setMaxResults(rows).list();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Long count(String hql) &#123;</div><div class="line">		Query q=this.getSession().createQuery(hql);</div><div class="line">		return (Long) q.uniqueResult();</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class Basedaoserviceimpl&lt;T&gt; implements Basedaoservice&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	private Basedao&lt;T&gt; basedao;</div><div class="line">	</div><div class="line">	public Basedao&lt;T&gt; getBasedao() &#123;</div><div class="line">		return basedao;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setBasedao(Basedao&lt;T&gt; basedao) &#123;</div><div class="line">		this.basedao = basedao;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public DataGrid datagrid(Tbook book) &#123;</div><div class="line">	</div><div class="line">		DataGrid dg=new DataGrid();</div><div class="line">		//查询所有的book数据</div><div class="line">		 String hql="from Book b";</div><div class="line">      </div><div class="line">        //排序sql</div><div class="line">		 if(book.getSort()!=null)&#123;</div><div class="line">				hql += " order by " + book.getSort() + " " + book.getOrder();</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		//取出所有的book记录，放在集合汇总</div><div class="line">		 List&lt;Book&gt; l=(List&lt;Book&gt;) basedao.find(hql, book.getPage(), book.getRows());</div><div class="line">		 //查出所有记录数</div><div class="line">		 String totalHql = "select count(*) " + hql;</div><div class="line">	    </div><div class="line">	    //将book对象集合一次加进Tbook包装类集合</div><div class="line">		 List&lt;Tbook&gt; nl=new ArrayList&lt;Tbook&gt;();</div><div class="line">			if (l != null &amp;&amp; l.size() &gt; 0) &#123;</div><div class="line">				for(Book t:l)&#123;</div><div class="line">					Tbook u=new Tbook();</div><div class="line">					BeanUtils.copyProperties(t, u);</div><div class="line">					nl.add(u);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">				dg.setTotal(basedao.count(totalHql));</div><div class="line">				dg.setRows(nl);</div><div class="line">				return dg;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>9 action主题代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class booksort implements ModelDriven&lt;Tbook&gt; &#123;</div><div class="line"></div><div class="line">    //利用modaldriven包装Tbook</div><div class="line">	private Tbook book=new Tbook();</div><div class="line">	</div><div class="line">	private Basedaoservice&lt;Book&gt; basedaoservice;</div><div class="line">	</div><div class="line">	</div><div class="line">	public void showdatagrid() throws Exception&#123;</div><div class="line">		HttpServletResponse response=Character.Tojson();</div><div class="line">		Gson gson=new Gson();          //创建gson对象</div><div class="line">		response.getWriter().write(gson.toJson(basedaoservice.datagrid(book))); //将对象转为json数据</div><div class="line">	&#125;</div><div class="line">	</div><div class="line"></div><div class="line">	</div><div class="line">	public Basedaoservice&lt;Book&gt; getBasedaoservice() &#123;</div><div class="line">		return basedaoservice;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	public void setBasedaoservice(Basedaoservice&lt;Book&gt; basedaoservice) &#123;</div><div class="line">		this.basedaoservice = basedaoservice;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Tbook getModel() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return book;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>10 spring配置和structs配置（参考之前的博客）这里就不配置了，基本都是套路</p>
<p>至此就能加载数据了，当然easy ui在后台界面中的使用不仅方便而且强大，这也是笔者最喜欢使用easy ui的原因</p>
]]></content>
      
        <categories>
            
            <category> 项目经验 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis 之四:mybatis整合spring]]></title>
      <url>http://www.myzwl.win/2017/03/24/mybatis4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整合思路：<br>    1、数据源信息交给spring管理<br>2、sqlsessionfactory交给spring进行单例管理<br>3、由spring来管理mapper代理的代理类</p>
<p>下面以根据用户id查询用户信息案例来搭建工程<br>步骤一：建立java工程</p>
<p>步骤二：添加整合包（这里需要的jar包过多）<br>Mysql的驱动包<br>Mybatis的核心包和依赖包<br>Mybatis和spring的整合包<br>Spring的包<br>dbcp数据库连接池包<br>等等</p>
<p>步骤三：在src目录下建立sqlmapconfig.xml配置文件，里面暂时只有一个dtd文件声明<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE configuration</div><div class="line">PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</div><div class="line">"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>步骤四：在src目录下建立applicationcontext.xml配置文件<br>里面目前只配置一些重要连接数据库的信息，后面步骤将加入重要信息<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt;</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line">	&lt;!-- 创建数据源 --&gt;</div><div class="line">	&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;</div><div class="line">		&lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt;</div><div class="line">		&lt;property name="url" value="jdbc:mysql://localhost:9806/sshe" /&gt;</div><div class="line">		&lt;property name="username" value="root" /&gt;</div><div class="line">		&lt;property name="password" value="root" /&gt;</div><div class="line">		&lt;property name="maxActive" value="10" /&gt;</div><div class="line">		&lt;property name="maxIdle" value="5" /&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">	&lt;!-- SqlSessionFactory --&gt;</div><div class="line">	&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;</div><div class="line">		&lt;!-- 指定mybatis的全局配置文件的路径 --&gt;</div><div class="line">		&lt;property name="configLocation" value="SqlMapConfig.xml"&gt;&lt;/property&gt;</div><div class="line">		&lt;!-- 数据源 --&gt;</div><div class="line">		&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>步骤五：创建pojo类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">private int age;</div><div class="line">private int id;</div><div class="line">private String name;</div><div class="line">此处省略set与get方法。。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤六：创建mapper代理<br>首先是UserMapper.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE mapper    </div><div class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    </div><div class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line">&lt;mapper namespace="com.zwl.mapper.UserMapper"&gt;</div><div class="line">	&lt;!-- 根据用户ID查询用户信息 --&gt;</div><div class="line">	&lt;select id="findUserById" parameterType="int" resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT</div><div class="line">		* FROM user WHERE id =#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure></p>
<p>接下来是mapper接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(int id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在sqlmapconfig.xml文件中声明代理文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">	&lt;!-- 加载映射文件 --&gt;</div><div class="line">	&lt;mappers&gt;</div><div class="line">		&lt;mapper resource=<span class="string">"com/zwl/mapper/UserMapper.xml"</span> /&gt;</div><div class="line">	&lt;/mappers&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>步骤七：spring中注入<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"UserMapper"</span> class=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</div><div class="line">		&lt;!-- 设置代理类的接口 --&gt;</div><div class="line">		&lt;property name=<span class="string">"mapperInterface"</span> value=<span class="string">"com.zwl.mapper.UserMapper"</span>&gt;&lt;/property&gt;</div><div class="line">		&lt;!-- 依赖注入SqlSessionFactory --&gt;</div><div class="line">		&lt;property name=<span class="string">"sqlSessionFactory"</span> ref=<span class="string">"sqlSessionFactory"</span>&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>步骤八：测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class test &#123;</div><div class="line">	private ApplicationContext ctx;</div><div class="line"></div><div class="line">//在测试之前自动加载</div><div class="line">	@Before</div><div class="line">	public void setUp() throws Exception &#123;</div><div class="line">		ctx = new ClassPathXmlApplicationContext(</div><div class="line">				"applicationContext.xml");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Test</div><div class="line">	public void testFindUserById() throws Exception &#123;</div><div class="line">		</div><div class="line">		UserMapper dao = (UserMapper) ctx.getBean("userMapper");</div><div class="line">		</div><div class="line">		User user = dao.findUserById(1);</div><div class="line">		</div><div class="line">		System.out.println(user.getName());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：取出数据库中的helloworld<br>至此mybatis整合spring完成</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis 之三:映射文件]]></title>
      <url>http://www.myzwl.win/2017/03/23/mybatis3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基本上我们对数据库的操作都在映射文件中编写，通过mapper代理方式简化配置，同时依据不同的参数和返回类型完成相关需求</p>
<h5 id="一：parameterType输入参数"><a href="#一：parameterType输入参数" class="headerlink" title="一：parameterType输入参数"></a>一：parameterType输入参数</h5><p>简单类型：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id="findUserById" parameterType="int"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>参数是基本类型，在之前已演示</p>
<p>Pojo类型<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;insert id=<span class="string">"insertuser"</span> parameterType=<span class="string">"com.zwl.pojo.User"</span>&gt;</div><div class="line">&lt;selectKey keyProperty=<span class="string">"id"</span> resultType=<span class="string">"int"</span> <span class="attribute">order</span>=<span class="string">"AFTER"</span>&gt;</div><div class="line">select LAST_INSERT_ID()</div><div class="line">&lt;/selectKey&gt;</div><div class="line">insert into user values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</div><div class="line">&lt;/insert&gt;</div></pre></td></tr></table></figure></p>
<p>即参数类型是一个对象，如之前的添加操作</p>
<p>包装pojo类型<br>即在类中包含另一个对象，如<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class Uservo &#123;</div><div class="line">private User user;</div><div class="line">此处省略set。。get方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件中<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id="findUserById" parameterType="com.zwl.pojo.Uservo"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;user.id&#125;</div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>参数是包装类，注意参数是包装类的属性</p>
<p>Map<br>  同传递pojo对象一样，map的key相当于pojo的属性<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id="findUserById" parameterType="hashmap"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;id&#125; and name=#&#123;name&#125;</div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>显然，参数是hashmap，其中#{id}与#{name}都是hashmap的key</p>
<p>接口文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(HashMap&lt;String, Object&gt; id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">UserMapper mapper=sqlSession.getMapper(UserMapper.class);</div><div class="line">				</div><div class="line">				HashMap&lt;String, Object&gt; hm=new HashMap&lt;&gt;();</div><div class="line">				hm.put("id", 1);</div><div class="line">				hm.put("name","helloworld");</div><div class="line">				</div><div class="line">				User u=mapper.findUserById(hm);</div><div class="line">				System.out.println(u.getAge());</div><div class="line">				sqlSession.close();</div></pre></td></tr></table></figure></p>
<h4 id="输出映射"><a href="#输出映射" class="headerlink" title="输出映射"></a>输出映射</h4><p>Resulttype：<br>    使用要求：<br>  使用resultType进行结果映射时，需要查询出的列名和映射的对象的属性名一致，才能映射成功。<br>如果查询的列名和对象的属性名全部不一致，那么映射的对象为空。<br>如果查询的列名和对象的属性名有一个一致，那么映射的对象不为空，但是只有映射正确那一个属性才有值。</p>
<p>简单类型：resultType=”int”<br>Pojo对象：resultType=”com.zwl.pojo.User”</p>
<p>如之前的案例<br>Resultmap<br>使用resultMap进行结果映射时，不需要查询的列名和映射的属性名必须一致。但是需要声明一个resultMap，来对列名和属性名进行映射<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;resultMap type=<span class="string">"com.zwl.pojo.User"</span> id=<span class="string">"Userresult"</span>&gt;</div><div class="line">	&lt;id column=<span class="string">"id_"</span> property=<span class="string">"id"</span>/&gt;</div><div class="line">	&lt;result column=<span class="string">"name_"</span> property=<span class="string">"name"</span>/&gt;</div><div class="line">	&lt;result column=<span class="string">"age_"</span> property=<span class="string">"age"</span>/&gt;</div><div class="line">	&lt;/resultMap&gt;</div></pre></td></tr></table></figure></p>
<p>其中id为查询结果中唯一列映射，result标签为映射结果中的普通列</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id=<span class="string">"findUserById"</span> parameterType=<span class="string">"int"</span></div><div class="line">		resultMap=<span class="string">"Userresult"</span> &gt;</div><div class="line">		SELECT id id_,name name_,age age_ FROM user WHERE id =#&#123;id&#125; </div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure>
<p>其中resultmap必须与声明中的id保持一致，这样才能引用</p>
<p>接口：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(int id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">User u=mapper.findUserById(1);</div><div class="line">				System.out.println(u.getAge());</div><div class="line">				sqlSession.close();</div></pre></td></tr></table></figure>
<p>mybatis与hibernate的区别及各自应用场景<br>Mybatis技术特点：<br>1、    通过直接编写SQL语句，可以直接对SQL进行性能的优化；<br>2、    学习门槛低，学习成本低。只要有SQL基础，就可以学习mybatis，而且很容易上手；<br>3、    由于直接编写SQL语句，所以灵活多变，代码维护性更好。<br>4、    不能支持数据库无关性，即数据库发生变更，要写多套代码进行支持，移植性不好。</p>
<p>Hibernate技术特点：<br>1、    标准的orm框架，程序员不需要编写SQL语句。<br>2、    具有良好的数据库无关性，即数据库发生变化的话，代码无需再次编写。<br>3、    学习门槛高，需要对数据关系模型有良好的基础，而且在设置OR映射的时候，需要考虑好性能和对象模型的权衡。<br>4、    程序员不能自主的去进行SQL性能优化。</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis 之二:开发dao的两种方式]]></title>
      <url>http://www.myzwl.win/2017/03/22/mybatis2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Dao层的开发，在mybatis中可以通过原始dao（一个接口和接口实现类），而在mybatis中可以更方便的通过mapper代理模式，当然需要满足一定的规范性原则</p>
<p>不多说，以一个增加user信息为例</p>
<p>一：首先在映射文件中写一个增加用户配置信息<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 添加用户 --&gt;</div><div class="line">	&lt;!-- selectKey：查询主键，在标签内需要输入查询主键的sql --&gt;</div><div class="line">	&lt;!-- <span class="attribute">order</span>：指定查询主键的sql和insert语句的执行顺序，相当于insert语句来说 --&gt;</div><div class="line">	&lt;!-- LAST_INSERT_ID：该函数是mysql的函数，获取自增主键的ID，它必须配合insert语句一起使用 --&gt;</div><div class="line">	&lt;insert id=<span class="string">"insertuser"</span> parameterType=<span class="string">"com.zwl.pojo.User"</span>&gt;</div><div class="line">	&lt;selectKey keyProperty=<span class="string">"id"</span> resultType=<span class="string">"int"</span> <span class="attribute">order</span>=<span class="string">"AFTER"</span>&gt;select LAST_INSERT_ID()&lt;/selectKey&gt;</div><div class="line">	insert into user values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</div><div class="line">	&lt;/insert&gt;</div></pre></td></tr></table></figure></p>
<p>注意：这里的插入中原表中主键有自增长，所以需要先获得主键，在增加，这是一个插入语句</p>
<p>二：dao接口及其实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public interface userdao &#123;</div><div class="line">//添加user</div><div class="line">	public void insertusers(User user) throws Exception;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Dao接口实现类</div><div class="line">public class userdaoimpl implements userdao &#123;</div><div class="line"></div><div class="line">	private SqlSessionFactory sqlSessionFactory;</div><div class="line">	</div><div class="line">//通过构造函数注入sqlSessionFactory</div><div class="line">	public userdaoimpl(SqlSessionFactory sqlSessionFactory)&#123;</div><div class="line">		this.sqlSessionFactory=sqlSessionFactory;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void insertusers(User user) throws Exception &#123;</div><div class="line">//通过线程安全方式获得sqlsession，实现增删该查操作</div><div class="line">		SqlSession sqlsession=sqlSessionFactory.openSession();</div><div class="line">//注意这里的test是映射文件中的namespace，insertuser是id用于标识</div><div class="line">		sqlsession.insert("test.insertuser", user);</div><div class="line">//添加操作需要提交事务</div><div class="line">		sqlsession.commit();</div><div class="line">		sqlsession.close();</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>编写测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//读取配置文件</div><div class="line">				//全局配置文件的路径</div><div class="line">				String resource = "SqlMapConfig.xml";</div><div class="line">				InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">				</div><div class="line">				//创建SqlSessionFactory</div><div class="line">				SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div><div class="line"></div><div class="line">              //创建user</div><div class="line">	            User u=new User();</div><div class="line">				u.setName("java");</div><div class="line">				u.setAge(18);</div><div class="line">				</div><div class="line">//调用dao层方法，实现添加功能</div><div class="line">				userdao dao=new userdaoimpl(sqlSessionFactory);</div><div class="line">				dao.insertusers(u);</div></pre></td></tr></table></figure></p>
<p>这种原始dao方式，我们很熟悉，也很好理解，到时当方法多的时候，就会存在大量多余的重复编码问题</p>
<p>Mapper代理的开发模式<br>即开发mapper接口（相当于dao接口）<br>Mapper代理使用的是jdk的代理策略</p>
<p>还有一点是mapper代理最重要的，就是必须满足mapper代理的开发规范<br>1 mapper接口的全限定名要和mapper映射文件的namespace值一致<br>2 mapper接口的方法名称要和mapper映射文件的statement的id一致。<br>3 mapper接口的方法参数类型要和mapper映射文件的statement的parameterType的值一致，而且它的参数是一个。<br>4 mapper接口的方法返回值类型要和mapper映射文件的statement的resultType的值一致。</p>
<p>下面以入门程序的通过id查询user为例<br>首先是修改映射文件，改名为UserMapper.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE mapper    </div><div class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    </div><div class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line">&lt;!-- namespace：命名空间，对statement的信息进行分类管理 --&gt;</div><div class="line">&lt;!-- 注意：在mapper代理时，它具有特殊及重要的作用 --&gt;</div><div class="line">&lt;mapper namespace="com.zwl.mapper.UserMapper"&gt;</div><div class="line">	&lt;!-- 根据用户ID查询用户信息 --&gt;</div><div class="line">	&lt;!-- select：表示一个MappedStatement对象 --&gt;</div><div class="line">	&lt;!-- id：statement的唯一标示 --&gt;</div><div class="line">	&lt;!-- #&#123;&#125;：表示一个占位符？ --&gt;</div><div class="line">	&lt;!-- #&#123;id&#125;：里面的id表示输入参数的参数名称，如果该参数是简单类型，那么#&#123;&#125;里面的参数名称可以任意 --&gt;</div><div class="line">	&lt;!-- parameterType：输入参数的java类型 --&gt;</div><div class="line">	&lt;!-- resultType：输出结果的所映射的java类型（单条结果所对应的java类型） --&gt;</div><div class="line">	</div><div class="line"></div><div class="line">	&lt;select id="findUserById" parameterType="int"</div><div class="line">		resultType="com.zwl.pojo.User" &gt;</div><div class="line">		select * from user where id=#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure></p>
<p>上述的namespace需要和mapper接口的全限定名一致<br>然后是mapper接口开发（UserMapper.java）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package com.zwl.mapper;</div><div class="line"></div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(int id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来是在配置文件中声明映射文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;mappers&gt;</div><div class="line">		&lt;mapper resource=<span class="string">"com/zwl/mapper/UserMapper.xml"</span> /&gt;</div><div class="line">	&lt;/mappers&gt;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">String resource = "SqlMapConfig.xml";</div><div class="line">				InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">				</div><div class="line">				//创建SqlSessionFactory</div><div class="line">				SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div><div class="line">				</div><div class="line">			//创建SqlSession</div><div class="line">				SqlSession sqlSession = sqlSessionFactory.openSession();</div><div class="line">				</div><div class="line">//通过mybatis的sqlsession来创建代理对象</div><div class="line">				UserMapper mapper=sqlSession.getMapper(UserMapper.class);</div><div class="line">				</div><div class="line">				User u=mapper.findUserById(1);</div><div class="line">				System.out.println(u.getName());</div><div class="line">				sqlSession.close();</div></pre></td></tr></table></figure></p>
<p>最后的测试结果是取出数据库中id为1的helloworld</p>
<p>至此mapper代理开发dao完成，这里只给了一个简单的例子，总的来说，只要满足规范，就可以简化配置</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis 之一:hello world]]></title>
      <url>http://www.myzwl.win/2017/03/21/mybatis1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mybatis就是一个封装了jdbc的持久层框架，它和hibernate都属于orm框架，但是具体说，hibernate是一个完全的orm框架，而mybatis是一个不完全的orm框架，mybatis只关注sql本身，而不需要关注如连接的创建，statement的创建等操作。Mybatis会将输入参数、输出结果进行映射。</p>
<p>不多说，先来一个入门程序，意在先从整体了解<br>步骤一：创建一个java工程</p>
<p>步骤二：导入jar包，首先创建一个lib文件夹，在将包导入<br><img src="/images/imgs2/17.gif" alt="Alt text"></p>
<p>步骤三：数据库中的表user<br><img src="/images/imgs2/18.gif" alt="Alt text"></p>
<p>步骤四：创建pojo类，与数据库字段对应<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pojo;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line">	private int age;</div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line">	public int getId() &#123;</div><div class="line">		return id;</div><div class="line">	&#125;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public void setId(int id) &#123;</div><div class="line">		this.id = id;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤五：创建全局配置文件（mybatis核心配置文件SqlMapConfig.xml，放在src目录下）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE configuration</div><div class="line">PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</div><div class="line">"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">	&lt;!-- 配置mybatis的环境信息，与spring整合，该信息由spring来管理 --&gt;</div><div class="line">	&lt;environments default="development"&gt;</div><div class="line">		&lt;environment id="development"&gt;</div><div class="line">			&lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt;</div><div class="line">			&lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;</div><div class="line">			&lt;!-- 配置数据源，采用mybatis连接池 --&gt;</div><div class="line">			&lt;dataSource type="POOLED"&gt;</div><div class="line">				&lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt;</div><div class="line">				&lt;property name="url" value="jdbc:mysql://localhost:9806/sshe" /&gt;</div><div class="line">				&lt;property name="username" value="root" /&gt;</div><div class="line">				&lt;property name="password" value="root" /&gt;</div><div class="line">			&lt;/dataSource&gt;</div><div class="line">		&lt;/environment&gt;</div><div class="line">	&lt;/environments&gt;</div><div class="line"></div><div class="line">	&lt;mappers&gt;</div><div class="line">		还没有映射文件 </div><div class="line">	&lt;/mappers&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>简要说明一下，类似于hibernate核心配置文件，连接数据库，这里暂时还没有映射文件，后面步骤在加上</p>
<p>步骤六：映射文件（User.xml）这里是通过id查询返回对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE mapper    </div><div class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    </div><div class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line">&lt;!-- namespace：命名空间，对statement的信息进行分类管理 --&gt;</div><div class="line">&lt;!-- 注意：在mapper代理时，它具有特殊及重要的作用 --&gt;</div><div class="line">&lt;mapper namespace="test"&gt;</div><div class="line">	&lt;!-- 根据用户ID查询用户信息 --&gt;</div><div class="line">	&lt;!-- select：表示一个MappedStatement对象 --&gt;</div><div class="line">	&lt;!-- id：statement的唯一标示 --&gt;</div><div class="line">	&lt;!-- #&#123;&#125;：表示一个占位符？ --&gt;</div><div class="line">	&lt;!-- #&#123;id&#125;：里面的id表示输入参数的参数名称，如果该参数是简单类型，那么#&#123;&#125;里面的参数名称可以任意 --&gt;</div><div class="line">	&lt;!-- parameterType：输入参数的java类型 --&gt;</div><div class="line">	&lt;!-- resultType：输出结果的所映射的java类型（单条结果所对应的java类型） --&gt;</div><div class="line">	&lt;select id="findUserById" parameterType="int"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure></p>
<p>步骤七：在全局配置文件中声明映射文件（User.xml）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;mappers&gt;</div><div class="line">		&lt;mapper resource=<span class="string">"com/zwl/pojo/User.xml"</span> /&gt;</div><div class="line">	&lt;/mappers&gt;</div></pre></td></tr></table></figure></p>
<p>步骤八：测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">import java.io.InputStream;</div><div class="line"></div><div class="line">import org.apache.ibatis.io.Resources;</div><div class="line">import org.apache.ibatis.session.SqlSession;</div><div class="line">import org.apache.ibatis.session.SqlSessionFactory;</div><div class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public class test &#123;</div><div class="line">	@Test</div><div class="line">	public void findUserByIdtest() throws Exception&#123;</div><div class="line">		        //读取配置文件</div><div class="line">				//全局配置文件的路径</div><div class="line">				String resource = "SqlMapConfig.xml";</div><div class="line">				InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">				</div><div class="line">				//创建SqlSessionFactory</div><div class="line">				SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div><div class="line">				</div><div class="line">				//创建SqlSession</div><div class="line">				SqlSession sqlSession = sqlSessionFactory.openSession();</div><div class="line">				</div><div class="line">				//调用SqlSession的增删改查方法</div><div class="line">				//第一个参数：表示statement的唯一标示</div><div class="line">				User u=sqlSession.selectOne("test.findUserById", 1);</div><div class="line">				System.out.println(u.getName());</div><div class="line">				sqlSession.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后可将数据库中id为1的数据取出</p>
<p>至此，入门程序算是完成了，通过上面步骤发现，这里的不完全orm，还是得最后我们自己写sql，这样我们就可以面对复杂表关系时，自己优化了</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring mvc之四:数据回显与json]]></title>
      <url>http://www.myzwl.win/2017/03/20/springmvc4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>比较struts2与spring mvc<br>实现机制：<br>Struts2是基于过滤器实现的。<br>Springmvc基于servlet实现。Servlet比过滤器快。</p>
<p>运行速度：<br>Struts2是多列<br>请求来了以后，struts2创建多少个对象：<br>ActionContext，valuestack，UserAction，ActionSuport，ModelDriven<br>Springmvc是单列</p>
<p>参数封装来分析：<br>Struts基于属性进行封装。<br>Springmvc基于方法封装。</p>
<p>页面回显：<br> 查询所有<br>构造一组list数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("userlist")</div><div class="line">   //model	相当于application域对象</div><div class="line">	public String userlist(Model modal)&#123;</div><div class="line">		List&lt;User&gt; list=new ArrayList&lt;&gt;();</div><div class="line">		User u1=new User();</div><div class="line">		u1.setId(1);</div><div class="line">		u1.setSex("1");</div><div class="line">		u1.setAddress("lol");</div><div class="line">		u1.setUsername("1");</div><div class="line">		u1.setBirthday(new Date());</div><div class="line">		</div><div class="line">		User u2=new User();</div><div class="line">		u2.setId(1);</div><div class="line">		u2.setSex("1");</div><div class="line">		u2.setAddress("lol");</div><div class="line">		u2.setUsername("1");</div><div class="line">		u2.setBirthday(new Date());</div><div class="line">		</div><div class="line">		list.add(u1);</div><div class="line">		list.add(u2);</div><div class="line">		</div><div class="line">		modal.addAttribute("userlist", list);</div><div class="line">		</div><div class="line">		return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>页面回显（利用jstl标签回显）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;//声明此标签</div><div class="line"></div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;table border="1" style="color: blue"&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">&lt;td&gt;姓名&lt;/td&gt;</div><div class="line">&lt;td&gt;生日&lt;/td&gt;</div><div class="line">&lt;td&gt;性别&lt;/td&gt;</div><div class="line">&lt;td&gt;地址&lt;/td&gt;</div><div class="line">&lt;td&gt;操作&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;c:forEach items="$&#123;userlist &#125;" var="user"&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">&lt;td&gt;$&#123;user.username &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;user.birthday &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;user.sex &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;user.address &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;</div><div class="line">&lt;a href="$&#123;pageContext.request.contextPath &#125;/test/update?id=$&#123;user.id &#125;"&gt;delete&lt;/a&gt;</div><div class="line">&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line"></div><div class="line">&lt;/c:forEach&gt;</div><div class="line"></div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>注意此处有个delete</p>
<blockquote>
<p><a href="${pageContext.request.contextPath }/test/update?id=${user.id }">delete</a></p>
</blockquote>
<p>利用？的方法，无疑将值显示的传过去，很不安全</p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc2/test/userlist.do" target="_blank" rel="external">http://localhost:100/springmvc2/test/userlist.do</a></p>
<p>可以取出集合中的数据，同时delete中有显示id=参数传过去了</p>
<h4 id="URL模版映射"><a href="#URL模版映射" class="headerlink" title="URL模版映射"></a>URL模版映射</h4><p>url模版映射是restfull软件架构<br>Web.xml拦截方式：在rest目录下所有请求都被拦截，servlet可以拦截目录<br>配置如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;/rest<span class="comment">/*&lt;/url-pattern&gt;</span></div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
<p>（）:匹配接受页面Url路径参数<br>@Pathariable：（）里面参数注入后面参数里面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("update/&#123;id&#125;")</div><div class="line">	public String update(@PathVariable Integer id)&#123;</div><div class="line">		System.out.println(id);</div><div class="line">		</div><div class="line">		return "redirect:/test/userlist.do";</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>页面修改：</p>
<blockquote>
<p><a href="${pageContext.request.contextPath }/rest/test/update/${user.id }">delete</a></p>
</blockquote>
<p>测试：同样输入相同地址，会发现href代参直接变成/参数</p>
<h4 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h4><p>转发<br>关键字：forward<br>本类进行转发：<br>本类方法与方法之间进行forward<br>转发方式：</p>
<blockquote>
<p>return “forward : /test/userlist.do”;</p>
</blockquote>
<p>跨类进行转发：<br>转发方式：return ”forward：/items/userlist.do“；<br>其中items是类前面的路径声明</p>
<p>重定向<br>关键字：redirect<br>本类进行重定向：<br>本类方法与方法之间进行redirect<br>重定向方式：</p>
<blockquote>
<p>return “redirect:/test/userlist.do”;</p>
</blockquote>
<p>跨类进行重定向：<br>转发方式：return ”redirect：/items/userlist.do“；</p>
<h4 id="responseBody和-RequestBody"><a href="#responseBody和-RequestBody" class="headerlink" title="@responseBody和@RequestBody"></a>@responseBody和@RequestBody</h4><p>@responseBody把后台pojo转换json对象，返回到页面。<br>@RequestBody接受前台json数据，把json数据自动封装javaBean。</p>
<p>下面以一个实例说明<br>这里ajax传递json数据用jquery来模拟</p>
<p>步骤一：导入jar包（jackson-core-asl-1.9.11.jar和jackson-mapper-asl-1.9.11.jar）<br>加入jquery<br>在springmvc.xml文件中声明对json数据的支持<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</div><div class="line">		&lt;property name=<span class="string">"messageConverters"</span>&gt;</div><div class="line">		&lt;bean class=<span class="string">"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"</span>&gt;&lt;/bean&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>页面传递ajax格式<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">function requestjson()&#123;</div><div class="line">	//模拟了一个json格式数据</div><div class="line">			 var jsonobj=JSON.stringify(&#123;"username":"11","sex":"man","address":"ok"&#125;); </div><div class="line">			$.ajax(&#123;</div><div class="line">				type:'POST',</div><div class="line">				url:'&lt;%=path%&gt;/test/requestjson.do',</div><div class="line">	//申明传递的是json格式</div><div class="line">				 contentType:'application/json;charset=utf-8', </div><div class="line">	//传递的数据</div><div class="line">				data:jsonobj,</div><div class="line">	//如果成功，返回数据</div><div class="line">				success:function(data)&#123;</div><div class="line">					</div><div class="line">					alert(data.username);</div><div class="line">				&#125;</div><div class="line">			&#125;)</div><div class="line">			</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	&lt;/script&gt;</div><div class="line"></div><div class="line">	 &lt;body&gt;</div><div class="line">  &lt;form action=""&gt;</div><div class="line">   &lt;input type="text" name="username1" onclick="requestjson();"/&gt;</div><div class="line">   &lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>后台代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("requestjson")</div><div class="line">	public @ResponseBody User requestjson(@RequestBody User user)&#123;</div><div class="line">		System.out.println(user.getSex());</div><div class="line">		</div><div class="line">		return user;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>此处声明了接受的参数和返回的都是json数据格式</p>
<p>测试：在浏览器输入<a href="http://localhost:100/springmvc2/index.jsp" target="_blank" rel="external">http://localhost:100/springmvc2/index.jsp</a><br>通过点击文本，后台会打印参数，同时返回一个user对象给前台，并显示出来</p>
<p>pojo，后台返回json<br>前台请求数据构造：key=value&amp;key=value.<br>首先是页面<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">				type:'POST',</div><div class="line">				url:'&lt;%=path%&gt;/user/requestjson1.do',</div><div class="line">				data:'username=lol&amp;address=zwl',</div><div class="line">				success:function(data)&#123;</div><div class="line">					</div><div class="line">					alert(data.username);</div><div class="line">				&#125;</div><div class="line">			&#125;)</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">后台代码：</div><div class="line">@RequestMapping("requestjson1")</div><div class="line">	public @ResponseBody User requestjson1(User user)&#123;</div><div class="line">		System.out.println(user.getAddress());</div><div class="line">		</div><div class="line">		return user;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>最后在springmvc中配置的前两个设配器，我们可以通过一个注解声明代替</p>
<blockquote>
<p><mvc:annotation-driven></mvc:annotation-driven></p>
</blockquote>
<p>不仅如此，它还自动包括了json数据格式声明等等<br>即默认创建注解处理器映射器，注解处理器适配器。提供json格式支持。</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[spring mvc之三:注解开发]]></title>
      <url>http://www.myzwl.win/2017/03/19/springmvc3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我们都是通过xml方式显示配置，会发现配置起来特别麻烦。当使用注解时，有时只需在相关类中做相关的声明，就能完成同样的工作。</p>
<p>不多说：先来一个注解开发例子</p>
<p>步骤一：首先创建一个web工程</p>
<p>步骤二：添加jar包</p>
<p>步骤三：配置web.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt;</div><div class="line">  </div><div class="line">  &lt;filter&gt;</div><div class="line">  &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line">  &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">  &lt;init-param&gt;</div><div class="line">  &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line">  &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line">  &lt;/init-param&gt;</div><div class="line">  &lt;/filter&gt;</div><div class="line">  </div><div class="line">  &lt;filter-mapping&gt;</div><div class="line">  &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">  &lt;/filter-mapping&gt;</div><div class="line">  </div><div class="line">  &lt;servlet&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">  &lt;!-- 默认加载方式</div><div class="line">  	   默认加载必须规范：</div><div class="line">  	   * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml</div><div class="line">  	   * 路径规范：必须在WEB-INF目录下面</div><div class="line">   --&gt;</div><div class="line"> &lt;/servlet&gt;</div><div class="line">  </div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>步骤四：配置springmvc-servlet.xml文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt;</div><div class="line">		</div><div class="line">		&lt;!--  扫描基本的父包，这样子类包被自动扫到执行 --&gt;</div><div class="line">		&lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt;</div><div class="line">		</div><div class="line">	&lt;!-- 配置注解处理器映射器 </div><div class="line">			功能：寻找执行类Controller</div><div class="line">		--&gt;</div><div class="line"></div><div class="line">		 &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt;</div><div class="line">		&lt;!-- 配置注解处理器适配器 </div><div class="line">			功能：调用controller方法，执行controller</div><div class="line">		--&gt;</div><div class="line"></div><div class="line">		&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;</div><div class="line">		&lt;/bean&gt;</div><div class="line">		&lt;!-- 配置sprigmvc视图解析器：解析逻辑试图 </div><div class="line">			 后台返回逻辑试图：index</div><div class="line">			视图解析器解析出真正物理视图：前缀+逻辑试图+后缀====/WEB-INF/jsps/index.jsp</div><div class="line">		--&gt;</div><div class="line">		&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;</div><div class="line">		&lt;property name="prefix" value="/"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;		</div><div class="line">		&lt;/bean&gt;</div><div class="line">		&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>这里简要说明一下，以上是注解最基本的配置，有扫描配置，两个基本配置和一个视图配置</p>
<p>步骤五：自定义controller类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import org.springframework.stereotype.Controller;</div><div class="line">import org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"></div><div class="line">@Controller  //相当于&lt;bean class="Usercontrol"/&gt;并且声明这是一个controller</div><div class="line">public class Usercontrol &#123;</div><div class="line"></div><div class="line">	@RequestMapping("hello") //相当于需要访问的路径hello.do</div><div class="line">	public String say()&#123;</div><div class="line">		return "index" ;  //放回到逻辑视图index.jsp</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个最简化的注解配置<br>对应index.jsp<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> &lt;body&gt;</div><div class="line">hello 盲僧</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：浏览器中输入<a href="http://localhost:100/springmvc2/hello.do" target="_blank" rel="external">http://localhost:100/springmvc2/hello.do</a></p>
<p>对应输出结果</p>
<blockquote>
<p>hello 盲僧</p>
</blockquote>
<h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h4><p>它有三种方式，分别为</p>
<blockquote>
<p>requestMapping(“hello”)<br>requestMapping(“/hello.do”)<br>requestMapping(value=”/hello.do”)</p>
</blockquote>
<p>都能达到同样的效果，都是需要访问的路径<br>如果在类前面添加此属性，则相当于映射路径在加一层<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Controller <span class="comment">//&lt;bean class="Usercontrol"/&gt;</span></div><div class="line">@RequestMapping(<span class="string">"/test"</span>)</div><div class="line">public class Usercontrol &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>即<a href="http://localhost:100/springmvc2/test/hello.do" target="_blank" rel="external">http://localhost:100/springmvc2/test/hello.do</a></p>
<p>另外，注意下里面还有个method配置，即按什么模式接受表单</p>
<blockquote>
<p>@RequestMapping(value=”/hello.do”,method=RequestMethod.GET)</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>@RequestMapping(value=”/hello.do”,method=RequestMethod.POST)</p>
</blockquote>
<p>默认是两个都可以的</p>
<blockquote>
<p>requestMapping(value=”/hello.do”,method={RequestMethod.POST, RequestMethod.GET})</p>
</blockquote>
<h4 id="封装参数"><a href="#封装参数" class="headerlink" title="封装参数"></a>封装参数</h4><p>分析接受参数类型：<br>基本类型，int，String等等基本类型。<br>Pojo类型<br>包装类型<br>Springmvc参数封装：基于方法进行封装。</p>
<p>一：基本类型<br> 封装int型参数<br>页面<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  &lt;body&gt;</div><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/ test/recieve.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">id：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"id"</span> id=<span class="string">"id"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>接受参数方法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recieve")</div><div class="line">	public String recieve(Integer id)&#123;</div><div class="line">		System.out.println(id);</div><div class="line">  return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>注意这里的Integer id必须要与页面中的name=”id”一致才能正确接受参数</p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc2/index.jsp" target="_blank" rel="external">http://localhost:100/springmvc2/index.jsp</a></p>
<p>然后输入id，后台即可接收到参数</p>
<p>接受字符转类型<br>页面：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/ test/recievestr.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">id：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"name"</span> id=<span class="string">"name"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>接收参数方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recievestr")</div><div class="line">	public String recievestr(String name)&#123;</div><div class="line">		System.out.println(name);</div><div class="line">		  return "login";&#125;</div></pre></td></tr></table></figure></p>
<p>接受数组：<br>分析：批量：checkbox复选框。Value必须有值<br>页面：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/test/recievearray.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">ID：&lt;<span class="selector-tag">input</span> type=<span class="string">"checkbox"</span> name=<span class="string">"ids"</span> value=<span class="string">"1"</span> id=<span class="string">"ids"</span>&gt;</div><div class="line">ID：&lt;<span class="selector-tag">input</span> type=<span class="string">"checkbox"</span> name=<span class="string">"ids"</span> value=<span class="string">"2"</span> id=<span class="string">"ids"</span>&gt;</div><div class="line">ID：&lt;<span class="selector-tag">input</span> type=<span class="string">"checkbox"</span> name=<span class="string">"ids"</span> value=<span class="string">"3"</span> id=<span class="string">"ids"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>接受参数的方法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recievearray")</div><div class="line">	public String recievearray(Integer []ids)&#123;</div><div class="line">		System.out.println(ids);</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>接受pojo类<br>页面：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/test/recieveUser.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">姓名：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"username"</span> id=<span class="string">"username"</span>&gt;</div><div class="line">生日：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"birthday"</span> id=<span class="string">"birthday"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>Pojo类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">	</div><div class="line">	private String username;</div><div class="line">	private Date birthday;</div><div class="line"></div><div class="line">此处省略set。Get方法&#125;</div></pre></td></tr></table></figure></p>
<p>接受参数的方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recieveUser")</div><div class="line">	public String recievearray(User user)&#123;</div><div class="line">		System.out.println(user.getUsername());</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>接受包装类型参数<br> 包装pojo类</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Usercus &#123;</div><div class="line">	private User user;</div><div class="line">此处省略set。Get方法。&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/usercus.do" method="post"&gt;</div><div class="line">姓名：&lt;input type="text" name="user.username" id="username"&gt;</div><div class="line">生日：&lt;input type="text" name="user.birthday" id="birthday"&gt;</div><div class="line">&lt;input type="submit" value="提交"&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">接受参数的方法：</div><div class="line">@RequestMapping("usercus")</div><div class="line">	public String usercus(Usercus user)&#123;</div><div class="line">		System.out.println(user.getUser().getUsername());</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>接受集合类型参数<br> 接受list集合<br>首先在包装类中加入如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private List&lt;User&gt; userlist;</div><div class="line">此处省略set，get方法</div><div class="line"></div><div class="line">然后是页面</div><div class="line">&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/recievelist.do" method="post"&gt;</div><div class="line">姓名：&lt;input type="text" name="userList[0].username" id="username"&gt;</div><div class="line">地址：&lt;input type="text" name="userList[0].address" id="address"&gt;</div><div class="line"></div><div class="line">姓名：&lt;input type="text" name="userList[1].username" id="username"&gt;</div><div class="line">地址：&lt;input type="text" name="userList[1].address" id="address"&gt;</div><div class="line">&lt;input type="submit" value="提交"&gt;</div><div class="line"></div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">接受参数方法：</div><div class="line">@RequestMapping("recievelist")</div><div class="line">	public String recievelist(Usercus userlist)</div><div class="line">	&#123;</div><div class="line">		System.out.println(userlist.getUserlist().get(0).getUsername());</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[spring mvc之二:处理器]]></title>
      <url>http://www.myzwl.win/2017/03/18/springmvc2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在spring mvc中，使用映射处理器可以把web请求映射到正确的处理器上，spring内置了很多映射器，而且我们也可以自定义处理器，映射处理器都能把请求传递到处理器执行链接上，并且处理器执行链接必须包含能处理该请求的处理器，而且处理器链接也能包含一系列拦截器<br>  接下来就是一些常见的处理映射器</p>
<h4 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h4><p> 功能：寻找Controller<br>        根据url请求去匹配bean的name属性url，从而获取Controller<br>      这里注意：这是默认的映射器，也就是说我们不配置这个，也能自动执行这个<br>     如：入门程序中的案例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置自定义Controler --&gt;</div><div class="line">		&lt;bean id=<span class="string">"mycontrol"</span> name=<span class="string">"/hello.do"</span> class=<span class="string">"com.zwl.control.mycontrol"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p> 即根据自定义的/hello.do，找到对应的mycontrol.java类</p>
<h4 id="SimpleUrlHandlerMaping"><a href="#SimpleUrlHandlerMaping" class="headerlink" title="SimpleUrlHandlerMaping"></a>SimpleUrlHandlerMaping</h4><p> 功能：寻找Controller<br>      根据浏览器url匹配简单url的key，key又Controller的id找到Controller<br>如：在映射文件中配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</div><div class="line">		&lt;property name=<span class="string">"mappings"</span>&gt;</div><div class="line">		&lt;props&gt;</div><div class="line">		&lt;prop key=<span class="string">"zwl.do"</span>&gt;mycontrol&lt;/prop&gt;</div><div class="line">		&lt;prop key=<span class="string">"slycmiaoxi.do"</span>&gt;mycontrol&lt;/prop&gt;</div><div class="line">		&lt;/props&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;/bean&gt;</div><div class="line"></div><div class="line">		   &lt;!-- 配置自定义Controler --&gt;</div><div class="line">		&lt;bean id=<span class="string">"mycontrol"</span>  class=<span class="string">"com.zwl.control.mycontrol"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器输入<a href="http://localhost:100/springmvc1/zwl.do或者http://localhost:100/springmvc1/slycmiaoxi.do" target="_blank" rel="external">http://localhost:100/springmvc1/zwl.do或者http://localhost:100/springmvc1/slycmiaoxi.do</a></p>
<p>输出结果：</p>
<blockquote>
<p>hello world</p>
</blockquote>
<p>此外：这个映射器是把url进行集中配置</p>
<h4 id="ControllerClassNameHandlerMapping"><a href="#ControllerClassNameHandlerMapping" class="headerlink" title="ControllerClassNameHandlerMapping"></a>ControllerClassNameHandlerMapping</h4><p>功能：寻找Controller<br>       根据类名（Mycontrol）类名.do来访问,类名首字母小写<br>在配置文件中增加如下配置</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 定义通过: 类名<span class="selector-class">.do</span> 形式来访问controller --&gt;</div><div class="line">		 &lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>注意，这里并没有声明mycontrol.do和只有一个类mycontrol.java</p>
<p>测试：在浏览器输入<a href="http://localhost:100/springmvc1/mycontrol.do" target="_blank" rel="external">http://localhost:100/springmvc1/mycontrol.do</a><br>结果：</p>
<blockquote>
<p>hello world</p>
</blockquote>
<p>事实上，以上三个映射器都可以同时存在</p>
<p>下面将是处理器适配器</p>
<h4 id="SimpleControllerHandlerAdapter"><a href="#SimpleControllerHandlerAdapter" class="headerlink" title="SimpleControllerHandlerAdapter"></a>SimpleControllerHandlerAdapter</h4><p>功能：执行controller<br>      调用controller里面方法，返回modelAndView。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置处理器适配器执行Controlelr ,springmvc默认的</div><div class="line">		SimpleControllerHandlerAdapter:执行Controller</div><div class="line">		--&gt;</div><div class="line">		&lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h4 id="HttpRequestHandlerAdapter"><a href="#HttpRequestHandlerAdapter" class="headerlink" title="HttpRequestHandlerAdapter"></a>HttpRequestHandlerAdapter</h4><p>功能：执行controller<br>首先新建一个类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import javax.servlet.ServletException;</div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import org.springframework.web.HttpRequestHandler;</div><div class="line"></div><div class="line">public class httpcontrol implements HttpRequestHandler &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void handleRequest(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line">		       request.setCharacterEncoding("utf-8");</div><div class="line">		     //给Request设置值，在页面进行回显</div><div class="line">		       request.setAttribute("hello", "lol");</div><div class="line">		       response.setCharacterEncoding("utf-8");</div><div class="line">		     //跳转页面</div><div class="line">		       request.getRequestDispatcher("/index.jsp").forward(request, response);;</div><div class="line"> </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在配置文件中配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!-- HttpRequestHandlerAdapter负责执行实现接口HttpRequestHandler的后端</div><div class="line">			 控制器。</div><div class="line">		 --&gt;</div><div class="line">		&lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"</span>&gt;&lt;/bean&gt;</div><div class="line">		</div><div class="line">		&lt;!-- 配置自定义HttpController --&gt;</div><div class="line">		&lt;bean id=<span class="string">"http"</span> class=<span class="string">"com.zwl.control.httpcontrol"</span>&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">		&lt;prop key=<span class="string">"/zwl.do"</span>&gt;http&lt;/prop&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入：<a href="http://localhost:100/springmvc1/zwl.do" target="_blank" rel="external">http://localhost:100/springmvc1/zwl.do</a></p>
<p>输出结果：</p>
<blockquote>
<p>lol</p>
</blockquote>
<p>注意这两个处理器设配器可以共存！</p>
<h4 id="命令控制器"><a href="#命令控制器" class="headerlink" title="命令控制器"></a>命令控制器</h4><p>Spring mvc通过命令设计模式接受页面参数。</p>
<p>自定义命令控制器<br>首先新建一个pojo类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pojo;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line">private int id;</div><div class="line">private String username;</div><div class="line">public int getId() &#123;</div><div class="line">	return id;</div><div class="line">&#125;</div><div class="line">public String getUsername() &#123;</div><div class="line">	return username;</div><div class="line">&#125;</div><div class="line">public void setId(int id) &#123;</div><div class="line">	this.id = id;</div><div class="line">&#125;</div><div class="line">public void setUsername(String username) &#123;</div><div class="line">	this.username = username;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自定义控制器<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import org.springframework.validation.BindException;</div><div class="line">import org.springframework.web.servlet.ModelAndView;</div><div class="line">import org.springframework.web.servlet.config.MvcNamespaceHandler;</div><div class="line">import org.springframework.web.servlet.mvc.AbstractCommandController;</div><div class="line"></div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public class CommandController extends AbstractCommandController &#123;</div><div class="line"></div><div class="line">	//指定参数绑定哪个pojo类</div><div class="line">		public CommandController()&#123;</div><div class="line">			</div><div class="line">			this.setCommandClass(User.class);</div><div class="line">			</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected ModelAndView handle(HttpServletRequest request,</div><div class="line">			HttpServletResponse response, Object command, BindException error)</div><div class="line">			throws Exception &#123;</div><div class="line">		//将命令对象强转成用户对象</div><div class="line">		User user=(User)command;</div><div class="line">		ModelAndView mv=new ModelAndView();</div><div class="line">		mv.addObject("user",user);</div><div class="line">        mv.setViewName("index");	</div><div class="line">		return mv;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>封装参数页面（这里是login.jsp）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  &lt;body&gt;</div><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/command.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">姓名：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"username"</span> id=<span class="string">"username"</span>&gt;</div><div class="line">id：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"id"</span> id=<span class="string">"id"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>配置bean<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=<span class="string">"/command.do"</span> class=<span class="string">"com.zwl.control.CommandController"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>回显数据：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> &lt;body&gt;</div><div class="line"> $&#123;user<span class="selector-class">.username</span> &#125; &lt;br&gt;</div><div class="line">$&#123;user<span class="selector-class">.id</span> &#125; &lt;br&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc1/login.jsp到login.jsp" target="_blank" rel="external">http://localhost:100/springmvc1/login.jsp到login.jsp</a><br>然后分别将name输入中文和非中文，发现出现中文乱码</p>
<p>需要Spring编码过滤器：在web.xml配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line"> &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line"> &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line"> &lt;init-param&gt;</div><div class="line"> &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line"> &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line"> &lt;/init-param&gt;</div><div class="line"> &lt;/filter&gt;</div><div class="line"> </div><div class="line"> &lt;filter-mapping&gt;</div><div class="line"> &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line"> &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line"> &lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>然后输入中文，就没有乱码了</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring mvc之一:hello world]]></title>
      <url>http://www.myzwl.win/2017/03/17/springmvc1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MVC模式是Model-View-Control的简写，而spring mvc主要负责c层，主要为封装web请求为一个数据对象、调用业务逻辑层来处理数据对象、返回处理数据结果及相应的视图给用户</p>
<p>简要概述spring mvc：<br>   SpringC层框架的核心是DispatcherServlet，它的作用是将请求分发给不同的后端处理器，springC层框架使用了后端控制器、映射处理器和视图解析器来共同完成c层的主要任务，真正的把业务层处理的数据结果和相应的视图拼成一个对象，即ModelAndView对象</p>
<p>下面以hello world为入门程序搭建环境<br>步骤一：创建一个web工程</p>
<p>步骤二：导入相关jar包<br><img src="/images/imgs2/16.gif" alt="Alt text"></p>
<p>步骤三：编写web.xml配置文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt;</div><div class="line"></div><div class="line">  &lt;servlet&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet</div><div class="line">&lt;/servlet-class&gt;</div><div class="line"> &lt;/servlet&gt;</div><div class="line">  </div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>简要说明一下：dispatcherservlet就是一个servlet，也是对请求进行转发的核心servlet。在这里即所有的.do的请求将首先被dispatcherservlet处理，而它要做的工作就是对请求进行分发（即把请求转发给具体的controller），可以简单的认为，他就是一个总控处理器，除此之外，它还能使用spring的其他功能<br>同时注意一下上面的servlet-name<br>默认加载方式<br>         默认加载必须规范：</p>
<pre><code>* 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml
* 路径规范：必须在WEB-INF目录下面
</code></pre><p> 步骤四：配置springmvc-servlet.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt;</div><div class="line">		</div><div class="line">		</div><div class="line">		&lt;!-- 配置处理器映射器,springmvc默认的处理器映射器</div><div class="line">		BeanNameUrlHandlerMapping：根据bean(自定义Controler)的name属性的url去寻找hanler(Action:Controller)</div><div class="line">		 --&gt;</div><div class="line">		&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt;</div><div class="line">	 	</div><div class="line">		&lt;!-- 配置处理器适配器执行Controlelr ,springmvc默认的</div><div class="line">		SimpleControllerHandlerAdapter:执行Controller</div><div class="line">		--&gt;</div><div class="line">		&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt;</div><div class="line">		</div><div class="line">		&lt;!-- 配置自定义Controler --&gt;</div><div class="line">		&lt;bean id="mycontrol" name="/hello.do" class="com.zwl.control.mycontrol"&gt;&lt;/bean&gt;</div><div class="line">		</div><div class="line">	</div><div class="line">		&lt;!-- 配置sprigmvc视图解析器：解析逻辑试图 </div><div class="line">			 后台返回逻辑试图：index</div><div class="line">			视图解析器解析出真正物理视图：前缀+逻辑试图+后缀--&gt;</div><div class="line"></div><div class="line">		&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;</div><div class="line">		&lt;property name="prefix" value="/"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;		</div><div class="line">		&lt;/bean&gt;</div><div class="line">		&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>步骤五：自定义controller<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import org.springframework.web.servlet.ModelAndView;</div><div class="line">import org.springframework.web.servlet.mvc.Controller;</div><div class="line"></div><div class="line">public class mycontrol implements Controller &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public ModelAndView handleRequest(HttpServletRequest arg0,</div><div class="line">			HttpServletResponse arg1) throws Exception &#123;</div><div class="line">		//接受请求，参数，验证参数</div><div class="line">		//封装参数，调用业务方法</div><div class="line">		//返回视图</div><div class="line">		ModelAndView mv=new ModelAndView();</div><div class="line">		</div><div class="line">		//设置页面回显数据</div><div class="line">		mv.addObject("hello","hello world");</div><div class="line">		//指定跳转的视图</div><div class="line">		//返回物理视图</div><div class="line">        mv.setViewName("index");	</div><div class="line">		return mv;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤六：定义视图页面<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">   $&#123;hello&#125;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc1/hello.do" target="_blank" rel="external">http://localhost:100/springmvc1/hello.do</a></p>
<p>结果：</p>
<blockquote>
<p>hello world </p>
</blockquote>
<p>简要分析入门程序的过程<br>1 启动服务器，根据web.xml的配置加载前端控制器dispatcherservlet。在加载时，会完成一系列的初始化动作。</p>
<p>2 根据servlet的映射请求（上面的.do），并参照spingmvc-servlet.xml文件，把具体的请求分发给特定的后端处理器，如上面的mycontrol</p>
<p>3 后端控制器调用相应的逻辑层代码，完成处理并返回视图对象ModelAndView给前端处理器</p>
<p>4 前端处理器根据后端控制器返回的ModelAndView对象，返回一个相应的页面给客户端</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring之装配bean]]></title>
      <url>http://www.myzwl.win/2017/03/16/spring2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在spring中，对象无需自己负责查找或创建与其关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象，例如一个消费系统需要信誉证件，但它不需要自己创建，它只负责自己两手空空，而容器就赋予它一个信用卡认证组件。<br>  通常，我们将创建应用对象间相互协作关系的行为称为装配。这也是依赖注入的本质。</p>
<h4 id="一：声明bean"><a href="#一：声明bean" class="headerlink" title="一：声明bean"></a>一：声明bean</h4><p>  首先我们假想一个选秀场景，该bean为一个表演接口<br>  public interface Performe {<br>    public void perform();<br>}<br>很显然我们需要一些参赛者，而这些参赛者就需要spring帮我们创建了</p>
<h4 id="二：创建spring配置"><a href="#二：创建spring配置" class="headerlink" title="二：创建spring配置"></a>二：创建spring配置</h4><p>   Spring是一个基于容器的框架，但是如果我们不对他进行任何配置，那么它就相当于一个空框架，一般情况下有采用XML或者注解式声明，这里都采用xml形式。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">		xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">		xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<h4 id="三：声明一个简单的bean"><a href="#三：声明一个简单的bean" class="headerlink" title="三：声明一个简单的bean"></a>三：声明一个简单的bean</h4><p>  这次表演者可以使各种各样的人，首先是一个杂技师。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Juggler implements Performe &#123;</div><div class="line"></div><div class="line">	private int bigbang=5;</div><div class="line">	</div><div class="line">	public Juggler()&#123;	</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Juggler(int bigbang)&#123;</div><div class="line">		this.bigbang=bigbang;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void perform() &#123;</div><div class="line">		System.out.println("it is "+bigbang);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要打印出杂技师扔了多少块Bigbang；</p>
<p>接下来在spring中配置bean，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;bean id=<span class="string">"juggle"</span> class=<span class="string">"com.zwl.dao.Juggler"</span>&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>这是一个最简单的声明格式<br>接下来就是加载spring上下文，进行测试</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Juggler hello=(Juggler) ApplicaionContextUtil.getApplicationContext().getBean("juggle");</div><div class="line">		hello.perform();</div></pre></td></tr></table></figure>
<p>ApplicaionContextUtil.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private static ApplicationContext ac=null;</div><div class="line"></div><div class="line">private ApplicaionContextUtil()&#123;		</div><div class="line">&#125;</div><div class="line">static&#123;</div><div class="line">	ac=new ClassPathXmlApplicationContext("applicationContext.xml");</div><div class="line">&#125;</div><div class="line">public static ApplicationContext getApplicationContext()&#123;</div><div class="line">	return ac;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<blockquote>
<p>it is 5</p>
</blockquote>
<h4 id="四：通过构造器注入"><a href="#四：通过构造器注入" class="headerlink" title="四：通过构造器注入"></a>四：通过构造器注入</h4><p> 有时候我们需要通过构造方法进行注入<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"juggle"</span> class=<span class="string">"com.zwl.dao.Juggler"</span>&gt;</div><div class="line">&lt;constructor-arg value=<span class="string">"66"</span>&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>因为Juggle有一个代参和无参构造函数，默认不配置constructor-arg则是默认构造函数，相反则是代参构造函数，</p>
<p>构造器注入对象引用<br> 上面是注入的基本类型，如果是一个对象了？<br> 在Juggler类中增加如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private Helloworld helloworld;</div><div class="line">	</div><div class="line">	public Juggler(Helloworld helloworld)&#123;</div><div class="line">		this.helloworld=helloworld;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">public void perform() &#123;</div><div class="line">		System.out.println("it is "+bigbang);</div><div class="line">		helloworld.sayhello();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>其中helloworld为入门时的程序</p>
<p>接下来就是配置文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.spring.Helloworld"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"name"</span>&gt;</div><div class="line">&lt;value&gt;hello world!&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt; </div><div class="line"></div><div class="line">&lt;bean id=<span class="string">"juggle"</span> class=<span class="string">"com.zwl.dao.Juggler"</span>&gt;</div><div class="line">&lt;constructor-arg ref=<span class="string">"helloworld"</span>&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>其中ref为注入另一个bean的id<br>测试结果：</p>
<blockquote>
<p>it is 5<br>it is hello world</p>
</blockquote>
<h4 id="五：bean的作用域"><a href="#五：bean的作用域" class="headerlink" title="五：bean的作用域"></a>五：bean的作用域</h4><p>  所有的spring bean默认都是单例，即它总是返回同一个bean实例，通过在bean中的scope属性进行设置，一般有如下属性<br>  Singleton 在每一个spring容器中，一个bean定义只对应一个对象实例（默认）<br>  Prototype  允许bean的定义可以被实例化任意次（每次调用都创建一个实例）<br>  另外还有request，session，global-session，一般只用前两者<br>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Helloworld hello=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld");</div><div class="line">		Helloworld hello1=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld");</div><div class="line">		System.out.println(hello==hello1);</div></pre></td></tr></table></figure></p>
<p>当采用默认scope时，测试结果为true</p>
<p>当进行如下修改时<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.spring.Helloworld"</span> scope=<span class="string">"prototype"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>测试结果为false</p>
<p>另外在我们初始化和销毁bean时，需要在bean中配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.spring.Helloworld"</span> scope=<span class="string">"prototype"</span> init-method=<span class="string">"sayhello"</span> destroy-method=<span class="string">"saybyb"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>其中sayhello与saybyb都是该类中方法，当在调用该bean之前，调用init-method，而在该bean销毁前，即生命周期结束前实现destroy-method，</p>
<h4 id="六：注入bean属性"><a href="#六：注入bean属性" class="headerlink" title="六：注入bean属性"></a>六：注入bean属性</h4><p>   通常，javabean的属性时私有的，同时拥有一组set与get方法取出该属性，spring可以借助set配置属性的值<br>   注意，这里和利用构造器的注入差不多<br>   如注入简单值<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"name"</span> value=<span class="string">"hello world"</span>&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>引用其他bean<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"hello"</span> ref=<span class="string">"helloworld"</span>&gt;&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>其中name中的值是该bean中的属性，名字要一致，而ref是该配置文件中的其他bean</p>
<h4 id="七：装配集合"><a href="#七：装配集合" class="headerlink" title="七：装配集合"></a>七：装配集合</h4><p>  前面我们都是介绍单个对象的装配，对于复合类型该如何装配了<br> 不妨模拟一个案例<br>首相是一个Student类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package com.zwl.spring;</div><div class="line"></div><div class="line">public class Student &#123;</div><div class="line"></div><div class="line">	private String name;</div><div class="line"></div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是School类，主要有的属性为集合，首先是list<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class School &#123;</div><div class="line"></div><div class="line">	private List&lt;Student&gt; stulist;</div><div class="line">	</div><div class="line">	public List&lt;Student&gt; getStulist() &#123;</div><div class="line">		return stulist;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setStulist(List&lt;Student&gt; stulist) &#123;</div><div class="line">		this.stulist = stulist;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置的bean<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"stu"</span> class=<span class="string">"com.zwl.spring.Student"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"name"</span> value=<span class="string">"hello"</span>&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id=<span class="string">"stu1"</span> class=<span class="string">"com.zwl.spring.Student"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"name"</span> value=<span class="string">"world"</span>&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>简要说明一下，这里注入同一个类的不同bean，用于装入集合<br>然后是配置school<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"sch"</span> class=<span class="string">"com.zwl.spring.School"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"stulist"</span>&gt;</div><div class="line">&lt;list&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu"</span>/&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu1"</span>/&gt;</div><div class="line">&lt;/list&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>一般格式如下，属性下，配置<list>和要引入的bean</list></p>
<p>测试代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch");</div><div class="line">		String name1=hello.getStulist().get(0).getName();</div><div class="line">		String name=hello.getStulist().get(1).getName();</div><div class="line">		System.out.println(name1+name);</div></pre></td></tr></table></figure></p>
<p>测试结果:</p>
<blockquote>
<p>helloworld</p>
</blockquote>
<p>Set集合装配<br> 首先在school类中加入如下属性<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> private Set&lt;Student&gt; stuset;</div><div class="line">省略set与get方法</div></pre></td></tr></table></figure></p>
<p>配置文件，添加如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"stuset"</span>&gt;</div><div class="line">&lt;set&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu"</span>/&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu1"</span>/&gt;</div><div class="line">&lt;/set&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>对应测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch");</div><div class="line">	Iterator&lt;Student&gt; it=hello.getStuset().iterator();</div><div class="line">	while(it.hasNext())&#123;</div><div class="line">		Student stu=it.next();</div><div class="line">		System.out.println(stu.getName());</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这里通过迭代器取出对象<br>测试结果：</p>
<blockquote>
<p>hello<br>world</p>
</blockquote>
<p>Map集合装配<br> 首先在school中添加如下属性：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private Map&lt;String, Student&gt; stumap;</div><div class="line">省略set与get方法。。</div></pre></td></tr></table></figure></p>
<p>配置文件，添加如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"stumap"</span>&gt;</div><div class="line">&lt;map&gt;</div><div class="line">&lt;entry key=<span class="string">"11"</span> value-ref=<span class="string">"stu"</span>&gt;&lt;/entry&gt;</div><div class="line">&lt;entry key=<span class="string">"22"</span> value-ref=<span class="string">"stu1"</span>&gt;&lt;/entry&gt;</div><div class="line">&lt;/map&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>其中，key为map的索引值，而value-ref为引用的bean<br>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch");</div><div class="line">		String name=hello.getStumap().get("11").getName();</div><div class="line">		String name1=hello.getStumap().get("22").getName();</div><div class="line">		System.out.println(name+name1);</div></pre></td></tr></table></figure></p>
<p>测试结果:</p>
<blockquote>
<p>helloworld</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring之hello world]]></title>
      <url>http://www.myzwl.win/2017/03/15/spring1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> spring 是容器框架,用于配置bean,并维护bean之间关系的框架，而bean是java中的任何一种对象 javabean/service/action/数据源./dao, ioc(控制反转 inverse of control) di( dependency injection 依赖注入)，而spring的设计思想主要为单例和工厂模式，它能很好的解耦，简化开发，同时贯穿于各层。</p>
<p> 不多说，先来一个入门案例，目的在先具体把握，最后在看细节</p>
<p> 步骤一：创建一个web工程，同时引入两个jar包，一个是spring核心包（spring.jar）和日包（commons-logging.jar）及测试包junit；</p>
<p> 步骤二：新建applicationContent.xml文件，该文件是spring的核心文件，先放在src目录下，里面暂时什么都不写</p>
<p> 步骤三：编写helloworld类：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.zwl.spring;</div><div class="line"></div><div class="line">public class Helloworld &#123;</div><div class="line">private String name;</div><div class="line"></div><div class="line">public String getName() &#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setName(String name) &#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">public void sayhello()&#123;</div><div class="line">	System.out.println("it is "+name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要通过spring自动注入name为helloworld来演示</p>
<p>步骤四：配置applicationContent.xml文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">		xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">		xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;</div><div class="line"></div><div class="line">&lt;!-- bean元素的作用是，当我们的spring框架加载时候，spring就会自动的创建一个bean对象，并放入内存 ,</div><div class="line">相当于Helloworld helloworld=new Helloworld();</div><div class="line">helloworld.setName("helloworld!"); </div><div class="line">id:用于唯一标识该bean，</div><div class="line">class:相应的bean所处的位置</div><div class="line">--&gt;</div><div class="line">&lt;bean id="helloworld" class="com.zwl.spring.Helloworld"&gt;</div><div class="line">&lt;property name="name"&gt;</div><div class="line">&lt;value&gt;hello world!&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>步骤五：编写工具类<br>因为spring也是初始化加载很耗内存，所以同样采取单例模式初始化<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utils;</div><div class="line"></div><div class="line">import org.springframework.context.ApplicationContext;</div><div class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line">public class ApplicaionContextUtil &#123;</div><div class="line">private static ApplicationContext ac=null;</div><div class="line">	</div><div class="line">	private ApplicaionContextUtil()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	static&#123;</div><div class="line">		//1.得到spring 的applicationContext对象(容器对象)</div><div class="line">		ac=new ClassPathXmlApplicationContext("applicationContext.xml");</div><div class="line">	&#125;</div><div class="line">	public static ApplicationContext getApplicationContext()&#123;</div><div class="line">		return ac;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤六：编写测试类（用junit4）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">	public void test()&#123;</div><div class="line">//得到bean对象</div><div class="line">	 Helloworld hello=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld");</div><div class="line">	 hello.sayhello();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>it is hello world ！</p>
</blockquote>
<p>至此helloworld程序完成，当然这只是一个初步的认识spring是什么，事实上spring的注入远不止如此简单，但至少有一点可以明确，通过spring，可以帮我们管理，特别是结合其他开源框架，达到解耦和高效的作用。</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代理模式（四）之模仿spring Aop及真实jdk的动态代理]]></title>
      <url>http://www.myzwl.win/2017/03/14/dyproxy3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式，尤其是动态代理，他从思想上改变了我们对编程的认识，可以想象一个切面我们在其中添加任何控制如事务、日志、权限等，而这也是面向切面编程的核心，更是spring Aop的核心，而设计才是实用的，框架和配置都是虚的，尤其当抛开jdk底层代码设计，才发现其中的来龙去脉和乐趣。</p>
<p>总之，动态代理设计模式的思想太强大了。接下来将用之前模拟的jdk动态代码和jdk本身自带的动态来模拟一个案例</p>
<p>大概物理情景是，添加一个打野信息接口和打野代理，利用InvocationHandler实现代理对具体打野的代理</p>
<p>首先是一个打野接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line"></div><div class="line">public interface JungleInfo &#123;</div><div class="line"></div><div class="line">	public void addJungle();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打野接口实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line"></div><div class="line">public class JungleInfoimpl implements JungleInfo &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void addJungle() &#123;</div><div class="line">		System.out.println("Js is ganking");</div><div class="line">		System.out.println("Leesin is ganking");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打野代理<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line"></div><div class="line">import java.lang.reflect.Method;</div><div class="line"></div><div class="line">public class JungleHandler implements InvocationHandler &#123;</div><div class="line"></div><div class="line">private Object target;</div><div class="line">	</div><div class="line">	public JungleHandler(Object target) &#123;</div><div class="line">		super();</div><div class="line">		this.target = target;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void invoke(Object o, Method m) &#123;</div><div class="line">		//控制之前的业务逻辑</div><div class="line">		System.out.println("JungleHandler is starting");</div><div class="line">		try &#123;</div><div class="line">			m.invoke(target);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		//控制之后的业务逻辑</div><div class="line">		System.out.println("JungleHandler is ending");</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了方便这里只是打印了一个语句<br>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">      //被代理对象</div><div class="line">      JungleInfo jun=new JungleInfoimpl();</div><div class="line">      //代理类</div><div class="line">InvocationHandler invo=new JungleHandler(jun);</div><div class="line">JungleInfo jung=(JungleInfo) Proxy.newProxyInstance(JungleInfo.class, invo);</div><div class="line">jung.addJungle();</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>JungleHandler is starting<br>Js is ganking<br>Leesin is ganking<br>JungleHandler is ending</p>
</blockquote>
<p>至此我们发现如果我们想在这个切面中再加一个控制，好办，再写一个handle类，代理其它handle类，达到切面控制效果。<br>当然，以后只要实现InvocationHandler接口就能达到效果，而proxy底层都不需要知道</p>
<h3 id="jdk的动态代理"><a href="#jdk的动态代理" class="headerlink" title="jdk的动态代理"></a>jdk的动态代理</h3><p>同样是上面的例子，知识代理handler需要改变</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">     package com.zwl.pr;</div><div class="line"></div><div class="line">import java.lang.reflect.InvocationHandler;</div><div class="line">import java.lang.reflect.Method;</div><div class="line"></div><div class="line">public class JungleHandlers implements InvocationHandler &#123;</div><div class="line"></div><div class="line">	</div><div class="line">private Object target;</div><div class="line">	</div><div class="line">	public JungleHandlers(Object target) &#123;</div><div class="line">		super();</div><div class="line">		this.target = target;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public Object invoke(Object proxy, Method method, Object[] args)</div><div class="line">			throws Throwable &#123;</div><div class="line">		System.out.println("Jdk is starting");</div><div class="line">		method.invoke(target, args);</div><div class="line">		System.out.println("Jdk is ending");</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中Object proxy是指代理类，Method method是指被代理的方法，Object[] args为该方法的参数数组</p>
<p>接下来是测试类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">      JungleInfo jun=new JungleInfoimpl();</div><div class="line">JungleHandlers invo=new JungleHandlers(jun);</div><div class="line">JungleInfo jung=(JungleInfo) Proxy.newProxyInstance(JungleInfo.class.getClassLoader(),new Class&lt;?&gt;[]&#123;JungleInfo.class&#125;,  invo);</div><div class="line">jung.addJungle();</div></pre></td></tr></table></figure>
<p>其中jung将返回一个代理类的实例JungleInfo.class.getClassLoader()是类装载器，第二个参数是任何真实类拥有的全部接口的数组，第三个参数就是真实的handles</p>
<p>测试结果：</p>
<blockquote>
<p>Jdk is starting<br>Js is ganking<br>Leesin is ganking<br>Jdk is ending</p>
</blockquote>
<p>至此，我们利用动态代理，就可以在不修改原来代码的基础上，就可以在原来代码的基础上做操作，而这恰恰就是AOP编程的核心</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代理模式（三）之模仿jdk底层动态代理实现]]></title>
      <url>http://www.myzwl.win/2017/03/13/dyproxy2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面的基础上在做进一步的改进，前面我们是动态写死了方法，即自己指定了方法名，当然我们可以利用反射帮我们完成函数名的动态指定</p>
<p>首先是一个反射例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//拿到相应的类</div><div class="line">Method[]  methods=com.zwl.pr.Jungle.class.getMethods();</div><div class="line">		for(Method method: methods)&#123;</div><div class="line">		//循环输出该类的函数名，如public void ss();最后只输出ss</div><div class="line">			System.out.println(method.getName());</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>有了这个原理就可以对之前的proxy进行改造</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">public static Object newProxyInstance(Class interfac) throws Exception&#123;</div><div class="line">      </div><div class="line">      //动态拿到方法的代码</div><div class="line">		String methodStr = "";</div><div class="line">		String rt = "\r\n";</div><div class="line">		</div><div class="line">		//将指定的动态接口类名拿到</div><div class="line">		Method[] methods = interfac.getMethods();</div><div class="line"></div><div class="line">		//循环添加方法</div><div class="line">		for(Method m : methods) &#123;</div><div class="line">			methodStr += "@Override" + rt + </div><div class="line">						 "public void " + m.getName() + "() &#123;" + rt +</div><div class="line">						 	"   long start = System.currentTimeMillis();" + rt +</div><div class="line">							"   leesin." + m.getName() + "();" + rt +</div><div class="line">							"   long end = System.currentTimeMillis();" + rt +</div><div class="line">							"   System.out.println(\"time:\" + (end-start));" + rt +</div><div class="line">						 "&#125;";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line"></div><div class="line">				"public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"Jungle leesin;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(Jungle leesin) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.leesin = leesin;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line">          //这里循环动态输出方法</div><div class="line">					methodStr +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line"></div><div class="line">		//这里将动态生成的代理文件放到指定文件夹中，避免与bin里的.class文件冲突</div><div class="line">		String filename=</div><div class="line">				"E:/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div><div class="line"></div><div class="line">		   //compile</div><div class="line">				JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">				StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">				Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">				CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">				t.call();</div><div class="line">				fileMgr.close();</div><div class="line">				</div><div class="line">				//load into memory and create an instance</div><div class="line">				//更改到指定文件夹</div><div class="line">				URL[] urls = new URL[] &#123;new URL("file:/" + "E:/src/")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div><div class="line">				</div><div class="line">				Constructor ctr = c.getConstructor(Jungle.class);</div><div class="line">				</div><div class="line">				//返回任意一个类</div><div class="line">				Object jungle=ctr.newInstance(new LeeSin());</div><div class="line">				</div><div class="line">		</div><div class="line">		return jungle;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<pre><code>注意这里和之前做了几处修改
1.利用反射动态生成方法
2.更改编译后生成文件的目录
3.返回类型为object
4具体在代码里有注释

测试类：
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class);</div><div class="line">		jungle.gank();</div></pre></td></tr></table></figure>
</code></pre><p>输出结果</p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>LeeSin is ganking…<br>gank time:1336<br>time:1336</p>
</blockquote>
<p>这里很明显发现方法都是固定的，如果想要方法都是动态生成的，则要进行进一步修改<br>首先增加一个<br>InvocationHandler动态生成类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface InvocationHandler &#123;</div><div class="line">	public void invoke(Object o, Method m);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是具体的针对所有接口的时间处理类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class TimeHandler implements InvocationHandler &#123;</div><div class="line"></div><div class="line">   //代理类</div><div class="line">	private Object target;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	public TimeHandler(Object target) &#123;</div><div class="line">		super();</div><div class="line">		this.target = target;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void invoke(Object o, Method m) &#123;</div><div class="line">		long start = System.currentTimeMillis();</div><div class="line">		try &#123;</div><div class="line">			//指定代理类的动态方法</div><div class="line">			m.invoke(target);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		long end = System.currentTimeMillis();</div><div class="line">		System.out.println("time:" + (end-start));</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后proxy里也要进行相应修改</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//参数分别为被代理对象与代理对象</div><div class="line">public static Object newProxyInstance(Class interfac,InvocationHandler h) throws Exception&#123;</div><div class="line">		String methodStr = "";</div><div class="line">		String rt = "\r\n";</div><div class="line">		</div><div class="line">		Method[] methods = interfac.getMethods();</div><div class="line">		</div><div class="line">	//动态生成方法，其中this是指代理对象本身，而md是指方法名，这里的h是构造函数传的代理对象</div><div class="line">		for(Method m : methods) &#123;</div><div class="line">			methodStr += "@Override" + rt + </div><div class="line">						 "public void " + m.getName() + "() &#123;" + rt +</div><div class="line">						 "    try &#123;" + rt +</div><div class="line">						 "    Method md = " + interfac.getName() + ".class.getMethod(\"" + m.getName() + "\");" + rt +</div><div class="line">						 "    h.invoke(this, md);" + rt +</div><div class="line">						 "    &#125;catch(Exception e) &#123;e.printStackTrace();&#125;" + rt +</div><div class="line">						</div><div class="line">						 "&#125;";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line">               "import java.lang.reflect.Method;" + rt +</div><div class="line">				"public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"com.zwl.pr.InvocationHandler h;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(InvocationHandler h) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.h = h;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line"></div><div class="line">					methodStr +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line">		String filename=</div><div class="line">				"E:/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div><div class="line"></div><div class="line">		   //compile</div><div class="line">				JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">				StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">				Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">				CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">				t.call();</div><div class="line">				fileMgr.close();</div><div class="line">				</div><div class="line">				//load into memory and create an instance</div><div class="line">				URL[] urls = new URL[] &#123;new URL("file:/" + "E:/src/")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div><div class="line">				</div><div class="line">				//返回代理类</div><div class="line">				Constructor ctr = c.getConstructor(InvocationHandler.class);</div><div class="line">				</div><div class="line">				Object jungle=ctr.newInstance(h);</div><div class="line">				</div><div class="line">		</div><div class="line">		return jungle;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//被代理对象</div><div class="line">LeeSin leesin=new LeeSin();</div><div class="line">//代理对象</div><div class="line">		InvocationHandler ivo=new TimeHandler(leesin);</div><div class="line">		Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class,ivo);</div><div class="line">		jungle.gank();</div></pre></td></tr></table></figure>
<p>对应生成的java文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line">import java.lang.reflect.Method;</div><div class="line">public class LeeSinTimeProxy implements com.zwl.pr.Jungle&#123;</div><div class="line">com.zwl.pr.InvocationHandler h;</div><div class="line">public LeeSinTimeProxy(InvocationHandler h) &#123;</div><div class="line">super();</div><div class="line">this.h = h;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public void gank() &#123;</div><div class="line">    try &#123;</div><div class="line">    Method md = com.zwl.pr.Jungle.class.getMethod("gank");</div><div class="line">    h.invoke(this, md);</div><div class="line">    &#125;catch(Exception e) &#123;e.printStackTrace();&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>对应的测试结果 </p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>LeeSin is ganking…<br>gank time:2642<br>time:2642</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代理模式（二）之初识动态代理]]></title>
      <url>http://www.myzwl.win/2017/03/12/dyproxy1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我们通过静态代理可以在编译期创建一个代理对象，如果要求我们必须在运行时创建一个代理，如时间代理，如何做了？<br>也就是说，需要写一个代理（proxy），然后我们只需要传入相关接口，它就可以主动生成代理对象</p>
<p>再一次使用之前的情景，即有一个打野对象接口和具体打野盲僧，然后编写一个针对打野的动态代理（proxy），只要传入（打野接口对象），就可以动态自动生成该java文件，并且载入内存并不jvm编译</p>
<p>下面就是其代码实现</p>
<p>Jungle（打野接口）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">  //打野gank方法</div><div class="line">	public void gank();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LeeSin（盲僧）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		//gank开始时间</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		System.out.println("LeeSin is ganking...");</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			//gank进行中</div><div class="line">			Thread.sleep(new Random().nextInt(10000));</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		//gank结束时间</div><div class="line">        long ends=System.currentTimeMillis();</div><div class="line">        System.out.println("gank time:"+(ends-starts));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果想要动态生成一个事件代理（按常理应该新建一个代理类），按照动态思想，我们将该创建该类的所以涉及的代码赋给一个字符串<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">String str=</div><div class="line">		"package com.zwl.pr;" +</div><div class="line"></div><div class="line">		"public class LeeSinTimeProxy implements Jungle &#123;" +</div><div class="line"></div><div class="line">			</div><div class="line">			"Jungle leesin;" +</div><div class="line">			</div><div class="line">			</div><div class="line">			"public LeeSinTimeProxy(Jungle leesin) &#123;" +</div><div class="line">				"super();" +</div><div class="line">				"this.leesin = leesin;" +</div><div class="line">			"&#125;" +</div><div class="line"></div><div class="line"></div><div class="line">			"@Override" +</div><div class="line">			"public void gank() &#123;" +</div><div class="line">				"long starts=System.currentTimeMillis();" +</div><div class="line">				"leesin.gank();" +</div><div class="line">				 "long ends=System.currentTimeMillis();" +</div><div class="line">			      "  System.out.println(\"gank time:\"+(ends-starts));" +</div><div class="line"></div><div class="line">			"&#125;" +</div><div class="line"></div><div class="line">		"&#125;" ;</div></pre></td></tr></table></figure></p>
<p>上面字符串就是创建该代理的代码，然后如果jvm能自动将其编译成.class并且载入内存，就是一个真的类了，按照这种思想，我们可以通过jvm提供的方法完成<br>为了方便先把上述动态创建时间代理放在测试中（也就是main函数中）<br>1.首先将代码格式修整一下，即加个换行，同时将字符写入时间代理文件中<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> //换行，防止所有代码全部挤在一行</div><div class="line">String rt = "\r\n";</div><div class="line"></div><div class="line">//要动态生成的类的代码</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line"></div><div class="line">				"public class LeeSinTimeProxy implements Jungle &#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"Jungle leesin;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(Jungle leesin) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.leesin = leesin;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line"></div><div class="line">					"@Override" + rt +</div><div class="line">					"public void gank() &#123;" + rt +</div><div class="line">						"long starts=System.currentTimeMillis();" + rt +</div><div class="line">						"leesin.gank();" + rt +</div><div class="line">						 "long ends=System.currentTimeMillis();" + rt +</div><div class="line">					      "  System.out.println(\"gank time:\"+(ends-starts));" + rt +</div><div class="line"></div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		//得到该项目的根路径</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line"></div><div class="line">		//该时间代理文件的完整路径，不存在则创建（第一次自动动态创建）</div><div class="line">		String filename=System.getProperty("user.dir")+</div><div class="line">				"/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		//将字符写入该文件</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div></pre></td></tr></table></figure></p>
<p>这里先一小段一小段的加，目前是已经在该包下生成一个LeeSinTimeProxy.java文件，并且里面有被写入的字符，但是纯粹只是一个文件，因为还没被编译和载入内存</p>
<p>2.进行编译<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">            //compile</div><div class="line">            //得到java编译器，也就是javac了，至此我们可以最终将其编译，得到.class（二进制文件）</div><div class="line">JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">           //管理编译文件，默认为空就行</div><div class="line">StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">//所有编译的文件，目前就一个，当然可以传入多个</div><div class="line">Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">//编译任务管理，目前传入上面两个参数，其余默认为空就行</div><div class="line">CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">//执行任务编译</div><div class="line">t.call();</div><div class="line">fileMgr.close();</div></pre></td></tr></table></figure></p>
<p>至此，在包下也动态生成了一个.class文件，而平常我们编译时都会在path路径下，jdk主动生成.class，而此时我们自己指定了位置</p>
<p>3.载入内存<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//指定载入内存的url</div><div class="line">URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir")+"/src")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">//指定class文件载入</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div></pre></td></tr></table></figure></p>
<p>4.利用反射取出实例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//反射取出类</div><div class="line">Constructor ctr = c.getConstructor(Jungle.class);</div><div class="line">				</div><div class="line">		//操作该类相应方法，此处是动态返回类</div><div class="line">				Jungle jubgle= (Jungle) ctr.newInstance(new LeeSin());</div><div class="line">				//调用gank方法</div><div class="line">				jubgle.gank();</div></pre></td></tr></table></figure>
<p>以下是结果：</p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>LeeSin is ganking…<br>gank time:7557<br>gank time:7563</p>
</blockquote>
<p>至此算是动态生成了时间代理，但是目前是很有局限性的，因为我们指定了一个特定接口，而不是泛指，当然通过这个例子，也算是初识了一把动态模式的魅力，当然它的最大魅力，在于制定任何接口，返回相应的代理类</p>
<p>在这里我们先将测试的类中代码移至Proxy类中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class Proxy &#123;</div><div class="line"> </div><div class="line"> //这里的interfac就是动态指定了任何接口代理，而且必须取它的名字，否则是执行其tostring方法</div><div class="line">	public static Object newProxyInstance(Class interfac) throws Exception&#123;</div><div class="line">		String rt = "\r\n";</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line"></div><div class="line">				"public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"Jungle leesin;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(Jungle leesin) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.leesin = leesin;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line"></div><div class="line">					"@Override" + rt +</div><div class="line">					"public void gank() &#123;" + rt +</div><div class="line">						"long starts=System.currentTimeMillis();" + rt +</div><div class="line">						"leesin.gank();" + rt +</div><div class="line">						 "long ends=System.currentTimeMillis();" + rt +</div><div class="line">					      "  System.out.println(\"gank time:\"+(ends-starts));" + rt +</div><div class="line"></div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line">		String filename=System.getProperty("user.dir")+</div><div class="line">				"/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div><div class="line"></div><div class="line">		   //compile</div><div class="line">				JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">				StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">				Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">				CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">				t.call();</div><div class="line">				fileMgr.close();</div><div class="line">				</div><div class="line">				//load into memory and create an instance</div><div class="line">				URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir")+"/src")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div><div class="line">				</div><div class="line">				Constructor ctr = c.getConstructor(Jungle.class);</div><div class="line">				</div><div class="line">				Jungle jubgle= (Jungle) ctr.newInstance(new LeeSin());</div><div class="line">				jubgle.gank();</div><div class="line">		</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目前先不管错误，在做测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      LeeSin leesin=new LeeSin();</div><div class="line">Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class);</div><div class="line">jungle.gank();</div></pre></td></tr></table></figure></p>
<p>这里参数我们可以设置任何class接口，当然先不管错误，至少动态代理算是成功了。</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代理模式（一）之静态代理]]></title>
      <url>http://www.myzwl.win/2017/03/11/stproxy/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式从定义上说就是给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用</p>
<p>一般情况下，我们可以通过继承或者聚合来实现代理，当然继承会造成类爆炸，而聚合则更灵活<br>不多说，模拟一个静态代理的情景<br>假设打野是一个接口，有gank方法，记录打野行为，打野具体对象盲僧，实现其gank的时间并记录下来，然后后续打野盲僧1、盲僧2分别记录打野具体对象的gank时间和gank日志（目前打野对象为LeeSin）</p>
<p>Jungle（打野接口）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">  //打野gank方法</div><div class="line">	public void gank();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LeeSin（盲僧）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		//gank开始时间</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		System.out.println("LeeSin is ganking...");</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			//gank进行中</div><div class="line">			Thread.sleep(new Random().nextInt(10000));</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		//gank结束时间</div><div class="line">        long ends=System.currentTimeMillis();</div><div class="line">        System.out.println("gank time:"+(ends-starts));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是使用代理对象，比如用一个代理记录打野gank方法的时间<br>不妨先用继承（与后面聚合比较会发现继承将造成类爆炸）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//时间代理，记录gank时间</div><div class="line">public class LeeSin1 extends LeeSin &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		super.gank();</div><div class="line">		 long ends=System.currentTimeMillis();</div><div class="line">	        System.out.println("gank time:"+(ends-starts));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这时再有一个log代理，记录gank日志<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class LeeSin2 extends LeeSin &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		System.out.println("LeeSin starts ganking");</div><div class="line">		super.gank();</div><div class="line">		System.out.println("LeeSin ends ganking");		 </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果这时说先记录日志在记录时间或者先记录时间在记录日志，这时就要写两个类<br>列出主体代码（另一个调换位置）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">@Override</div><div class="line">public void gank() &#123;</div><div class="line">	System.out.println("LeeSin starts ganking");</div><div class="line">	long starts=System.currentTimeMillis();</div><div class="line">	super.gank();</div><div class="line">	 long ends=System.currentTimeMillis();</div><div class="line">        System.out.println("gank time:"+(ends-starts));</div><div class="line">        System.out.println("LeeSin ends ganking");	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能目前代理类较少，还没有缺陷，如果是100个甚至更多，只要稍微要求下顺序或者其他，就要增加一个类，显然造成类爆炸，所以继承代理不可取</p>
<p>利用聚合代理（因为被代理类都是继承或者实现Jungle，所以可以用jungle代理，知识子类行为不同而已<br>打野时间代理类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class LeeSinTimeProxy implements Jungle &#123;</div><div class="line"></div><div class="line">	//代理对象</div><div class="line">	Jungle leesin;</div><div class="line">	</div><div class="line">	</div><div class="line">	public LeeSinTimeProxy(Jungle leesin) &#123;</div><div class="line">		super();</div><div class="line">		this.leesin = leesin;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		leesin.gank();</div><div class="line">		 long ends=System.currentTimeMillis();</div><div class="line">	        System.out.println("gank time:"+(ends-starts));</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>日志代理<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSinlogProxy implements Jungle &#123;</div><div class="line"></div><div class="line">	</div><div class="line">	Jungle leesin;</div><div class="line">	</div><div class="line">	</div><div class="line">	public LeeSinlogProxy(Jungle leesin) &#123;</div><div class="line">		super();</div><div class="line">		this.leesin = leesin;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		System.out.println("LeeSin starts ganking");</div><div class="line">		leesin.gank();</div><div class="line">		System.out.println("LeeSin ends ganking");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		LeeSin leesin=new LeeSin();</div><div class="line">		</div><div class="line">		Jungle jungletime=new LeeSinTimeProxy(leesin);</div><div class="line">		Jungle junglelog=new LeeSinlogProxy(jungletime);</div><div class="line">		junglelog.gank();</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>LeeSin starts ganking<br>LeeSin is ganking…<br>gank time:1005<br>gank time:1005<br>LeeSin ends ganking</p>
</blockquote>
<p>注意这里是日志代理时间，时间代理盲僧，如果更改顺序，只需改变被代理对象即可<br><img src="/images/imgs2/15.gif" alt="Alt text"></p>
<p>至此我们可以简单归纳一下静态代理<br>大概有抽象角色：如打野  ，代理角色（被聚合类的引用），以及真实角色</p>
<p>最后不得不提的是静态代理虽然简单，但是有很多局限性，比如它是在编译期由我们主动创建的，也就说在程序运行前已经存在在.class文件中了，如果代理类一旦多的话，代理内容就无法复用，新增方法时，代理对象也要跟着增加方法。</p>
<p>所以代理设计模式真正的魅力和强大之处而是动态代理！！</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[抽象工厂设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/10/abstractfactory/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>抽象工厂方法通俗的讲就是为创建一组相关或相互依赖的对象提供一组接口，无需指定他们的具体类。因此，他们通常为创建一族产品对象，并且该产品由不同等级划分。</p>
<p>这里还是以之前的例子为例，假设有一个产生top（上单）的机器，另一个产生Jungle（打野）的机器，同时top可以有ad（物理上单）和ap(法术上单)，同样，Jungle可以有ad和ap打野，现在需要一个工厂，可以同时产生仅含ad的打野和上单，另一个产生仅含ap的打野和上单，当然可以按照自己的组合<br><img src="/images/imgs2/13.gif" alt="Alt text"><br>打野</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line"></div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ad打野</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class AdJungle implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ap打野<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ApJungle implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上单<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface Top &#123;</div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ad上单<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class AdTop implements Top &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ap上单<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ApTop implements Top &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生产打野和上单的工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface AbstractFactory &#123;</div><div class="line">public Top factorytop();</div><div class="line">public Jungle factoryjungle();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生产ad打野和上单的工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class AdFactory implements AbstractFactory &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Top factorytop() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new AdTop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle factoryjungle() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new AdJungle();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生产ap打野和上单的工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ApFactory implements AbstractFactory &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Top factorytop() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new ApTop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle factoryjungle() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new ApJungle();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过上面例子，我们可以发现抽象工厂易于交换产品系列，通过按需改变具体工厂从而使用不同的产品配置，同时它也将创建实例的过程与客户端分类</p>
<p>当然它的缺点就是和简单工厂一样，如果要从sql server切换到mysql，需要重新实例很多次</p>
<p>最后对应工厂系列的设计模式，无论选择哪一个，最终的目的都是为了解耦！</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[观察者设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/10/observer/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观察者模式从定义上说就是一种一对多的依赖关系，即当一个对象的状态发生改变时，其它依赖此对象的对象会得到通知并且做出相应的改变。一般有“推”模型和“拉”模型，前者是被观察者将所有信息通知所有人，而后者则是被观察者不主动提供信息，观察者主动索要信息</p>
<p>在这里还是以之前的例子为例</p>
<p><img src="/images/imgs2/14.gif" alt="Alt text"></p>
<p>这是一个推模型，也就是被观察者根据状态发生改变时将所有信息都主动通知观察者<br>其中：Jungle（打野）是被观察者，即如果有一些状态变化，如对方打野有动作则将通知observer（目前假定只有上路和adc）<br>observer：观察者，用来监听被观察者并且根据相应的变化做出变化<br>top：上单  adc：Adc LesSin：打野盲僧<br>以下是相关代码：</p>
<p>Jungle（被观察者）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">     </div><div class="line">     //增加观察者</div><div class="line">	public void addObserve(Observer obs);</div><div class="line">	 //删除观察者</div><div class="line">	public void deleteObserve(Observer obs);</div><div class="line">	 //通知观察者</div><div class="line">	public void notifyObserve(String msg);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>observer（观察者）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Observer &#123;</div><div class="line">   //收到通知后状态变化</div><div class="line">	public void notifybyJungle(String msg);</div><div class="line">&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LeeSin<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line">   //存放所有的观察者</div><div class="line">	List&lt;Observer&gt; list=new ArrayList&lt;Observer&gt;();</div><div class="line">	</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void addObserve(Observer obs) &#123;</div><div class="line">		list.add(obs);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void deleteObserve(Observer obs) &#123;</div><div class="line">		list.remove(obs);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void notifyObserve(String msg) &#123;</div><div class="line">		for(Observer obs : list)&#123;</div><div class="line">			obs.notifybyJungle(msg);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>top<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class top implements Observer &#123;</div><div class="line"> </div><div class="line"> //收到消息</div><div class="line">	public String newmsg;</div><div class="line">	</div><div class="line">	public String getNewmsg() &#123;</div><div class="line">		return newmsg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setNewmsg(String newmsg) &#123;</div><div class="line">		this.newmsg = newmsg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void notifybyJungle(String msg) &#123;</div><div class="line">		newmsg=msg;</div><div class="line">		System.out.println("上单收到:"+newmsg);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Adc<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Adc implements Observer &#123;</div><div class="line"></div><div class="line">public String newmsg;</div><div class="line">	</div><div class="line">	public String getNewmsg() &#123;</div><div class="line">		return newmsg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setNewmsg(String newmsg) &#123;</div><div class="line">		this.newmsg = newmsg;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void notifybyJungle(String msg) &#123;</div><div class="line">		newmsg=msg;</div><div class="line">		System.out.println("adc收到:"+newmsg);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		Jungle jungle=new LeeSin();</div><div class="line">		</div><div class="line">		Observer obs1=new Adc();</div><div class="line">		</div><div class="line">		Observer obs2=new top();</div><div class="line">		</div><div class="line">		jungle.addObserve(obs1);</div><div class="line">		jungle.addObserve(obs2);</div><div class="line">		</div><div class="line">		jungle.notifyObserve("敌方打野正在打小龙");</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下面是输出结果</p>
<blockquote>
<p>adc收到:敌方打野正在打小龙<br>上单收到:敌方打野正在打小龙</p>
</blockquote>
<p>如果我们使用拉模型，即观察者主动向被观察者索要信息，那么上面程序将做部分修改</p>
<p>大体思路就是将Jungle（被观察者）的通知函数改为void即<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">     </div><div class="line">     //增加观察者</div><div class="line">	public void addObserve(Observer obs);</div><div class="line">	 //删除观察者</div><div class="line">	public void deleteObserve(Observer obs);</div><div class="line">	 //通知观察者</div><div class="line">	public void notifyObserve();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相应的observer将更改为<br>observer（观察者）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Observer &#123;</div><div class="line">   //收到通知后状态变化</div><div class="line">	public void notifybyJungle(Jungle jungle);</div><div class="line">&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于推与拉模型，如果目标角色过于复杂，则优先使用推模式，反之则使用拉模式</p>
<p>观察者模式应用场景<br>1、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变</p>
<p>2、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[工厂方法设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/09/factory/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工厂方法模式又被称为多态工厂模式，通俗的讲就是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中，因此，也属于创建型模式</p>
<p><img src="/images/imgs2/12.gif" alt="Alt text"><br>这里Jungle的每个具体类都对应一个具体工厂<br>下面就是以工厂方法创建它们，通过抽象工厂选择不同的具体子工厂，从而产生不同的具体打野类</p>
<p>打野接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//打野英雄</div><div class="line">public interface Jungle &#123;</div><div class="line"></div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>工厂接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface junglefactor &#123;</div><div class="line">//产生打野</div><div class="line">public Jungle createjungle();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>盲僧</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("盲僧正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("盲僧太灵活了");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("盲僧正在打野怪");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剑圣</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Js implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("剑圣正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("js也灵活");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("剑圣正在打野");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>盲僧工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class LeeSinFactory implements junglefactor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle createjungle() &#123;</div><div class="line">		</div><div class="line">		return new LeeSin();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">剑圣工厂</div><div class="line">``` stylus</div><div class="line">public class JsFactory implements junglefactor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle createjungle() &#123;</div><div class="line">		</div><div class="line">		return new Js();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">测试类：</div><div class="line">``` stylus</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		// Jungle jungle= JungleFactory.createJungle("LeeSin");</div><div class="line">		// jungle.gankenemy();</div><div class="line"></div><div class="line">      junglefactor factory=new LeeSinFactory();</div><div class="line">    Jungle jubjle=factory.createjungle();</div><div class="line">    jubjle.flexible();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这里通过多态，产生不同的工厂，从而产生不同的打野</p>
<p>工厂方法比较简单工厂模式</p>
<p>现在我们要是把打野对象由盲僧换成剑圣的话，利用简单工厂，那就要<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Jungle jungle= JungleFactory.createJungle("Js");</div><div class="line">``` </div><div class="line">如果是100或者更多的话，那就要重复上述代码那么多次</div><div class="line"></div><div class="line">但是如果采用工厂方法，只需要改一处</div><div class="line">```stylus</div><div class="line">junglefactor factory=new JsFactory();</div></pre></td></tr></table></figure></p>
<p>显然对外扩展开放，对内修改关闭更好。而简单工厂则违背了该原则</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单工厂设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/08/simplefactory/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单工厂模式又叫静态工厂设计模式。通俗的讲，就是通过专门定义一个类来负责建立其他类的实例，与此同时被创建的类都必须满足他们有共同的父类，所以，它是一种创建型模式。</p>
<p><img src="/images/imgs2/11.gif" alt="Alt text"><br>这里Leesin（盲僧）与Js（剑圣）继承Jungle（打野），而JungleFactory（打野生产工厂）产生具体打野对象<br>下面将以简单工厂创建他们，满足通过传入打野工厂不同的参数，产生不同的打野对象</p>
<p>打野接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//打野英雄</div><div class="line">public interface Jungle &#123;</div><div class="line"></div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>盲僧</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("盲僧正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("盲僧太灵活了");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("盲僧正在打野怪");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剑圣</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Js implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("剑圣正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("js也灵活");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("剑圣正在打野");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打野工厂</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class JungleFactory &#123;</div><div class="line"></div><div class="line">	public static Jungle createJungle(String Junglename)&#123;</div><div class="line">		 Jungle jungle=null;</div><div class="line">		 switch(Junglename)&#123;</div><div class="line">		 case "LeeSin":</div><div class="line">			 jungle=new LeeSin();</div><div class="line">			 break;</div><div class="line">		 case "Js" :</div><div class="line">			 jungle=new Js();</div><div class="line">			 break;</div><div class="line">		 default :</div><div class="line">			  break;</div><div class="line">		 </div><div class="line">		 &#125;</div><div class="line">		return jungle;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是测试类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		Jungle jungle= JungleFactory.createJungle("LeeSin");</div><div class="line">		jungle.gankenemy();</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>当然，我们这里通过不同的参数，获得不同的打野英雄<br>当然这个例子也很好理解简单工厂</p>
<p>事实上，我们知道如果我们一开始用的是sql server数据库，然后我们想换数据库，如果不用工厂模式，那么将替换许多东西，如果这时，使用简单工厂模式，就会使问题变简单许多。</p>
<p>利用简单工厂模式大概思路就是先创建一个抽象数据库(DBobject)，然后是具体实现类sql server与mysql类，然后再来一个生成数据库工厂(DBobjectFactory)通过传入不同的数据库参数，从而连接不同的数据库</p>
<p>至此我们发现，简单工厂的优点在于工厂类中包含了必要的逻辑判断，而且可以根据客户端的选择条件不同而动态的实例化相关的类</p>
<p>当然它的缺点也很明显，当我们创建的抽象实例过多时，显然高内聚就增多了，不利于维护了</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[职责链设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/07/filter/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 职责链，通俗地讲就是把责任处理对象连城一条链，这样当一个处理对象不能及时处理的时候就会交给下一个处理对象直到被处理为止。就好比生活中，我们有事向学校请假，得找班主任签字同意，然后有些时候需要院里签字，甚至教务处，最后将假条交给同学，最后在给相应授课老师，可能这个例子还不太准确，但是总之经过一些列流程，最后才会处理。</p>
<p>当然，在程序中，最常见的就是过滤关键字了，首先模拟一下非web下的责任链</p>
<p><strong>首先定义一个过滤接口</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Filter &#123;</div><div class="line">	String doFilter(String str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>接下来就是各式各样的过滤字</strong><br>敏感字过滤</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SesitiveFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String doFilter(String str) &#123;</div><div class="line">		//第一个参数是非法字符，第二个参数是被替换的字符</div><div class="line">		String r = str.replace("瞎子", "李青")</div><div class="line">			 .replace("小学僧", "盲僧");</div><div class="line">		</div><div class="line">		return r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>过滤html标签</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class HTMLFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String doFilter(String str) &#123;</div><div class="line">	//&lt;&gt;被替换成[]</div><div class="line">		String r = str.replace('&lt;', '[')</div><div class="line">				   .replace('&gt;', ']');</div><div class="line">		return r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>过滤链:将过滤器串成一个链，并保存过滤后的字</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class FilterChain implements Filter &#123;</div><div class="line">     //保存所有的具体过滤器</div><div class="line">	List&lt;Filter&gt; filters=new ArrayList&lt;Filter&gt;();</div><div class="line">	</div><div class="line">    //过滤器串成链</div><div class="line">	public FilterChain addFilter(Filter f)</div><div class="line">	&#123;</div><div class="line">		this.filters.add(f);</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">  //返回过滤后的字符</div><div class="line">	@Override</div><div class="line">	public String doFilter(String str) &#123;</div><div class="line">		String r=str;</div><div class="line">		for(Filter f:filters)&#123;</div><div class="line">			r=f.doFilter(r);</div><div class="line">		&#125;</div><div class="line">		return r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		String msg = "因为一个英雄而爱上了lol，他就是瞎子，虽然我是小学僧，但是我还是只坚信我的&lt;我的信仰&gt;英雄！！";</div><div class="line">		FilterChain fc = new FilterChain();</div><div class="line">		fc.addFilter(new SesitiveFilter())</div><div class="line">		  .addFilter(new HTMLFilter());</div><div class="line">		String result=fc.doFilter(msg);</div><div class="line">		System.out.println(result);</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>输出结果:</p>
<blockquote>
<p>因为一个英雄而爱上了lol，他就是李青，虽然我是盲僧，但是我还是只坚信我的[我的信仰]英雄！！</p>
</blockquote>
<h4 id="Web下责任链"><a href="#Web下责任链" class="headerlink" title="Web下责任链"></a>Web下责任链</h4><p>当然一般情况下，都是过滤web环境下的字符，大概思路跟非web下差不多</p>
<p>首先需要建立request和response对象，即接收和响应</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Request &#123;</div><div class="line">String requestStr;</div><div class="line"></div><div class="line">public String getRequestStr() &#123;</div><div class="line">	return requestStr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setRequestStr(String requestStr) &#123;</div><div class="line">	this.requestStr = requestStr;</div><div class="line">&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Response &#123;</div><div class="line">	 String responseStr;</div><div class="line">	public String getResponseStr() &#123;</div><div class="line">		return responseStr;</div><div class="line">	&#125;</div><div class="line">	public void setResponseStr(String responseStr) &#123;</div><div class="line">		this.responseStr = responseStr;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是Filter接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Filter &#123;</div><div class="line">	void doFilter(Request request, Response response, FilterChain chain);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>紧接着是filterchain类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class FilterChain implements Filter &#123;</div><div class="line">    //存放各种filter</div><div class="line">	List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();</div><div class="line">   </div><div class="line">    //控制filter的索引</div><div class="line">	int index = 0;</div><div class="line"></div><div class="line">    //添加filter</div><div class="line">	public FilterChain addFilter(Filter f) &#123;</div><div class="line">		this.filters.add(f);</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">//filter链，特别注意这里有一个迭代，与具体filter里的迭代相呼应</div><div class="line">//主要是依次先取出request的接受字符过滤，然后在倒叙依次取完response的响应过滤,而这恰恰是struts2框架原理的核心，当然spring mvc(直接基于servlet)也类似，都是基于拦截或者过滤实现的</div><div class="line">	@Override</div><div class="line">	public void doFilter(Request request, Response response, FilterChain chain) &#123;</div><div class="line">		// 过滤器取完退出</div><div class="line">if(index == filters.size()) return ;</div><div class="line">		</div><div class="line">	//依次取出过滤器</div><div class="line">		Filter f = filters.get(index);</div><div class="line">		index ++;</div><div class="line">		f.doFilter(request, response, chain);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就是具体的filter了（这里就是web中的真实拦截顺序了）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SesitiveFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void doFilter(Request request, Response response, FilterChain chain) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		request.requestStr = request.requestStr.replace("瞎子", "李青")</div><div class="line">				 .replace("小学僧", "盲僧") ;</div><div class="line">		chain.doFilter(request, response, chain);</div><div class="line">		response.responseStr += "SesitiveFilterresponse";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一个filter</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class HTMLFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void doFilter(Request request, Response response,FilterChain chain) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		request.requestStr = request.requestStr.replace('&lt;', '[')</div><div class="line">				   .replace('&gt;', ']') ;</div><div class="line">		</div><div class="line">		chain.doFilter(request, response, chain);</div><div class="line">		response.responseStr += "HTMLFilterresponse";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先附一张structs2原理图，来对比一下上述过滤过程<br><img src="/images/imgs2/9.gif" alt="Alt text"><br>主要关注action invocation中部分</p>
<p>测试类:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		String msg = "因为一个英雄而爱上了lol，他就是瞎子，虽然我是小学僧，但是我还是只坚信我的&lt;我的信仰&gt;英雄！！";</div><div class="line">		Request request = new Request();</div><div class="line">		request.setRequestStr(msg);</div><div class="line">		Response response = new Response();</div><div class="line">		response.setResponseStr("response");</div><div class="line">		FilterChain fc = new FilterChain();</div><div class="line">		fc.addFilter(new HTMLFilter())</div><div class="line">		  .addFilter(new SesitiveFilter())</div><div class="line">		  ;</div><div class="line">		</div><div class="line">		fc.doFilter(request, response, fc);</div><div class="line">		System.out.println(request.getRequestStr());</div><div class="line">		System.out.println(response.getResponseStr());</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>结果:</p>
<blockquote>
<p>因为一个英雄而爱上了lol，他就是李青，虽然我是盲僧，但是我还是只坚信我的[我的信仰]英雄！！<br>response–SesitiveFilterresponse–HTMLFilterresponse</p>
</blockquote>
<p>最后归纳一下责任链设计模式的一般形式<br><img src="/images/imgs2/10.gif" alt="Alt text"><br>分别为客户端、处理者和具体处理者</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[迭代器设计模式]]></title>
      <url>http://www.myzwl.win/2017/03/06/iterator/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 为什么会有迭代器？<br>当我们想要 遍历取出集合一组数据时，一般都是用for里面套着i循环，或者使用for（对象 x :某个集合)的形式取出，不过因为集合类型的不同，取出的形式也不同，但是当我们想要一种统一的方法去遍历集合时，就可以用迭代器去实现，说了那么多，不如来一个直观的例子。</p>
<p><img src="/images/imgs2/7.gif" alt="Alt text"><br>这里模仿Arraylist集合中的迭代器实现过程，其中<br>Iterator:执行递增遍历的接口<br>Collection:一些集合的上层接口<br>Arraylist: 目前只实现了add、size及迭代器<br>ArrayListIterator: 用于Arraylist的迭代器</p>
<p>Iterator接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;</div><div class="line">//取得下一个元素</div><div class="line">Object next();</div><div class="line">//检查有没有下一个元素</div><div class="line">boolean hasNext();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Collection接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Collection &#123;</div><div class="line">public void add(Object o);//增加一个对象</div><div class="line">public int size();//返回长度</div><div class="line">Iterator iterator();//内聚迭代器</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Arraylist类（这里ArrayListIterator是其内部类）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">package com.zwl.iterator;</div><div class="line"></div><div class="line">public class ArrayList implements Collection&#123;</div><div class="line">//默认都是初始化为10的</div><div class="line">Object objects[]=new Object[10];</div><div class="line">//默认集合长度都为0的</div><div class="line">int index=0;</div><div class="line"></div><div class="line">//增加方法</div><div class="line">public void add(Object o)&#123;</div><div class="line">//集合长度动态增长，每次都使其长度增加2倍，并且创建一个增长后的新数组</div><div class="line">//将旧数组先copy给新数组，在指向旧数组的引用</div><div class="line">//同时保证每添加一个对象，集合长度自增长，这样就不会出现越界情况</div><div class="line">	if(index==objects.length)&#123;</div><div class="line">		Object newobjects[]=new Object[objects.length*2];</div><div class="line">		System.arraycopy(objects, 0, newobjects, 0, objects.length);</div><div class="line">		objects=newobjects;</div><div class="line">	&#125;</div><div class="line">	objects[index]=o;</div><div class="line">	index++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回集合长度</div><div class="line">public int size()&#123;</div><div class="line">	return index;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//统一迭代器方法</div><div class="line">@Override</div><div class="line">public Iterator iterator() &#123;</div><div class="line">	// TODO Auto-generated method stub</div><div class="line">	return new ArrayListIterator();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//内部类，返回arraylist的专有迭代器</div><div class="line">private class ArrayListIterator implements Iterator&#123;</div><div class="line">    //取集合中对象的索引</div><div class="line">        private int currentIndex=0;</div><div class="line">    </div><div class="line">   //取出集合中当前索引的一个对象</div><div class="line">	@Override</div><div class="line">	public Object next() &#123;</div><div class="line">		Object o = objects[currentIndex];</div><div class="line">		currentIndex ++;</div><div class="line">		return o;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//判断集合是否含有下一个元素</div><div class="line">	@Override</div><div class="line">	public boolean hasNext() &#123;</div><div class="line">//索引值超出集合长度，集合中元素取完</div><div class="line">		if(currentIndex&gt;=index) return false;</div><div class="line">		else</div><div class="line">			return true;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		Collection al=new ArrayList();</div><div class="line">		</div><div class="line"> for(int i=0;i&lt;15;i++)&#123;</div><div class="line">	 al.add(new Object());</div><div class="line"> &#125;</div><div class="line"> System.out.println(al.size());</div><div class="line"> </div><div class="line"> Iterator it=al.iterator();</div><div class="line"> while(it.hasNext())&#123;</div><div class="line">	 Object o=it.next();</div><div class="line">	 System.out.println(o+"  ");</div><div class="line"> &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>至此，可以归纳一下迭代器设计模式的一般形式<br><img src="/images/imgs2/8.gif" alt="Alt text"></p>
<p>其中：<br>1：Iterator(迭代器) 参与者：<br> 定义访问和遍历元素的接口（如Iterator)</p>
<p>2.ConcreteIterator(具体迭代器)参与者<br>实现迭代器的接口(如ArrayListIterator)</p>
<p>3.Aggregate(聚合)参与者<br>定义建立Iterator参与者的接口(如Collection)</p>
<p>4.ConcreteAggregate（具体聚合）参与者<br>实现Aggregate所定义的接口（如Arraylist）</p>
<p>最后不得不提的是，无论一个集合实现的结果如何，都能使用iterator，此外，我们通过改变iterato，来增加各种iterator，如反向遍历，双向遍历（即，增加一个previous方法），只要注意一下currentInde和index就可以了</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jquery之ajax]]></title>
      <url>http://www.myzwl.win/2017/03/05/jqajax/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ajax ：异步请求，浏览器地址栏不改变，进行局部刷新</p>
<p>首先先来看一下ajax在浏览器与服务器之间的传输过程</p>
<p><img src="/images/imgs2/3.gif" alt="Alt text"></p>
<h4 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h4><p>jquery中有多种ajax请求，根据应用场景不同，选择的ajax不同</p>
<p><img src="/images/imgs2/4.gif" alt="Alt text"></p>
<ol>
<li><p>$.ajax(…) 最底层ajax请求，编写最复杂，完成功能最全的</p>
</li>
<li><p>load() 、$.get() 、$.post() </p>
</li>
<li><p>$.getJSON() 可以完成js“跨域”请求<br>域名：域名+端口+项目，js默认不能跨域请求</p>
</li>
</ol>
<ol>
<li>$.getScript()  动态加载js文件。</li>
</ol>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p><img src="/images/imgs2/5.gif" alt="Alt text"></p>
<h4 id="json解析"><a href="#json解析" class="headerlink" title="json解析"></a>json解析</h4><p><img src="/images/imgs2/6.gif" alt="Alt text"></p>
<p>下面将对上面部分进行模拟<br>首先是有一个按钮</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"button"</span> value=<span class="string">"发送ajax"</span> /&gt;</div></pre></td></tr></table></figure>
<p>然后在js中操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   // 请求路径，我这里是请求到一个servlet</div><div class="line">var url = "getajaxname";</div><div class="line">// 请求参数，采用json</div><div class="line">var params = &#123;"username":"盲僧", "password":"我的最爱"&#125;;</div></pre></td></tr></table></figure>
<p>接下来就是利用不同形式的ajax发送请求<br>1 load()函数 ，必须使用jquery对象</p>
<pre><code>* * 格式：load(url, [data], [callback])
*         参数1：url ，请求路径
*         参数2：data，请求参数
*         参数3：callback，回调函数
* * 如果没有请求参数，发送的GET请求
* * 如果有请求参数，发送的POST请求。请求没有中文乱码
* * 回调函数的参数
*         参数1：data，响应数据。load()永远获得字符串，如果需要使用，必须手动转换json对象。
*         
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(this).load(url,params,function(data)&#123;</div><div class="line">		//转换json对象</div><div class="line">		var jsonData = eval("("+data+")");</div><div class="line">		alert(jsonData.value);</div><div class="line">	&#125;);</div></pre></td></tr></table></figure>
<p>后台servlet，这里利用gson.jar包回送json数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">		response.setContentType("text/html,charset=utf-8");</div><div class="line">		PrintWriter out = response.getWriter();</div><div class="line">   String name= request.getParameter("username");</div><div class="line">      String age= request.getParameter("password");</div><div class="line">      System.out.println(name);</div><div class="line">      System.out.println(age);</div><div class="line">      /*out.println("ajax ok");*/</div><div class="line">      JsonObject json=new JsonObject();</div><div class="line">      json.addProperty("value", "ok");</div><div class="line">      response.getWriter().write(json.toString());</div><div class="line">		out.flush();</div><div class="line">		out.close();</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>我们可以通过火狐里的firebug进行测试和观察</p>
<p>2 $.get() 全局函数，发送get请求</p>
<pre><code>* * 格式：jQuery.get(url, [data], [callback], [type])
*         * 参数4：type ，返回内容格式，xml, html, script, json, text, _default。
* * GET请求不适合发送中文数据，存放请求的中文乱码。
*         必须手动解码   new String(username.getBytes(&quot;ISO-8859-1&quot;) ,&quot;UTF-8&quot;)
* * 响应数据，如果使用  application/json;charset=UTF-8 ，jQuery自动将数据转换json对象。
* * 响应数据，如果使用  text/html;charset=UTF-8 ，回调函数获得字符串数据，需要手动转换。
*         使用“参数4”，设置&quot;json&quot;，jQuery将字符串 转换成 json对象
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.get(url,params,function(data)&#123;</div><div class="line">		alert(data.value);</div><div class="line">	&#125;,"json");</div></pre></td></tr></table></figure>
<p>将servlet中post中代码copy到get中，但是后台接受的是乱码</p>
<p>3 $.post() 全局函数，发送post请求</p>
<pre><code>* * 格式：jQuery.post(url, [data], [callback], [type])
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.post(url,params,function(data)&#123;</div><div class="line">		alert(data.value);</div><div class="line">	&#125;,"json")</div></pre></td></tr></table></figure>
<p>4 $.ajax() 底层功能最强大的</p>
<pre><code>* * 格式：jQuery.ajax([settings])
*         参数settings：设置所有的参数
*             url:发送请求的地址
*             data:发送到服务器的数据,请求参数
*             type:请求方式 (&quot;POST&quot; 或 &quot;GET&quot;)， 
*             success:成功的回调函数，success(data, textStatus, jqXHR)
*             error:请求失败时调用此函数
*             dataType:预期服务器返回的数据类型
*                 &quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理。
*                 &quot;html&quot;: 返回纯文本 HTML 信息；包含的script标签会在插入dom时执行。
*                 &quot;script&quot;: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了&quot;cache&quot;参数。&apos;&apos;&apos;注意：&apos;&apos;&apos;在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载)
*                 &quot;json&quot;: 返回 JSON 数据 。
*                 &quot;jsonp&quot;: JSONP 格式。使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。
*                 &quot;text&quot;: 返回纯文本字符串
*/
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">	"url":url,</div><div class="line">	"data":params,</div><div class="line">	"type":"POST",</div><div class="line">	"success":function(data)&#123;</div><div class="line">		alert(data.value);</div><div class="line">	&#125;,</div><div class="line">	"error":function()&#123;</div><div class="line">		alert("服务器繁忙，请稍后重试");</div><div class="line">	&#125;,</div><div class="line">	"dataType":"json"</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一般情况下，我都会选择使用.ajax前后台交互，因为它功能相对较多，其次我们也可以选择适合我们的属性用。</p>
<p>当然后面的ajax，平时也没用到过，所以就不介绍了，当然api是最好的资料，google是最好的老师。</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识原生态ajax]]></title>
      <url>http://www.myzwl.win/2017/03/04/ajax/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1 Ajax是一种网页开发技术，（Asynchronous Javascript+XML）异步JavaScript和xml，<br>2 Ajax是异步交互，局部刷新<br>3 Ajax是减少服务器压力<br>4 Ajax能提高用户体验</p>
<h4 id="Ajax交互与传统交互比较"><a href="#Ajax交互与传统交互比较" class="headerlink" title="Ajax交互与传统交互比较"></a>Ajax交互与传统交互比较</h4><p>传统交互：网页整体刷新（同步），服务器压力大，用户体验不好<br> Ajax交互：局部刷新，服务器压力小，用户体验好</p>
<p>不妨先来一个实例，先从整体把握，在细节看<br>首先是jsp页面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div style="text-align: center;"&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">    &lt;input type="button" value="ajax异步交互" onclick="loadname()"/&gt;&amp;nbsp;&amp;nbsp;&lt;input type="text" name="name" id="name"/&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>有个按钮事件，用于验证ajax</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">	function loadname()&#123;</div><div class="line">		var xmlHttp;</div><div class="line">		if(window.XMLHttpRequest)&#123;</div><div class="line">			xmlHttp=new XMLHttpRequest();</div><div class="line">		&#125;</div><div class="line">		else&#123;</div><div class="line">			xmlHttp=new ActiveXObject("Microsoft.XMLHTTP");</div><div class="line">		&#125;</div><div class="line">		xmlHttp.open("post", "getajaxname?name=666&amp;age=16", true);</div><div class="line">		xmlHttp.send();	</div><div class="line">	&#125;</div><div class="line">	&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这段作用是利用ajax异步向后台传了两个参数name=666与age=16，路径是getajaxname为一个servlet路径，通过post方式</p>
<p>后台servlet</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">		response.setContentType("text/html,charset=utf-8");</div><div class="line">		PrintWriter out = response.getWriter();</div><div class="line">      String name= request.getParameter("name");</div><div class="line">      String age= request.getParameter("age");</div><div class="line">      System.out.println(name);</div><div class="line">      System.out.println(age);</div><div class="line">		out.flush();</div><div class="line">		out.close();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这里接受前台传来的参数并打印出来</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Web.xml文件</div><div class="line">&lt;servlet&gt;</div><div class="line">    &lt;servlet-name&gt;getajaxname&lt;/servlet-name&gt;</div><div class="line">    &lt;<span class="attribute">display</span>-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;</div><div class="line">    &lt;description&gt;This is the description of my J2EE component&lt;/description&gt;</div><div class="line">    &lt;servlet-class&gt;com<span class="selector-class">.zwl</span><span class="selector-class">.servlet</span><span class="selector-class">.getajaxname</span>&lt;/servlet-class&gt;</div><div class="line">  &lt;/servlet&gt;</div><div class="line"></div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;getajaxname&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;/getajaxname&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
<p>主要是映射一个servlet</p>
<p>至此入门程序算是完成，下面将对上述部分进行分析</p>
<h4 id="创建XMLHttpRequest对象"><a href="#创建XMLHttpRequest对象" class="headerlink" title="创建XMLHttpRequest对象"></a>创建XMLHttpRequest对象</h4><p>所有现代浏览器均支持XMLHttpRequest 对象（IE5 和IE6 使用ActiveXObject）<br>XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>创建语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var xmlHttp;</div><div class="line">		if(window.XMLHttpRequest)&#123;</div><div class="line">			xmlHttp=new XMLHttpRequest();</div><div class="line">		&#125;</div><div class="line">		else&#123;</div><div class="line">			xmlHttp=new ActiveXObject("Microsoft.XMLHTTP");</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h4 id="XMLHttpRequest-对象请求后台"><a href="#XMLHttpRequest-对象请求后台" class="headerlink" title="XMLHttpRequest 对象请求后台"></a>XMLHttpRequest 对象请求后台</h4><p>open(method,url,async)<br>规定请求的类型、URL 以及是否异步处理请求。<br>method：请求的类型；GET 或POST<br>url：文件在服务器上的位置<br>async：true（异步）或false（同步）</p>
<p>send(string)<br>将请求发送到服务器。<br>string：仅用于POST 请求</p>
<p>语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xmlHttp.open("post", "getajaxname?name=666&amp;age=16", true);</div><div class="line">xmlHttp.send();</div></pre></td></tr></table></figure>
<p>有时候需要将参数封装在一个函数中<br>首先得声明setRequestHeader(header,value)</p>
<p>向请求添加HTTP 头。<br>header: 规定头的名称<br>value: 规定头的值<br>创建语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");</div></pre></td></tr></table></figure>
<p>将入门程序部分代码修改如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xmlHttp.open("post", "getajaxname", true);</div><div class="line">	xmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");</div><div class="line">		xmlHttp.send("name=666&amp;age=16");</div></pre></td></tr></table></figure>
<h4 id="XMLHttpRequest-对象响应服务器"><a href="#XMLHttpRequest-对象响应服务器" class="headerlink" title="XMLHttpRequest 对象响应服务器"></a>XMLHttpRequest 对象响应服务器</h4><p>现在在前面的代码基础上添加几行代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alert("readystate:"+xmlHttp.readyState+" status:"+xmlHttp.status);</div><div class="line">		xmlHttp.onreadystatechange=function()&#123;</div><div class="line">			alert("readystate:"+xmlHttp.readyState+" status:"+xmlHttp.status);</div><div class="line">		&#125;;</div><div class="line">		</div><div class="line">		xmlHttp.open("post", "getajaxname", true);</div><div class="line">		xmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");</div><div class="line">		xmlHttp.send("name=666&amp;age=16");</div></pre></td></tr></table></figure>
<p>先分析一下onreadystatechange 事件<br>当请求被发送到服务器时，我们需要执行一些基于响应的任务。<br>每当readyState 改变时，就会触发onreadystatechange 事件。<br>readyState 属性存有XMLHttpRequest 的状态信息。</p>
<p>下面是XMLHttpRequest 对象的三个重要的属性：<br>onreadystatechange存储函数（或函数名）<br>每当readyState 属性改变时，就会调用该函数。</p>
<p>readyState<br>存有XMLHttpRequest 的状态。从0 到4 发生变化。<br>0: 请求未初始化<br>1: 服务器连接已建立<br>2: 请求已接收<br>3: 请求处理中<br>4: 请求已完成，且响应已就绪</p>
<p>status<br>200: “OK”<br>404: 未找到页面</p>
<p>执行上面程序就会发现相应值的变化</p>
<p>接下来在后台加入返回的信息<br>public void doPost(HttpServletRequest request, HttpServletResponse response)<br>            throws ServletException, IOException {</p>
<pre><code>    response.setContentType(&quot;text/html,charset=utf-8&quot;);
    PrintWriter out = response.getWriter();
//向前台返回一个信息
  out.println(&quot;ajax ok&quot;);
    out.flush();
    out.close();
}
</code></pre><p>页面：根据前面的状态码，进行接收参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(xmlHttp.readyState==4 &amp;&amp; xmlHttp.status==200)&#123;</div><div class="line">				document.getElementById("name").value=xmlHttp.responseText;</div><div class="line">			&#125;</div></pre></td></tr></table></figure>
<p>responseText 获得字符串形式的响应数据</p>
<p>最后会发现表单被自动填充</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识git]]></title>
      <url>http://www.myzwl.win/2017/03/03/git/</url>
      <content type="html"><![CDATA[<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git是linux之父Linus的第二个伟大的作品，它是分布式版本控制系统，即每个人可以通过clone将工作建立在本地库中</p>
<p>对比之前我们是通过hexo d的提交给远程仓库的master branch，当然我们也可以git提交或者clone到本地。</p>
<p><strong>远程仓库代码clone到本地</strong></p>
<ol>
<li>首先需要生成公钥与仓库连接<br>首先添加用户名<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global user<span class="selector-class">.name</span> <span class="string">"yourname"</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>其次添加e-mail</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global user<span class="selector-class">.email</span> <span class="string">"youreamil"</span></div></pre></td></tr></table></figure>
<p>默认在administrator目录下生成.ssh并在下生成两个文件id_rsa和id_rsa.pub秘钥，</p>
<p>生成公钥</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -C <span class="string">"youremail"</span></div></pre></td></tr></table></figure>
<p>这时候我们可以在.ssh文件下用 ls -al显示所有文件（因为.ssh是隐藏的，我是新建了一个.ssh）</p>
<p>2 配置公钥<br>在setting中的ssh and GPG keys中新建ssh key将id_rsa.pub中的内容辅助进去<br>最后用ssh -T git@github.com检查公钥是否配置成功</p>
<p>3 初始化.git<br>在本地新建任意一个文件，在该路径下，<br>初始化为本地仓库<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure></p>
<p>提交文件到缓存区</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add filename（.表示所有文件）</div></pre></td></tr></table></figure>
<p>查看状态</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
<p>本地提交，即完成提交至远程仓库的准备</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m <span class="string">"words"</span></div></pre></td></tr></table></figure>
<p>查看commit记录</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure>
<p>远程最新的代码更新到本地</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull origin master</div></pre></td></tr></table></figure>
<p>本地代码推到远程仓库，实现本地与远程仓库的同步</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master</div></pre></td></tr></table></figure>
<p>这里我是先将我的一个仓库先clone到本地</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone 仓库地址</div></pre></td></tr></table></figure>
<p>然后在该仓库目录下执行add和commit，最后在push提交到远程仓库，如果没有远程仓库，可先关联</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin 仓库</div></pre></td></tr></table></figure>
<p>再push</p>
<p>3.其他常用命令<br>查看当前项目有哪些远程仓库可以执行</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure>
<p>建立分支<br>查看分支（branch）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch</div></pre></td></tr></table></figure>
<p>默认都是master，并且master提交<br>新建分支</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch name</div></pre></td></tr></table></figure>
<p>切换分支`</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout name</div></pre></td></tr></table></figure>
<p>删除分支</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d name</div></pre></td></tr></table></figure>
<p>如果我们想要传送另一个分支到远程仓库<br>只需在push中</p>
<p>git push origin branch master</p>
<p>当然git的命令太多了，只总结了学习过程中实验到的</p>
<p>接下来如果将别人代码clone到本地，一般先fork，在利用clone</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ssm三大框架整合]]></title>
      <url>http://www.myzwl.win/2017/03/02/ssm/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> ssm三大框架整合主要指的是spring mvc+mybatis+spring，利用mvc分层思想实现解耦，其中spring mvc负责业务控制和跳转，mybatis负责持久层，spring管理各层，下面将以一个通过id查询用户信息功能搭建整合环境</p>
<ol>
<li><p>建立一个web工程</p>
</li>
<li><p>导入ssm整合的相关jar包，包括spring(包含springmvc)，mybatis，mybatis-spring整合。数据库驱动，jstl，c3p0管理数据源，log4j.由于整合包过多，可以自行到网上下载</p>
</li>
<li><p>配置核心文件初始化<br>Web.xml配置</p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt;</div><div class="line">  &lt;display-name&gt;springmvc19_day01_01&lt;/display-name&gt;</div><div class="line">  </div><div class="line">  //配置中文乱码过滤器</div><div class="line">  &lt;filter&gt;</div><div class="line">  &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line">  &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">  &lt;init-param&gt;</div><div class="line">  &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line">  &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line">  &lt;/init-param&gt;</div><div class="line">  &lt;/filter&gt;</div><div class="line">  </div><div class="line">  &lt;filter-mapping&gt;</div><div class="line">  &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">  &lt;/filter-mapping&gt;</div><div class="line">  </div><div class="line">  //启用spring监听</div><div class="line">  &lt;listener&gt;</div><div class="line">		&lt;listener-class&gt;</div><div class="line">			org.springframework.web.context.ContextLoaderListener</div><div class="line">		&lt;/listener-class&gt;</div><div class="line">	&lt;/listener&gt;</div><div class="line">  </div><div class="line">  //启动spring mvc</div><div class="line">  &lt;servlet&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">  &lt;!-- 默认加载方式</div><div class="line">  	   默认加载必须规范：</div><div class="line">  	   * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml</div><div class="line">  	   * 路径规范：必须在WEB-INF目录下面</div><div class="line">   --&gt;</div><div class="line"> &lt;/servlet&gt;</div><div class="line">  </div><div class="line">  //spring mvc 过滤文件</div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line">  </div><div class="line">  //rest格式拦截，主要用在提交带参数问题</div><div class="line">   &lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line">  </div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<ol>
<li>加载springmvc-servlet.xml文件</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt;</div><div class="line">		//自动扫面根路径以下的所有包，就不要显示配置bean了</div><div class="line">		&lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt;</div><div class="line">		</div><div class="line">		//默认创建注解处理器映射器，注解处理器适配器。提供json格式支持。</div><div class="line">		 &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; </div><div class="line">		 </div><div class="line">&lt;!-- 配置sprigmvc视图解析器：解析逻辑视图 </div><div class="line">			 后台返回逻辑试图：index</div><div class="line">			视图解析器解析出真正物理视图：前缀+逻辑试图+后缀====/WEB-INF/jsps/index.jsp</div><div class="line">		--&gt;</div><div class="line"></div><div class="line">		&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;</div><div class="line">		&lt;property name="prefix" value="/"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;		</div><div class="line">		&lt;/bean&gt;</div><div class="line">		&lt;/beans&gt;</div></pre></td></tr></table></figure>
<ol>
<li>加载spring配置文件</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt;</div><div class="line">		//自动扫面根路径以下的所有包，就不要显示配置bean了</div><div class="line">		&lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt;</div><div class="line">		</div><div class="line">	&lt;!-- 第一步：配置数据源 --&gt;</div><div class="line">	&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;</div><div class="line">		&lt;property name="jdbcUrl" value="jdbc:mysql://localhost:mysql端口/你的项目"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="user" value="你的用户名"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="password" value="你的密码"&gt;&lt;/property&gt;</div><div class="line"></div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 第二步：创建sqlSessionFactory。生产sqlSession，即产生会话 --&gt;</div><div class="line">	&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;</div><div class="line">	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 配置mybatis接口代理开发</div><div class="line">		* 接口类名和映射文件必须同名</div><div class="line">		*　接口类和映射文件必须在同一个目录　下</div><div class="line">		* 映射文件namespace名字必须是接口的全类路径名</div><div class="line">		*　接口的方法名必须和映射Statement的ｉｄ一致</div><div class="line">	 --&gt;</div><div class="line">	 &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;</div><div class="line">	 &lt;property name="basePackage" value="com.zwl.dao"&gt;&lt;/property&gt;</div><div class="line">	 &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt;</div><div class="line">	 &lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 第三步：事务 --&gt;</div><div class="line">	&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;</div><div class="line">	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 配置通知 --&gt;</div><div class="line">	&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;</div><div class="line">	&lt;tx:attributes&gt;</div><div class="line">	&lt;tx:method name="save*" propagation="REQUIRED" /&gt;</div><div class="line">	&lt;tx:method name="update*" propagation="REQUIRED" /&gt;</div><div class="line">	&lt;tx:method name="delete*" propagation="REQUIRED" /&gt;</div><div class="line">	&lt;tx:method name="insert*" propagation="REQUIRED" /&gt;</div><div class="line">	&lt;tx:method name="*" propagation="REQUIRED" /&gt;	</div><div class="line">	&lt;/tx:attributes&gt;</div><div class="line">	&lt;/tx:advice&gt;</div><div class="line"></div><div class="line">&lt;!-- 配置拦截service --&gt;</div><div class="line">	&lt;aop:config&gt;</div><div class="line">	&lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.zwl.service.*.*(..))"/&gt;</div><div class="line">	&lt;/aop:config&gt;</div><div class="line">	</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>以上三个包都必须在web-inf下</p>
<ol>
<li>编写接口代码<br>首先是pojo类</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">	 private String name;       //用户名</div><div class="line">	private String pwd;        //密码</div><div class="line">	private int uid;           //用户id</div><div class="line">此处省略set、get方法。&#125;</div></pre></td></tr></table></figure>
<p>然后利用mapper代理模式开发dao层<br>首先是Usermapper.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE mapper    </div><div class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    </div><div class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line">&lt;mapper namespace="com.zwl.dao.Usermapper"&gt;</div><div class="line">	&lt;!-- 根据用户ID查询用户信息 --&gt;</div><div class="line">	&lt;select id="findUserById" parameterType="int" resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT</div><div class="line">		* FROM users WHERE uid =#&#123;uid&#125;</div><div class="line">	&lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure>
<p>然后是接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Usermapper &#123;</div><div class="line">	public User findUserById(int id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>编写service层<br>这里用到spring注解依赖注入</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Userservice &#123;</div><div class="line"></div><div class="line">	public User finduserbyid(Integer id) throws Exception;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//声明业务层为注解，为控制层依赖注入服务</div><div class="line">@Service</div><div class="line">public class Userserviceimpl implements Userservice &#123;</div><div class="line"> </div><div class="line">//通过注解注入dao层组件</div><div class="line">	@Resource</div><div class="line">	private Usermapper usermapper;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public User finduserbyid(Integer id) throws Exception &#123;</div><div class="line">		User user=usermapper.findUserById(id);</div><div class="line">		return user;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>控制层</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//注解自动在spring中注入该bean</div><div class="line">@Controller</div><div class="line">//请求路径，放在开头，请求url，controller前必须加入该映射路径</div><div class="line">@RequestMapping("/user")</div><div class="line">public class Usercontrol &#123;</div><div class="line">  //自动注入bean</div><div class="line">	@Resource</div><div class="line">	private Userservice userservice;</div><div class="line"></div><div class="line">//请求路径，放在方法前，为请求url，到时根据这个找到类里相应方法</div><div class="line">	@RequestMapping("toadd")</div><div class="line">	public String toadd()&#123;</div><div class="line">//返回视图，在配置文件中已经配置了前缀和后缀，所以返回到index.jsp</div><div class="line">		return "index";</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@RequestMapping("uid")</div><div class="line">	//这里的参数id必须和前台提交的参数name相同，才能接收到</div><div class="line">	public void finduserbyid(Integer id)</div><div class="line">	&#123;</div><div class="line">		try &#123;</div><div class="line">			User u=userservice.finduserbyid(id);</div><div class="line">			System.out.println(u.getName());</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li>页面<br>index.jsp</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/user/uid.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">id：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"id"</span> id=<span class="string">"id"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<ol>
<li>数据库<br>里面字段必须为uid，name和password，和pojo类相对应，并且里面有数据</li>
</ol>
<p>最后我们可以在浏览器输入http：//localhost:端口/项目名/user/toadd.do到index.jsp页面，最后通过输入id，后台输出用户信息</p>
<p>至此ssm整合完成，会发现它比ssh2更方便，特别是注解开发</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ssh三大框架整合]]></title>
      <url>http://www.myzwl.win/2017/03/01/ssh/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>ssh三大框架整合主要指的是structs2+hibernate+spring，利用mvc分层思想实现解耦，其中structs2负责业务控制和跳转，hibernate负责持久层，spring管理各层</strong></p>
<h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>下面将以一个简单的登录功能搭建整合环境</p>
<ol>
<li><p>首先建立一个web工程，取名ssh2</p>
</li>
<li><p>导入jar包，由于ssh2整合包过多，可以自行官网下载</p>
</li>
<li><p>导入相关配置文件<br>Spring核心文件：applicationcontent.xml放在web-inf下<br>web工程核心文件：web.xml也放在web-inf下<br>structs2核心文件：structs.xml放在src目录下<br>里面暂时什么都不配置</p>
</li>
<li><p>数据库<br>为了方便，设置三个字段，id（int）、name（varchar）、age（int），其中id为主键，且是自增长的</p>
</li>
<li><p>配置核心文件初始化<br>Web.xml配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app version="2.5" </div><div class="line">	xmlns="http://java.sun.com/xml/ns/javaee" </div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" </div><div class="line">	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee </div><div class="line">	http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;</div><div class="line">	&lt;filter&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">	//启动structs2框架	&lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;</div><div class="line">	&lt;/filter&gt;</div><div class="line">//允许后缀名为.action或者.jsp的请求通过</div><div class="line">	&lt;filter-mapping&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">		&lt;url-pattern&gt;*.action&lt;/url-pattern&gt;</div><div class="line">	&lt;/filter-mapping&gt;</div><div class="line">	&lt;filter-mapping&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">		&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</div><div class="line">	&lt;/filter-mapping&gt;</div><div class="line">//启动spring监听，即开启spring框架</div><div class="line">	&lt;listener&gt;</div><div class="line">		&lt;listener-class&gt;</div><div class="line">			org.springframework.web.context.ContextLoaderListener</div><div class="line">		&lt;/listener-class&gt;</div><div class="line">	&lt;/listener&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Applicationcontent.xml文件配置（目前没有实现任何功能，给出原始配置）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans</div><div class="line">xmlns="http://www.springframework.org/schema/beans"</div><div class="line">xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt;</div><div class="line">	&lt;!-- 定义数据源 ，即连接数据库所需的配置--&gt;</div><div class="line">	&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;</div><div class="line">		&lt;property name="driverClassName"&gt;</div><div class="line">			&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="url"&gt;</div><div class="line">			&lt;value&gt;jdbc:mysql://localhost:mysql端口/数据库名&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="username"&gt;</div><div class="line">			&lt;value&gt;你的用户名&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="password"&gt;</div><div class="line">			&lt;value&gt;你的密码&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 定义SessionFactory --&gt;</div><div class="line">	&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;</div><div class="line">		&lt;property name="dataSource"&gt;</div><div class="line">			&lt;ref bean="dataSource"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="hibernateProperties"&gt;</div><div class="line">			&lt;props&gt;</div><div class="line">//hibernate的方言，决定用哪个数据库</div><div class="line">				&lt;prop key="hibernate.dialect"&gt;</div><div class="line">					org.hibernate.dialect.MySQLDialect</div><div class="line">				&lt;/prop&gt;</div><div class="line">            //是否启动显示sql语句</div><div class="line">				&lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt;</div><div class="line">			&lt;/props&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">//声明hibernate的映射文件，目前没有，后续步骤在此处加上</div><div class="line">		&lt;property name="mappingResources"&gt;</div><div class="line">			&lt;list&gt;</div><div class="line">				&lt;value&gt;&lt;/value&gt;</div><div class="line">			&lt;/list&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	&lt;!-- 定义HibernateTemplate，相当于纯hibernate的session --&gt;</div><div class="line">	&lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt;</div><div class="line">		&lt;property name="sessionFactory"&gt;</div><div class="line">			&lt;ref bean="sessionFactory"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	省略具体的业务代码注入配置</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>Structs.xml文件配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE struts PUBLIC</div><div class="line">    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"</div><div class="line">    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</div><div class="line">&lt;struts&gt;</div><div class="line"></div><div class="line">//防止乱码</div><div class="line">&lt;constant name="struts.i18n.encoding" value="utf-8"/&gt;</div><div class="line">&lt;/struts&gt;</div><div class="line">目前该文件里面什么功能都没配置，只是个声明</div></pre></td></tr></table></figure>
<ol>
<li>编写业务代码<br>按照mvc思想，先从持久层开始，即编写hibernate的orm对象user.java</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line"></div><div class="line">	private int age;</div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">此处省略set。Get方法&#125;</div></pre></td></tr></table></figure>
<p>映射文件User.hbm.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC </div><div class="line">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line">&lt;hibernate-mapping package="com.zwl.pojo"&gt;</div><div class="line">&lt;class name="User" &gt;</div><div class="line">&lt;id name="id"&gt;</div><div class="line">&lt;generator class="increment"&gt;&lt;/generator&gt;</div><div class="line">&lt;/id&gt;</div><div class="line">&lt;property name="name"&gt;&lt;/property&gt;</div><div class="line">&lt;property name="age"&gt;&lt;/property&gt;</div><div class="line">&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure>
<p>注意这里普通属性有时为了方便，只要声明一个name，其他属性hibernate会自动识别并补充</p>
<p>接下来要在spring中声明该映射文件</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"mappingResources"</span>&gt;</div><div class="line">			&lt;list&gt;</div><div class="line">				&lt;value&gt;com/zwl/pojo/User<span class="selector-class">.hbm</span><span class="selector-class">.xml</span>&lt;/value&gt;</div><div class="line">			&lt;/list&gt;</div><div class="line">		&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>至此，持久层完成</p>
<p>接下来是dao层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public interface dengludao &#123;</div><div class="line">//登录功能</div><div class="line">public User denglu(User u);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Dao层的实现类</div><div class="line">import org.springframework.orm.hibernate3.support.HibernateDaoSupport;</div><div class="line"></div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public class dengludaoimpl extends HibernateDaoSupport implements dengludao&#123;</div><div class="line">	//这里用了spring提供的操作hibernate的模板方法</div><div class="line">	@Override</div><div class="line">	public User denglu(User u) &#123;</div><div class="line">    //find里可以写sql语句</div><div class="line">		List&lt;User&gt; list=this.getHibernateTemplate().find("select user from User as user where user.id=?",u.getId());</div><div class="line">		if(list.size()==0)&#123;</div><div class="line">			return null;&#125;</div><div class="line">					else&#123;</div><div class="line">						return (User) list.get(0);</div><div class="line">					&#125;</div><div class="line">	&#125;&#125;</div><div class="line">	</div><div class="line">接下来要在spring中注入到组件</div><div class="line">&lt;!-- 配置DAO组件 --&gt;</div><div class="line">	&lt;bean id="dengludao" class="com.zwl.dao.dengludaoimpl"&gt;</div><div class="line">		&lt;property name="hibernateTemplate"&gt;</div><div class="line">			&lt;ref bean="hibernateTemplate"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>接下来是业务层：<br> 首先是接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public interface dengluservice &#123;</div><div class="line">public boolean isdenglu(User u);</div><div class="line">&#125;</div><div class="line">然后是实现类</div><div class="line">public class dengluserviceimpl implements dengluservice&#123;</div><div class="line"> //引用dao层组建</div><div class="line">	private dengludao denglu;</div><div class="line">	</div><div class="line">	public dengludao getDenglu() &#123;</div><div class="line">		return denglu;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setDenglu(dengludao denglu) &#123;</div><div class="line">		this.denglu = denglu;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public boolean isdenglu(User u) &#123;</div><div class="line">		if(denglu.denglu(u)!=null)</div><div class="line">		return true;</div><div class="line">		else&#123;</div><div class="line">		return false;</div><div class="line">		&#125;</div><div class="line">	&#125;&#125;</div><div class="line">接下来就要在spring中注入业务层组件</div><div class="line">&lt;!-- 配置业务逻辑组件 --&gt;</div><div class="line">	&lt;bean id="dengluservice" class="com.zwl.dao.dengluserviceimpl"&gt;</div><div class="line">		&lt;property name="denglu"&gt;</div><div class="line">			&lt;ref bean="dengludao"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div></pre></td></tr></table></figure>
<ol>
<li>表现层<br>首先是两个页面<br>Index.Jsp主要提交表单</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"userdenglu.action"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">   id:&lt;<span class="selector-tag">input</span> name=<span class="string">"id"</span> type=<span class="string">"text"</span>&gt;</div><div class="line">   &lt;br/&gt;</div><div class="line">   &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">   &lt;/form&gt;</div></pre></td></tr></table></figure>
<p>Success.jsp<br>主要就是一句success提示</p>
<ol>
<li>控制层</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class userdenglu extends ActionSupport&#123;</div><div class="line"></div><div class="line">	private dengluservice dengluservic;</div><div class="line">	private int id;</div><div class="line">省略set与get方法。。</div><div class="line">	@Override</div><div class="line">	public String execute() throws Exception &#123;</div><div class="line">		User u=new User();</div><div class="line">		u.setId(id);</div><div class="line">//如果id存在，返回成功</div><div class="line">		if(dengluservic.isdenglu(u))&#123;</div><div class="line">			return SUCCESS;</div><div class="line">		&#125;</div><div class="line">		return ERROR;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>接下来需要在spring中注入action</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置userdengluAction --&gt;</div><div class="line">	&lt;bean id=<span class="string">"userdenglu"</span> class=<span class="string">"com.zwl.action.userdenglu"</span>&gt;</div><div class="line">		&lt;property name=<span class="string">"dengluservic"</span>&gt;</div><div class="line">			&lt;ref bean=<span class="string">"dengluservice"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>同时在structs.xml中配置跳转</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"userdenglu"</span> class=<span class="string">"userdenglu"</span>&gt;</div><div class="line">			&lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">			&lt;result name=<span class="string">"error"</span>&gt;/error.jsp&lt;/result&gt;</div><div class="line">		&lt;/action&gt;</div></pre></td></tr></table></figure>
<p>最后通过在浏览器输入到index.jsp，然后输入id，数据库中可以预先插入数据，最后跳转，如果成功则跳到success.jsp，否则产生错误</p>
<p><strong>至此：ssh2框架环境搭建成功，最后提醒的是，这只是一个框架环境，我们可以在此基础上按照mvc思想，可以进行我们想要功能的开发</strong></p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 五大框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于java的execl导入数据库和取数据至页面]]></title>
      <url>http://www.myzwl.win/2017/02/28/execl/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在踩了许多坑之后，急需总结一下来提高自己，当然探索未知的过程也是自我能力的提升</p>
<h4 id="POI"><a href="#POI" class="headerlink" title="POI"></a>POI</h4><p><strong>akarta POI 是apache的子项目，它提供了一组操纵Windows文档的Java API，一般我们使用HSSF接口来操作execl对象，从而实现用纯Java代码来读取、写入、修改Excel文件</strong></p>
<p>我们可以到其官网下载最新<a href="http://www.apache.org/dyn/closer.cgi/jakarta/poi/" target="_blank" rel="external">poi文档</a></p>
<h4 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h4><p>首先我们定义一个需求，上传本地一个execl表（里面含有数据），提交给服务器，然后跳转到另一个界面（显示execl表中内容）</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>MyEclipse。ssh整合包，mysql，poi的相关包（去官网下载，导入poi-3.7-20101029.jar，poi-examples-3.7-20101029.jar，poi-ooxml-3.7-20101029.jar，poi-ooxml-schemas-3.7-20101029.jar，poi-scratchpad-3.7-20101029.jar）</p>
<ol>
<li><p>首先是建一个pojo类，主要与execl表中对应的字段相对应<br>为了方便，这里只有id，name，password字段</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pojo;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line"></div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">	private String password;</div><div class="line">	省略set..get方法</div></pre></td></tr></table></figure>
<p>2.execl表中写数据</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>password</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>java</td>
<td>lol</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>c</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>3.写读取execl表格的工具类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">package com.zwl.util;</div><div class="line"></div><div class="line">import java.io.FileInputStream;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">import org.apache.poi.hssf.usermodel.HSSFSheet;</div><div class="line">import org.apache.poi.hssf.usermodel.HSSFWorkbook;</div><div class="line">import org.apache.poi.hssf.usermodel.HSSFRow;</div><div class="line">import org.apache.poi.hssf.usermodel.HSSFCell;</div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public class ReadExcel &#123;</div><div class="line">      //将execl表中的数据读取出，并与pojo类对应，最后放在集合中</div><div class="line">	 public List&lt;User&gt; readXls(String path) throws IOException &#123;</div><div class="line">	   //execl表的全路径,并保存在输入流</div><div class="line">		 InputStream is = new FileInputStream(path);</div><div class="line">		 //HSSFWorkbook excell 文档对象介绍 </div><div class="line">		 HSSFWorkbook hssfWorkbook = new HSSFWorkbook(is);</div><div class="line">		 User user=null;</div><div class="line">		 List&lt;User&gt; list=new ArrayList&lt;User&gt;();</div><div class="line">		 // 循环工作表Sheet</div><div class="line">         for (int numSheet = 0; numSheet &lt; hssfWorkbook.getNumberOfSheets(); numSheet++) &#123;</div><div class="line">              // HSSFSheet excell的表单 </div><div class="line">             HSSFSheet hssfSheet = hssfWorkbook.getSheetAt(numSheet);</div><div class="line">             if (hssfSheet == null) &#123;</div><div class="line">                 continue;</div><div class="line">             &#125;</div><div class="line">          // 循环行Row</div><div class="line">             for (int rowNum = 1; rowNum &lt;= hssfSheet.getLastRowNum(); rowNum++) &#123;</div><div class="line">            	 //HSSFRow excell的行</div><div class="line">                 HSSFRow hssfRow = hssfSheet.getRow(rowNum);</div><div class="line">                 if (hssfRow != null) &#123;</div><div class="line">                    User u = new User();</div><div class="line">                    //HSSFCell excell的格子单元</div><div class="line">                    //这里取出每一行的数据，依次分别添加到pojo对象中，最后放在集合中</div><div class="line">                     HSSFCell no = hssfRow.getCell(0);</div><div class="line">                     HSSFCell name = hssfRow.getCell(1);</div><div class="line">                     HSSFCell age = hssfRow.getCell(2);</div><div class="line">                     int i=(int)Double.parseDouble(getValue(no));</div><div class="line">                     u.setId(i);</div><div class="line">                     u.setName(getValue(name));</div><div class="line">                     u.setPassword(getValue(age));</div><div class="line">                     list.add(u);</div><div class="line">                 &#125;</div><div class="line">             &#125;&#125;</div><div class="line">                 return list;</div><div class="line">                 &#125;</div><div class="line">                 </div><div class="line">                 @SuppressWarnings("static-access")</div><div class="line">                 private String getValue(HSSFCell hssfCell) &#123;</div><div class="line">                         if (hssfCell.getCellType() == hssfCell.CELL_TYPE_BOOLEAN) &#123;</div><div class="line">                             // 返回布尔类型的值</div><div class="line">                             return String.valueOf(hssfCell.getBooleanCellValue());</div><div class="line">                         &#125; else if (hssfCell.getCellType() == hssfCell.CELL_TYPE_NUMERIC) &#123;</div><div class="line">                             // 返回数值类型的值</div><div class="line">                             return String.valueOf(hssfCell.getNumericCellValue());</div><div class="line">                         &#125; else &#123;</div><div class="line">                             // 返回字符串类型的值</div><div class="line">                             return String.valueOf(hssfCell.getStringCellValue());</div><div class="line">                         &#125;</div><div class="line">                 &#125;	&#125;</div></pre></td></tr></table></figure>
<p>4.上传execl页面，这里只有主体部分</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//上传至后台的uploadaction，同时规定只能上传execl文件，并且这里的myFile要与后台action中属性对应</span></div><div class="line">  &lt;<span class="selector-tag">form</span> action=<span class="string">"upload.action"</span> enctype=<span class="string">"multipart/form-data"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> id=<span class="string">"share_box"</span> type=<span class="string">"file"</span> name=<span class="string">"myFile"</span> accept=<span class="string">"excel/*"</span>&gt;&lt;hr/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> id=<span class="string">"submit"</span> type=<span class="string">"submit"</span> name=<span class="string">""</span> value=<span class="string">"分享"</span>&gt;</div><div class="line">  &lt;/form&gt;</div></pre></td></tr></table></figure>
<p>5.action编写</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public class upload extends ActionSupport &#123;</div><div class="line">	private File myFile;                                         //上传的图片文件</div><div class="line">	private String myFileContentType;                            //文件类型</div><div class="line">	private String myFileFileName;                                //文件名</div><div class="line">              省略set与get方法</div><div class="line">	@Override</div><div class="line">	public String execute() throws Exception &#123;</div><div class="line">		</div><div class="line">	                         //创建一个输入流</div><div class="line">				InputStream is = new FileInputStream(myFile);</div><div class="line">				 //设置文件保存目录</div><div class="line">				String photoPath = </div><div class="line">					ServletActionContext.getServletContext().getRealPath("");</div><div class="line">				  //建立该文件</div><div class="line">				File filePhotoPath = new File(photoPath);</div><div class="line">				  //该用户第一次上传则创建</div><div class="line">				/*if(!filePhotoPath.isDirectory()) &#123;</div><div class="line">					filePhotoPath.mkdir();</div><div class="line">				&#125;*/</div><div class="line">				</div><div class="line">				 //解决中文文件名问题，将中文文件转化为uuid码</div><div class="line">						String extension = FilenameUtils.getExtension(this.getMyFileFileName());</div><div class="line">                                  //上传到服务器的execl表的全路径</div><div class="line">						String s=photoPath+'\\'+filename;</div><div class="line">						System.out.println(s);</div><div class="line">				//设置目标文件</div><div class="line">				File tofile = new File(photoPath,filename);</div><div class="line">				//使用输出流来包装目标文件</div><div class="line">				OutputStream os = new FileOutputStream(tofile);</div><div class="line">				//通过字节输入</div><div class="line">				byte[] buffer = new byte[1024];</div><div class="line">				int length = 0;</div><div class="line">				while((length = is.read(buffer)) &gt; 0) &#123;</div><div class="line">					os.write(buffer, 0, length);</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				</div><div class="line">				//关闭输入流</div><div class="line">				is.close();</div><div class="line">				//关闭输出流</div><div class="line">				os.close();</div><div class="line">				//引用读取execl表类</div><div class="line">		      ReadExcel rs=new ReadExcel();</div><div class="line">		                //取出execl表中的内容</div><div class="line">		 List&lt;User&gt; list=rs.readXls(s);</div><div class="line">		                      //将execl表中取出的数据放在session中，以便在下个界面显示数据</div><div class="line">		 Map session = ServletActionContext.getContext().getSession();</div><div class="line">		 session.put("stu", list);</div><div class="line">		return super.execute();</div><div class="line">	&#125;&#125;</div></pre></td></tr></table></figure>
<p>6.structs配置文件编写</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//spring中注入bean</span></div><div class="line">&lt;bean id=<span class="string">"upload"</span> class=<span class="string">"com.zwl.action.upload"</span>&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line"><span class="comment">//strucs.xml文件，其中涉及文件上传，必须有拦截栈的设置，ok.jsp为显示execl表格信息</span></div><div class="line">      &lt;action name=<span class="string">"upload"</span> class=<span class="string">"upload"</span>&gt;</div><div class="line">			&lt;result name=<span class="string">"success"</span>&gt;/ok.jsp&lt;/result&gt;</div><div class="line">			&lt;result name=<span class="string">"input"</span>&gt;/ok.jsp&lt;/result&gt;</div><div class="line">			&lt;!-- 配置fileUpload拦截器 --&gt;</div><div class="line">			&lt;interceptor-ref name=<span class="string">"fileUpload"</span>&gt;</div><div class="line">				&lt;!-- 配置允许上传文件类型 这里是execl文件格式允许上传--&gt;</div><div class="line">				&lt;param name=<span class="string">"allowedTypes"</span>&gt;application/excel,application/vnd.ms-excel&lt;/param&gt;</div><div class="line">				&lt;!-- 配置允许上传文件大小最大值 --&gt;</div><div class="line">				&lt;param name=<span class="string">"maximumSize"</span>&gt;<span class="number">5120000</span>&lt;/param&gt;</div><div class="line">			  &lt;/interceptor-ref&gt;</div><div class="line">			  &lt;interceptor-ref name=<span class="string">"defaultStack"</span>&gt;&lt;/interceptor-ref&gt;</div><div class="line">		&lt;/action&gt;</div></pre></td></tr></table></figure>
<p>7.取出信息在页面显示<br>通过标签循环取出session中的数据<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;s:iterator value=<span class="string">"#session.stu"</span>  id=<span class="string">"cri"</span>&gt;</div><div class="line">id:&lt;s:property value=<span class="string">"#cri.id"</span> escape=<span class="string">"false"</span>/&gt;&lt;br/&gt;</div><div class="line">name:&lt;s:property value=<span class="string">"#cri.name"</span> escape=<span class="string">"false"</span>/&gt;&lt;br/&gt;</div><div class="line">password:&lt;s:property value=<span class="string">"#cri.password"</span> escape=<span class="string">"false"</span>/&gt;&lt;br/&gt;</div><div class="line">&lt;/s:iterator&gt;</div></pre></td></tr></table></figure></p>
<p>至此我们可以本地上传execl，然后取出表中内容在另一个页面显示信息</p>
<h4 id="导入数据库"><a href="#导入数据库" class="headerlink" title="导入数据库"></a>导入数据库</h4><p>同样关键在于通过execl路径，通过工具包取出表中内容（存在集合中），将该集合循环取出放在数据库即可<br>9.后台插入数据到数据库的接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//映射文件</div><div class="line">hibernate-mapping package="com.zwl.pojo"&gt;</div><div class="line">    &lt;class name="User" table="user" &gt;</div><div class="line">        &lt;id name="id" &gt;</div><div class="line">            &lt;generator class="increment"&gt;&lt;/generator&gt;</div><div class="line">        &lt;/id&gt;</div><div class="line">        &lt;property name="name"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="password"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div><div class="line"></div><div class="line">//dao层</div><div class="line">public interface dengludao &#123;</div><div class="line">	public void insert(User u);</div><div class="line">&#125;</div><div class="line">//sercive层</div><div class="line">public interface dengluservice &#123;</div><div class="line">public void isinsert(User u);</div><div class="line">&#125;</div><div class="line">//实现类</div><div class="line">//dao层实现类</div><div class="line">@Override</div><div class="line">	public void insert(User u) &#123;</div><div class="line">		this.getHibernateTemplate().save(u);</div><div class="line">		&#125;</div><div class="line">//service层实现类</div><div class="line">private dengludao denglu;</div><div class="line">@Override</div><div class="line">	public void isinsert(User u) &#123;</div><div class="line">		denglu.insert(u);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	当然最后还得在spring中注入</div></pre></td></tr></table></figure>
<p>10.最后在action中修改一下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//首先增加组件（spring中注入）</div><div class="line">private dengluservice dengluservic;</div><div class="line">省略set与get</div><div class="line">// 在execute中末尾增加如下代码</div><div class="line">                    for(User u : list)&#123;</div><div class="line">			//循环取出execl表中数据</div><div class="line">			User ss=new User();</div><div class="line">			ss.setId(u.getId());</div><div class="line">			ss.setName(u.getName());</div><div class="line">			ss.setPassword(u.getPassword());</div><div class="line">			//循环插入到数据库</div><div class="line">			dengluservic.isinsert(ss);</div><div class="line">		 &#125;</div></pre></td></tr></table></figure>
<p><strong>最后只要我们上传execl文件，就可以先插入数据库，再在另一个页面显示信息了，注意这里有些地方笔者只给出主体代码，其次有些spring中要注入bean，这里省略了</strong></p>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java工具包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Arraylist底层]]></title>
      <url>http://www.myzwl.win/2017/02/27/arraylist/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ArrayList也叫数组列表，底层使用的是数组实现的，严格来说是动态数组。<br> 一般情况下，一个问题的认识都是由具体到抽象，先看一个入门案例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; al=new ArrayList&lt;&gt;();</div><div class="line">	al.add("hello");</div><div class="line">	al.add("world");</div><div class="line">	al.add("lol");</div><div class="line">	System.out.println(al.size());</div><div class="line">	System.out.println(al.get(0));</div><div class="line">	System.out.println(al.get(1));</div><div class="line">	System.out.println(al.get(2));</div><div class="line">	al.remove(1);</div><div class="line">	System.out.println(al.size());</div><div class="line">	System.out.println(al.get(1));</div></pre></td></tr></table></figure>
<p>测试结果：3 hello world lol 2<br>这个例子也很好理解，大概流程是先创建集合，在依次加入数据，依次取出和大小，在删除其中一个，在看大小和删除的数据是否存在，好了，入门程序就到这了，运用这几个方法我们可以把它复杂化运用到我们以后想要的上面。</p>
<p>至此下面将开始简单介绍一下add，get，remove方法的源码分析。<br>（当然我们也可以通过设置断点追踪源码）</p>
<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>在此之前，先介绍一下源码中的几个静态常量</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private static final int DEFAULT_CAPACITY=10;//数组为空默认的最小分配数组容量</div><div class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//默认空数组</div><div class="line">private int size;//数组长度，初始化默认为0；</div></pre></td></tr></table></figure>
<p><strong>下面就是add方法</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line">//保证数组容量的容量始终够用</div><div class="line">     ensureCapacityInternal(size + 1);  </div><div class="line">   //size是elementData数组中元素的个数，初始为0</div><div class="line">     elementData[size++] = e;</div><div class="line">      return true;&#125;</div></pre></td></tr></table></figure>
<p>首先进入第一个方法分析：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private void ensureCapacityInternal(int minCapacity) &#123;</div><div class="line">//如果数组没有元素，给数组一个默认大小，会选择实例化时的值与默认大小较大者</div><div class="line">        if (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">        &#125;</div><div class="line">        //保证容量够用</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   private void ensureExplicitCapacity(int minCapacity) &#123;</div><div class="line">//数组发生size更改的次数，默认为0</div><div class="line">        modCount++;</div><div class="line">         //如果数组长度小于默认的容量10，则调用扩大数组大小的方法</div><div class="line">             if (minCapacity - elementData.length &gt; 0)</div><div class="line">            grow(minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//数组长度的上限</div><div class="line">   private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</div><div class="line">  </div><div class="line">   private void grow(int minCapacity) &#123;</div><div class="line">        // 保证数组容量扩大一倍</div><div class="line">        int oldCapacity = elementData.length;</div><div class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</div><div class="line">        if (newCapacity - minCapacity &lt; 0)</div><div class="line">            newCapacity = minCapacity;</div><div class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div class="line">            newCapacity = hugeCapacity(minCapacity);</div><div class="line">        // 得到扩大容量后的新数组</div><div class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private static int hugeCapacity(int minCapacity) &#123;</div><div class="line">//返回新数组的大小</div><div class="line">        if (minCapacity &lt; 0) </div><div class="line">            throw new OutOfMemoryError();</div><div class="line">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">            Integer.MAX_VALUE :</div><div class="line">            MAX_ARRAY_SIZE;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>至此算是把add方法的底层分析了一遍，我们现在是不是可以假象一个简单例子来模拟流程</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; al=new ArrayList&lt;&gt;();</div><div class="line">	al.add("hello");</div></pre></td></tr></table></figure>
<p>大概执行流程，数组为空，分配一个默认大小为10的容量，容量动态扩充，然后size变化，最后将值赋给数组，说了这么多，还是有点，总之，可以自己模拟数据，然后进行断点调试，就大概了解其过程了。</p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>在此之前先补充一下arraylist的构造函数，如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//如果构造函数不指定大小，则将默认空对象给数组对象</div><div class="line">public ArrayList() &#123;</div><div class="line">        super();</div><div class="line">        this.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">//指定初始化数组大小</div><div class="line">public ArrayList(int initialCapacity) &#123;</div><div class="line">        super();</div><div class="line">        if (initialCapacity &lt; 0)</div><div class="line">            throw new IllegalArgumentException("Illegal Capacity: "+</div><div class="line">                                               initialCapacity);</div><div class="line">        this.elementData = new Object[initialCapacity];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面就来看一看get方法的执行过程</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line">//判断index是否合法</div><div class="line">        rangeCheck(index);</div><div class="line">      //得到相应的数组数据</div><div class="line">        return elementData(index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private void rangeCheck(int index) &#123;</div><div class="line">//判断数组是否越界</div><div class="line">        if (index &gt;= size)</div><div class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到它的执行过程就这两步</p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><p>这里先说明一下，由于删除操作会改变size，所以每次删除都需要把元素向前移动一个位置，然后把最后一个位置设置为null，一次删除操作完成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public E remove(int index) &#123;</div><div class="line">   //判断index是否合法</div><div class="line">        rangeCheck(index);</div><div class="line">// size更改的次数</div><div class="line">        modCount++;</div><div class="line">//保存待删除的位置的元素</div><div class="line">        E oldValue = elementData(index);</div><div class="line">        //要移动的元素个数</div><div class="line">        int numMoved = size - index - 1;</div><div class="line">    //如果index不是最后一个元素，则从第index+1到最后一个位置，依次向前移动一个位置</div><div class="line">        if (numMoved &gt; 0)</div><div class="line">            System.arraycopy(elementData, index+1, elementData, index,</div><div class="line">                             numMoved);</div><div class="line"> //元素的size-1并且最后一个元素位置设为null</div><div class="line">        elementData[--size] = null; </div><div class="line">        return oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static native void arraycopy(Object src,  int  srcPos,</div><div class="line">                                        Object dest, int destPos,</div><div class="line">                                        int length);</div></pre></td></tr></table></figure>
<p>很遗憾：断点调试中没有源码，因为其是native，是其他语言编写的，这里只做简单介绍<br>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的源数组到 dest 引用的目标数组，数组组件的一个子序列被复制下来。被复制的组件的编号等于 length 参数。源数组中位置在 srcPos 到 srcPos+length-1 之间的组件被分别复制到目标数组中的 destPos 到 destPos+length-1 位置。</p>
<p>最后不得不提的是因为arraylist是动态增长的，即容量增产幅度遵循size/2+1，即默认为10，所以依次为：10,16,25.。。。。<br>这就造成arraylist是线程不安全的，多线程中产生问题，参考单例模式</p>
]]></content>
      
        <categories>
            
            <category> 学习进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于servlet的验证码和md5加密]]></title>
      <url>http://www.myzwl.win/2017/02/26/md5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>验证码通俗的讲就是为了防止机器人自动注册无限制，而md5加密则将明文密码转化为一个32位字符串</p>
<h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>这里是基于servlet的，也就是说通过java代码随机生成一个你设置的位数的字符串，然后将其保存在session中，以便后续是通过ajax传给前台验证或者是后台验证<br><strong>首先是生成验证码的类,这里我放在了com.ltw.tools包下</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class yanzhengma extends HttpServlet &#123;</div><div class="line"></div><div class="line">	public void doGet(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line">		// 7.禁止浏览器缓存随机图片</div><div class="line">		response.setDateHeader("Expires", -1);</div><div class="line">		response.setHeader("Cache-Control", "no-cache");</div><div class="line">		response.setHeader("Pragma", "no-cache");</div><div class="line">		// 6.通知客户机以图片方式打开发送过去的数据</div><div class="line">		response.setHeader("Content-Type", "image/jpeg");</div><div class="line">		// 1.在内存中创建一副图片</div><div class="line">		BufferedImage image = new BufferedImage(60, 30,</div><div class="line">				BufferedImage.TYPE_INT_RGB);</div><div class="line">		// 2.向图片上写数据</div><div class="line">		Graphics g = image.getGraphics();</div><div class="line">		// 设背景色</div><div class="line">		g.setColor(Color.BLACK);</div><div class="line">		g.fillRect(0, 0, 60, 30);</div><div class="line">		// 3.设置写入数据的颜色和字体</div><div class="line">		g.setColor(Color.RED);</div><div class="line">		g.setFont(new Font(null, Font.BOLD, 20));</div><div class="line">		// 4.向图片上写数据</div><div class="line">		String num = makeNum();</div><div class="line">		//这句话就是把随机生成的数值，保存到session，</div><div class="line">//通过session就可以直接去到随即生成的验证码了</div><div class="line">		request.getSession().setAttribute("checkcode", num);		g.drawString(num, 0, 20);</div><div class="line">		// 5.把写好数据的图片输出给浏览器</div><div class="line">		ImageIO.write(image, "jpg", response.getOutputStream());</div><div class="line">	&#125;</div><div class="line">	//该函数时随机生成7位数字</div><div class="line">	public String makeNum() &#123;</div><div class="line">		Random r = new Random();</div><div class="line">		//9999999 可以生成7位</div><div class="line">		String num = r.nextInt(99999) + ""; </div><div class="line">		StringBuffer sb = new StringBuffer();</div><div class="line">		//如果不够4位，前面补零</div><div class="line">		for (int i = 0; i &lt; 5 - num.length(); i++) &#123;</div><div class="line">			sb.append("0");</div><div class="line">		&#125;</div><div class="line">		num = sb.toString() + num;</div><div class="line">		return num;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要注意的是随机生成的数字放在session的checkcode中，通过设置r.nextInt(xxx)，xxx表示生成几位，如9999，则为四位验证码，然后在for循环中改成设置的位即可<br><strong>接下来将验证码映射成资源文件，在web.xml中设置</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;servlet&gt;</div><div class="line">    &lt;servlet-name&gt;yanzhengma&lt;/servlet-name&gt;</div><div class="line">    &lt;servlet-class&gt;com<span class="selector-class">.ltw</span><span class="selector-class">.tools</span><span class="selector-class">.yanzhengma</span>&lt;/servlet-class&gt;</div><div class="line">  &lt;/servlet&gt;</div><div class="line">  </div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;yanzhengma&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;/yanzhengma&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
<p>这样该类就被映射成一个资源，然后在页面中直接取资源</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"yanzhenma"</span> placeholder=<span class="string">"请输入验证码"</span> required=<span class="string">"required"</span>&gt;</div><div class="line">&lt;!--      验证码，后台已将该.java映射为文件 --&gt;</div><div class="line">            &lt;<span class="selector-tag">img</span> src=<span class="string">'/项目名/yanzhengma'</span> style=<span class="string">"width:400px;height: 50px;"</span> &gt;</div><div class="line">           &lt;<span class="selector-tag">input</span> id=<span class="string">"submit"</span> type=<span class="string">"submit"</span> value=<span class="string">"登录"</span>&gt;</div></pre></td></tr></table></figure>
<p>如果这里我们需要在前台输入验证码验证，可以通过ajax传值验证。<br>然后在写一个servlet用来将checkcode转换为json传给前台</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class dengluyanzhen extends HttpServlet &#123;</div><div class="line"></div><div class="line">	public void doGet(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;&#125;</div><div class="line"></div><div class="line">	public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line">		String code = (String) request.getSession().getAttribute("checkcode");  //获得验证码</div><div class="line">		  </div><div class="line">        response.setContentType("text/html; charset=UTF-8");  </div><div class="line">        response.setHeader("Cache-Control", "no-cache");  </div><div class="line">        response.setHeader("Pragma", "no-cache");  </div><div class="line">        PrintWriter out = response.getWriter();  </div><div class="line">          </div><div class="line">        StringBuffer sb = new StringBuffer();  </div><div class="line">        sb.append(code);  </div><div class="line">        out.write(sb.toString());     //转化为json格式将验证码返回给前端</div><div class="line">        out.close();  </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在前台，还是上面那个页面增加如下代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> &lt;script type="text/javascript"&gt;</div><div class="line">$(function()&#123;</div><div class="line"></div><div class="line">	/* 利用ajax异步传值，result获得后台传过来的json数据，即验证码 */</div><div class="line">	 var result = "";</div><div class="line">       $.ajax(&#123;</div><div class="line">           url:'&lt;%=path%&gt;/dengluyanzhen',</div><div class="line">           type:"POST",</div><div class="line">           dataType:"json",</div><div class="line">           async:true,//关闭异步加载,这样只有加载完成才进行下一步</div><div class="line">           success:function (data) &#123;</div><div class="line">               result = data;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">	 $("#submit").click(function () &#123; </div><div class="line">			var num1=$("[name='yanzhenma']").val();</div><div class="line">			 if(result!=num1)&#123;</div><div class="line">				alert("您输入的验证码不一致！请重新输入");</div><div class="line">				return false;</div><div class="line">				window.location.href="error.jsp";</div><div class="line">			&#125;	</div><div class="line">			&#125;); </div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h4 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h4><p>主要是一个算法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class MD5 &#123;</div><div class="line">	public final static String MD5(String s) &#123;      </div><div class="line">		char hexDigits[] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9','a', 'b', 'c', 'd', 'e', 'f' &#125;;      </div><div class="line">		try &#123;      </div><div class="line">			byte[] strTemp = s.getBytes();      </div><div class="line">			MessageDigest mdTemp = MessageDigest.getInstance("MD5");      </div><div class="line">			mdTemp.update(strTemp);      </div><div class="line">			byte[] md = mdTemp.digest();      </div><div class="line">			int j = md.length;      </div><div class="line">			char str[] = new char[j * 2];      </div><div class="line">			int k = 0;      </div><div class="line">			for (int i = 0; i &lt; j; i++) &#123;      </div><div class="line">				byte byte0 = md[i];      </div><div class="line">				str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];      </div><div class="line">				str[k++] = hexDigits[byte0 &amp; 0xf];      </div><div class="line">			&#125;      </div><div class="line">			return new String(str);      </div><div class="line">		&#125; catch (Exception e) &#123;      </div><div class="line">			return null;      </div><div class="line">		&#125;     </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们想要将一个字符加密，直接调用该类的静态方法即可，如<br>MD5.MD5(users.getPwd())。</p>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java工具包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于struts2的二维码]]></title>
      <url>http://www.myzwl.win/2017/02/25/erweima/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间因为一些原因要做一个二维码，故此google了许多，当然是在踩了许多坑之后，找到了适合自己的方法，故在此将其总结一下，来提高自己</p>
<h4 id="什么是二维码"><a href="#什么是二维码" class="headerlink" title="什么是二维码"></a>什么是二维码</h4><p>总的来说就是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，最后通过相关设备读取。</p>
<h4 id="zxing"><a href="#zxing" class="headerlink" title="zxing"></a>zxing</h4><p>zxing是google的一个开源源码，主要用于java生成和解析的条形码，二维码，通过引用相关jar包，实现其中的相关接口来开发，这里我引用的是QRCode.jar主要是生成二维码</p>
<h4 id="需求案例"><a href="#需求案例" class="headerlink" title="需求案例"></a>需求案例</h4><p><strong>假设我们通过扫描二维码将数据库中的信息取出来并显示在另一个页面</strong></p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>MyEclipse、mysql数据库（这里建了一张简单表，有id、name、password）、ssh整合包（事实上，我们可以单独使用struts2，只不过耗时一些），QRCode.jar包，jquery-1.8.3.js,gson.jar</p>
<h4 id="二维码工具包"><a href="#二维码工具包" class="headerlink" title="二维码工具包"></a>二维码工具包</h4><p>这里主要有三个类，一个是图像本身类（包含其本身一些属性）、二维码处理类（包括生成和解析图像二维码），最后一个是将本地图片通过调用处理类转化为二维码。<br>这里我将其放在com.zwl.util包下（以下是相关代码）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class QRCodeImageBean implements QRCodeImage&#123;</div><div class="line"></div><div class="line">	  BufferedImage bufImg;  </div><div class="line">	    </div><div class="line">	    public QRCodeImageBean(BufferedImage bufImg) &#123;  </div><div class="line">	        this.bufImg = bufImg;  </div><div class="line">	    &#125;  </div><div class="line">	    public int getHeight() &#123;  </div><div class="line">	        return bufImg.getHeight();  </div><div class="line">	    &#125;  </div><div class="line">	    public int getPixel(int x, int y) &#123;  </div><div class="line">	        return bufImg.getRGB(x, y);  </div><div class="line">	    &#125;  </div><div class="line">	    public int getWidth() &#123;  </div><div class="line">	        return bufImg.getWidth();  </div><div class="line">	    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>生成和解析二维码类</strong><br>public class QRCode {</p>
<pre><code> /**
 * 解析二维码(QRCode)
 * @param imgPath
 * @return content（返回二维码内容）
 */
public static  String decoderQRCode(String imgPath) {  
    // QRCode 二维码图片的文件  
    File imageFile = new File(imgPath);  
    BufferedImage bufImg = null;  
    String content = null;  
    try {  
        bufImg = ImageIO.read(imageFile);  
        QRCodeDecoder decoder = new QRCodeDecoder();  
        content = new String(decoder.decode(new QRCodeImageBean(bufImg)), &quot;utf-8&quot;);   
    } catch (IOException e) {  
        System.out.println(&quot;Error: &quot; + e.getMessage());  
        e.printStackTrace();  
    } catch (DecodingFailedException dfe) {  
        System.out.println(&quot;Error: &quot; + dfe.getMessage());  
        dfe.printStackTrace();  
    }  
    return content;  
}  

/**  
 * 生成二维码(QRCode)图片  
 * @param content 存储内容  
 * @param imgPath 图片路径  
 * @param imgType 图片类型  
 */    
public static void encoderQRCode(String content, String imgPath, String imgType) {    
    encoderQRCode(content, imgPath, imgType, 7);    
}  

/**  
 * 生成二维码(QRCode)图片  
 * @param content 存储内容  
 * @param imgPath 图片路径  
 * @param imgType 图片类型  
 * @param size 二维码尺寸  
 */    
public static void encoderQRCode(String content, String imgPath, String imgType, int size) {    
    try {    
        BufferedImage bufImg = qRCodeCommon(content, imgType, size);    

        File imgFile = new File(imgPath);    
        // 生成二维码QRCode图片    
        ImageIO.write(bufImg, imgType, imgFile);    
    } catch (Exception e) {    
        e.printStackTrace();    
    }    
}  

/**  
 * 生成二维码(QRCode)图片的公共方法  
 * @param content 存储内容  
 * @param imgType 图片类型  
 * @param size 二维码尺寸  
 * @return  
 */    
private static BufferedImage qRCodeCommon(String content, String imgType, int size) {    
    BufferedImage bufImg = null;    
    try {    
        Qrcode qrcodeHandler = new Qrcode();    
        // 设置二维码排错率，可选L(7%)、M(15%)、Q(25%)、H(30%)，排错率越高可存储的信息越少，但对二维码清晰度的要求越小    
        qrcodeHandler.setQrcodeErrorCorrect(&apos;M&apos;);    
        qrcodeHandler.setQrcodeEncodeMode(&apos;B&apos;);    
        // 设置设置二维码尺寸，取值范围1-40，值越大尺寸越大，可存储的信息越大    
        qrcodeHandler.setQrcodeVersion(size);    
        // 获得内容的字节数组，设置编码格式    
        byte[] contentBytes = content.getBytes(&quot;utf-8&quot;);    
        // 图片尺寸    
        int imgSize = 67 + 12 * (size - 1);    
        bufImg = new BufferedImage(imgSize, imgSize, BufferedImage.TYPE_INT_RGB);    
        Graphics2D gs = bufImg.createGraphics();    
        // 设置背景颜色    
        gs.setBackground(Color.WHITE);    
        gs.clearRect(0, 0, imgSize, imgSize);    

        // 设定图像颜色&gt; BLACK    
        gs.setColor(Color.BLACK);    
        // 设置偏移量，不设置可能导致解析出错    
        int pixoff = 2;    
        // 输出内容&gt; 二维码    
        if (contentBytes.length &gt; 0 &amp;&amp; contentBytes.length &lt; 800) {    
            boolean[][] codeOut = qrcodeHandler.calQrcode(contentBytes);    
            for (int i = 0; i &lt; codeOut.length; i++) {    
                for (int j = 0; j &lt; codeOut.length; j++) {    
                    if (codeOut[j][i]) {    
                        gs.fillRect(j * 3 + pixoff, i * 3 + pixoff, 3, 3);    
                    }    
                }    
            }    
        } else {    
            throw new Exception(&quot;QRCode content bytes length = &quot; + contentBytes.length + &quot; not in [0, 800].&quot;);    
        }    
        gs.dispose();    
        bufImg.flush();    
    } catch (Exception e) {    
        e.printStackTrace();    
    }    
    return bufImg;    
}  }
</code></pre><p>最后一个类是本地生成二维码图片</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;  </div><div class="line">       String imgPath = "C:/Users/Administrator/Desktop/img/xiazi.jpg";  </div><div class="line">        QRCode handler = new QRCode();  </div><div class="line">        String qrCon = handler.decoderQRCode(imgPath);</div><div class="line">        String encoderContent = "http://192.168.43.44:100/librarytest/success1.jsp?id=2";    </div><div class="line">       handler.encoderQRCode(encoderContent, imgPath, "png"); </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>其中imgPath是本地你想将某个图片生成二维码的那个图片</strong><br><strong>qrCon为解析后的二维码内容，我这里就是一个url地址</strong><br><strong>encoderContent：设置二维码的内容，这里为url带个参数，扫描后就会跳转到相应界面</strong><br>这里的参数想要取出，可以先将内容取出，在通过string类中的方法将字符创相应位置字符取出即可<br>至此，工具类算是有了，接下来就是结合具体配置</p>
<h4 id="后台方法"><a href="#后台方法" class="headerlink" title="后台方法"></a>后台方法</h4><p>首先是web.xml（启用struts2和spring）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app version="2.5" </div><div class="line">	xmlns="http://java.sun.com/xml/ns/javaee" </div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" </div><div class="line">	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee </div><div class="line">	http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;</div><div class="line">	&lt;filter&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">		&lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;</div><div class="line">	&lt;/filter&gt;</div><div class="line">	&lt;filter-mapping&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">		&lt;url-pattern&gt;*.action&lt;/url-pattern&gt;</div><div class="line">	&lt;/filter-mapping&gt;</div><div class="line">	&lt;filter-mapping&gt;</div><div class="line">		&lt;filter-name&gt;struts2&lt;/filter-name&gt;</div><div class="line">		&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</div><div class="line">	&lt;/filter-mapping&gt;</div><div class="line">	&lt;listener&gt;</div><div class="line">		&lt;listener-class&gt;</div><div class="line">		org.springframework.web.context.ContextLoaderListener</div><div class="line">		&lt;/listener-class&gt;</div><div class="line">	&lt;/listener&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<p>然后是applicationContext.xml（为了方便直接将所有方法都注入了）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans</div><div class="line">xmlns="http://www.springframework.org/schema/beans"</div><div class="line">xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt;</div><div class="line">	&lt;!-- 定义数据源 --&gt;</div><div class="line">	&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;</div><div class="line">		&lt;property name="driverClassName"&gt;</div><div class="line">			&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="url"&gt;</div><div class="line">			&lt;value&gt;jdbc:mysql://localhost:msql端口/项目&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="username"&gt;</div><div class="line">			&lt;value&gt;你的用户名&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="password"&gt;</div><div class="line">			&lt;value&gt;你的密码&lt;/value&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	&lt;!-- 定义SessionFactory --&gt;</div><div class="line">	&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;</div><div class="line">		&lt;property name="dataSource"&gt;</div><div class="line">			&lt;ref bean="dataSource"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="hibernateProperties"&gt;</div><div class="line">			&lt;props&gt;</div><div class="line">				&lt;prop key="hibernate.dialect"&gt;</div><div class="line">					org.hibernate.dialect.MySQLDialect</div><div class="line">				&lt;/prop&gt;</div><div class="line">				&lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt;</div><div class="line">			&lt;/props&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="mappingResources"&gt;</div><div class="line">			&lt;list&gt;</div><div class="line">				&lt;value&gt;com/zwl/pojo/User.hbm.xml&lt;/value&gt;</div><div class="line">			&lt;/list&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	&lt;!-- 定义HibernateTemplate --&gt;</div><div class="line">	&lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt;</div><div class="line">		&lt;property name="sessionFactory"&gt;</div><div class="line">			&lt;ref bean="sessionFactory"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">	&lt;!-- 配置DAO组件 --&gt;</div><div class="line">	&lt;bean id="returnuserdao" class="com.zwl.impl.returnuserdaoimpl"&gt;</div><div class="line">		&lt;property name="hibernateTemplate"&gt;</div><div class="line">			&lt;ref bean="hibernateTemplate"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	&lt;!-- 配置业务逻辑组件 --&gt;</div><div class="line">	&lt;bean id="returnuserservice" class="com.zwl.impl.returnuserserviceimpl"&gt;</div><div class="line">		&lt;property name="userdao"&gt;</div><div class="line">			&lt;ref bean="returnuserdao"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	&lt;!-- 配置userdengluAction --&gt;</div><div class="line">	&lt;bean id="userreturn" class="com.zwl.action.userreturn"&gt;</div><div class="line">		&lt;property name="returnuser"&gt;</div><div class="line">			&lt;ref bean="returnuserservice"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>pojo类（与数据库映射那个类）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">	private String password;</div><div class="line">省略set与get方法。。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>映射文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line">&lt;hibernate-mapping package="com.zwl.pojo"&gt;</div><div class="line">    &lt;class name="User" table="user" &gt;</div><div class="line">        &lt;id name="id" &gt;</div><div class="line">            &lt;generator class="increment"&gt;&lt;/generator&gt;</div><div class="line">        &lt;/id&gt;</div><div class="line">        &lt;property name="name"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="password"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接下来就是接口编写</p>
<p>dao层<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface returnuserdao &#123;</div><div class="line">//通过id返回User</div><div class="line">public User returnuserbyid(int id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>service层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface returnuserservice &#123;</div><div class="line">public   User  returnuser(int id);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>分别得实现类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class returnuserdaoimpl extends HibernateDaoSupport implements	returnuserdao &#123;</div><div class="line">	@Override</div><div class="line">	public User returnuserbyid(int id) &#123;</div><div class="line">		List list=this.getHibernateTemplate().find(" from User user where user.id = '" + id + "'");</div><div class="line">		if(list.size()==0)&#123;</div><div class="line">			return null;</div><div class="line">		&#125;else&#123;</div><div class="line">			return (User)list.get(0);</div><div class="line">		&#125;	&#125;&#125;</div><div class="line">public class returnuserserviceimpl implements returnuserservice&#123;</div><div class="line"></div><div class="line">	private returnuserdao userdao;</div><div class="line"></div><div class="line">	public returnuserdao getUserdao() &#123;</div><div class="line">		return userdao;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setUserdao(returnuserdao userdao) &#123;</div><div class="line">		this.userdao = userdao;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public User returnuser(int id) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return userdao.returnuserbyid(id);</div><div class="line">	&#125;&#125;</div></pre></td></tr></table></figure>
<p><strong>这里只有两个页面，一个只有二维码，另一个是扫描后跳转的页面并且可以从数据库中取出相关信息</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">			   &lt;figure&gt;</div><div class="line">&lt;figcaption&gt;图书1扫码:&lt;/figcaption&gt;</div><div class="line">&lt;img src="img/dl.gif"&gt;你本地生成的二维码图片</div><div class="line">&lt;/figure&gt;</div><div class="line">``` </div><div class="line">接下来是通过ajax从后台异步加载数据，当然是在你扫码后，直接将数据显示在表单中</div><div class="line"></div><div class="line">``` stylus</div><div class="line"> &lt;script type="text/javascript"&gt;</div><div class="line">  $(function()&#123;</div><div class="line">      /*     通过ajax异步提交表单 */</div><div class="line">$.ajax(&#123;</div><div class="line">	        /* 提交路径 */</div><div class="line">	url : '$&#123;pageContext.request.contextPath&#125;/userreturn!userreturn.action',</div><div class="line">	data:params,</div><div class="line">	type:"POST",</div><div class="line">	 dataType:"json",</div><div class="line">	/* 提交成功后，并得到后台返回的数据 */</div><div class="line">	success : function(r) &#123;</div><div class="line">		/* 解析后台json格式，并得到对象 */</div><div class="line">		$("#id").val(r.id);</div><div class="line">		$("#name").val(r.name);</div><div class="line">		$("#password").val(r.password);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">	   &#125;);</div><div class="line">  &lt;/script&gt;</div><div class="line">  </div><div class="line">  &lt;body&gt;</div><div class="line">  &lt;form action="" method="post"&gt;</div><div class="line">  id  :&amp;nbsp;&lt;input id="id" name="id" type="text"/&gt;&lt;br/&gt;</div><div class="line">  name  :&amp;nbsp;&lt;input id="name" name="name" type="text"/&gt;&lt;br/&gt;</div><div class="line">  password  :&amp;nbsp;&lt;input id="password" name="password" type="text"/&gt;&lt;br/&gt;</div><div class="line">  &lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure>
<h4 id="Action类"><a href="#Action类" class="headerlink" title="Action类"></a>Action类</h4><p><strong>接下来就是action的编写</strong><br>首先是 QRCodeAction</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class QRCodeAction extends ActionSupport &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	// 封装上传文件域的属性</div><div class="line">	private File image;</div><div class="line">	// 封装上传文件类型的属性</div><div class="line">	private String imageContentType;</div><div class="line">	// 封装上传文件名的属性</div><div class="line">	private String imageFileName;</div><div class="line">	private String message;</div><div class="line">	private String content;</div><div class="line"></div><div class="line">	此处省略属性的set与get方法。。</div><div class="line">	/**</div><div class="line">	 * 生成二维码</div><div class="line">	 * @return  String</div><div class="line">	 *</div><div class="line">	 */</div><div class="line">	public String encoderQRCode()&#123;</div><div class="line">		String realpath = ServletActionContext.getServletContext().getRealPath("/file");</div><div class="line">		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");</div><div class="line">		String imgName = sdf.format(new Date()) + ".png";</div><div class="line">		String  imgPath= realpath+"/"+imgName;</div><div class="line">		QRCode.encoderQRCode(content, imgPath, "png");</div><div class="line">		message = imgName;</div><div class="line">		return Action.SUCCESS;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 获取二维码</div><div class="line">	 * @return  String</div><div class="line">	 *</div><div class="line">	 */</div><div class="line">	public String decoderQRCode() &#123;</div><div class="line">        try &#123;</div><div class="line">        	String realpath = ServletActionContext.getServletContext().getRealPath("/img");</div><div class="line">        	File savefile = new File(new File(realpath), imageFileName);</div><div class="line">        	if (!savefile.getParentFile().exists())</div><div class="line">        		savefile.getParentFile().mkdirs();</div><div class="line">			FileUtils.copyFile(image, savefile);</div><div class="line">			message   = QRCode.decoderQRCode(realpath+"/"+imageFileName);</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		return Action.SUCCESS;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>然后是我们需要的userreturnaction（主要后台信息通过json格式传给前台）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class userreturn  &#123;</div><div class="line"></div><div class="line">	private returnuserservice returnuser;  //通过用户id查询用户信息</div><div class="line">	private String img;                    //接受二维码图片的名字</div><div class="line">	省略set与get方法。。</div><div class="line"></div><div class="line">       //解析二维码，入库查询，并返回用户信息</div><div class="line">	public void userreturn() throws Exception &#123;</div><div class="line">		HttpServletResponse response=ServletActionContext.getResponse();</div><div class="line">		HttpServletRequest request=ServletActionContext.getRequest();</div><div class="line">		response.setCharacterEncoding("UTF-8");</div><div class="line">		response.setContentType("application/json; charset=utf-8");          //返回json数据</div><div class="line">	        response.setHeader("Cache-Control", "no-cache");                 //不要缓存</div><div class="line">	        response.setHeader("Pragma", "no-cache");  </div><div class="line">		PrintWriter out = response.getWriter();</div><div class="line">		System.out.println("被扫描的二维码图片的名字:"+img);</div><div class="line">		QRCode qrcode=new QRCode();</div><div class="line">		String path=qrcode.decoderQRCode("E:/newday/librarytest/WebRoot/img/"+img);//二维码图片地址</div><div class="line">		System.out.println("二维码解析的内容:"+path);</div><div class="line">		int id=Integer.parseInt(path.substring(path.length()-1));</div><div class="line">		System.out.println("用户的id号:"+id);</div><div class="line">		User user=returnuser.returnuser(id);</div><div class="line">		System.out.println("用户的姓名:"+user.getName());</div><div class="line">		System.out.println("用户的密码:"+user.getPassword());</div><div class="line">		JsonObject json=new JsonObject();</div><div class="line">		json.addProperty("id", id);</div><div class="line">		json.addProperty("name", user.getName());</div><div class="line">		json.addProperty("password", user.getPassword());</div><div class="line">		response.getWriter().write(json.toString());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意在页面中需要jquery-1.8.3.js包，同时此处json格式转换用的是gson.jar包<br>最后就是struts.xml配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line"></div><div class="line">&lt;!DOCTYPE struts PUBLIC</div><div class="line">    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"</div><div class="line">    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</div><div class="line">&lt;struts&gt;</div><div class="line"></div><div class="line">&lt;constant name="struts.i18n.encoding" value="utf-8"/&gt;</div><div class="line">&lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt; </div><div class="line"> &lt;constant name="struts.devMode" value="false" /&gt;</div><div class="line">	&lt;constant name="struts.i18n.encoding" value="UTF-8"/&gt;</div><div class="line">	&lt;constant name="struts.multipart.maxSize" value="10701096"/&gt;&lt;!-- 上传文件最大值 --&gt;</div><div class="line">	&lt;constant name="struts.multipart.saveDir" value="/tmp"/&gt;&lt;!-- 上传文件设置属性 --&gt;</div><div class="line">	&lt;constant name="struts.custom.i18n.resources" value="global" /&gt;</div><div class="line">	&lt;constant name="struts.action.extension" value="action"&gt;&lt;/constant&gt;</div><div class="line">	</div><div class="line">	&lt;package namespace="/"   name="struct2" extends="struts-default"&gt;</div><div class="line">		&lt;action name="userreturn" class="userreturn" method="userreturn"&gt;</div><div class="line">		&lt;/action&gt;</div><div class="line">	&lt;/package&gt;</div><div class="line">	</div><div class="line">     &lt;package name="QRCode" extends="json-default"&gt;</div><div class="line">	    &lt;action name="qRCodeAction_*" class="com.zwl.action.QRCodeAction" method="&#123;1&#125;" &gt;</div><div class="line">	        &lt;result  type="json"&gt;</div><div class="line">		       &lt;param name="root"&gt;message&lt;/param&gt;</div><div class="line">		    &lt;/result&gt;</div><div class="line">		&lt;/action&gt;</div><div class="line">	&lt;/package&gt; </div><div class="line">&lt;/struts&gt;</div></pre></td></tr></table></figure>
<p>最后打开含有二维码那个页面，然后扫一扫就可以跳转到含数据的界面，当然笔者之前遇到了几个问题，首先是图片地址在action中要正确，不然出现null，其次这是只能一个二维码并且含参数id的，只能有一个action，当然可以优化。。。</p>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java工具包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用nat123搭建本地服务器]]></title>
      <url>http://www.myzwl.win/2017/02/24/nat123/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>这是笔者去年第一次将web项目通过外网访问，当然结果很美好，过程很艰难，当时也是第一次用文档记录了探索过程，当然也是在google老师的帮助下，诚然学习最大的乐趣就是通过自己忘我的想尽一切办法最后solve的那种快感</strong><br><em>进入正题</em></p>
<p> 1 因为要把服务器架在自己的机子上，所以可以选择花生壳和nat123，于是当时百度了一堆关于该技术，充其量只是了解了概念，然后修改tomcat配置文件，先将默认的8080端口改为100（按理讲应该改为80，之后注意中讲为什么），然后将root文件夹全部删掉，当然还有一部（但是我配置了只要一输入域名就是空白页，所以我舍弃了这一步）配置域名与tomcat项目的映射</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Context path=<span class="string">""</span> debug=<span class="string">"0"</span> docBase=<span class="string">"你项目的决定路径"</span> reloadable=<span class="string">"true"</span>&gt;&lt;/Context&gt;</div></pre></td></tr></table></figure>
<p> 2 tomcat部分算是完成了，之后我选择了用nat123，建议去官网下载最新版本，注册，登录然后按照百度步骤，懒得写了就截个图吧<br> <img src="/images/imgs1/15.gif" alt="Alt text"></p>
<pre><code>注意应用类型我们选80（http）网站，毕竟这是相对来说最佳选择，内网端口（默认可以写80）我选择了100（之后一定要打开和开放端口，后面再说），内网地址，命令行中输入ipconfig查看ip4就是内网，当然也可以用localhost等等（因为他们在tomcat配置，或者在c盘的一个文件中为他们设置了常量，百度就能找到c盘那个源码，tomcat不多说就在配置里面，很好找），其他配置不动，然后保存
</code></pre><p>  <img src="/images/imgs1/16.gif" alt="Alt text"><br>    这样就有了域名<br>  <img src="/images/imgs1/17.gif" alt="Alt text"></p>
<pre><code>在打开nav123客户端，出现笑脸，如图等表示映射正常，
</code></pre><hr>
<p><strong>然后下面才是最恐怖的地方了（出现各种问题）</strong></p>
<p><strong>1 如果你内网和tomcat选择的是80端口，注意80端口默认不打开的，先开启控制面板-系统与安全-windows防火墙-高级设置-入站规则-新建规则-端口-80-下一步。。-完成，</strong><br>   然后在用netstat –a看看有没有80端口，假设有了，然后以为顺利 了，结果点击客户端的设置，发现最上面出现无公网连接，也就是说内网的80端口不能映射外网，这下麻烦了，好吧，据需钻研解决方案。试着其中一个靠谱的，说路由器配置中没有开放外网，好吧<br><img src="/images/imgs1/18.gif" alt="Alt text"><br>   先在计算机中输入192.168.1.1（这是电信的），打开路由器（然后简单去了解了一下路由器）先开启dmz主机，指派一个特定内网ip（那个机子对外开放），然后</p>
<p><img src="/images/imgs1/19.gif" alt="Alt text"></p>
<p><strong>在虚拟服务中打开相应端口80（暂且不是100），然后自以为一切顺利，在点开客户端那个设置或打开命名行输入ipconfig，都显示自己的公网了，相当于一道闸门打开了，当然也找不出问题了，结果又出现将域名输入出现错误。</strong></p>
<p><strong>结果觉得可能是80端口被封（可是已经在客户端能做的范围内把80打开了，最好的解释是要去电信局备案，才能在服务器端解封80端口），也就是说，80端口我们用不了了）</strong></p>
<p><strong>居然一时用不了，就用其他端口吧，就100吧，把之前所有的80开放改为100，然后在打开网页（注意：tomcat没有配置项目初始化，自己指定），然后在用手机或者其他机子试一次，即域名+项目名，结果成功了，但是网速不行啊（又头疼了~~）</strong></p>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 踩坑 , window </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单例设计模式]]></title>
      <url>http://www.myzwl.win/2017/02/23/danli/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>在介绍单例设计模式之前，先简单介绍一下java的内存分析，可以帮助我们更好的了解相关内容。在此之前，先简单介绍几个相关概念</strong></p>
<h3 id="Stack（栈）"><a href="#Stack（栈）" class="headerlink" title="Stack（栈）"></a>Stack（栈）</h3><p>存放基本数据类型的数据和对象的引用及存放变量，如果存放的是基本数据类型（非static），直接将变量名和值存入stack中，如果是引用，只将变量名存入栈，然后指向它new的对象（存放在堆中）</p>
<h3 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a>Heap（堆）</h3><p>存放new产生的数据</p>
<h3 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h3><p>存放在对象中用static定义的静态成员（基本类型）</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>存放所有数据</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><strong>下面将模拟几个实例先说明在证明。（此外注意String不是基本数据类型）</strong><br><img src="/images/imgs2/1.gif" alt="Alt text"><br>上面给出了一个实例，意在了解内存分配，接下来将以String为例说明</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String str="abc";</div><div class="line">String str1="abc";</div><div class="line">String str2=str;</div><div class="line">String str3=new String("abc");</div><div class="line">String str4=new String("abc");</div><div class="line">String str5=str3;</div><div class="line">static String str6="abc";</div><div class="line">static String str7=new String("abc");</div></pre></td></tr></table></figure>
<p>对应的测试内存地址是否相等</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   System.out.println(str==str1);</div><div class="line">System.out.println(str==str2);</div><div class="line">System.out.println(str1==str2);</div></pre></td></tr></table></figure>
<p>测试结果 true true true<br>说明String 是引用类型，而且上面方法产生的变量都只在栈中并且都是同一个地址</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   System.out.println(str==str3);</div><div class="line">System.out.println(str3==str4);</div></pre></td></tr></table></figure>
<p>测试结果：false false<br>说明：new 之后的对象地址存放在堆中，同时堆中每个new之后的对象地址都是不一样的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   System.out.println(str==str6);</div><div class="line">System.out.println(str3==str6);</div><div class="line">System.out.println(str6==str7);</div><div class="line">System.out.println(str3==str7);</div></pre></td></tr></table></figure>
<p>测试结果：true false false false<br>说明：String类型的静态变量存放在栈中，而new之后的静态变量存放在堆中</p>
<p>关于内存分配，比较复杂，这里只简单验证其中一些，其他可以自己设计案例模拟</p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>顾名思义就是指唯一的对象实例<br>具体点说就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例只存在一个，<br>通常其结构如下所示。<br><img src="/images/imgs2/2.gif" alt="Alt text"><br>入门案例：首先是单例类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pojo;</div><div class="line"></div><div class="line">public class Singleton &#123;</div><div class="line"> private static Singleton singleton=new Singleton();</div><div class="line"> </div><div class="line"> private Singleton()&#123;&#125;</div><div class="line"></div><div class="line"> public static Singleton getInstance()</div><div class="line"> &#123;</div><div class="line">	 return singleton;</div><div class="line"> &#125;&#125;</div></pre></td></tr></table></figure>
<p>测试用junit4进行测试</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test1()&#123;</div><div class="line">	System.out.println("start test..");</div><div class="line">	Singleton obj1=Singleton.getInstance();</div><div class="line">	Singleton obj2=Singleton.getInstance();</div><div class="line">	System.out.println(obj1==obj2);</div><div class="line">	System.out.println("end test..");</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果：start test.. true end test..<br>说明，obj1与obj2是同一个实例，间接说明了单例的特性</p>
<p>至此我们对单例有了一个初步的形式上的认识了，那么它的特点是什么了？主要为三点<br>一：单例类确保自己只有一个实例（构造函数私有：不被外部实例化，也不被继承）<br>二：单例类必须自己创建自己的实例<br>三：单例类必须为其他对象提供唯一的实例</p>
<p>说到单例就必然涉及到多线程，不多说，先模拟一个多线程来说明单例中存在的并发问题。<br>友情提醒一下，上面用的是饿汉式创建单例，就一开始就创建了一个实例，显然浪费内存，接下来将用懒汉式创建单例<br>主体类代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static Singleton singleton;</div><div class="line">	</div><div class="line">	 private Singleton()&#123; &#125;</div><div class="line">	 </div><div class="line">	 public static Singleton getInstance()</div><div class="line">	 &#123;</div><div class="line">		 if(singleton==null)&#123;</div><div class="line">			 singleton=new Singleton();</div><div class="line">		 &#125;</div><div class="line">		 return singleton;</div><div class="line">	 &#125;</div></pre></td></tr></table></figure>
<p>下面将用三个线程模拟，两个线程调用单例类，第三个线程启动前两个线程，测试用junit</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class thread1 implements Runnable&#123;</div><div class="line">	Singleton singleton;</div><div class="line">	public Singleton getSingleton() &#123;</div><div class="line">		return singleton;</div><div class="line">	&#125;</div><div class="line">	public void setSingleton(Singleton singleton) &#123;</div><div class="line">		this.singleton = singleton;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		singleton=Singleton.getInstance();	&#125;&#125;</div><div class="line">		</div><div class="line">public class Thread2 implements Runnable&#123;</div><div class="line">	Singleton singleton;</div><div class="line">	public Singleton getSingleton() &#123;</div><div class="line">		return singleton;	&#125;</div><div class="line">		</div><div class="line">	public void setSingleton(Singleton singleton) &#123;</div><div class="line">		this.singleton = singleton;	&#125;</div><div class="line">		</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		 singleton=Singleton.getInstance();</div><div class="line">			&#125;&#125;</div></pre></td></tr></table></figure>
<p>简单说明一下，这两个线程目的是调用单例类（注意如果是单例，决不允许出现不同实例）<br>先贴出测试类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   thread3 t=new thread3();</div><div class="line">Thread tt=new Thread(t);</div><div class="line">tt.start();</div></pre></td></tr></table></figure>
<p>这里我们通过控制第三个线程来构造并发，(这里采用数学中的极限思想)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class thread3 implements Runnable&#123;</div><div class="line">	thread1 t1=new thread1();</div><div class="line">	Thread2 t2=new Thread2();</div><div class="line">	Thread t=new Thread(t1);</div><div class="line">	Thread t3=new Thread(t2);</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">	long start=System.currentTimeMillis();</div><div class="line">		t.start();</div><div class="line">		t3.start();</div><div class="line">		long end=System.currentTimeMillis();</div><div class="line">		System.out.println(end-start);   //并发的时间间隔</div><div class="line">		System.out.println(t1.getSingleton());</div><div class="line">		System.out.println(t2.getSingleton());</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试结果：0 null null<br>多次运行，又出现另一种结果：6<br>com.zwl.pojo.Singleton@8fdcd1<br>null和其他不同步结果<br>说明在很短的时间间隔类，一个居然已经有了实例，而另一个居然是空，显然不是单例，想想倘若在此时去操作该单例，可能就会是静态类发生变化，也就是并发问题了。</p>
<p>很自然。那么怎么去解决了，一种很通用的方法就是加锁实现同步</p>
<h3 id="双锁机制"><a href="#双锁机制" class="headerlink" title="双锁机制"></a>双锁机制</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static Singleton getInstance()</div><div class="line"> &#123;</div><div class="line">	 if(singleton==null)</div><div class="line">	 &#123;</div><div class="line">		 synchronized(Singleton.class)</div><div class="line">		 &#123;</div><div class="line">	 if(singleton==null)&#123;</div><div class="line">		 singleton=new Singleton();</div><div class="line">	 &#125;</div><div class="line">		 &#125;</div><div class="line">	 &#125;</div><div class="line">	 return singleton;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Synchronized关键字，声明使该线程在某处同步，也就是一个线程先占用，另一个线程被阻塞，显然如果不为空，就直接返回对象，对应第二个线程也就不执行if语句了，达到单例效果，可以想象如果为计数变量，同样可以通过二次加锁实现同步<br>  但是实际还是出现不同步，原因是jvm的一个bug，它允许无序写入线程，导致不同步，当然我们可以通过申明volatile关键字。<br> 为什么就可以解决双重解锁的bug了？<br>原因是volatile保证原子性，顺序性，即在双重加锁前保证多线程实现顺序性，举个例子吧，现在有两个线程t1和t2，分别执行b，c操作，如果乱序写入，可能出现t1正在操作b还没完成，t2操作c，致使单例失败，所以需要保证顺序性。<br>经过不断的测试，发现完全同步，只不过时间间隔为0，和null，null，至少是同步了~</p>
<p><strong>接下来简单比较一下饿汉式和懒汉式的区别</strong><br>从速度和反应时间上，饿汉式加载好，从资源利用率上懒汉式好，<br>饿汉式很明显不会出现多线程并发问题，所以是线程安全的，而懒汉式则是非线程安全的</p>
<p>关于单例模式的应用，笔者在当初学习过程中，遇到很多，学习总是一个不断压缩与重新认识的过程，像sql工具类，hibernate的懒加载，mybatis及 spring中的一些配置等等，往往把握不好，就会出现错误，这里只列举一些工具类，因为它是笔者接触的第一个单例应用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Private static Connection connection;</div><div class="line">Private sqlhelper()&#123;&#125;；</div><div class="line">	public static Connection mysqlconn() throws Exception &#123;</div><div class="line">		try &#123;</div><div class="line">			// 加载驱动</div><div class="line">			Class.forName("com.mysql.jdbc.Driver");</div><div class="line">			// 连接数据库</div><div class="line">			 connection = DriverManager.getConnection(</div><div class="line">					"jdbc:mysql://localhost:3306/software", "root", "");</div><div class="line">			System.out.println("获得数据库");</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; </div><div class="line">		return connection;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[window分区导致双系统无引导界面]]></title>
      <url>http://www.myzwl.win/2017/02/22/fenqu/</url>
      <content type="html"><![CDATA[<p><strong>先简单介绍一下情境，笔者电脑上装的是双系统，而且bios上设置了system password（当然，已经忘记了是多少了），然后心血来潮在阿里云买了一个学生优惠的服务器，安装了mysql+tomcat7+jdk，在电脑上d盘已经装了linux，在c盘上分了一个分区，那么问题来了，当再次打开电脑时，无引导界面，取而代之的是</strong></p>
<p><img src="/images/z4.gif" alt="Alt text"><br>然后google了许多解决方案，当然是在彩果许多坑之后找到了适合自己的解决方案，毕竟一个问题的解决总不是一帆风顺的。<br>  <em>进入正题</em><br>  <strong>如果我们要重装系统，肯定得用到bios设置，那么问题来了，如果你设置了密码，并且密码忘记了，那怎么办?</strong><br>  一种办法是通过硬件，通过把电池正负极按照网上说的折腾一下，就可以恢复bios出厂设置，显然这种方法有极大风险，可能会损坏硬件（具体参考google）或者用相关修复工具，但是笔者的电脑都无引导界面，尴尬了~<br>  还有一种办法就是在你输入3次错误的密码时会出现如下错误代码</p>
<p> <img src="/images/z1.gif" alt="Alt text"><br> 然后就是<a href="https://bios.pw.org" target="_blank" rel="external">在这里面设置</a>，如下图，输入上述的错误代码，就出现了bios密码，</p>
<p> <img src="/images/z2.gif" alt="Alt text"></p>
<p> <strong>当然，笔者电脑里有许多宝贵的数据，不可能也不愿意重装系统，经过google一番，发现是分区导致引导盘不能引导，只需要找到该分区，在llinux上重新修复就行了</strong></p>
<blockquote>
<p>首先在页面中输入如下ls<br>grub rescue&gt; ls<br>出现如下（基本都差不多）<br>hd0，（hd0，nsdoc9），（hd0，nsdoc8），（hd0，nsdoc7），（hd0<br>，nsdoc6），（hd0，nsdoc5），（hd0，nsdoc2），（hd0，nsdoc1）</p>
</blockquote>
<p>然后通过ls 如上的分区循环一遍，如ls （hd0，nsdoc9）/<br>上述有一个会出现详细信息，他就是安装linux那个分区，其余都是unknown filesystem，当然如果出现bad filesystem那是你没加/<br>如下图：</p>
<p><img src="/images/z3.gif" alt="Alt text"></p>
<p><strong>接下来设置root引导盘</strong></p>
<blockquote>
<p>set root=(hd0，nsdoc6）<br>这里设置的是上述找到分区的那个盘<br>set prefix=(hd0，nsdoc6）/boot/grub/</p>
</blockquote>
<p>然后可以用set验证一下</p>
<blockquote>
<p>set<br>会出现上述设置的信息</p>
</blockquote>
<p>最后执行下述命令</p>
<blockquote>
<p>insmod normal<br>在输入normal，就会自动跳转到引导界面，我们选择ubuntu进入，在里面进行修复即可</p>
</blockquote>
<p>进入linux系统打开终端，先更新grub，即输入</p>
<blockquote>
<p>sudo update-grub</p>
</blockquote>
<p>ok后在输入</p>
<blockquote>
<p>sudo grub-install /dev/sda<br>结束后，我们就可以重启电脑，一切都ok了。<br>进入电脑后笔者做的第一件事就是备份数据，毕竟要给自己留条后路，如果遇到更复杂的情况就后悔莫及了。。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 踩坑 , window </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里云服务器上搭建javaweb站点]]></title>
      <url>http://www.myzwl.win/2017/02/21/dajianserver/</url>
      <content type="html"><![CDATA[<p><strong>事实上笔者在去年8月份的时候就已经在自己电脑上通过nat123搭建了一台服务器，即p2p，自己的电脑作为服务器，但是这很不安全，而且每次别人通过外网访问，电脑必须打开而且开着服务器，由于是免费的，导致别人访问网速跟不上等等，最近阿里云有学生9.9元购买服务器，所以笔者买了一个，也很有兴趣将笔者之前写的两个网站部署上，结果很美好，但过程很坑，所以就需要总结来提高自己</strong><br><em>进入正题</em><br>笔者也是google了许多例子和前人的经验找到适合自己的方法</p>
<p><strong>首先需要租一台云服务器，我选择了阿里云</strong><br><img src="/images/imgs1/1.gif" alt="Alt text"></p>
<p>注意这里操作系统有四个选项，笔者发现只有第四个符合自己（貌似是自定义），然后按照步骤，其中有些需要注意<br><img src="/images/imgs1/1.gif" alt="Alt text"></p>
<p>安全组，这里暂时可以选择默认的第一个，因为后面如果在搭建web时需要一些端口（如mysql默认3306端口改掉，tomcat8080端口换成80等等），到时可以在后台操作）</p>
<p><img src="/images/imgs1/3.gif" alt="Alt text"><br>关于镜像选择，因为笔者是window7，而且还是32位的，相对64位只能有不大于4g的内存，</p>
<p><img src="/images/imgs1/4.gif" alt="Alt text"><br>这里的密码就是之后在本地机子上远程登录这个服务器所要的密码</p>
<p>ok至此，成功租了一台服务器，这时你会收到一条短信，里面有你这台服务器的公网地址</p>
<p><strong>然后笔者就开始着手在本机上登录该服务器，当然是为了搭建javaweb准备的</strong></p>
<ol>
<li><p>在本机上准备javaweb需要的环境<br><img src="/images/imgs1/5.gif" alt="Alt text"></p>
</li>
<li><p>在本机上新建一个分区用来放上述软件供服务器远程使用（其实也可以不用分区，直接复制也行，毕竟笔者被分区坑了，导致后来的双系统引导界面消失）</p>
</li>
<li><p>本机上登录远程连接可以用运行-mstsc-直接进入到如下界面<br><img src="/images/imgs1/6.gif" alt="Alt text"><br>其中计算机就是你的公网地址，如果你是新建了一个分区，那么就点选项在本地资源的详细信息中就新建的那个分区勾上，笔者这里是x盘（如果没有的话就直接连接）<br><img src="/images/imgs1/7.gif" alt="Alt text"></p>
</li>
<li><p>后面什么证书，安全啊先不管了，应该是进入远程服务器了<br><img src="/images/imgs1/8.gif" alt="Alt text"></p>
</li>
<li><p>接下来就是将mysql，jdk等复制到c盘中，因为只有一个盘，后续就是安装配置了</p>
</li>
<li>安装jdk，笔者的是jdk1.6（注意jdk版本不同，后续运行高版本会出像版本错误，笔者已吃过亏），配置环境变量</li>
<li>安装tomcat，配置tomcat环境变量，注意上述不需要自定义文件夹，因为只有一个c盘，tomcat默认端口是8080</li>
<li>安装mysql，这里面需要注意的是里面有端口设置，可以选择默认的3306或者自定义，然后就是用户与密码设置</li>
<li>可以使用可视化数据库工具，这里笔者使用了navicat<br><strong>至此算是搭建了一个简单web环境，可以先测试一下</strong><br>拷贝一个已经被编译过的web项目，启动tomcat与mysql，然后利用localhost:8080/项目名访问，如果出现界面就表示以上配置成功</li>
</ol>
<p><strong>接下来需要买一个域名</strong><br><img src="/images/imgs1/9.gif" alt="Alt text"></p>
<ol>
<li>成功后点击解析，在里面找到新手设置，点进去<br><img src="/images/imgs1/10.gif" alt="Alt text"><br>点击设置网站解析，然后输入公网，即可。</li>
<li>在远程服务器中，找到tomcat下conf下的server.xml文件，如果我们不想要8080端口并且输入域名时不想要端口的话，就先把8080端口改成80</li>
</ol>
<blockquote>
<p> Connector port=”80” protocol=”HTTP/1.1”<br>               connectionTimeout=”20000”<br>               redirectPort=”8443” /&gt;</p>
</blockquote>
<p> 3.然后找到host</p>
<blockquote>
<p>  Host name=”你刚刚解析的域名”  appBase=”webapp”<br>            unpackWARs=”true” autoDeploy=”true”&gt;</p>
<p>&lt;Context path=”” docBase=”/项目名” debug=”0” reloadable=”true” </p>
</blockquote>
<p>注意这里appBase是放项目的站点，context内的docBase是你的项目名，目前我们只是一个tomcat运行一个域名执行一个项目<br>然后打开C:\Windows\System32\drivers\etc下的host文件<br>增加如下设置</p>
<blockquote>
<p>127.0.0.1       localhost<br>  ::1             localhost<br>192.168.1.11    刚刚的域名</p>
</blockquote>
<p>保存，然后重启服务器，可能会发现会遇到一些问题，如80端口被占用，80端口未开放等等，假设未被占有（如果占用，google上有解决方法），<br>如果未开放，这里我们就需要在云服务器上进行端口开放设置</p>
<p><strong>进入我们购买的云服务器，点击安全组，选中一个实例，点击配置，选择公网入方向，按照步骤开放想要的端口</strong><br> <img src="/images/imgs1/10.gif" alt="Alt text"></p>
<p> 至此只要输入域名就可以访问了。</p>
<p> 当然，如果我们想要一个tomcat上配置多个域名，每个域名运行各自不同的项目，那如何做了，经过踩坑后，大概如下步骤</p>
<ol>
<li>可以选择在tomcat下新建一个站点，类似于原来的webapp，然后在server.xml中进行配置一个新host</li>
</ol>
<blockquote>
<p>  Host name=”第二个域名”  appBase=”新创建的站点”<br>            unpackWARs=”true” autoDeploy=”true”&gt;</p>
<p>&lt;Context path=”” docBase=”/第二个项目名” debug=”0” reloadable=”true”</p>
</blockquote>
<p>2.然后在hosts文件汇总加入第二个域名</p>
<blockquote>
<p>127.0.0.1       localhost<br>  ::1             localhost<br>192.168.1.11    刚刚的域名<br>192.168.1.11    第二个域名</p>
</blockquote>
<p>最后重启服务器。<br>笔者在这里遇到了一个很奇怪的坑，同一服务器下的项目出现奇怪的jar包冲突，只要删掉xerces包就行了（当然是在远程服务器上才产生冲突的）</p>
]]></content>
      
        <categories>
            
            <category> 学习踩坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 踩坑 , window </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初步搭建hexo博客]]></title>
      <url>http://www.myzwl.win/2017/02/20/hexo1/</url>
      <content type="html"><![CDATA[<p>博客是一种能够更好提高自己的途径，关于利用hexo搭建博客，笔者是一路google一路踩坑，才完成的，当然关于这方面的搭建，实在太多了，笔者也只是稍微总结一下</p>
<ol>
<li>首先在github上注册一个账号</li>
<li>创建代码库（repository），一般以yourname/youname.github.io</li>
<li>setting中选择主题</li>
<li>购买一个域名（这里以笔者在阿里云买的为例）</li>
<li>点击域名里的解析<br><img src="/images/imgs1/12.gif" alt="Alt text"><br>注意CNAME为你的仓库名，其他套用<br>6.回到setting中在Custom domain下填写你刚才的域名，然后在code中会出现一个CNAME文件<br>7.yourname.gthub.io访问你的博客，目前应该只是一个默认主页</li>
</ol>
<p><strong>接下来就是本地安装hexo与github page联系起来</strong><br> 1.官网安装node.js（注意是32位还是64位）<br> 2安装git（在过程中会有一项自带环境变量设置，选中，不然后面无法识别git）<br> 3安装hexo（以笔者的在e:/blog下为例）<br> 在git bush中</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-cli -g</div></pre></td></tr></table></figure>
<p>然后在输入</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo --save</div></pre></td></tr></table></figure>
<p>然后利用</p>
<blockquote>
<p>hexo -v</p>
</blockquote>
<p>验证安装是否成功</p>
<p> 4.然后在要创建的目录下初始化hexo</p>
<blockquote>
<p>hexo init</p>
</blockquote>
<p>5安装所需的组件和依赖组件<br>  npm install</p>
<p>笔者当时一下子全部安装了很多扩展组件如:</p>
<blockquote>
<p>npm install hexo-deployer-git –save</p>
</blockquote>
<p>在看看目录下应该产生如下目录<br><img src="/images/imgs1/13.gif" alt="Alt text"></p>
<p>6 生成静态文件</p>
<blockquote>
<p>hexo g</p>
</blockquote>
<p>7 启动服务器，进行本地预览访问</p>
<blockquote>
<p>hexo s</p>
</blockquote>
<p>然后在浏览器中打开<a href="http://localhost:4000/，会出现一个默认的hexo主页" target="_blank" rel="external">http://localhost:4000/，会出现一个默认的hexo主页</a></p>
<p>8 Hexo与github page 联系<br>首先是配置Git个人信息</p>
<blockquote>
<p>git config –global user.name “用户名”<br>git config –global user.email “邮箱地址”</p>
</blockquote>
<p>9 生成密钥</p>
<blockquote>
<p>sh-keygen -t rsa -C “邮箱地址”</p>
</blockquote>
<p>这里笔者遇到一个坑，默认是在administrator目录下生成一个.ssh文件夹里面包含<br><img src="/images/imgs1/14.gif" alt="Alt text"><br>结果没有，所以自己在该目录下创建一个.ssh文件夹</p>
<p>10 配置Deployment（以笔者的为例）</p>
<blockquote>
<p>deploy:<br>  type: git<br>repository: <a href="http://github.com/slycmiaoxi/slycmiaoxi.github.io.git" target="_blank" rel="external">http://github.com/slycmiaoxi/slycmiaoxi.github.io.git</a><br>branch: master</p>
</blockquote>
<p>这里的repository是git上对应的use ssh进行clone的</p>
<p>11 登录到git的use ssh将.ssh文件下的id_rsa.pub里的内容复制到改里面</p>
<p>12 写文章上传</p>
<blockquote>
<p>hexo new post “article title” 新建一个文章，默认放再_post下<br>  hexo clean 清空public里的文件，该文件夹是上传到git上<br>  hexo g 生成到public文件夹中<br>  hexo d 部署，此过程要输入用户名和密码，</p>
</blockquote>
<p>  笔者在hexo d过程中曾出现一致无权限，后来在google老师的指引下需要设置用户名和密码，在.ssh文件下生成known_hosts文件，如果没有遇到，那是比较幸运了<br>  目前还是默认的主题，显然不好看，其次编写文章需要markdown语言，笔者使用的是小书匠，因为其组件丰富，操作简单</p>
<p> 13 更换主题<br> 首先需要cd到你的hexo根目录，然后</p>
<blockquote>
<p>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> themes/next</p>
</blockquote>
<p> 我选择的是next主题，因为其功能，配置方面相对较强大，当然在主题配置方面一路是坑，这里推荐去next官网看配置，大部分都涉及到<br> 如果我们启用next主题，只要在_config.yml（站配置文件中）找到theme，将默认的改成next即可，<br> 另一方面，在theme文件夹下的next文件夹下的_config.yml(主题配置文件）进行主题的配置，当然里面其他文件也是可以配置的，当然google是最好的帮手<br> 最后主题也配置好了，只需要输入yourname.github.io就可以访问你的博客了<br> 当然笔者是一路踩坑过来，很多google也不一定适合自己，只有自己探索过的才是最适合自己的。<br> 最后需要说一下，多说老是注册异常，后来干脆选择友言代替，总之theme里面有很多需要探索的，google是最好的老师</p>
]]></content>
      
        <categories>
            
            <category> 学习总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
