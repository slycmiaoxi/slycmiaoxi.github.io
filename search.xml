<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[spring mvc之三:注解开发]]></title>
      <url>%2F2017%2F03%2F31%2Fspringmvc3%2F</url>
      <content type="text"><![CDATA[前言之前我们都是通过xml方式显示配置，会发现配置起来特别麻烦。当使用注解时，有时只需在相关类中做相关的声明，就能完成同样的工作。 不多说：先来一个注解开发例子 步骤一：首先创建一个web工程 步骤二：添加jar包 步骤三：配置web.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 默认加载方式 默认加载必须规范： * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml * 路径规范：必须在WEB-INF目录下面 --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 步骤四：配置springmvc-servlet.xml文件123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; &lt;!-- 扫描基本的父包，这样子类包被自动扫到执行 --&gt; &lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置注解处理器映射器 功能：寻找执行类Controller --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- 配置注解处理器适配器 功能：调用controller方法，执行controller --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;/bean&gt; &lt;!-- 配置sprigmvc视图解析器：解析逻辑试图 后台返回逻辑试图：index 视图解析器解析出真正物理视图：前缀+逻辑试图+后缀====/WEB-INF/jsps/index.jsp --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 这里简要说明一下，以上是注解最基本的配置，有扫描配置，两个基本配置和一个视图配置 步骤五：自定义controller类12345678910111213package com.zwl.control;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller //相当于&lt;bean class="Usercontrol"/&gt;并且声明这是一个controllerpublic class Usercontrol &#123; @RequestMapping("hello") //相当于需要访问的路径hello.do public String say()&#123; return "index" ; //放回到逻辑视图index.jsp &#125;&#125; 这是一个最简化的注解配置对应index.jsp123 &lt;body&gt;hello 盲僧 &lt;/body&gt; 测试：浏览器中输入http://localhost:100/springmvc2/hello.do 对应输出结果 hello 盲僧 RequestMapping它有三种方式，分别为 requestMapping(“hello”)requestMapping(“/hello.do”)requestMapping(value=”/hello.do”) 都能达到同样的效果，都是需要访问的路径如果在类前面添加此属性，则相当于映射路径在加一层123@Controller //&lt;bean class="Usercontrol"/&gt;@RequestMapping("/test")public class Usercontrol &#123;&#125; 即http://localhost:100/springmvc2/test/hello.do 另外，注意下里面还有个method配置，即按什么模式接受表单 @RequestMapping(value=”/hello.do”,method=RequestMethod.GET) 或者 @RequestMapping(value=”/hello.do”,method=RequestMethod.POST) 默认是两个都可以的 requestMapping(value=”/hello.do”,method={RequestMethod.POST, RequestMethod.GET}) 封装参数分析接受参数类型：基本类型，int，String等等基本类型。Pojo类型包装类型Springmvc参数封装：基于方法进行封装。 一：基本类型 封装int型参数页面123456 &lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath &#125;/ test/recieve.do" method="post"&gt;id：&lt;input type="text" name="id" id="id"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; &lt;/body&gt; 接受参数方法12345@RequestMapping("recieve") public String recieve(Integer id)&#123; System.out.println(id); return "login"; &#125; 注意这里的Integer id必须要与页面中的name=”id”一致才能正确接受参数 测试：在浏览器中输入http://localhost:100/springmvc2/index.jsp 然后输入id，后台即可接收到参数 接受字符转类型页面：1234&lt;form action="$&#123;pageContext.request.contextPath &#125;/ test/recievestr.do" method="post"&gt;id：&lt;input type="text" name="name" id="name"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; 接收参数方法：1234@RequestMapping("recievestr") public String recievestr(String name)&#123; System.out.println(name); return "login";&#125; 接受数组：分析：批量：checkbox复选框。Value必须有值页面：123456&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/recievearray.do" method="post"&gt;ID：&lt;input type="checkbox" name="ids" value="1" id="ids"&gt;ID：&lt;input type="checkbox" name="ids" value="2" id="ids"&gt;ID：&lt;input type="checkbox" name="ids" value="3" id="ids"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; 接受参数的方法12345@RequestMapping("recievearray") public String recievearray(Integer []ids)&#123; System.out.println(ids); return "login"; &#125; 接受pojo类页面：12345&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/recieveUser.do" method="post"&gt;姓名：&lt;input type="text" name="username" id="username"&gt;生日：&lt;input type="text" name="birthday" id="birthday"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; Pojo类123456public class User &#123; private String username; private Date birthday;此处省略set。Get方法&#125; 接受参数的方法：12345@RequestMapping("recieveUser") public String recievearray(User user)&#123; System.out.println(user.getUsername()); return "login"; &#125; 接受包装类型参数 包装pojo类 123456789101112131415161718public class Usercus &#123; private User user;此处省略set。Get方法。&#125;&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/usercus.do" method="post"&gt;姓名：&lt;input type="text" name="user.username" id="username"&gt;生日：&lt;input type="text" name="user.birthday" id="birthday"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt;接受参数的方法：@RequestMapping("usercus") public String usercus(Usercus user)&#123; System.out.println(user.getUser().getUsername()); return "login"; &#125; 接受集合类型参数 接受list集合首先在包装类中加入如下代码123456789101112131415161718192021private List&lt;User&gt; userlist;此处省略set，get方法然后是页面&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/recievelist.do" method="post"&gt;姓名：&lt;input type="text" name="userList[0].username" id="username"&gt;地址：&lt;input type="text" name="userList[0].address" id="address"&gt;姓名：&lt;input type="text" name="userList[1].username" id="username"&gt;地址：&lt;input type="text" name="userList[1].address" id="address"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt;接受参数方法：@RequestMapping("recievelist") public String recievelist(Usercus userlist) &#123; System.out.println(userlist.getUserlist().get(0).getUsername()); return "login"; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring mvc之二:处理器]]></title>
      <url>%2F2017%2F03%2F31%2Fspringmvc2%2F</url>
      <content type="text"><![CDATA[前言在spring mvc中，使用映射处理器可以把web请求映射到正确的处理器上，spring内置了很多映射器，而且我们也可以自定义处理器，映射处理器都能把请求传递到处理器执行链接上，并且处理器执行链接必须包含能处理该请求的处理器，而且处理器链接也能包含一系列拦截器 接下来就是一些常见的处理映射器 BeanNameUrlHandlerMapping 功能：寻找Controller 根据url请求去匹配bean的name属性url，从而获取Controller 这里注意：这是默认的映射器，也就是说我们不配置这个，也能自动执行这个 如：入门程序中的案例：12&lt;!-- 配置自定义Controler --&gt; &lt;bean id="mycontrol" name="/hello.do" class="com.zwl.control.mycontrol"&gt;&lt;/bean&gt; 即根据自定义的/hello.do，找到对应的mycontrol.java类 SimpleUrlHandlerMaping 功能：寻找Controller 根据浏览器url匹配简单url的key，key又Controller的id找到Controller如：在映射文件中配置1234567891011&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="zwl.do"&gt;mycontrol&lt;/prop&gt; &lt;prop key="slycmiaoxi.do"&gt;mycontrol&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置自定义Controler --&gt; &lt;bean id="mycontrol" class="com.zwl.control.mycontrol"&gt;&lt;/bean&gt; 测试：在浏览器输入http://localhost:100/springmvc1/zwl.do或者http://localhost:100/springmvc1/slycmiaoxi.do 输出结果： hello world 此外：这个映射器是把url进行集中配置 ControllerClassNameHandlerMapping功能：寻找Controller 根据类名（Mycontrol）类名.do来访问,类名首字母小写在配置文件中增加如下配置 12&lt;!-- 定义通过: 类名.do 形式来访问controller --&gt; &lt;bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"&gt;&lt;/bean&gt; 注意，这里并没有声明mycontrol.do和只有一个类mycontrol.java 测试：在浏览器输入http://localhost:100/springmvc1/mycontrol.do结果： hello world 事实上，以上三个映射器都可以同时存在 下面将是处理器适配器 SimpleControllerHandlerAdapter功能：执行controller 调用controller里面方法，返回modelAndView。 1234&lt;!-- 配置处理器适配器执行Controlelr ,springmvc默认的 SimpleControllerHandlerAdapter:执行Controller --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt; HttpRequestHandlerAdapter功能：执行controller首先新建一个类12345678910111213141516171819202122232425package com.zwl.control;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.HttpRequestHandler;public class httpcontrol implements HttpRequestHandler &#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); //给Request设置值，在页面进行回显 request.setAttribute("hello", "lol"); response.setCharacterEncoding("utf-8"); //跳转页面 request.getRequestDispatcher("/index.jsp").forward(request, response);; &#125;&#125; 然后在配置文件中配置123456789&lt;!-- HttpRequestHandlerAdapter负责执行实现接口HttpRequestHandler的后端 控制器。 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- 配置自定义HttpController --&gt; &lt;bean id="http" class="com.zwl.control.httpcontrol"&gt;&lt;/bean&gt; &lt;prop key="/zwl.do"&gt;http&lt;/prop&gt; 测试：在浏览器中输入：http://localhost:100/springmvc1/zwl.do 输出结果： lol 注意这两个处理器设配器可以共存！ 命令控制器Spring mvc通过命令设计模式接受页面参数。 自定义命令控制器首先新建一个pojo类123456789101112131415161718package com.zwl.pojo;public class User &#123;private int id;private String username;public int getId() &#123; return id;&#125;public String getUsername() &#123; return username;&#125;public void setId(int id) &#123; this.id = id;&#125;public void setUsername(String username) &#123; this.username = username;&#125;&#125; 自定义控制器12345678910111213141516171819202122232425262728293031323334package com.zwl.control;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.validation.BindException;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.config.MvcNamespaceHandler;import org.springframework.web.servlet.mvc.AbstractCommandController;import com.zwl.pojo.User;public class CommandController extends AbstractCommandController &#123; //指定参数绑定哪个pojo类 public CommandController()&#123; this.setCommandClass(User.class); &#125; @Override protected ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object command, BindException error) throws Exception &#123; //将命令对象强转成用户对象 User user=(User)command; ModelAndView mv=new ModelAndView(); mv.addObject("user",user); mv.setViewName("index"); return mv; &#125;&#125; 封装参数页面（这里是login.jsp）12345678 &lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath &#125;/command.do" method="post"&gt;姓名：&lt;input type="text" name="username" id="username"&gt;id：&lt;input type="text" name="id" id="id"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; &lt;/body&gt; 配置bean1&lt;bean name="/command.do" class="com.zwl.control.CommandController"&gt;&lt;/bean&gt; 回显数据：1234 &lt;body&gt; $&#123;user.username &#125; &lt;br&gt;$&#123;user.id &#125; &lt;br&gt; &lt;/body&gt; 测试：在浏览器中输入http://localhost:100/springmvc1/login.jsp到login.jsp然后分别将name输入中文和非中文，发现出现中文乱码 需要Spring编码过滤器：在web.xml配置12345678910111213&lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 然后输入中文，就没有乱码了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring mvc之一:hello world]]></title>
      <url>%2F2017%2F03%2F31%2Fspringmvc1%2F</url>
      <content type="text"><![CDATA[前言MVC模式是Model-View-Control的简写，而spring mvc主要负责c层，主要为封装web请求为一个数据对象、调用业务逻辑层来处理数据对象、返回处理数据结果及相应的视图给用户 简要概述spring mvc： SpringC层框架的核心是DispatcherServlet，它的作用是将请求分发给不同的后端处理器，springC层框架使用了后端控制器、映射处理器和视图解析器来共同完成c层的主要任务，真正的把业务层处理的数据结果和相应的视图拼成一个对象，即ModelAndView对象 下面以hello world为入门程序搭建环境步骤一：创建一个web工程 步骤二：导入相关jar包 步骤三：编写web.xml配置文件1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 简要说明一下：dispatcherservlet就是一个servlet，也是对请求进行转发的核心servlet。在这里即所有的.do的请求将首先被dispatcherservlet处理，而它要做的工作就是对请求进行分发（即把请求转发给具体的controller），可以简单的认为，他就是一个总控处理器，除此之外，它还能使用spring的其他功能同时注意一下上面的servlet-name默认加载方式 默认加载必须规范： * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml * 路径规范：必须在WEB-INF目录下面 步骤四：配置springmvc-servlet.xml12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; &lt;!-- 配置处理器映射器,springmvc默认的处理器映射器 BeanNameUrlHandlerMapping：根据bean(自定义Controler)的name属性的url去寻找hanler(Action:Controller) --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- 配置处理器适配器执行Controlelr ,springmvc默认的 SimpleControllerHandlerAdapter:执行Controller --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- 配置自定义Controler --&gt; &lt;bean id="mycontrol" name="/hello.do" class="com.zwl.control.mycontrol"&gt;&lt;/bean&gt; &lt;!-- 配置sprigmvc视图解析器：解析逻辑试图 后台返回逻辑试图：index 视图解析器解析出真正物理视图：前缀+逻辑试图+后缀--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 步骤五：自定义controller123456789101112131415161718192021222324252627package com.zwl.control;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;public class mycontrol implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123; //接受请求，参数，验证参数 //封装参数，调用业务方法 //返回视图 ModelAndView mv=new ModelAndView(); //设置页面回显数据 mv.addObject("hello","hello world"); //指定跳转的视图 //返回物理视图 mv.setViewName("index"); return mv; &#125;&#125; 步骤六：定义视图页面123&lt;body&gt; $&#123;hello&#125; &lt;/body&gt; 测试：在浏览器中输入http://localhost:100/springmvc1/hello.do 结果： hello world 简要分析入门程序的过程1 启动服务器，根据web.xml的配置加载前端控制器dispatcherservlet。在加载时，会完成一系列的初始化动作。 2 根据servlet的映射请求（上面的.do），并参照spingmvc-servlet.xml文件，把具体的请求分发给特定的后端处理器，如上面的mycontrol 3 后端控制器调用相应的逻辑层代码，完成处理并返回视图对象ModelAndView给前端处理器 4 前端处理器根据后端控制器返回的ModelAndView对象，返回一个相应的页面给客户端]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring之装配bean]]></title>
      <url>%2F2017%2F03%2F30%2Fspring2%2F</url>
      <content type="text"><![CDATA[前言在spring中，对象无需自己负责查找或创建与其关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象，例如一个消费系统需要信誉证件，但它不需要自己创建，它只负责自己两手空空，而容器就赋予它一个信用卡认证组件。 通常，我们将创建应用对象间相互协作关系的行为称为装配。这也是依赖注入的本质。 一：声明bean 首先我们假想一个选秀场景，该bean为一个表演接口 public interface Performe { public void perform();}很显然我们需要一些参赛者，而这些参赛者就需要spring帮我们创建了 二：创建spring配置 Spring是一个基于容器的框架，但是如果我们不对他进行任何配置，那么它就相当于一个空框架，一般情况下有采用XML或者注解式声明，这里都采用xml形式。12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;&lt;/beans&gt; 三：声明一个简单的bean 这次表演者可以使各种各样的人，首先是一个杂技师。12345678910111213141516public class Juggler implements Performe &#123; private int bigbang=5; public Juggler()&#123; &#125; public Juggler(int bigbang)&#123; this.bigbang=bigbang; &#125; @Override public void perform() &#123; System.out.println("it is "+bigbang); &#125;&#125; 主要打印出杂技师扔了多少块Bigbang； 接下来在spring中配置bean，123&lt;bean id="juggle" class="com.zwl.dao.Juggler"&gt;&lt;/bean&gt; 这是一个最简单的声明格式接下来就是加载spring上下文，进行测试 123Juggler hello=(Juggler) ApplicaionContextUtil.getApplicationContext().getBean("juggle"); hello.perform(); ApplicaionContextUtil.xml 12345678910private static ApplicationContext ac=null;private ApplicaionContextUtil()&#123; &#125;static&#123; ac=new ClassPathXmlApplicationContext("applicationContext.xml");&#125;public static ApplicationContext getApplicationContext()&#123; return ac;&#125; 测试结果： it is 5 四：通过构造器注入 有时候我们需要通过构造方法进行注入123&lt;bean id="juggle" class="com.zwl.dao.Juggler"&gt;&lt;constructor-arg value="66"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 因为Juggle有一个代参和无参构造函数，默认不配置constructor-arg则是默认构造函数，相反则是代参构造函数， 构造器注入对象引用 上面是注入的基本类型，如果是一个对象了？ 在Juggler类中增加如下代码12345678910private Helloworld helloworld; public Juggler(Helloworld helloworld)&#123; this.helloworld=helloworld; &#125;public void perform() &#123; System.out.println("it is "+bigbang); helloworld.sayhello(); &#125; 其中helloworld为入门时的程序 接下来就是配置文件123456789&lt;bean id="helloworld" class="com.zwl.spring.Helloworld"&gt;&lt;property name="name"&gt;&lt;value&gt;hello world!&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id="juggle" class="com.zwl.dao.Juggler"&gt;&lt;constructor-arg ref="helloworld"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 其中ref为注入另一个bean的id测试结果： it is 5it is hello world 五：bean的作用域 所有的spring bean默认都是单例，即它总是返回同一个bean实例，通过在bean中的scope属性进行设置，一般有如下属性 Singleton 在每一个spring容器中，一个bean定义只对应一个对象实例（默认） Prototype 允许bean的定义可以被实例化任意次（每次调用都创建一个实例） 另外还有request，session，global-session，一般只用前两者测试代码：123Helloworld hello=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld"); Helloworld hello1=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld"); System.out.println(hello==hello1); 当采用默认scope时，测试结果为true 当进行如下修改时1&lt;bean id="helloworld" class="com.zwl.spring.Helloworld" scope="prototype"&gt; 测试结果为false 另外在我们初始化和销毁bean时，需要在bean中配置1&lt;bean id="helloworld" class="com.zwl.spring.Helloworld" scope="prototype" init-method="sayhello" destroy-method="saybyb"&gt; 其中sayhello与saybyb都是该类中方法，当在调用该bean之前，调用init-method，而在该bean销毁前，即生命周期结束前实现destroy-method， 六：注入bean属性 通常，javabean的属性时私有的，同时拥有一组set与get方法取出该属性，spring可以借助set配置属性的值 注意，这里和利用构造器的注入差不多 如注入简单值12&lt;property name="name" value="hello world"&gt;&lt;/property&gt; 引用其他bean1&lt;property name="hello" ref="helloworld"&gt;&lt;/property&gt; 其中name中的值是该bean中的属性，名字要一致，而ref是该配置文件中的其他bean 七：装配集合 前面我们都是介绍单个对象的装配，对于复合类型该如何装配了 不妨模拟一个案例首相是一个Student类123456789101112131415package com.zwl.spring;public class Student &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 然后是School类，主要有的属性为集合，首先是list1234567891011121314public class School &#123; private List&lt;Student&gt; stulist; public List&lt;Student&gt; getStulist() &#123; return stulist; &#125; public void setStulist(List&lt;Student&gt; stulist) &#123; this.stulist = stulist; &#125; &#125; 配置的bean1234567&lt;bean id="stu" class="com.zwl.spring.Student"&gt;&lt;property name="name" value="hello"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="stu1" class="com.zwl.spring.Student"&gt;&lt;property name="name" value="world"&gt;&lt;/property&gt;&lt;/bean&gt; 简要说明一下，这里注入同一个类的不同bean，用于装入集合然后是配置school12345678&lt;bean id="sch" class="com.zwl.spring.School"&gt;&lt;property name="stulist"&gt;&lt;list&gt;&lt;ref bean="stu"/&gt;&lt;ref bean="stu1"/&gt;&lt;/list&gt;&lt;/property&gt;&lt;/bean&gt; 一般格式如下，属性下，配置和要引入的bean 测试代码1234School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch"); String name1=hello.getStulist().get(0).getName(); String name=hello.getStulist().get(1).getName(); System.out.println(name1+name); 测试结果: helloworld Set集合装配 首先在school类中加入如下属性12 private Set&lt;Student&gt; stuset;省略set与get方法 配置文件，添加如下：123456&lt;property name="stuset"&gt;&lt;set&gt;&lt;ref bean="stu"/&gt;&lt;ref bean="stu1"/&gt;&lt;/set&gt;&lt;/property&gt; 对应测试代码：123456School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch"); Iterator&lt;Student&gt; it=hello.getStuset().iterator(); while(it.hasNext())&#123; Student stu=it.next(); System.out.println(stu.getName()); &#125; 这里通过迭代器取出对象测试结果： helloworld Map集合装配 首先在school中添加如下属性：12private Map&lt;String, Student&gt; stumap;省略set与get方法。。 配置文件，添加如下123456&lt;property name="stumap"&gt;&lt;map&gt;&lt;entry key="11" value-ref="stu"&gt;&lt;/entry&gt;&lt;entry key="22" value-ref="stu1"&gt;&lt;/entry&gt;&lt;/map&gt;&lt;/property&gt; 其中，key为map的索引值，而value-ref为引用的bean测试代码：1234School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch"); String name=hello.getStumap().get("11").getName(); String name1=hello.getStumap().get("22").getName(); System.out.println(name+name1); 测试结果: helloworld]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring之hello world]]></title>
      <url>%2F2017%2F03%2F30%2Fspring1%2F</url>
      <content type="text"><![CDATA[前言 spring 是容器框架,用于配置bean,并维护bean之间关系的框架，而bean是java中的任何一种对象 javabean/service/action/数据源./dao, ioc(控制反转 inverse of control) di( dependency injection 依赖注入)，而spring的设计思想主要为单例和工厂模式，它能很好的解耦，简化开发，同时贯穿于各层。 不多说，先来一个入门案例，目的在先具体把握，最后在看细节 步骤一：创建一个web工程，同时引入两个jar包，一个是spring核心包（spring.jar）和日包（commons-logging.jar）及测试包junit； 步骤二：新建applicationContent.xml文件，该文件是spring的核心文件，先放在src目录下，里面暂时什么都不写 步骤三：编写helloworld类： 12345678910111213141516171819package com.zwl.spring;public class Helloworld &#123;private String name;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125; public void sayhello()&#123; System.out.println("it is "+name);&#125; &#125; 这里主要通过spring自动注入name为helloworld来演示 步骤四：配置applicationContent.xml文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;&lt;!-- bean元素的作用是，当我们的spring框架加载时候，spring就会自动的创建一个bean对象，并放入内存 ,相当于Helloworld helloworld=new Helloworld();helloworld.setName("helloworld!"); id:用于唯一标识该bean，class:相应的bean所处的位置--&gt;&lt;bean id="helloworld" class="com.zwl.spring.Helloworld"&gt;&lt;property name="name"&gt;&lt;value&gt;hello world!&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; 步骤五：编写工具类因为spring也是初始化加载很耗内存，所以同样采取单例模式初始化1234567891011121314151617181920package com.zwl.utils;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ApplicaionContextUtil &#123;private static ApplicationContext ac=null; private ApplicaionContextUtil()&#123; &#125; static&#123; //1.得到spring 的applicationContext对象(容器对象) ac=new ClassPathXmlApplicationContext("applicationContext.xml"); &#125; public static ApplicationContext getApplicationContext()&#123; return ac; &#125;&#125; 步骤六：编写测试类（用junit4）123456@Test public void test()&#123;//得到bean对象 Helloworld hello=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld"); hello.sayhello(); &#125; 测试结果： it is hello world ！ 至此helloworld程序完成，当然这只是一个初步的认识spring是什么，事实上spring的注入远不止如此简单，但至少有一点可以明确，通过spring，可以帮我们管理，特别是结合其他开源框架，达到解耦和高效的作用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代理模式（四）之模仿spring Aop及真实jdk的动态代理]]></title>
      <url>%2F2017%2F03%2F29%2Fdyproxy3%2F</url>
      <content type="text"><![CDATA[前言代理模式，尤其是动态代理，他从思想上改变了我们对编程的认识，可以想象一个切面我们在其中添加任何控制如事务、日志、权限等，而这也是面向切面编程的核心，更是spring Aop的核心，而设计才是实用的，框架和配置都是虚的，尤其当抛开jdk底层代码设计，才发现其中的来龙去脉和乐趣。 总之，动态代理设计模式的思想太强大了。接下来将用之前模拟的jdk动态代码和jdk本身自带的动态来模拟一个案例 大概物理情景是，添加一个打野信息接口和打野代理，利用InvocationHandler实现代理对具体打野的代理 首先是一个打野接口 123456package com.zwl.pr;public interface JungleInfo &#123; public void addJungle();&#125; 打野接口实现类123456789101112package com.zwl.pr;public class JungleInfoimpl implements JungleInfo &#123; @Override public void addJungle() &#123; System.out.println("Js is ganking"); System.out.println("Leesin is ganking"); &#125;&#125; 打野代理123456789101112131415161718192021222324252627package com.zwl.pr;import java.lang.reflect.Method;public class JungleHandler implements InvocationHandler &#123;private Object target; public JungleHandler(Object target) &#123; super(); this.target = target; &#125; @Override public void invoke(Object o, Method m) &#123; //控制之前的业务逻辑 System.out.println("JungleHandler is starting"); try &#123; m.invoke(target); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //控制之后的业务逻辑 System.out.println("JungleHandler is ending"); &#125;&#125; 为了方便这里只是打印了一个语句测试类123456 //被代理对象 JungleInfo jun=new JungleInfoimpl(); //代理类InvocationHandler invo=new JungleHandler(jun);JungleInfo jung=(JungleInfo) Proxy.newProxyInstance(JungleInfo.class, invo);jung.addJungle(); 输出结果： class com.zwl.pr.LeeSinTimeProxyJungleHandler is startingJs is gankingLeesin is gankingJungleHandler is ending 至此我们发现如果我们想在这个切面中再加一个控制，好办，再写一个handle类，代理其它handle类，达到切面控制效果。当然，以后只要实现InvocationHandler接口就能达到效果，而proxy底层都不需要知道 jdk的动态代理同样是上面的例子，知识代理handler需要改变 12345678910111213141516171819202122232425 package com.zwl.pr;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class JungleHandlers implements InvocationHandler &#123; private Object target; public JungleHandlers(Object target) &#123; super(); this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("Jdk is starting"); method.invoke(target, args); System.out.println("Jdk is ending"); return null; &#125;&#125; 其中Object proxy是指代理类，Method method是指被代理的方法，Object[] args为该方法的参数数组 接下来是测试类 1234 JungleInfo jun=new JungleInfoimpl();JungleHandlers invo=new JungleHandlers(jun);JungleInfo jung=(JungleInfo) Proxy.newProxyInstance(JungleInfo.class.getClassLoader(),new Class&lt;?&gt;[]&#123;JungleInfo.class&#125;, invo);jung.addJungle(); 其中jung将返回一个代理类的实例JungleInfo.class.getClassLoader()是类装载器，第二个参数是任何真实类拥有的全部接口的数组，第三个参数就是真实的handles 测试结果： Jdk is startingJs is gankingLeesin is gankingJdk is ending 至此，我们利用动态代理，就可以在不修改原来代码的基础上，就可以在原来代码的基础上做操作，而这恰恰就是AOP编程的核心]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代理模式（三）之模仿jdk底层动态代理实现]]></title>
      <url>%2F2017%2F03%2F29%2Fdyproxy2%2F</url>
      <content type="text"><![CDATA[前言在前面的基础上在做进一步的改进，前面我们是动态写死了方法，即自己指定了方法名，当然我们可以利用反射帮我们完成函数名的动态指定 首先是一个反射例子123456//拿到相应的类Method[] methods=com.zwl.pr.Jungle.class.getMethods(); for(Method method: methods)&#123; //循环输出该类的函数名，如public void ss();最后只输出ss System.out.println(method.getName()); &#125; 有了这个原理就可以对之前的proxy进行改造 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static Object newProxyInstance(Class interfac) throws Exception&#123; //动态拿到方法的代码 String methodStr = ""; String rt = "\r\n"; //将指定的动态接口类名拿到 Method[] methods = interfac.getMethods(); //循环添加方法 for(Method m : methods) &#123; methodStr += "@Override" + rt + "public void " + m.getName() + "() &#123;" + rt + " long start = System.currentTimeMillis();" + rt + " leesin." + m.getName() + "();" + rt + " long end = System.currentTimeMillis();" + rt + " System.out.println(\"time:\" + (end-start));" + rt + "&#125;"; &#125; String str= "package com.zwl.pr;" + rt + "public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt + "Jungle leesin;" + rt + "public LeeSinTimeProxy(Jungle leesin) &#123;" + rt + "super();" + rt + "this.leesin = leesin;" + rt + "&#125;" + rt + //这里循环动态输出方法 methodStr + "&#125;" ; //System.out.println(System.getProperty("user.dir")); //这里将动态生成的代理文件放到指定文件夹中，避免与bin里的.class文件冲突 String filename= "E:/src/com/zwl/pr/LeeSinTimeProxy.java"; File f=new File(filename); FileWriter fw=new FileWriter(f); fw.write(str); fw.flush(); fw.close(); //compile JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(filename); CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units); t.call(); fileMgr.close(); //load into memory and create an instance //更改到指定文件夹 URL[] urls = new URL[] &#123;new URL("file:/" + "E:/src/")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy"); System.out.println(c); Constructor ctr = c.getConstructor(Jungle.class); //返回任意一个类 Object jungle=ctr.newInstance(new LeeSin()); return jungle; &#125; 注意这里和之前做了几处修改 1.利用反射动态生成方法 2.更改编译后生成文件的目录 3.返回类型为object 4具体在代码里有注释 测试类： 12Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class); jungle.gank(); 输出结果 class com.zwl.pr.LeeSinTimeProxyLeeSin is ganking…gank time:1336time:1336 这里很明显发现方法都是固定的，如果想要方法都是动态生成的，则要进行进一步修改首先增加一个InvocationHandler动态生成类123public interface InvocationHandler &#123; public void invoke(Object o, Method m);&#125; 然后是具体的针对所有接口的时间处理类123456789101112131415161718192021222324252627public class TimeHandler implements InvocationHandler &#123; //代理类 private Object target; public TimeHandler(Object target) &#123; super(); this.target = target; &#125; @Override public void invoke(Object o, Method m) &#123; long start = System.currentTimeMillis(); try &#123; //指定代理类的动态方法 m.invoke(target); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println("time:" + (end-start)); &#125;&#125; 然后proxy里也要进行相应修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//参数分别为被代理对象与代理对象public static Object newProxyInstance(Class interfac,InvocationHandler h) throws Exception&#123; String methodStr = ""; String rt = "\r\n"; Method[] methods = interfac.getMethods(); //动态生成方法，其中this是指代理对象本身，而md是指方法名，这里的h是构造函数传的代理对象 for(Method m : methods) &#123; methodStr += "@Override" + rt + "public void " + m.getName() + "() &#123;" + rt + " try &#123;" + rt + " Method md = " + interfac.getName() + ".class.getMethod(\"" + m.getName() + "\");" + rt + " h.invoke(this, md);" + rt + " &#125;catch(Exception e) &#123;e.printStackTrace();&#125;" + rt + "&#125;"; &#125; String str= "package com.zwl.pr;" + rt + "import java.lang.reflect.Method;" + rt + "public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt + "com.zwl.pr.InvocationHandler h;" + rt + "public LeeSinTimeProxy(InvocationHandler h) &#123;" + rt + "super();" + rt + "this.h = h;" + rt + "&#125;" + rt + methodStr + "&#125;" ; //System.out.println(System.getProperty("user.dir")); String filename= "E:/src/com/zwl/pr/LeeSinTimeProxy.java"; File f=new File(filename); FileWriter fw=new FileWriter(f); fw.write(str); fw.flush(); fw.close(); //compile JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(filename); CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units); t.call(); fileMgr.close(); //load into memory and create an instance URL[] urls = new URL[] &#123;new URL("file:/" + "E:/src/")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy"); System.out.println(c); //返回代理类 Constructor ctr = c.getConstructor(InvocationHandler.class); Object jungle=ctr.newInstance(h); return jungle; &#125; 测试类： 123456//被代理对象LeeSin leesin=new LeeSin();//代理对象 InvocationHandler ivo=new TimeHandler(leesin); Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class,ivo); jungle.gank(); 对应生成的java文件123456789101112131415package com.zwl.pr;import java.lang.reflect.Method;public class LeeSinTimeProxy implements com.zwl.pr.Jungle&#123;com.zwl.pr.InvocationHandler h;public LeeSinTimeProxy(InvocationHandler h) &#123;super();this.h = h;&#125;@Overridepublic void gank() &#123; try &#123; Method md = com.zwl.pr.Jungle.class.getMethod("gank"); h.invoke(this, md); &#125;catch(Exception e) &#123;e.printStackTrace();&#125;&#125;&#125; 对应的测试结果 class com.zwl.pr.LeeSinTimeProxyLeeSin is ganking…gank time:2642time:2642]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代理模式（二）之初识动态代理]]></title>
      <url>%2F2017%2F03%2F29%2Fdyproxy1%2F</url>
      <content type="text"><![CDATA[前言之前我们通过静态代理可以在编译期创建一个代理对象，如果要求我们必须在运行时创建一个代理，如时间代理，如何做了？也就是说，需要写一个代理（proxy），然后我们只需要传入相关接口，它就可以主动生成代理对象 再一次使用之前的情景，即有一个打野对象接口和具体打野盲僧，然后编写一个针对打野的动态代理（proxy），只要传入（打野接口对象），就可以动态自动生成该java文件，并且载入内存并不jvm编译 下面就是其代码实现 Jungle（打野接口）1234public interface Jungle &#123; //打野gank方法 public void gank();&#125; LeeSin（盲僧）123456789101112131415161718192021public class LeeSin implements Jungle &#123; @Override public void gank() &#123; //gank开始时间 long starts=System.currentTimeMillis(); System.out.println("LeeSin is ganking..."); try &#123; //gank进行中 Thread.sleep(new Random().nextInt(10000)); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //gank结束时间 long ends=System.currentTimeMillis(); System.out.println("gank time:"+(ends-starts)); &#125;&#125; 如果想要动态生成一个事件代理（按常理应该新建一个代理类），按照动态思想，我们将该创建该类的所以涉及的代码赋给一个字符串12345678910111213141516171819202122232425String str= "package com.zwl.pr;" + "public class LeeSinTimeProxy implements Jungle &#123;" + "Jungle leesin;" + "public LeeSinTimeProxy(Jungle leesin) &#123;" + "super();" + "this.leesin = leesin;" + "&#125;" + "@Override" + "public void gank() &#123;" + "long starts=System.currentTimeMillis();" + "leesin.gank();" + "long ends=System.currentTimeMillis();" + " System.out.println(\"gank time:\"+(ends-starts));" + "&#125;" + "&#125;" ; 上面字符串就是创建该代理的代码，然后如果jvm能自动将其编译成.class并且载入内存，就是一个真的类了，按照这种思想，我们可以通过jvm提供的方法完成为了方便先把上述动态创建时间代理放在测试中（也就是main函数中）1.首先将代码格式修整一下，即加个换行，同时将字符写入时间代理文件中1234567891011121314151617181920212223242526272829303132333435363738394041 //换行，防止所有代码全部挤在一行String rt = "\r\n";//要动态生成的类的代码 String str= "package com.zwl.pr;" + rt + "public class LeeSinTimeProxy implements Jungle &#123;" + rt + "Jungle leesin;" + rt + "public LeeSinTimeProxy(Jungle leesin) &#123;" + rt + "super();" + rt + "this.leesin = leesin;" + rt + "&#125;" + rt + "@Override" + rt + "public void gank() &#123;" + rt + "long starts=System.currentTimeMillis();" + rt + "leesin.gank();" + rt + "long ends=System.currentTimeMillis();" + rt + " System.out.println(\"gank time:\"+(ends-starts));" + rt + "&#125;" + rt + "&#125;" ; //得到该项目的根路径 //System.out.println(System.getProperty("user.dir")); //该时间代理文件的完整路径，不存在则创建（第一次自动动态创建） String filename=System.getProperty("user.dir")+ "/src/com/zwl/pr/LeeSinTimeProxy.java"; //将字符写入该文件 File f=new File(filename); FileWriter fw=new FileWriter(f); fw.write(str); fw.flush(); fw.close(); 这里先一小段一小段的加，目前是已经在该包下生成一个LeeSinTimeProxy.java文件，并且里面有被写入的字符，但是纯粹只是一个文件，因为还没被编译和载入内存 2.进行编译123456789101112 //compile //得到java编译器，也就是javac了，至此我们可以最终将其编译，得到.class（二进制文件）JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); //管理编译文件，默认为空就行StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);//所有编译的文件，目前就一个，当然可以传入多个Iterable units = fileMgr.getJavaFileObjects(filename);//编译任务管理，目前传入上面两个参数，其余默认为空就行CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);//执行任务编译t.call();fileMgr.close(); 至此，在包下也动态生成了一个.class文件，而平常我们编译时都会在path路径下，jdk主动生成.class，而此时我们自己指定了位置 3.载入内存123456//指定载入内存的urlURL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir")+"/src")&#125;; URLClassLoader ul = new URLClassLoader(urls);//指定class文件载入 Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy"); System.out.println(c); 4.利用反射取出实例 1234567//反射取出类Constructor ctr = c.getConstructor(Jungle.class); //操作该类相应方法，此处是动态返回类 Jungle jubgle= (Jungle) ctr.newInstance(new LeeSin()); //调用gank方法 jubgle.gank(); 以下是结果： class com.zwl.pr.LeeSinTimeProxyLeeSin is ganking…gank time:7557gank time:7563 至此算是动态生成了时间代理，但是目前是很有局限性的，因为我们指定了一个特定接口，而不是泛指，当然通过这个例子，也算是初识了一把动态模式的魅力，当然它的最大魅力，在于制定任何接口，返回相应的代理类 在这里我们先将测试的类中代码移至Proxy类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Proxy &#123; //这里的interfac就是动态指定了任何接口代理，而且必须取它的名字，否则是执行其tostring方法 public static Object newProxyInstance(Class interfac) throws Exception&#123; String rt = "\r\n"; String str= "package com.zwl.pr;" + rt + "public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt + "Jungle leesin;" + rt + "public LeeSinTimeProxy(Jungle leesin) &#123;" + rt + "super();" + rt + "this.leesin = leesin;" + rt + "&#125;" + rt + "@Override" + rt + "public void gank() &#123;" + rt + "long starts=System.currentTimeMillis();" + rt + "leesin.gank();" + rt + "long ends=System.currentTimeMillis();" + rt + " System.out.println(\"gank time:\"+(ends-starts));" + rt + "&#125;" + rt + "&#125;" ; //System.out.println(System.getProperty("user.dir")); String filename=System.getProperty("user.dir")+ "/src/com/zwl/pr/LeeSinTimeProxy.java"; File f=new File(filename); FileWriter fw=new FileWriter(f); fw.write(str); fw.flush(); fw.close(); //compile JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(filename); CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units); t.call(); fileMgr.close(); //load into memory and create an instance URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir")+"/src")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy"); System.out.println(c); Constructor ctr = c.getConstructor(Jungle.class); Jungle jubgle= (Jungle) ctr.newInstance(new LeeSin()); jubgle.gank(); return null; &#125;&#125; 目前先不管错误，在做测试类123 LeeSin leesin=new LeeSin();Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class);jungle.gank(); 这里参数我们可以设置任何class接口，当然先不管错误，至少动态代理算是成功了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代理模式（一）之静态代理]]></title>
      <url>%2F2017%2F03%2F29%2Fstproxy%2F</url>
      <content type="text"><![CDATA[前言代理模式从定义上说就是给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用 一般情况下，我们可以通过继承或者聚合来实现代理，当然继承会造成类爆炸，而聚合则更灵活不多说，模拟一个静态代理的情景假设打野是一个接口，有gank方法，记录打野行为，打野具体对象盲僧，实现其gank的时间并记录下来，然后后续打野盲僧1、盲僧2分别记录打野具体对象的gank时间和gank日志（目前打野对象为LeeSin） Jungle（打野接口）1234public interface Jungle &#123; //打野gank方法 public void gank();&#125; LeeSin（盲僧）123456789101112131415161718192021public class LeeSin implements Jungle &#123; @Override public void gank() &#123; //gank开始时间 long starts=System.currentTimeMillis(); System.out.println("LeeSin is ganking..."); try &#123; //gank进行中 Thread.sleep(new Random().nextInt(10000)); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //gank结束时间 long ends=System.currentTimeMillis(); System.out.println("gank time:"+(ends-starts)); &#125;&#125; 接下来就是使用代理对象，比如用一个代理记录打野gank方法的时间不妨先用继承（与后面聚合比较会发现继承将造成类爆炸） 123456789101112//时间代理，记录gank时间public class LeeSin1 extends LeeSin &#123; @Override public void gank() &#123; long starts=System.currentTimeMillis(); super.gank(); long ends=System.currentTimeMillis(); System.out.println("gank time:"+(ends-starts)); &#125;&#125; 如果这时再有一个log代理，记录gank日志12345678910public class LeeSin2 extends LeeSin &#123; @Override public void gank() &#123; System.out.println("LeeSin starts ganking"); super.gank(); System.out.println("LeeSin ends ganking"); &#125;&#125; 如果这时说先记录日志在记录时间或者先记录时间在记录日志，这时就要写两个类列出主体代码（另一个调换位置）1234567891011@Overridepublic void gank() &#123; System.out.println("LeeSin starts ganking"); long starts=System.currentTimeMillis(); super.gank(); long ends=System.currentTimeMillis(); System.out.println("gank time:"+(ends-starts)); System.out.println("LeeSin ends ganking"); &#125; 可能目前代理类较少，还没有缺陷，如果是100个甚至更多，只要稍微要求下顺序或者其他，就要增加一个类，显然造成类爆炸，所以继承代理不可取 利用聚合代理（因为被代理类都是继承或者实现Jungle，所以可以用jungle代理，知识子类行为不同而已打野时间代理类1234567891011121314151617181920212223public class LeeSinTimeProxy implements Jungle &#123; //代理对象 Jungle leesin; public LeeSinTimeProxy(Jungle leesin) &#123; super(); this.leesin = leesin; &#125; @Override public void gank() &#123; long starts=System.currentTimeMillis(); leesin.gank(); long ends=System.currentTimeMillis(); System.out.println("gank time:"+(ends-starts)); &#125;&#125; 日志代理123456789101112131415161718192021public class LeeSinlogProxy implements Jungle &#123; Jungle leesin; public LeeSinlogProxy(Jungle leesin) &#123; super(); this.leesin = leesin; &#125; @Override public void gank() &#123; System.out.println("LeeSin starts ganking"); leesin.gank(); System.out.println("LeeSin ends ganking"); &#125;&#125; 测试类12345678public static void main(String[] args) &#123; LeeSin leesin=new LeeSin(); Jungle jungletime=new LeeSinTimeProxy(leesin); Jungle junglelog=new LeeSinlogProxy(jungletime); junglelog.gank(); &#125; 测试结果： LeeSin starts gankingLeeSin is ganking…gank time:1005gank time:1005LeeSin ends ganking 注意这里是日志代理时间，时间代理盲僧，如果更改顺序，只需改变被代理对象即可 至此我们可以简单归纳一下静态代理大概有抽象角色：如打野 ，代理角色（被聚合类的引用），以及真实角色 最后不得不提的是静态代理虽然简单，但是有很多局限性，比如它是在编译期由我们主动创建的，也就说在程序运行前已经存在在.class文件中了，如果代理类一旦多的话，代理内容就无法复用，新增方法时，代理对象也要跟着增加方法。 所以代理设计模式真正的魅力和强大之处而是动态代理！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[观察者设计模式]]></title>
      <url>%2F2017%2F03%2F28%2Fobserver%2F</url>
      <content type="text"><![CDATA[前言观察者模式从定义上说就是一种一对多的依赖关系，即当一个对象的状态发生改变时，其它依赖此对象的对象会得到通知并且做出相应的改变。一般有“推”模型和“拉”模型，前者是被观察者将所有信息通知所有人，而后者则是被观察者不主动提供信息，观察者主动索要信息 在这里还是以之前的例子为例 这是一个推模型，也就是被观察者根据状态发生改变时将所有信息都主动通知观察者其中：Jungle（打野）是被观察者，即如果有一些状态变化，如对方打野有动作则将通知observer（目前假定只有上路和adc）observer：观察者，用来监听被观察者并且根据相应的变化做出变化top：上单 adc：Adc LesSin：打野盲僧以下是相关代码： Jungle（被观察者） 12345678910public interface Jungle &#123; //增加观察者 public void addObserve(Observer obs); //删除观察者 public void deleteObserve(Observer obs); //通知观察者 public void notifyObserve(String msg); &#125; observer（观察者）123456public interface Observer &#123; //收到通知后状态变化 public void notifybyJungle(String msg);&#125; &#125; LeeSin1234567891011121314151617181920212223242526public class LeeSin implements Jungle &#123; //存放所有的观察者 List&lt;Observer&gt; list=new ArrayList&lt;Observer&gt;(); @Override public void addObserve(Observer obs) &#123; list.add(obs); &#125; @Override public void deleteObserve(Observer obs) &#123; list.remove(obs); &#125; @Override public void notifyObserve(String msg) &#123; for(Observer obs : list)&#123; obs.notifybyJungle(msg); &#125; &#125;&#125; top123456789101112131415161718192021public class top implements Observer &#123; //收到消息 public String newmsg; public String getNewmsg() &#123; return newmsg; &#125; public void setNewmsg(String newmsg) &#123; this.newmsg = newmsg; &#125; @Override public void notifybyJungle(String msg) &#123; newmsg=msg; System.out.println("上单收到:"+newmsg); &#125;&#125; Adc1234567891011121314151617181920public class Adc implements Observer &#123;public String newmsg; public String getNewmsg() &#123; return newmsg; &#125; public void setNewmsg(String newmsg) &#123; this.newmsg = newmsg; &#125; @Override public void notifybyJungle(String msg) &#123; newmsg=msg; System.out.println("adc收到:"+newmsg); &#125;&#125; 测试类123456789101112public static void main(String[] args) &#123; Jungle jungle=new LeeSin(); Observer obs1=new Adc(); Observer obs2=new top(); jungle.addObserve(obs1); jungle.addObserve(obs2); jungle.notifyObserve("敌方打野正在打小龙"); &#125; 下面是输出结果 adc收到:敌方打野正在打小龙上单收到:敌方打野正在打小龙 如果我们使用拉模型，即观察者主动向被观察者索要信息，那么上面程序将做部分修改 大体思路就是将Jungle（被观察者）的通知函数改为void即12345678910public interface Jungle &#123; //增加观察者 public void addObserve(Observer obs); //删除观察者 public void deleteObserve(Observer obs); //通知观察者 public void notifyObserve(); &#125; 相应的observer将更改为observer（观察者）123456public interface Observer &#123; //收到通知后状态变化 public void notifybyJungle(Jungle jungle);&#125; &#125; 对于推与拉模型，如果目标角色过于复杂，则优先使用推模式，反之则使用拉模式 观察者模式应用场景1、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变 2、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抽象工厂设计模式]]></title>
      <url>%2F2017%2F03%2F27%2Fabstractfactory%2F</url>
      <content type="text"><![CDATA[前言抽象工厂方法通俗的讲就是为创建一组相关或相互依赖的对象提供一组接口，无需指定他们的具体类。因此，他们通常为创建一族产品对象，并且该产品由不同等级划分。 这里还是以之前的例子为例，假设有一个产生top（上单）的机器，另一个产生Jungle（打野）的机器，同时top可以有ad（物理上单）和ap(法术上单)，同样，Jungle可以有ad和ap打野，现在需要一个工厂，可以同时产生仅含ad的打野和上单，另一个产生仅含ap的打野和上单，当然可以按照自己的组合打野 123456789101112public interface Jungle &#123; //gank能力强 public void gankenemy(); //本身足够灵活 public void flexible(); //打野不太伤 public void killbeast(); &#125; ad打野 123456789101112131415161718192021public class AdJungle implements Jungle &#123; @Override public void gankenemy() &#123; // TODO Auto-generated method stub &#125; @Override public void flexible() &#123; // TODO Auto-generated method stub &#125; @Override public void killbeast() &#123; // TODO Auto-generated method stub &#125;&#125; ap打野123456789101112131415161718192021public class ApJungle implements Jungle &#123; @Override public void gankenemy() &#123; // TODO Auto-generated method stub &#125; @Override public void flexible() &#123; // TODO Auto-generated method stub &#125; @Override public void killbeast() &#123; // TODO Auto-generated method stub &#125;&#125; 上单12345678910public interface Top &#123; //gank能力强 public void gankenemy(); //本身足够灵活 public void flexible(); //打野不太伤 public void killbeast();&#125; ad上单123456789101112131415161718192021public class AdTop implements Top &#123; @Override public void gankenemy() &#123; // TODO Auto-generated method stub &#125; @Override public void flexible() &#123; // TODO Auto-generated method stub &#125; @Override public void killbeast() &#123; // TODO Auto-generated method stub &#125;&#125; ap上单123456789101112131415161718192021public class ApTop implements Top &#123; @Override public void gankenemy() &#123; // TODO Auto-generated method stub &#125; @Override public void flexible() &#123; // TODO Auto-generated method stub &#125; @Override public void killbeast() &#123; // TODO Auto-generated method stub &#125;&#125; 生产打野和上单的工厂1234public interface AbstractFactory &#123;public Top factorytop();public Jungle factoryjungle();&#125; 生产ad打野和上单的工厂123456789101112131415public class AdFactory implements AbstractFactory &#123; @Override public Top factorytop() &#123; // TODO Auto-generated method stub return new AdTop(); &#125; @Override public Jungle factoryjungle() &#123; // TODO Auto-generated method stub return new AdJungle(); &#125;&#125; 生产ap打野和上单的工厂123456789101112131415public class ApFactory implements AbstractFactory &#123; @Override public Top factorytop() &#123; // TODO Auto-generated method stub return new ApTop(); &#125; @Override public Jungle factoryjungle() &#123; // TODO Auto-generated method stub return new ApJungle(); &#125;&#125; 通过上面例子，我们可以发现抽象工厂易于交换产品系列，通过按需改变具体工厂从而使用不同的产品配置，同时它也将创建实例的过程与客户端分类 当然它的缺点就是和简单工厂一样，如果要从sql server切换到mysql，需要重新实例很多次 最后对应工厂系列的设计模式，无论选择哪一个，最终的目的都是为了解耦！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工厂方法设计模式]]></title>
      <url>%2F2017%2F03%2F27%2Ffactory%2F</url>
      <content type="text"><![CDATA[前言工厂方法模式又被称为多态工厂模式，通俗的讲就是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中，因此，也属于创建型模式 这里Jungle的每个具体类都对应一个具体工厂下面就是以工厂方法创建它们，通过抽象工厂选择不同的具体子工厂，从而产生不同的具体打野类 打野接口12345678910111213//打野英雄public interface Jungle &#123; //gank能力强 public void gankenemy(); //本身足够灵活 public void flexible(); //打野不太伤 public void killbeast(); &#125; 工厂接口1234public interface junglefactor &#123;//产生打野public Jungle createjungle();&#125; 盲僧 123456789101112131415161718192021public class LeeSin implements Jungle &#123; @Override public void gankenemy() &#123; System.out.println("盲僧正在gank"); &#125; @Override public void flexible() &#123; System.out.println("盲僧太灵活了"); &#125; @Override public void killbeast() &#123; System.out.println("盲僧正在打野怪"); &#125;&#125; 剑圣 123456789101112131415161718192021public class Js implements Jungle &#123; @Override public void gankenemy() &#123; System.out.println("剑圣正在gank"); &#125; @Override public void flexible() &#123; System.out.println("js也灵活"); &#125; @Override public void killbeast() &#123; System.out.println("剑圣正在打野"); &#125;&#125; 盲僧工厂12345678910111213141516171819202122232425262728293031323334public class LeeSinFactory implements junglefactor &#123; @Override public Jungle createjungle() &#123; return new LeeSin(); &#125;&#125;``` 剑圣工厂``` styluspublic class JsFactory implements junglefactor &#123; @Override public Jungle createjungle() &#123; return new Js(); &#125;&#125;``` 测试类：``` styluspublic static void main(String[] args) &#123; // Jungle jungle= JungleFactory.createJungle("LeeSin"); // jungle.gankenemy(); junglefactor factory=new LeeSinFactory(); Jungle jubjle=factory.createjungle(); jubjle.flexible(); &#125; 这里通过多态，产生不同的工厂，从而产生不同的打野 工厂方法比较简单工厂模式 现在我们要是把打野对象由盲僧换成剑圣的话，利用简单工厂，那就要1234567Jungle jungle= JungleFactory.createJungle("Js");``` 如果是100或者更多的话，那就要重复上述代码那么多次但是如果采用工厂方法，只需要改一处```stylusjunglefactor factory=new JsFactory(); 显然对外扩展开放，对内修改关闭更好。而简单工厂则违背了该原则]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单工厂设计模式]]></title>
      <url>%2F2017%2F03%2F27%2Fsimplefactory%2F</url>
      <content type="text"><![CDATA[前言简单工厂模式又叫静态工厂设计模式。通俗的讲，就是通过专门定义一个类来负责建立其他类的实例，与此同时被创建的类都必须满足他们有共同的父类，所以，它是一种创建型模式。 这里Leesin（盲僧）与Js（剑圣）继承Jungle（打野），而JungleFactory（打野生产工厂）产生具体打野对象下面将以简单工厂创建他们，满足通过传入打野工厂不同的参数，产生不同的打野对象 打野接口 12345678910111213//打野英雄public interface Jungle &#123; //gank能力强 public void gankenemy(); //本身足够灵活 public void flexible(); //打野不太伤 public void killbeast(); &#125; 盲僧 123456789101112131415161718192021public class LeeSin implements Jungle &#123; @Override public void gankenemy() &#123; System.out.println("盲僧正在gank"); &#125; @Override public void flexible() &#123; System.out.println("盲僧太灵活了"); &#125; @Override public void killbeast() &#123; System.out.println("盲僧正在打野怪"); &#125;&#125; 剑圣 123456789101112131415161718192021public class Js implements Jungle &#123; @Override public void gankenemy() &#123; System.out.println("剑圣正在gank"); &#125; @Override public void flexible() &#123; System.out.println("js也灵活"); &#125; @Override public void killbeast() &#123; System.out.println("剑圣正在打野"); &#125;&#125; 打野工厂 12345678910111213141516171819public class JungleFactory &#123; public static Jungle createJungle(String Junglename)&#123; Jungle jungle=null; switch(Junglename)&#123; case "LeeSin": jungle=new LeeSin(); break; case "Js" : jungle=new Js(); break; default : break; &#125; return jungle; &#125;&#125; 下面是测试类 12345public static void main(String[] args) &#123; Jungle jungle= JungleFactory.createJungle("LeeSin"); jungle.gankenemy(); &#125; 当然，我们这里通过不同的参数，获得不同的打野英雄当然这个例子也很好理解简单工厂 事实上，我们知道如果我们一开始用的是sql server数据库，然后我们想换数据库，如果不用工厂模式，那么将替换许多东西，如果这时，使用简单工厂模式，就会使问题变简单许多。 利用简单工厂模式大概思路就是先创建一个抽象数据库(DBobject)，然后是具体实现类sql server与mysql类，然后再来一个生成数据库工厂(DBobjectFactory)通过传入不同的数据库参数，从而连接不同的数据库 至此我们发现，简单工厂的优点在于工厂类中包含了必要的逻辑判断，而且可以根据客户端的选择条件不同而动态的实例化相关的类 当然它的缺点也很明显，当我们创建的抽象实例过多时，显然高内聚就增多了，不利于维护了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[职责链设计模式]]></title>
      <url>%2F2017%2F03%2F26%2Ffilter%2F</url>
      <content type="text"><![CDATA[前言 职责链，通俗地讲就是把责任处理对象连城一条链，这样当一个处理对象不能及时处理的时候就会交给下一个处理对象直到被处理为止。就好比生活中，我们有事向学校请假，得找班主任签字同意，然后有些时候需要院里签字，甚至教务处，最后将假条交给同学，最后在给相应授课老师，可能这个例子还不太准确，但是总之经过一些列流程，最后才会处理。 当然，在程序中，最常见的就是过滤关键字了，首先模拟一下非web下的责任链 首先定义一个过滤接口 123public interface Filter &#123; String doFilter(String str);&#125; 接下来就是各式各样的过滤字敏感字过滤 123456789101112public class SesitiveFilter implements Filter &#123; @Override public String doFilter(String str) &#123; //第一个参数是非法字符，第二个参数是被替换的字符 String r = str.replace("瞎子", "李青") .replace("小学僧", "盲僧"); return r; &#125;&#125; 过滤html标签 1234567891011public class HTMLFilter implements Filter &#123; @Override public String doFilter(String str) &#123; //&lt;&gt;被替换成[] String r = str.replace('&lt;', '[') .replace('&gt;', ']'); return r; &#125;&#125; 过滤链:将过滤器串成一个链，并保存过滤后的字 12345678910111213141516171819202122public class FilterChain implements Filter &#123; //保存所有的具体过滤器 List&lt;Filter&gt; filters=new ArrayList&lt;Filter&gt;(); //过滤器串成链 public FilterChain addFilter(Filter f) &#123; this.filters.add(f); return this; &#125; //返回过滤后的字符 @Override public String doFilter(String str) &#123; String r=str; for(Filter f:filters)&#123; r=f.doFilter(r); &#125; return r; &#125;&#125; 测试： 123456789public static void main(String[] args) &#123; String msg = "因为一个英雄而爱上了lol，他就是瞎子，虽然我是小学僧，但是我还是只坚信我的&lt;我的信仰&gt;英雄！！"; FilterChain fc = new FilterChain(); fc.addFilter(new SesitiveFilter()) .addFilter(new HTMLFilter()); String result=fc.doFilter(msg); System.out.println(result); &#125; 输出结果: 因为一个英雄而爱上了lol，他就是李青，虽然我是盲僧，但是我还是只坚信我的[我的信仰]英雄！！ Web下责任链当然一般情况下，都是过滤web环境下的字符，大概思路跟非web下差不多 首先需要建立request和response对象，即接收和响应 123456789101112131415161718192021public class Request &#123;String requestStr;public String getRequestStr() &#123; return requestStr;&#125;public void setRequestStr(String requestStr) &#123; this.requestStr = requestStr;&#125; &#125;public class Response &#123; String responseStr; public String getResponseStr() &#123; return responseStr; &#125; public void setResponseStr(String responseStr) &#123; this.responseStr = responseStr; &#125;&#125; 然后是Filter接口 123public interface Filter &#123; void doFilter(Request request, Response response, FilterChain chain);&#125; 紧接着是filterchain类 123456789101112131415161718192021222324252627public class FilterChain implements Filter &#123; //存放各种filter List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(); //控制filter的索引 int index = 0; //添加filter public FilterChain addFilter(Filter f) &#123; this.filters.add(f); return this; &#125; //filter链，特别注意这里有一个迭代，与具体filter里的迭代相呼应//主要是依次先取出request的接受字符过滤，然后在倒叙依次取完response的响应过滤,而这恰恰是struts2框架原理的核心，当然spring mvc(直接基于servlet)也类似，都是基于拦截或者过滤实现的 @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; // 过滤器取完退出if(index == filters.size()) return ; //依次取出过滤器 Filter f = filters.get(index); index ++; f.doFilter(request, response, chain); &#125;&#125; 然后就是具体的filter了（这里就是web中的真实拦截顺序了） 123456789101112public class SesitiveFilter implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; // TODO Auto-generated method stub request.requestStr = request.requestStr.replace("瞎子", "李青") .replace("小学僧", "盲僧") ; chain.doFilter(request, response, chain); response.responseStr += "SesitiveFilterresponse"; &#125;&#125; 另一个filter 12345678910111213public class HTMLFilter implements Filter &#123; @Override public void doFilter(Request request, Response response,FilterChain chain) &#123; // TODO Auto-generated method stub request.requestStr = request.requestStr.replace('&lt;', '[') .replace('&gt;', ']') ; chain.doFilter(request, response, chain); response.responseStr += "HTMLFilterresponse"; &#125;&#125; 先附一张structs2原理图，来对比一下上述过滤过程主要关注action invocation中部分 测试类: 12345678910111213141516public static void main(String[] args) &#123; String msg = "因为一个英雄而爱上了lol，他就是瞎子，虽然我是小学僧，但是我还是只坚信我的&lt;我的信仰&gt;英雄！！"; Request request = new Request(); request.setRequestStr(msg); Response response = new Response(); response.setResponseStr("response"); FilterChain fc = new FilterChain(); fc.addFilter(new HTMLFilter()) .addFilter(new SesitiveFilter()) ; fc.doFilter(request, response, fc); System.out.println(request.getRequestStr()); System.out.println(response.getResponseStr()); &#125; 结果: 因为一个英雄而爱上了lol，他就是李青，虽然我是盲僧，但是我还是只坚信我的[我的信仰]英雄！！response–SesitiveFilterresponse–HTMLFilterresponse 最后归纳一下责任链设计模式的一般形式分别为客户端、处理者和具体处理者]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[迭代器设计模式]]></title>
      <url>%2F2017%2F03%2F26%2Fiterator%2F</url>
      <content type="text"><![CDATA[前言 为什么会有迭代器？当我们想要 遍历取出集合一组数据时，一般都是用for里面套着i循环，或者使用for（对象 x :某个集合)的形式取出，不过因为集合类型的不同，取出的形式也不同，但是当我们想要一种统一的方法去遍历集合时，就可以用迭代器去实现，说了那么多，不如来一个直观的例子。 这里模仿Arraylist集合中的迭代器实现过程，其中Iterator:执行递增遍历的接口Collection:一些集合的上层接口Arraylist: 目前只实现了add、size及迭代器ArrayListIterator: 用于Arraylist的迭代器 Iterator接口 123456public interface Iterator &#123;//取得下一个元素Object next();//检查有没有下一个元素boolean hasNext();&#125; Collection接口 12345public interface Collection &#123;public void add(Object o);//增加一个对象public int size();//返回长度Iterator iterator();//内聚迭代器&#125; Arraylist类（这里ArrayListIterator是其内部类） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.zwl.iterator;public class ArrayList implements Collection&#123;//默认都是初始化为10的Object objects[]=new Object[10];//默认集合长度都为0的int index=0;//增加方法public void add(Object o)&#123;//集合长度动态增长，每次都使其长度增加2倍，并且创建一个增长后的新数组//将旧数组先copy给新数组，在指向旧数组的引用//同时保证每添加一个对象，集合长度自增长，这样就不会出现越界情况 if(index==objects.length)&#123; Object newobjects[]=new Object[objects.length*2]; System.arraycopy(objects, 0, newobjects, 0, objects.length); objects=newobjects; &#125; objects[index]=o; index++;&#125;//返回集合长度public int size()&#123; return index;&#125;//统一迭代器方法@Overridepublic Iterator iterator() &#123; // TODO Auto-generated method stub return new ArrayListIterator();&#125;//内部类，返回arraylist的专有迭代器private class ArrayListIterator implements Iterator&#123; //取集合中对象的索引 private int currentIndex=0; //取出集合中当前索引的一个对象 @Override public Object next() &#123; Object o = objects[currentIndex]; currentIndex ++; return o; &#125;//判断集合是否含有下一个元素 @Override public boolean hasNext() &#123;//索引值超出集合长度，集合中元素取完 if(currentIndex&gt;=index) return false; else return true; &#125; &#125;&#125; 测试类： 123456789101112131415public static void main(String[] args) &#123; Collection al=new ArrayList(); for(int i=0;i&lt;15;i++)&#123; al.add(new Object()); &#125; System.out.println(al.size()); Iterator it=al.iterator(); while(it.hasNext())&#123; Object o=it.next(); System.out.println(o+" "); &#125; &#125; 至此，可以归纳一下迭代器设计模式的一般形式 其中：1：Iterator(迭代器) 参与者： 定义访问和遍历元素的接口（如Iterator) 2.ConcreteIterator(具体迭代器)参与者实现迭代器的接口(如ArrayListIterator) 3.Aggregate(聚合)参与者定义建立Iterator参与者的接口(如Collection) 4.ConcreteAggregate（具体聚合）参与者实现Aggregate所定义的接口（如Arraylist） 最后不得不提的是，无论一个集合实现的结果如何，都能使用iterator，此外，我们通过改变iterato，来增加各种iterator，如反向遍历，双向遍历（即，增加一个previous方法），只要注意一下currentInde和index就可以了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jquery之ajax]]></title>
      <url>%2F2017%2F03%2F23%2Fjqajax%2F</url>
      <content type="text"><![CDATA[前言ajax ：异步请求，浏览器地址栏不改变，进行局部刷新 首先先来看一下ajax在浏览器与服务器之间的传输过程 ajaxjquery中有多种ajax请求，根据应用场景不同，选择的ajax不同 $.ajax(…) 最底层ajax请求，编写最复杂，完成功能最全的 load() 、$.get() 、$.post() $.getJSON() 可以完成js“跨域”请求域名：域名+端口+项目，js默认不能跨域请求 $.getScript() 动态加载js文件。 回调函数 json解析 下面将对上面部分进行模拟首先是有一个按钮 1&lt;input type="button" value="发送ajax" /&gt; 然后在js中操作 1234 // 请求路径，我这里是请求到一个servletvar url = "getajaxname";// 请求参数，采用jsonvar params = &#123;"username":"盲僧", "password":"我的最爱"&#125;; 接下来就是利用不同形式的ajax发送请求1 load()函数 ，必须使用jquery对象 * * 格式：load(url, [data], [callback]) * 参数1：url ，请求路径 * 参数2：data，请求参数 * 参数3：callback，回调函数 * * 如果没有请求参数，发送的GET请求 * * 如果有请求参数，发送的POST请求。请求没有中文乱码 * * 回调函数的参数 * 参数1：data，响应数据。load()永远获得字符串，如果需要使用，必须手动转换json对象。 * 12345$(this).load(url,params,function(data)&#123; //转换json对象 var jsonData = eval("("+data+")"); alert(jsonData.value); &#125;); 后台servlet，这里利用gson.jar包回送json数据 1234567891011121314151617public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html,charset=utf-8"); PrintWriter out = response.getWriter(); String name= request.getParameter("username"); String age= request.getParameter("password"); System.out.println(name); System.out.println(age); /*out.println("ajax ok");*/ JsonObject json=new JsonObject(); json.addProperty("value", "ok"); response.getWriter().write(json.toString()); out.flush(); out.close(); &#125; 我们可以通过火狐里的firebug进行测试和观察 2 $.get() 全局函数，发送get请求 * * 格式：jQuery.get(url, [data], [callback], [type]) * * 参数4：type ，返回内容格式，xml, html, script, json, text, _default。 * * GET请求不适合发送中文数据，存放请求的中文乱码。 * 必须手动解码 new String(username.getBytes(&quot;ISO-8859-1&quot;) ,&quot;UTF-8&quot;) * * 响应数据，如果使用 application/json;charset=UTF-8 ，jQuery自动将数据转换json对象。 * * 响应数据，如果使用 text/html;charset=UTF-8 ，回调函数获得字符串数据，需要手动转换。 * 使用“参数4”，设置&quot;json&quot;，jQuery将字符串 转换成 json对象 123$.get(url,params,function(data)&#123; alert(data.value); &#125;,"json"); 将servlet中post中代码copy到get中，但是后台接受的是乱码 3 $.post() 全局函数，发送post请求 * * 格式：jQuery.post(url, [data], [callback], [type]) 123$.post(url,params,function(data)&#123; alert(data.value); &#125;,"json") 4 $.ajax() 底层功能最强大的 * * 格式：jQuery.ajax([settings]) * 参数settings：设置所有的参数 * url:发送请求的地址 * data:发送到服务器的数据,请求参数 * type:请求方式 (&quot;POST&quot; 或 &quot;GET&quot;)， * success:成功的回调函数，success(data, textStatus, jqXHR) * error:请求失败时调用此函数 * dataType:预期服务器返回的数据类型 * &quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理。 * &quot;html&quot;: 返回纯文本 HTML 信息；包含的script标签会在插入dom时执行。 * &quot;script&quot;: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了&quot;cache&quot;参数。&apos;&apos;&apos;注意：&apos;&apos;&apos;在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载) * &quot;json&quot;: 返回 JSON 数据 。 * &quot;jsonp&quot;: JSONP 格式。使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 * &quot;text&quot;: 返回纯文本字符串 */ 123456789101112$.ajax(&#123; "url":url, "data":params, "type":"POST", "success":function(data)&#123; alert(data.value); &#125;, "error":function()&#123; alert("服务器繁忙，请稍后重试"); &#125;, "dataType":"json"&#125;); 一般情况下，我都会选择使用.ajax前后台交互，因为它功能相对较多，其次我们也可以选择适合我们的属性用。 当然后面的ajax，平时也没用到过，所以就不介绍了，当然api是最好的资料，google是最好的老师。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识原生态ajax]]></title>
      <url>%2F2017%2F03%2F22%2Fajax%2F</url>
      <content type="text"><![CDATA[前言1 Ajax是一种网页开发技术，（Asynchronous Javascript+XML）异步JavaScript和xml，2 Ajax是异步交互，局部刷新3 Ajax是减少服务器压力4 Ajax能提高用户体验 Ajax交互与传统交互比较传统交互：网页整体刷新（同步），服务器压力大，用户体验不好 Ajax交互：局部刷新，服务器压力小，用户体验好 不妨先来一个实例，先从整体把握，在细节看首先是jsp页面： 12345&lt;div style="text-align: center;"&gt; &lt;div&gt; &lt;input type="button" value="ajax异步交互" onclick="loadname()"/&gt;&amp;nbsp;&amp;nbsp;&lt;input type="text" name="name" id="name"/&gt; &lt;/div&gt;&lt;/div&gt; 有个按钮事件，用于验证ajax 12345678910111213&lt;script type="text/javascript"&gt; function loadname()&#123; var xmlHttp; if(window.XMLHttpRequest)&#123; xmlHttp=new XMLHttpRequest(); &#125; else&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; xmlHttp.open("post", "getajaxname?name=666&amp;age=16", true); xmlHttp.send(); &#125; &lt;/script&gt; 这段作用是利用ajax异步向后台传了两个参数name=666与age=16，路径是getajaxname为一个servlet路径，通过post方式 后台servlet 123456789101112public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html,charset=utf-8"); PrintWriter out = response.getWriter(); String name= request.getParameter("name"); String age= request.getParameter("age"); System.out.println(name); System.out.println(age); out.flush(); out.close(); &#125; 这里接受前台传来的参数并打印出来 123456789101112Web.xml文件&lt;servlet&gt; &lt;servlet-name&gt;getajaxname&lt;/servlet-name&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;servlet-class&gt;com.zwl.servlet.getajaxname&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;getajaxname&lt;/servlet-name&gt; &lt;url-pattern&gt;/getajaxname&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 主要是映射一个servlet 至此入门程序算是完成，下面将对上述部分进行分析 创建XMLHttpRequest对象所有现代浏览器均支持XMLHttpRequest 对象（IE5 和IE6 使用ActiveXObject）XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。创建语法： 1234567var xmlHttp; if(window.XMLHttpRequest)&#123; xmlHttp=new XMLHttpRequest(); &#125; else&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; XMLHttpRequest 对象请求后台open(method,url,async)规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或POSTurl：文件在服务器上的位置async：true（异步）或false（同步） send(string)将请求发送到服务器。string：仅用于POST 请求 语法： 12xmlHttp.open("post", "getajaxname?name=666&amp;age=16", true);xmlHttp.send(); 有时候需要将参数封装在一个函数中首先得声明setRequestHeader(header,value) 向请求添加HTTP 头。header: 规定头的名称value: 规定头的值创建语法： 1xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded"); 将入门程序部分代码修改如下： 123xmlHttp.open("post", "getajaxname", true); xmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded"); xmlHttp.send("name=666&amp;age=16"); XMLHttpRequest 对象响应服务器现在在前面的代码基础上添加几行代码 12345678alert("readystate:"+xmlHttp.readyState+" status:"+xmlHttp.status); xmlHttp.onreadystatechange=function()&#123; alert("readystate:"+xmlHttp.readyState+" status:"+xmlHttp.status); &#125;; xmlHttp.open("post", "getajaxname", true); xmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded"); xmlHttp.send("name=666&amp;age=16"); 先分析一下onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当readyState 改变时，就会触发onreadystatechange 事件。readyState 属性存有XMLHttpRequest 的状态信息。 下面是XMLHttpRequest 对象的三个重要的属性：onreadystatechange存储函数（或函数名）每当readyState 属性改变时，就会调用该函数。 readyState存有XMLHttpRequest 的状态。从0 到4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status200: “OK”404: 未找到页面 执行上面程序就会发现相应值的变化 接下来在后台加入返回的信息public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html,charset=utf-8&quot;); PrintWriter out = response.getWriter(); //向前台返回一个信息 out.println(&quot;ajax ok&quot;); out.flush(); out.close(); } 页面：根据前面的状态码，进行接收参数 123if(xmlHttp.readyState==4 &amp;&amp; xmlHttp.status==200)&#123; document.getElementById("name").value=xmlHttp.responseText; &#125; responseText 获得字符串形式的响应数据 最后会发现表单被自动填充]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识git]]></title>
      <url>%2F2017%2F03%2F22%2Fgit%2F</url>
      <content type="text"><![CDATA[gitgit是linux之父Linus的第二个伟大的作品，它是分布式版本控制系统，即每个人可以通过clone将工作建立在本地库中 对比之前我们是通过hexo d的提交给远程仓库的master branch，当然我们也可以git提交或者clone到本地。 远程仓库代码clone到本地 首先需要生成公钥与仓库连接首先添加用户名1git config --global user.name "yourname" 其次添加e-mail 1git config --global user.email "youreamil" 默认在administrator目录下生成.ssh并在下生成两个文件id_rsa和id_rsa.pub秘钥， 生成公钥 1ssh-keygen -C "youremail" 这时候我们可以在.ssh文件下用 ls -al显示所有文件（因为.ssh是隐藏的，我是新建了一个.ssh） 2 配置公钥在setting中的ssh and GPG keys中新建ssh key将id_rsa.pub中的内容辅助进去最后用ssh -T git@github.com检查公钥是否配置成功 3 初始化.git在本地新建任意一个文件，在该路径下，初始化为本地仓库1git init 提交文件到缓存区 1git add filename（.表示所有文件） 查看状态 1git status 本地提交，即完成提交至远程仓库的准备 1git commit -m "words" 查看commit记录 1git log 远程最新的代码更新到本地 1git pull origin master 本地代码推到远程仓库，实现本地与远程仓库的同步 1git push origin master 这里我是先将我的一个仓库先clone到本地 1git clone 仓库地址 然后在该仓库目录下执行add和commit，最后在push提交到远程仓库，如果没有远程仓库，可先关联 1git remote add origin 仓库 再push 3.其他常用命令查看当前项目有哪些远程仓库可以执行 1git remote -v 建立分支查看分支（branch） 1git branch 默认都是master，并且master提交新建分支 1git branch name 切换分支` 1git checkout name 删除分支 1git branch -d name 如果我们想要传送另一个分支到远程仓库只需在push中 git push origin branch master 当然git的命令太多了，只总结了学习过程中实验到的 接下来如果将别人代码clone到本地，一般先fork，在利用clone]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssm三大框架整合]]></title>
      <url>%2F2017%2F03%2F21%2Fssm%2F</url>
      <content type="text"><![CDATA[前言 ssm三大框架整合主要指的是spring mvc+mybatis+spring，利用mvc分层思想实现解耦，其中spring mvc负责业务控制和跳转，mybatis负责持久层，spring管理各层，下面将以一个通过id查询用户信息功能搭建整合环境 建立一个web工程 导入ssm整合的相关jar包，包括spring(包含springmvc)，mybatis，mybatis-spring整合。数据库驱动，jstl，c3p0管理数据源，log4j.由于整合包过多，可以自行到网上下载 配置核心文件初始化Web.xml配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;springmvc19_day01_01&lt;/display-name&gt; //配置中文乱码过滤器 &lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; //启用spring监听 &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; //启动spring mvc &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 默认加载方式 默认加载必须规范： * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml * 路径规范：必须在WEB-INF目录下面 --&gt; &lt;/servlet&gt; //spring mvc 过滤文件 &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; //rest格式拦截，主要用在提交带参数问题 &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 加载springmvc-servlet.xml文件 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; //自动扫面根路径以下的所有包，就不要显示配置bean了 &lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt; //默认创建注解处理器映射器，注解处理器适配器。提供json格式支持。 &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 配置sprigmvc视图解析器：解析逻辑视图 后台返回逻辑试图：index 视图解析器解析出真正物理视图：前缀+逻辑试图+后缀====/WEB-INF/jsps/index.jsp --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 加载spring配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; //自动扫面根路径以下的所有包，就不要显示配置bean了 &lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt; &lt;!-- 第一步：配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:mysql端口/你的项目"&gt;&lt;/property&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="user" value="你的用户名"&gt;&lt;/property&gt; &lt;property name="password" value="你的密码"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 第二步：创建sqlSessionFactory。生产sqlSession，即产生会话 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置mybatis接口代理开发 * 接口类名和映射文件必须同名 * 接口类和映射文件必须在同一个目录 下 * 映射文件namespace名字必须是接口的全类路径名 * 接口的方法名必须和映射Statement的ｉｄ一致 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zwl.dao"&gt;&lt;/property&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 第三步：事务 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="save*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!-- 配置拦截service --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.zwl.service.*.*(..))"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 以上三个包都必须在web-inf下 编写接口代码首先是pojo类 12345public class User &#123; private String name; //用户名 private String pwd; //密码 private int uid; //用户id此处省略set、get方法。&#125; 然后利用mapper代理模式开发dao层首先是Usermapper.xml 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.zwl.dao.Usermapper"&gt; &lt;!-- 根据用户ID查询用户信息 --&gt; &lt;select id="findUserById" parameterType="int" resultType="com.zwl.pojo.User"&gt; SELECT * FROM users WHERE uid =#&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 然后是接口 123public interface Usermapper &#123; public User findUserById(int id) throws Exception;&#125; 编写service层这里用到spring注解依赖注入 12345public interface Userservice &#123; public User finduserbyid(Integer id) throws Exception; &#125; 实现类： 1234567891011121314//声明业务层为注解，为控制层依赖注入服务@Servicepublic class Userserviceimpl implements Userservice &#123; //通过注解注入dao层组件 @Resource private Usermapper usermapper; @Override public User finduserbyid(Integer id) throws Exception &#123; User user=usermapper.findUserById(id); return user; &#125;&#125; 控制层 1234567891011121314151617181920212223242526272829//注解自动在spring中注入该bean@Controller//请求路径，放在开头，请求url，controller前必须加入该映射路径@RequestMapping("/user")public class Usercontrol &#123; //自动注入bean @Resource private Userservice userservice;//请求路径，放在方法前，为请求url，到时根据这个找到类里相应方法 @RequestMapping("toadd") public String toadd()&#123;//返回视图，在配置文件中已经配置了前缀和后缀，所以返回到index.jsp return "index"; &#125; @RequestMapping("uid") //这里的参数id必须和前台提交的参数name相同，才能接收到 public void finduserbyid(Integer id) &#123; try &#123; User u=userservice.finduserbyid(id); System.out.println(u.getName()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 页面index.jsp 1234&lt;form action="$&#123;pageContext.request.contextPath &#125;/user/uid.do" method="post"&gt;id：&lt;input type="text" name="id" id="id"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; 数据库里面字段必须为uid，name和password，和pojo类相对应，并且里面有数据 最后我们可以在浏览器输入http：//localhost:端口/项目名/user/toadd.do到index.jsp页面，最后通过输入id，后台输出用户信息 至此ssm整合完成，会发现它比ssh2更方便，特别是注解开发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh三大框架整合]]></title>
      <url>%2F2017%2F03%2F21%2Fssh%2F</url>
      <content type="text"><![CDATA[前言ssh三大框架整合主要指的是structs2+hibernate+spring，利用mvc分层思想实现解耦，其中structs2负责业务控制和跳转，hibernate负责持久层，spring管理各层 ssh下面将以一个简单的登录功能搭建整合环境 首先建立一个web工程，取名ssh2 导入jar包，由于ssh2整合包过多，可以自行官网下载 导入相关配置文件Spring核心文件：applicationcontent.xml放在web-inf下web工程核心文件：web.xml也放在web-inf下structs2核心文件：structs.xml放在src目录下里面暂时什么都不配置 数据库为了方便，设置三个字段，id（int）、name（varchar）、age（int），其中id为主键，且是自增长的 配置核心文件初始化Web.xml配置 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; //启动structs2框架 &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt; &lt;/filter&gt;//允许后缀名为.action或者.jsp的请求通过 &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt;//启动spring监听，即开启spring框架 &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; Applicationcontent.xml文件配置（目前没有实现任何功能，给出原始配置） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beansxmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt; &lt;!-- 定义数据源 ，即连接数据库所需的配置--&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName"&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property name="url"&gt; &lt;value&gt;jdbc:mysql://localhost:mysql端口/数据库名&lt;/value&gt; &lt;/property&gt; &lt;property name="username"&gt; &lt;value&gt;你的用户名&lt;/value&gt; &lt;/property&gt; &lt;property name="password"&gt; &lt;value&gt;你的密码&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- 定义SessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; &lt;property name="dataSource"&gt; &lt;ref bean="dataSource"/&gt; &lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt;//hibernate的方言，决定用哪个数据库 &lt;prop key="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/prop&gt; //是否启动显示sql语句 &lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;//声明hibernate的映射文件，目前没有，后续步骤在此处加上 &lt;property name="mappingResources"&gt; &lt;list&gt; &lt;value&gt;&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义HibernateTemplate，相当于纯hibernate的session --&gt; &lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt; &lt;property name="sessionFactory"&gt; &lt;ref bean="sessionFactory"/&gt; &lt;/property&gt; &lt;/bean&gt; 省略具体的业务代码注入配置&lt;/beans&gt; Structs.xml文件配置 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;//防止乱码&lt;constant name="struts.i18n.encoding" value="utf-8"/&gt;&lt;/struts&gt;目前该文件里面什么功能都没配置，只是个声明 编写业务代码按照mvc思想，先从持久层开始，即编写hibernate的orm对象user.java 123456public class User &#123; private int age; private int id; private String name;此处省略set。Get方法&#125; 映射文件User.hbm.xml 12345678910111213&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.zwl.pojo"&gt;&lt;class name="User" &gt;&lt;id name="id"&gt;&lt;generator class="increment"&gt;&lt;/generator&gt;&lt;/id&gt;&lt;property name="name"&gt;&lt;/property&gt;&lt;property name="age"&gt;&lt;/property&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt; 注意这里普通属性有时为了方便，只要声明一个name，其他属性hibernate会自动识别并补充 接下来要在spring中声明该映射文件 12345&lt;property name="mappingResources"&gt; &lt;list&gt; &lt;value&gt;com/zwl/pojo/User.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 至此，持久层完成 接下来是dao层 123456789101112131415161718192021222324252627282930public interface dengludao &#123;//登录功能public User denglu(User u);&#125;Dao层的实现类import org.springframework.orm.hibernate3.support.HibernateDaoSupport;import com.zwl.pojo.User;public class dengludaoimpl extends HibernateDaoSupport implements dengludao&#123; //这里用了spring提供的操作hibernate的模板方法 @Override public User denglu(User u) &#123; //find里可以写sql语句 List&lt;User&gt; list=this.getHibernateTemplate().find("select user from User as user where user.id=?",u.getId()); if(list.size()==0)&#123; return null;&#125; else&#123; return (User) list.get(0); &#125; &#125;&#125; 接下来要在spring中注入到组件&lt;!-- 配置DAO组件 --&gt; &lt;bean id="dengludao" class="com.zwl.dao.dengludaoimpl"&gt; &lt;property name="hibernateTemplate"&gt; &lt;ref bean="hibernateTemplate"/&gt; &lt;/property&gt; &lt;/bean&gt; 接下来是业务层： 首先是接口 123456789101112131415161718192021222324252627282930public interface dengluservice &#123;public boolean isdenglu(User u);&#125;然后是实现类public class dengluserviceimpl implements dengluservice&#123; //引用dao层组建 private dengludao denglu; public dengludao getDenglu() &#123; return denglu; &#125; public void setDenglu(dengludao denglu) &#123; this.denglu = denglu; &#125; @Override public boolean isdenglu(User u) &#123; if(denglu.denglu(u)!=null) return true; else&#123; return false; &#125; &#125;&#125;接下来就要在spring中注入业务层组件&lt;!-- 配置业务逻辑组件 --&gt; &lt;bean id="dengluservice" class="com.zwl.dao.dengluserviceimpl"&gt; &lt;property name="denglu"&gt; &lt;ref bean="dengludao"/&gt; &lt;/property&gt; &lt;/bean&gt; 表现层首先是两个页面Index.Jsp主要提交表单 12345&lt;form action="userdenglu.action" method="post"&gt; id:&lt;input name="id" type="text"&gt; &lt;br/&gt; &lt;input type="submit"/&gt; &lt;/form&gt; Success.jsp主要就是一句success提示 控制层 123456789101112131415public class userdenglu extends ActionSupport&#123; private dengluservice dengluservic; private int id;省略set与get方法。。 @Override public String execute() throws Exception &#123; User u=new User(); u.setId(id);//如果id存在，返回成功 if(dengluservic.isdenglu(u))&#123; return SUCCESS; &#125; return ERROR; &#125; 接下来需要在spring中注入action 123456&lt;!-- 配置userdengluAction --&gt; &lt;bean id="userdenglu" class="com.zwl.action.userdenglu"&gt; &lt;property name="dengluservic"&gt; &lt;ref bean="dengluservice"/&gt; &lt;/property&gt; &lt;/bean&gt; 同时在structs.xml中配置跳转 1234&lt;action name="userdenglu" class="userdenglu"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;result name="error"&gt;/error.jsp&lt;/result&gt; &lt;/action&gt; 最后通过在浏览器输入到index.jsp，然后输入id，数据库中可以预先插入数据，最后跳转，如果成功则跳到success.jsp，否则产生错误 至此：ssh2框架环境搭建成功，最后提醒的是，这只是一个框架环境，我们可以在此基础上按照mvc思想，可以进行我们想要功能的开发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于java的execl导入数据库和取数据至页面]]></title>
      <url>%2F2017%2F03%2F20%2Fexecl%2F</url>
      <content type="text"><![CDATA[前言在踩了许多坑之后，急需总结一下来提高自己，当然探索未知的过程也是自我能力的提升 POIakarta POI 是apache的子项目，它提供了一组操纵Windows文档的Java API，一般我们使用HSSF接口来操作execl对象，从而实现用纯Java代码来读取、写入、修改Excel文件 我们可以到其官网下载最新poi文档 进入正题首先我们定义一个需求，上传本地一个execl表（里面含有数据），提交给服务器，然后跳转到另一个界面（显示execl表中内容） 环境准备MyEclipse。ssh整合包，mysql，poi的相关包（去官网下载，导入poi-3.7-20101029.jar，poi-examples-3.7-20101029.jar，poi-ooxml-3.7-20101029.jar，poi-ooxml-schemas-3.7-20101029.jar，poi-scratchpad-3.7-20101029.jar） 首先是建一个pojo类，主要与execl表中对应的字段相对应为了方便，这里只有id，name，password字段 12345678package com.zwl.pojo;public class User &#123; private int id; private String name; private String password; 省略set..get方法 2.execl表中写数据 id name password 1 java lol 2 c 3.写读取execl表格的工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.zwl.util;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFCell;import com.zwl.pojo.User;public class ReadExcel &#123; //将execl表中的数据读取出，并与pojo类对应，最后放在集合中 public List&lt;User&gt; readXls(String path) throws IOException &#123; //execl表的全路径,并保存在输入流 InputStream is = new FileInputStream(path); //HSSFWorkbook excell 文档对象介绍 HSSFWorkbook hssfWorkbook = new HSSFWorkbook(is); User user=null; List&lt;User&gt; list=new ArrayList&lt;User&gt;(); // 循环工作表Sheet for (int numSheet = 0; numSheet &lt; hssfWorkbook.getNumberOfSheets(); numSheet++) &#123; // HSSFSheet excell的表单 HSSFSheet hssfSheet = hssfWorkbook.getSheetAt(numSheet); if (hssfSheet == null) &#123; continue; &#125; // 循环行Row for (int rowNum = 1; rowNum &lt;= hssfSheet.getLastRowNum(); rowNum++) &#123; //HSSFRow excell的行 HSSFRow hssfRow = hssfSheet.getRow(rowNum); if (hssfRow != null) &#123; User u = new User(); //HSSFCell excell的格子单元 //这里取出每一行的数据，依次分别添加到pojo对象中，最后放在集合中 HSSFCell no = hssfRow.getCell(0); HSSFCell name = hssfRow.getCell(1); HSSFCell age = hssfRow.getCell(2); int i=(int)Double.parseDouble(getValue(no)); u.setId(i); u.setName(getValue(name)); u.setPassword(getValue(age)); list.add(u); &#125; &#125;&#125; return list; &#125; @SuppressWarnings("static-access") private String getValue(HSSFCell hssfCell) &#123; if (hssfCell.getCellType() == hssfCell.CELL_TYPE_BOOLEAN) &#123; // 返回布尔类型的值 return String.valueOf(hssfCell.getBooleanCellValue()); &#125; else if (hssfCell.getCellType() == hssfCell.CELL_TYPE_NUMERIC) &#123; // 返回数值类型的值 return String.valueOf(hssfCell.getNumericCellValue()); &#125; else &#123; // 返回字符串类型的值 return String.valueOf(hssfCell.getStringCellValue()); &#125; &#125; &#125; 4.上传execl页面，这里只有主体部分 12345//上传至后台的uploadaction，同时规定只能上传execl文件，并且这里的myFile要与后台action中属性对应 &lt;form action="upload.action" enctype="multipart/form-data" method="post"&gt; &lt;input id="share_box" type="file" name="myFile" accept="excel/*"&gt;&lt;hr/&gt; &lt;input id="submit" type="submit" name="" value="分享"&gt; &lt;/form&gt; 5.action编写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class upload extends ActionSupport &#123; private File myFile; //上传的图片文件 private String myFileContentType; //文件类型 private String myFileFileName; //文件名 省略set与get方法 @Override public String execute() throws Exception &#123; //创建一个输入流 InputStream is = new FileInputStream(myFile); //设置文件保存目录 String photoPath = ServletActionContext.getServletContext().getRealPath(""); //建立该文件 File filePhotoPath = new File(photoPath); //该用户第一次上传则创建 /*if(!filePhotoPath.isDirectory()) &#123; filePhotoPath.mkdir(); &#125;*/ //解决中文文件名问题，将中文文件转化为uuid码 String extension = FilenameUtils.getExtension(this.getMyFileFileName()); //上传到服务器的execl表的全路径 String s=photoPath+'\\'+filename; System.out.println(s); //设置目标文件 File tofile = new File(photoPath,filename); //使用输出流来包装目标文件 OutputStream os = new FileOutputStream(tofile); //通过字节输入 byte[] buffer = new byte[1024]; int length = 0; while((length = is.read(buffer)) &gt; 0) &#123; os.write(buffer, 0, length); &#125; //关闭输入流 is.close(); //关闭输出流 os.close(); //引用读取execl表类 ReadExcel rs=new ReadExcel(); //取出execl表中的内容 List&lt;User&gt; list=rs.readXls(s); //将execl表中取出的数据放在session中，以便在下个界面显示数据 Map session = ServletActionContext.getContext().getSession(); session.put("stu", list); return super.execute(); &#125;&#125; 6.structs配置文件编写 1234567891011121314151617//spring中注入bean&lt;bean id="upload" class="com.zwl.action.upload"&gt; &lt;/bean&gt;//strucs.xml文件，其中涉及文件上传，必须有拦截栈的设置，ok.jsp为显示execl表格信息 &lt;action name="upload" class="upload"&gt; &lt;result name="success"&gt;/ok.jsp&lt;/result&gt; &lt;result name="input"&gt;/ok.jsp&lt;/result&gt; &lt;!-- 配置fileUpload拦截器 --&gt; &lt;interceptor-ref name="fileUpload"&gt; &lt;!-- 配置允许上传文件类型 这里是execl文件格式允许上传--&gt; &lt;param name="allowedTypes"&gt;application/excel,application/vnd.ms-excel&lt;/param&gt; &lt;!-- 配置允许上传文件大小最大值 --&gt; &lt;param name="maximumSize"&gt;5120000&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; 7.取出信息在页面显示通过标签循环取出session中的数据12345&lt;s:iterator value="#session.stu" id="cri"&gt;id:&lt;s:property value="#cri.id" escape="false"/&gt;&lt;br/&gt;name:&lt;s:property value="#cri.name" escape="false"/&gt;&lt;br/&gt;password:&lt;s:property value="#cri.password" escape="false"/&gt;&lt;br/&gt;&lt;/s:iterator&gt; 至此我们可以本地上传execl，然后取出表中内容在另一个页面显示信息 导入数据库同样关键在于通过execl路径，通过工具包取出表中内容（存在集合中），将该集合循环取出放在数据库即可9.后台插入数据到数据库的接口 1234567891011121314151617181920212223242526272829303132333435//映射文件hibernate-mapping package="com.zwl.pojo"&gt; &lt;class name="User" table="user" &gt; &lt;id name="id" &gt; &lt;generator class="increment"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="name"&gt; &lt;/property&gt; &lt;property name="password"&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;//dao层public interface dengludao &#123; public void insert(User u);&#125;//sercive层public interface dengluservice &#123;public void isinsert(User u);&#125;//实现类//dao层实现类@Override public void insert(User u) &#123; this.getHibernateTemplate().save(u); &#125;//service层实现类private dengludao denglu;@Override public void isinsert(User u) &#123; denglu.insert(u); &#125; 当然最后还得在spring中注入 10.最后在action中修改一下 12345678910111213//首先增加组件（spring中注入）private dengluservice dengluservic;省略set与get// 在execute中末尾增加如下代码 for(User u : list)&#123; //循环取出execl表中数据 User ss=new User(); ss.setId(u.getId()); ss.setName(u.getName()); ss.setPassword(u.getPassword()); //循环插入到数据库 dengluservic.isinsert(ss); &#125; 最后只要我们上传execl文件，就可以先插入数据库，再在另一个页面显示信息了，注意这里有些地方笔者只给出主体代码，其次有些spring中要注入bean，这里省略了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识Arraylist底层]]></title>
      <url>%2F2017%2F03%2F19%2Farraylist%2F</url>
      <content type="text"><![CDATA[前言ArrayList也叫数组列表，底层使用的是数组实现的，严格来说是动态数组。 一般情况下，一个问题的认识都是由具体到抽象，先看一个入门案例： 1234567891011ArrayList&lt;String&gt; al=new ArrayList&lt;&gt;(); al.add("hello"); al.add("world"); al.add("lol"); System.out.println(al.size()); System.out.println(al.get(0)); System.out.println(al.get(1)); System.out.println(al.get(2)); al.remove(1); System.out.println(al.size()); System.out.println(al.get(1)); 测试结果：3 hello world lol 2这个例子也很好理解，大概流程是先创建集合，在依次加入数据，依次取出和大小，在删除其中一个，在看大小和删除的数据是否存在，好了，入门程序就到这了，运用这几个方法我们可以把它复杂化运用到我们以后想要的上面。 至此下面将开始简单介绍一下add，get，remove方法的源码分析。（当然我们也可以通过设置断点追踪源码） add方法在此之前，先介绍一下源码中的几个静态常量 123private static final int DEFAULT_CAPACITY=10;//数组为空默认的最小分配数组容量private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//默认空数组private int size;//数组长度，初始化默认为0； 下面就是add方法 123456public boolean add(E e) &#123;//保证数组容量的容量始终够用 ensureCapacityInternal(size + 1); //size是elementData数组中元素的个数，初始为0 elementData[size++] = e; return true;&#125; 首先进入第一个方法分析： 12345678910111213141516171819202122232425262728293031323334353637383940private void ensureCapacityInternal(int minCapacity) &#123;//如果数组没有元素，给数组一个默认大小，会选择实例化时的值与默认大小较大者 if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //保证容量够用 ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123;//数组发生size更改的次数，默认为0 modCount++; //如果数组长度小于默认的容量10，则调用扩大数组大小的方法 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125;//数组长度的上限 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) &#123; // 保证数组容量扩大一倍 int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 得到扩大容量后的新数组 elementData = Arrays.copyOf(elementData, newCapacity); &#125;private static int hugeCapacity(int minCapacity) &#123;//返回新数组的大小 if (minCapacity &lt; 0) throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 至此算是把add方法的底层分析了一遍，我们现在是不是可以假象一个简单例子来模拟流程 12ArrayList&lt;String&gt; al=new ArrayList&lt;&gt;(); al.add("hello"); 大概执行流程，数组为空，分配一个默认大小为10的容量，容量动态扩充，然后size变化，最后将值赋给数组，说了这么多，还是有点，总之，可以自己模拟数据，然后进行断点调试，就大概了解其过程了。 get方法在此之前先补充一下arraylist的构造函数，如下 1234567891011121314//如果构造函数不指定大小，则将默认空对象给数组对象public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA; &#125; //指定初始化数组大小public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity]; &#125; 下面就来看一看get方法的执行过程 123456789101112public E get(int index) &#123;//判断index是否合法 rangeCheck(index); //得到相应的数组数据 return elementData(index); &#125;private void rangeCheck(int index) &#123;//判断数组是否越界 if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; 可以看到它的执行过程就这两步 remove方法这里先说明一下，由于删除操作会改变size，所以每次删除都需要把元素向前移动一个位置，然后把最后一个位置设置为null，一次删除操作完成 123456789101112131415161718192021public E remove(int index) &#123; //判断index是否合法 rangeCheck(index);// size更改的次数 modCount++;//保存待删除的位置的元素 E oldValue = elementData(index); //要移动的元素个数 int numMoved = size - index - 1; //如果index不是最后一个元素，则从第index+1到最后一个位置，依次向前移动一个位置 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //元素的size-1并且最后一个元素位置设为null elementData[--size] = null; return oldValue; &#125; public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 很遗憾：断点调试中没有源码，因为其是native，是其他语言编写的，这里只做简单介绍从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的源数组到 dest 引用的目标数组，数组组件的一个子序列被复制下来。被复制的组件的编号等于 length 参数。源数组中位置在 srcPos 到 srcPos+length-1 之间的组件被分别复制到目标数组中的 destPos 到 destPos+length-1 位置。 最后不得不提的是因为arraylist是动态增长的，即容量增产幅度遵循size/2+1，即默认为10，所以依次为：10,16,25.。。。。这就造成arraylist是线程不安全的，多线程中产生问题，参考单例模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于servlet的验证码和md5加密]]></title>
      <url>%2F2017%2F03%2F19%2Fmd5%2F</url>
      <content type="text"><![CDATA[前言验证码通俗的讲就是为了防止机器人自动注册无限制，而md5加密则将明文密码转化为一个32位字符串 验证码这里是基于servlet的，也就是说通过java代码随机生成一个你设置的位数的字符串，然后将其保存在session中，以便后续是通过ajax传给前台验证或者是后台验证首先是生成验证码的类,这里我放在了com.ltw.tools包下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class yanzhengma extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 7.禁止浏览器缓存随机图片 response.setDateHeader("Expires", -1); response.setHeader("Cache-Control", "no-cache"); response.setHeader("Pragma", "no-cache"); // 6.通知客户机以图片方式打开发送过去的数据 response.setHeader("Content-Type", "image/jpeg"); // 1.在内存中创建一副图片 BufferedImage image = new BufferedImage(60, 30, BufferedImage.TYPE_INT_RGB); // 2.向图片上写数据 Graphics g = image.getGraphics(); // 设背景色 g.setColor(Color.BLACK); g.fillRect(0, 0, 60, 30); // 3.设置写入数据的颜色和字体 g.setColor(Color.RED); g.setFont(new Font(null, Font.BOLD, 20)); // 4.向图片上写数据 String num = makeNum(); //这句话就是把随机生成的数值，保存到session，//通过session就可以直接去到随即生成的验证码了 request.getSession().setAttribute("checkcode", num); g.drawString(num, 0, 20); // 5.把写好数据的图片输出给浏览器 ImageIO.write(image, "jpg", response.getOutputStream()); &#125; //该函数时随机生成7位数字 public String makeNum() &#123; Random r = new Random(); //9999999 可以生成7位 String num = r.nextInt(99999) + ""; StringBuffer sb = new StringBuffer(); //如果不够4位，前面补零 for (int i = 0; i &lt; 5 - num.length(); i++) &#123; sb.append("0"); &#125; num = sb.toString() + num; return num; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;&#125;&#125; 这里需要注意的是随机生成的数字放在session的checkcode中，通过设置r.nextInt(xxx)，xxx表示生成几位，如9999，则为四位验证码，然后在for循环中改成设置的位即可接下来将验证码映射成资源文件，在web.xml中设置 123456789&lt;servlet&gt; &lt;servlet-name&gt;yanzhengma&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ltw.tools.yanzhengma&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;yanzhengma&lt;/servlet-name&gt; &lt;url-pattern&gt;/yanzhengma&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 这样该类就被映射成一个资源，然后在页面中直接取资源 1234&lt;input type="text" name="yanzhenma" placeholder="请输入验证码" required="required"&gt;&lt;!-- 验证码，后台已将该.java映射为文件 --&gt; &lt;img src='/项目名/yanzhengma' style="width:400px;height: 50px;" &gt; &lt;input id="submit" type="submit" value="登录"&gt; 如果这里我们需要在前台输入验证码验证，可以通过ajax传值验证。然后在写一个servlet用来将checkcode转换为json传给前台 1234567891011121314151617181920public class dengluyanzhen extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;&#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String code = (String) request.getSession().getAttribute("checkcode"); //获得验证码 response.setContentType("text/html; charset=UTF-8"); response.setHeader("Cache-Control", "no-cache"); response.setHeader("Pragma", "no-cache"); PrintWriter out = response.getWriter(); StringBuffer sb = new StringBuffer(); sb.append(code); out.write(sb.toString()); //转化为json格式将验证码返回给前端 out.close(); &#125;&#125; 然后在前台，还是上面那个页面增加如下代码 123456789101112131415161718192021222324 &lt;script type="text/javascript"&gt;$(function()&#123; /* 利用ajax异步传值，result获得后台传过来的json数据，即验证码 */ var result = ""; $.ajax(&#123; url:'&lt;%=path%&gt;/dengluyanzhen', type:"POST", dataType:"json", async:true,//关闭异步加载,这样只有加载完成才进行下一步 success:function (data) &#123; result = data; &#125; &#125;); $("#submit").click(function () &#123; var num1=$("[name='yanzhenma']").val(); if(result!=num1)&#123; alert("您输入的验证码不一致！请重新输入"); return false; window.location.href="error.jsp"; &#125; &#125;); &#125;);&lt;/script&gt; MD5加密主要是一个算法 12345678910111213141516171819202122public class MD5 &#123; public final static String MD5(String s) &#123; char hexDigits[] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9','a', 'b', 'c', 'd', 'e', 'f' &#125;; try &#123; byte[] strTemp = s.getBytes(); MessageDigest mdTemp = MessageDigest.getInstance("MD5"); mdTemp.update(strTemp); byte[] md = mdTemp.digest(); int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(str); &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; 如果我们想要将一个字符加密，直接调用该类的静态方法即可，如MD5.MD5(users.getPwd())。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于struts2的二维码]]></title>
      <url>%2F2017%2F03%2F18%2Ferweima%2F</url>
      <content type="text"><![CDATA[前言前段时间因为一些原因要做一个二维码，故此google了许多，当然是在踩了许多坑之后，找到了适合自己的方法，故在此将其总结一下，来提高自己 什么是二维码总的来说就是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，最后通过相关设备读取。 zxingzxing是google的一个开源源码，主要用于java生成和解析的条形码，二维码，通过引用相关jar包，实现其中的相关接口来开发，这里我引用的是QRCode.jar主要是生成二维码 需求案例假设我们通过扫描二维码将数据库中的信息取出来并显示在另一个页面 环境准备MyEclipse、mysql数据库（这里建了一张简单表，有id、name、password）、ssh整合包（事实上，我们可以单独使用struts2，只不过耗时一些），QRCode.jar包，jquery-1.8.3.js,gson.jar 二维码工具包这里主要有三个类，一个是图像本身类（包含其本身一些属性）、二维码处理类（包括生成和解析图像二维码），最后一个是将本地图片通过调用处理类转化为二维码。这里我将其放在com.zwl.util包下（以下是相关代码） 123456789101112131415161718public class QRCodeImageBean implements QRCodeImage&#123; BufferedImage bufImg; public QRCodeImageBean(BufferedImage bufImg) &#123; this.bufImg = bufImg; &#125; public int getHeight() &#123; return bufImg.getHeight(); &#125; public int getPixel(int x, int y) &#123; return bufImg.getRGB(x, y); &#125; public int getWidth() &#123; return bufImg.getWidth(); &#125; &#125; 生成和解析二维码类public class QRCode { /** * 解析二维码(QRCode) * @param imgPath * @return content（返回二维码内容） */ public static String decoderQRCode(String imgPath) { // QRCode 二维码图片的文件 File imageFile = new File(imgPath); BufferedImage bufImg = null; String content = null; try { bufImg = ImageIO.read(imageFile); QRCodeDecoder decoder = new QRCodeDecoder(); content = new String(decoder.decode(new QRCodeImageBean(bufImg)), &quot;utf-8&quot;); } catch (IOException e) { System.out.println(&quot;Error: &quot; + e.getMessage()); e.printStackTrace(); } catch (DecodingFailedException dfe) { System.out.println(&quot;Error: &quot; + dfe.getMessage()); dfe.printStackTrace(); } return content; } /** * 生成二维码(QRCode)图片 * @param content 存储内容 * @param imgPath 图片路径 * @param imgType 图片类型 */ public static void encoderQRCode(String content, String imgPath, String imgType) { encoderQRCode(content, imgPath, imgType, 7); } /** * 生成二维码(QRCode)图片 * @param content 存储内容 * @param imgPath 图片路径 * @param imgType 图片类型 * @param size 二维码尺寸 */ public static void encoderQRCode(String content, String imgPath, String imgType, int size) { try { BufferedImage bufImg = qRCodeCommon(content, imgType, size); File imgFile = new File(imgPath); // 生成二维码QRCode图片 ImageIO.write(bufImg, imgType, imgFile); } catch (Exception e) { e.printStackTrace(); } } /** * 生成二维码(QRCode)图片的公共方法 * @param content 存储内容 * @param imgType 图片类型 * @param size 二维码尺寸 * @return */ private static BufferedImage qRCodeCommon(String content, String imgType, int size) { BufferedImage bufImg = null; try { Qrcode qrcodeHandler = new Qrcode(); // 设置二维码排错率，可选L(7%)、M(15%)、Q(25%)、H(30%)，排错率越高可存储的信息越少，但对二维码清晰度的要求越小 qrcodeHandler.setQrcodeErrorCorrect(&apos;M&apos;); qrcodeHandler.setQrcodeEncodeMode(&apos;B&apos;); // 设置设置二维码尺寸，取值范围1-40，值越大尺寸越大，可存储的信息越大 qrcodeHandler.setQrcodeVersion(size); // 获得内容的字节数组，设置编码格式 byte[] contentBytes = content.getBytes(&quot;utf-8&quot;); // 图片尺寸 int imgSize = 67 + 12 * (size - 1); bufImg = new BufferedImage(imgSize, imgSize, BufferedImage.TYPE_INT_RGB); Graphics2D gs = bufImg.createGraphics(); // 设置背景颜色 gs.setBackground(Color.WHITE); gs.clearRect(0, 0, imgSize, imgSize); // 设定图像颜色&gt; BLACK gs.setColor(Color.BLACK); // 设置偏移量，不设置可能导致解析出错 int pixoff = 2; // 输出内容&gt; 二维码 if (contentBytes.length &gt; 0 &amp;&amp; contentBytes.length &lt; 800) { boolean[][] codeOut = qrcodeHandler.calQrcode(contentBytes); for (int i = 0; i &lt; codeOut.length; i++) { for (int j = 0; j &lt; codeOut.length; j++) { if (codeOut[j][i]) { gs.fillRect(j * 3 + pixoff, i * 3 + pixoff, 3, 3); } } } } else { throw new Exception(&quot;QRCode content bytes length = &quot; + contentBytes.length + &quot; not in [0, 800].&quot;); } gs.dispose(); bufImg.flush(); } catch (Exception e) { e.printStackTrace(); } return bufImg; } } 最后一个类是本地生成二维码图片 1234567public static void main(String[] args) &#123; String imgPath = "C:/Users/Administrator/Desktop/img/xiazi.jpg"; QRCode handler = new QRCode(); String qrCon = handler.decoderQRCode(imgPath); String encoderContent = "http://192.168.43.44:100/librarytest/success1.jsp?id=2"; handler.encoderQRCode(encoderContent, imgPath, "png"); &#125; 其中imgPath是本地你想将某个图片生成二维码的那个图片qrCon为解析后的二维码内容，我这里就是一个url地址encoderContent：设置二维码的内容，这里为url带个参数，扫描后就会跳转到相应界面这里的参数想要取出，可以先将内容取出，在通过string类中的方法将字符创相应位置字符取出即可至此，工具类算是有了，接下来就是结合具体配置 后台方法首先是web.xml（启用struts2和spring） 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 然后是applicationContext.xml（为了方便直接将所有方法都注入了）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beansxmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt; &lt;!-- 定义数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName"&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property name="url"&gt; &lt;value&gt;jdbc:mysql://localhost:msql端口/项目&lt;/value&gt; &lt;/property&gt; &lt;property name="username"&gt; &lt;value&gt;你的用户名&lt;/value&gt; &lt;/property&gt; &lt;property name="password"&gt; &lt;value&gt;你的密码&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义SessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; &lt;property name="dataSource"&gt; &lt;ref bean="dataSource"/&gt; &lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="mappingResources"&gt; &lt;list&gt; &lt;value&gt;com/zwl/pojo/User.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义HibernateTemplate --&gt; &lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt; &lt;property name="sessionFactory"&gt; &lt;ref bean="sessionFactory"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置DAO组件 --&gt; &lt;bean id="returnuserdao" class="com.zwl.impl.returnuserdaoimpl"&gt; &lt;property name="hibernateTemplate"&gt; &lt;ref bean="hibernateTemplate"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置业务逻辑组件 --&gt; &lt;bean id="returnuserservice" class="com.zwl.impl.returnuserserviceimpl"&gt; &lt;property name="userdao"&gt; &lt;ref bean="returnuserdao"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置userdengluAction --&gt; &lt;bean id="userreturn" class="com.zwl.action.userreturn"&gt; &lt;property name="returnuser"&gt; &lt;ref bean="returnuserservice"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; pojo类（与数据库映射那个类） 123456public class User &#123; private int id; private String name; private String password;省略set与get方法。。&#125; 映射文件 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.zwl.pojo"&gt; &lt;class name="User" table="user" &gt; &lt;id name="id" &gt; &lt;generator class="increment"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="name"&gt; &lt;/property&gt; &lt;property name="password"&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 接口接下来就是接口编写 dao层1234public interface returnuserdao &#123;//通过id返回Userpublic User returnuserbyid(int id);&#125; service层 123public interface returnuserservice &#123;public User returnuser(int id); &#125; 分别得实现类 1234567891011121314151617181920212223242526public class returnuserdaoimpl extends HibernateDaoSupport implements returnuserdao &#123; @Override public User returnuserbyid(int id) &#123; List list=this.getHibernateTemplate().find(" from User user where user.id = '" + id + "'"); if(list.size()==0)&#123; return null; &#125;else&#123; return (User)list.get(0); &#125; &#125;&#125;public class returnuserserviceimpl implements returnuserservice&#123; private returnuserdao userdao; public returnuserdao getUserdao() &#123; return userdao; &#125; public void setUserdao(returnuserdao userdao) &#123; this.userdao = userdao; &#125; @Override public User returnuser(int id) &#123; // TODO Auto-generated method stub return userdao.returnuserbyid(id); &#125;&#125; 这里只有两个页面，一个只有二维码，另一个是扫描后跳转的页面并且可以从数据库中取出相关信息 1234567891011121314151617181920212223242526272829303132333435 &lt;figure&gt;&lt;figcaption&gt;图书1扫码:&lt;/figcaption&gt;&lt;img src="img/dl.gif"&gt;你本地生成的二维码图片&lt;/figure&gt;``` 接下来是通过ajax从后台异步加载数据，当然是在你扫码后，直接将数据显示在表单中``` stylus &lt;script type="text/javascript"&gt; $(function()&#123; /* 通过ajax异步提交表单 */$.ajax(&#123; /* 提交路径 */ url : '$&#123;pageContext.request.contextPath&#125;/userreturn!userreturn.action', data:params, type:"POST", dataType:"json", /* 提交成功后，并得到后台返回的数据 */ success : function(r) &#123; /* 解析后台json格式，并得到对象 */ $("#id").val(r.id); $("#name").val(r.name); $("#password").val(r.password);&#125;&#125;); &#125;); &lt;/script&gt; &lt;body&gt; &lt;form action="" method="post"&gt; id :&amp;nbsp;&lt;input id="id" name="id" type="text"/&gt;&lt;br/&gt; name :&amp;nbsp;&lt;input id="name" name="name" type="text"/&gt;&lt;br/&gt; password :&amp;nbsp;&lt;input id="password" name="password" type="text"/&gt;&lt;br/&gt; &lt;/form&gt; &lt;/body&gt; Action类接下来就是action的编写首先是 QRCodeAction 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class QRCodeAction extends ActionSupport &#123; private static final long serialVersionUID = 1L; // 封装上传文件域的属性 private File image; // 封装上传文件类型的属性 private String imageContentType; // 封装上传文件名的属性 private String imageFileName; private String message; private String content; 此处省略属性的set与get方法。。 /** * 生成二维码 * @return String * */ public String encoderQRCode()&#123; String realpath = ServletActionContext.getServletContext().getRealPath("/file"); SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss"); String imgName = sdf.format(new Date()) + ".png"; String imgPath= realpath+"/"+imgName; QRCode.encoderQRCode(content, imgPath, "png"); message = imgName; return Action.SUCCESS; &#125; /** * 获取二维码 * @return String * */ public String decoderQRCode() &#123; try &#123; String realpath = ServletActionContext.getServletContext().getRealPath("/img"); File savefile = new File(new File(realpath), imageFileName); if (!savefile.getParentFile().exists()) savefile.getParentFile().mkdirs(); FileUtils.copyFile(image, savefile); message = QRCode.decoderQRCode(realpath+"/"+imageFileName); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Action.SUCCESS; &#125; 然后是我们需要的userreturnaction（主要后台信息通过json格式传给前台） 1234567891011121314151617181920212223242526272829303132public class userreturn &#123; private returnuserservice returnuser; //通过用户id查询用户信息 private String img; //接受二维码图片的名字 省略set与get方法。。 //解析二维码，入库查询，并返回用户信息 public void userreturn() throws Exception &#123; HttpServletResponse response=ServletActionContext.getResponse(); HttpServletRequest request=ServletActionContext.getRequest(); response.setCharacterEncoding("UTF-8"); response.setContentType("application/json; charset=utf-8"); //返回json数据 response.setHeader("Cache-Control", "no-cache"); //不要缓存 response.setHeader("Pragma", "no-cache"); PrintWriter out = response.getWriter(); System.out.println("被扫描的二维码图片的名字:"+img); QRCode qrcode=new QRCode(); String path=qrcode.decoderQRCode("E:/newday/librarytest/WebRoot/img/"+img);//二维码图片地址 System.out.println("二维码解析的内容:"+path); int id=Integer.parseInt(path.substring(path.length()-1)); System.out.println("用户的id号:"+id); User user=returnuser.returnuser(id); System.out.println("用户的姓名:"+user.getName()); System.out.println("用户的密码:"+user.getPassword()); JsonObject json=new JsonObject(); json.addProperty("id", id); json.addProperty("name", user.getName()); json.addProperty("password", user.getPassword()); response.getWriter().write(json.toString()); &#125;&#125; 注意在页面中需要jquery-1.8.3.js包，同时此处json格式转换用的是gson.jar包最后就是struts.xml配置 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;&lt;constant name="struts.i18n.encoding" value="utf-8"/&gt;&lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt; &lt;constant name="struts.devMode" value="false" /&gt; &lt;constant name="struts.i18n.encoding" value="UTF-8"/&gt; &lt;constant name="struts.multipart.maxSize" value="10701096"/&gt;&lt;!-- 上传文件最大值 --&gt; &lt;constant name="struts.multipart.saveDir" value="/tmp"/&gt;&lt;!-- 上传文件设置属性 --&gt; &lt;constant name="struts.custom.i18n.resources" value="global" /&gt; &lt;constant name="struts.action.extension" value="action"&gt;&lt;/constant&gt; &lt;package namespace="/" name="struct2" extends="struts-default"&gt; &lt;action name="userreturn" class="userreturn" method="userreturn"&gt; &lt;/action&gt; &lt;/package&gt; &lt;package name="QRCode" extends="json-default"&gt; &lt;action name="qRCodeAction_*" class="com.zwl.action.QRCodeAction" method="&#123;1&#125;" &gt; &lt;result type="json"&gt; &lt;param name="root"&gt;message&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 最后打开含有二维码那个页面，然后扫一扫就可以跳转到含数据的界面，当然笔者之前遇到了几个问题，首先是图片地址在action中要正确，不然出现null，其次这是只能一个二维码并且含参数id的，只能有一个action，当然可以优化。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单例设计模式]]></title>
      <url>%2F2017%2F03%2F17%2Fdanli%2F</url>
      <content type="text"><![CDATA[前言在介绍单例设计模式之前，先简单介绍一下java的内存分析，可以帮助我们更好的了解相关内容。在此之前，先简单介绍几个相关概念 Stack（栈）存放基本数据类型的数据和对象的引用及存放变量，如果存放的是基本数据类型（非static），直接将变量名和值存入stack中，如果是引用，只将变量名存入栈，然后指向它new的对象（存放在堆中） Heap（堆）存放new产生的数据 静态域存放在对象中用static定义的静态成员（基本类型） 常量池存放所有数据 案例下面将模拟几个实例先说明在证明。（此外注意String不是基本数据类型）上面给出了一个实例，意在了解内存分配，接下来将以String为例说明 12345678String str="abc";String str1="abc";String str2=str;String str3=new String("abc");String str4=new String("abc");String str5=str3;static String str6="abc";static String str7=new String("abc"); 对应的测试内存地址是否相等 123 System.out.println(str==str1);System.out.println(str==str2);System.out.println(str1==str2); 测试结果 true true true说明String 是引用类型，而且上面方法产生的变量都只在栈中并且都是同一个地址 12 System.out.println(str==str3);System.out.println(str3==str4); 测试结果：false false说明：new 之后的对象地址存放在堆中，同时堆中每个new之后的对象地址都是不一样的 1234 System.out.println(str==str6);System.out.println(str3==str6);System.out.println(str6==str7);System.out.println(str3==str7); 测试结果：true false false false说明：String类型的静态变量存放在栈中，而new之后的静态变量存放在堆中 关于内存分配，比较复杂，这里只简单验证其中一些，其他可以自己设计案例模拟 单例顾名思义就是指唯一的对象实例具体点说就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例只存在一个，通常其结构如下所示。入门案例：首先是单例类 1234567891011package com.zwl.pojo;public class Singleton &#123; private static Singleton singleton=new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 测试用junit4进行测试 12345678@Testpublic void test1()&#123; System.out.println("start test.."); Singleton obj1=Singleton.getInstance(); Singleton obj2=Singleton.getInstance(); System.out.println(obj1==obj2); System.out.println("end test..");&#125; 测试结果：start test.. true end test..说明，obj1与obj2是同一个实例，间接说明了单例的特性 至此我们对单例有了一个初步的形式上的认识了，那么它的特点是什么了？主要为三点一：单例类确保自己只有一个实例（构造函数私有：不被外部实例化，也不被继承）二：单例类必须自己创建自己的实例三：单例类必须为其他对象提供唯一的实例 说到单例就必然涉及到多线程，不多说，先模拟一个多线程来说明单例中存在的并发问题。友情提醒一下，上面用的是饿汉式创建单例，就一开始就创建了一个实例，显然浪费内存，接下来将用懒汉式创建单例主体类代码： 1234567891011private static Singleton singleton; private Singleton()&#123; &#125; public static Singleton getInstance() &#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; return singleton; &#125; 下面将用三个线程模拟，两个线程调用单例类，第三个线程启动前两个线程，测试用junit 123456789101112131415161718192021222324public class thread1 implements Runnable&#123; Singleton singleton; public Singleton getSingleton() &#123; return singleton; &#125; public void setSingleton(Singleton singleton) &#123; this.singleton = singleton; &#125; @Override public void run() &#123; singleton=Singleton.getInstance(); &#125;&#125; public class Thread2 implements Runnable&#123; Singleton singleton; public Singleton getSingleton() &#123; return singleton; &#125; public void setSingleton(Singleton singleton) &#123; this.singleton = singleton; &#125; @Override public void run() &#123; singleton=Singleton.getInstance(); &#125;&#125; 简单说明一下，这两个线程目的是调用单例类（注意如果是单例，决不允许出现不同实例）先贴出测试类： 123 thread3 t=new thread3();Thread tt=new Thread(t);tt.start(); 这里我们通过控制第三个线程来构造并发，(这里采用数学中的极限思想) 123456789101112131415public class thread3 implements Runnable&#123; thread1 t1=new thread1(); Thread2 t2=new Thread2(); Thread t=new Thread(t1); Thread t3=new Thread(t2); @Override public void run() &#123; long start=System.currentTimeMillis(); t.start(); t3.start(); long end=System.currentTimeMillis(); System.out.println(end-start); //并发的时间间隔 System.out.println(t1.getSingleton()); System.out.println(t2.getSingleton()); &#125; 测试结果：0 null null多次运行，又出现另一种结果：6com.zwl.pojo.Singleton@8fdcd1null和其他不同步结果说明在很短的时间间隔类，一个居然已经有了实例，而另一个居然是空，显然不是单例，想想倘若在此时去操作该单例，可能就会是静态类发生变化，也就是并发问题了。 很自然。那么怎么去解决了，一种很通用的方法就是加锁实现同步 双锁机制12345678910111213public static Singleton getInstance() &#123; if(singleton==null) &#123; synchronized(Singleton.class) &#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; &#125; &#125; return singleton; &#125; Synchronized关键字，声明使该线程在某处同步，也就是一个线程先占用，另一个线程被阻塞，显然如果不为空，就直接返回对象，对应第二个线程也就不执行if语句了，达到单例效果，可以想象如果为计数变量，同样可以通过二次加锁实现同步 但是实际还是出现不同步，原因是jvm的一个bug，它允许无序写入线程，导致不同步，当然我们可以通过申明volatile关键字。 为什么就可以解决双重解锁的bug了？原因是volatile保证原子性，顺序性，即在双重加锁前保证多线程实现顺序性，举个例子吧，现在有两个线程t1和t2，分别执行b，c操作，如果乱序写入，可能出现t1正在操作b还没完成，t2操作c，致使单例失败，所以需要保证顺序性。经过不断的测试，发现完全同步，只不过时间间隔为0，和null，null，至少是同步了~ 接下来简单比较一下饿汉式和懒汉式的区别从速度和反应时间上，饿汉式加载好，从资源利用率上懒汉式好，饿汉式很明显不会出现多线程并发问题，所以是线程安全的，而懒汉式则是非线程安全的 关于单例模式的应用，笔者在当初学习过程中，遇到很多，学习总是一个不断压缩与重新认识的过程，像sql工具类，hibernate的懒加载，mybatis及 spring中的一些配置等等，往往把握不好，就会出现错误，这里只列举一些工具类，因为它是笔者接触的第一个单例应用。 12345678910111213141516Private static Connection connection;Private sqlhelper()&#123;&#125;； public static Connection mysqlconn() throws Exception &#123; try &#123; // 加载驱动 Class.forName("com.mysql.jdbc.Driver"); // 连接数据库 connection = DriverManager.getConnection( "jdbc:mysql://localhost:3306/software", "root", ""); System.out.println("获得数据库"); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return connection; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用nat123搭建本地服务器]]></title>
      <url>%2F2017%2F03%2F17%2Fnat123%2F</url>
      <content type="text"><![CDATA[前言这是笔者去年第一次将web项目通过外网访问，当然结果很美好，过程很艰难，当时也是第一次用文档记录了探索过程，当然也是在google老师的帮助下，诚然学习最大的乐趣就是通过自己忘我的想尽一切办法最后solve的那种快感进入正题 1 因为要把服务器架在自己的机子上，所以可以选择花生壳和nat123，于是当时百度了一堆关于该技术，充其量只是了解了概念，然后修改tomcat配置文件，先将默认的8080端口改为100（按理讲应该改为80，之后注意中讲为什么），然后将root文件夹全部删掉，当然还有一部（但是我配置了只要一输入域名就是空白页，所以我舍弃了这一步）配置域名与tomcat项目的映射 1&lt;Context path="" debug="0" docBase="你项目的决定路径" reloadable="true"&gt;&lt;/Context&gt; 2 tomcat部分算是完成了，之后我选择了用nat123，建议去官网下载最新版本，注册，登录然后按照百度步骤，懒得写了就截个图吧 注意应用类型我们选80（http）网站，毕竟这是相对来说最佳选择，内网端口（默认可以写80）我选择了100（之后一定要打开和开放端口，后面再说），内网地址，命令行中输入ipconfig查看ip4就是内网，当然也可以用localhost等等（因为他们在tomcat配置，或者在c盘的一个文件中为他们设置了常量，百度就能找到c盘那个源码，tomcat不多说就在配置里面，很好找），其他配置不动，然后保存 这样就有了域名 在打开nav123客户端，出现笑脸，如图等表示映射正常， 然后下面才是最恐怖的地方了（出现各种问题） 1 如果你内网和tomcat选择的是80端口，注意80端口默认不打开的，先开启控制面板-系统与安全-windows防火墙-高级设置-入站规则-新建规则-端口-80-下一步。。-完成， 然后在用netstat –a看看有没有80端口，假设有了，然后以为顺利 了，结果点击客户端的设置，发现最上面出现无公网连接，也就是说内网的80端口不能映射外网，这下麻烦了，好吧，据需钻研解决方案。试着其中一个靠谱的，说路由器配置中没有开放外网，好吧 先在计算机中输入192.168.1.1（这是电信的），打开路由器（然后简单去了解了一下路由器）先开启dmz主机，指派一个特定内网ip（那个机子对外开放），然后 在虚拟服务中打开相应端口80（暂且不是100），然后自以为一切顺利，在点开客户端那个设置或打开命名行输入ipconfig，都显示自己的公网了，相当于一道闸门打开了，当然也找不出问题了，结果又出现将域名输入出现错误。 结果觉得可能是80端口被封（可是已经在客户端能做的范围内把80打开了，最好的解释是要去电信局备案，才能在服务器端解封80端口），也就是说，80端口我们用不了了） 居然一时用不了，就用其他端口吧，就100吧，把之前所有的80开放改为100，然后在打开网页（注意：tomcat没有配置项目初始化，自己指定），然后在用手机或者其他机子试一次，即域名+项目名，结果成功了，但是网速不行啊（又头疼了~~）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[window分区导致双系统无引导界面]]></title>
      <url>%2F2017%2F03%2F17%2Ffenqu%2F</url>
      <content type="text"><![CDATA[先简单介绍一下情境，笔者电脑上装的是双系统，而且bios上设置了system password（当然，已经忘记了是多少了），然后心血来潮在阿里云买了一个学生优惠的服务器，安装了mysql+tomcat7+jdk，在电脑上d盘已经装了linux，在c盘上分了一个分区，那么问题来了，当再次打开电脑时，无引导界面，取而代之的是 然后google了许多解决方案，当然是在彩果许多坑之后找到了适合自己的解决方案，毕竟一个问题的解决总不是一帆风顺的。 进入正题 如果我们要重装系统，肯定得用到bios设置，那么问题来了，如果你设置了密码，并且密码忘记了，那怎么办? 一种办法是通过硬件，通过把电池正负极按照网上说的折腾一下，就可以恢复bios出厂设置，显然这种方法有极大风险，可能会损坏硬件（具体参考google）或者用相关修复工具，但是笔者的电脑都无引导界面，尴尬了~ 还有一种办法就是在你输入3次错误的密码时会出现如下错误代码 然后就是在这里面设置，如下图，输入上述的错误代码，就出现了bios密码， 当然，笔者电脑里有许多宝贵的数据，不可能也不愿意重装系统，经过google一番，发现是分区导致引导盘不能引导，只需要找到该分区，在llinux上重新修复就行了 首先在页面中输入如下lsgrub rescue&gt; ls出现如下（基本都差不多）hd0，（hd0，nsdoc9），（hd0，nsdoc8），（hd0，nsdoc7），（hd0，nsdoc6），（hd0，nsdoc5），（hd0，nsdoc2），（hd0，nsdoc1） 然后通过ls 如上的分区循环一遍，如ls （hd0，nsdoc9）/上述有一个会出现详细信息，他就是安装linux那个分区，其余都是unknown filesystem，当然如果出现bad filesystem那是你没加/如下图： 接下来设置root引导盘 set root=(hd0，nsdoc6）这里设置的是上述找到分区的那个盘set prefix=(hd0，nsdoc6）/boot/grub/ 然后可以用set验证一下 set会出现上述设置的信息 最后执行下述命令 insmod normal在输入normal，就会自动跳转到引导界面，我们选择ubuntu进入，在里面进行修复即可 进入linux系统打开终端，先更新grub，即输入 sudo update-grub ok后在输入 sudo grub-install /dev/sda结束后，我们就可以重启电脑，一切都ok了。进入电脑后笔者做的第一件事就是备份数据，毕竟要给自己留条后路，如果遇到更复杂的情况就后悔莫及了。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阿里云服务器上搭建javaweb站点]]></title>
      <url>%2F2017%2F03%2F16%2Fdajianserver%2F</url>
      <content type="text"><![CDATA[事实上笔者在去年8月份的时候就已经在自己电脑上通过nat123搭建了一台服务器，即p2p，自己的电脑作为服务器，但是这很不安全，而且每次别人通过外网访问，电脑必须打开而且开着服务器，由于是免费的，导致别人访问网速跟不上等等，最近阿里云有学生9.9元购买服务器，所以笔者买了一个，也很有兴趣将笔者之前写的两个网站部署上，结果很美好，但过程很坑，所以就需要总结来提高自己进入正题笔者也是google了许多例子和前人的经验找到适合自己的方法 首先需要租一台云服务器，我选择了阿里云 注意这里操作系统有四个选项，笔者发现只有第四个符合自己（貌似是自定义），然后按照步骤，其中有些需要注意 安全组，这里暂时可以选择默认的第一个，因为后面如果在搭建web时需要一些端口（如mysql默认3306端口改掉，tomcat8080端口换成80等等），到时可以在后台操作） 关于镜像选择，因为笔者是window7，而且还是32位的，相对64位只能有不大于4g的内存， 这里的密码就是之后在本地机子上远程登录这个服务器所要的密码 ok至此，成功租了一台服务器，这时你会收到一条短信，里面有你这台服务器的公网地址 然后笔者就开始着手在本机上登录该服务器，当然是为了搭建javaweb准备的 在本机上准备javaweb需要的环境 在本机上新建一个分区用来放上述软件供服务器远程使用（其实也可以不用分区，直接复制也行，毕竟笔者被分区坑了，导致后来的双系统引导界面消失） 本机上登录远程连接可以用运行-mstsc-直接进入到如下界面其中计算机就是你的公网地址，如果你是新建了一个分区，那么就点选项在本地资源的详细信息中就新建的那个分区勾上，笔者这里是x盘（如果没有的话就直接连接） 后面什么证书，安全啊先不管了，应该是进入远程服务器了 接下来就是将mysql，jdk等复制到c盘中，因为只有一个盘，后续就是安装配置了 安装jdk，笔者的是jdk1.6（注意jdk版本不同，后续运行高版本会出像版本错误，笔者已吃过亏），配置环境变量 安装tomcat，配置tomcat环境变量，注意上述不需要自定义文件夹，因为只有一个c盘，tomcat默认端口是8080 安装mysql，这里面需要注意的是里面有端口设置，可以选择默认的3306或者自定义，然后就是用户与密码设置 可以使用可视化数据库工具，这里笔者使用了navicat至此算是搭建了一个简单web环境，可以先测试一下拷贝一个已经被编译过的web项目，启动tomcat与mysql，然后利用localhost:8080/项目名访问，如果出现界面就表示以上配置成功 接下来需要买一个域名 成功后点击解析，在里面找到新手设置，点进去点击设置网站解析，然后输入公网，即可。 在远程服务器中，找到tomcat下conf下的server.xml文件，如果我们不想要8080端口并且输入域名时不想要端口的话，就先把8080端口改成80 Connector port=”80” protocol=”HTTP/1.1” connectionTimeout=”20000” redirectPort=”8443” /&gt; 3.然后找到host Host name=”你刚刚解析的域名” appBase=”webapp” unpackWARs=”true” autoDeploy=”true”&gt; &lt;Context path=”” docBase=”/项目名” debug=”0” reloadable=”true” 注意这里appBase是放项目的站点，context内的docBase是你的项目名，目前我们只是一个tomcat运行一个域名执行一个项目然后打开C:\Windows\System32\drivers\etc下的host文件增加如下设置 127.0.0.1 localhost ::1 localhost192.168.1.11 刚刚的域名 保存，然后重启服务器，可能会发现会遇到一些问题，如80端口被占用，80端口未开放等等，假设未被占有（如果占用，google上有解决方法），如果未开放，这里我们就需要在云服务器上进行端口开放设置 进入我们购买的云服务器，点击安全组，选中一个实例，点击配置，选择公网入方向，按照步骤开放想要的端口 至此只要输入域名就可以访问了。 当然，如果我们想要一个tomcat上配置多个域名，每个域名运行各自不同的项目，那如何做了，经过踩坑后，大概如下步骤 可以选择在tomcat下新建一个站点，类似于原来的webapp，然后在server.xml中进行配置一个新host Host name=”第二个域名” appBase=”新创建的站点” unpackWARs=”true” autoDeploy=”true”&gt; &lt;Context path=”” docBase=”/第二个项目名” debug=”0” reloadable=”true” 2.然后在hosts文件汇总加入第二个域名 127.0.0.1 localhost ::1 localhost192.168.1.11 刚刚的域名192.168.1.11 第二个域名 最后重启服务器。笔者在这里遇到了一个很奇怪的坑，同一服务器下的项目出现奇怪的jar包冲突，只要删掉xerces包就行了（当然是在远程服务器上才产生冲突的）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初步搭建hexo博客]]></title>
      <url>%2F2017%2F03%2F12%2Fhexo1%2F</url>
      <content type="text"><![CDATA[博客是一种能够更好提高自己的途径，关于利用hexo搭建博客，笔者是一路google一路踩坑，才完成的，当然关于这方面的搭建，实在太多了，笔者也只是稍微总结一下 首先在github上注册一个账号 创建代码库（repository），一般以yourname/youname.github.io setting中选择主题 购买一个域名（这里以笔者在阿里云买的为例） 点击域名里的解析注意CNAME为你的仓库名，其他套用6.回到setting中在Custom domain下填写你刚才的域名，然后在code中会出现一个CNAME文件7.yourname.gthub.io访问你的博客，目前应该只是一个默认主页 接下来就是本地安装hexo与github page联系起来 1.官网安装node.js（注意是32位还是64位） 2安装git（在过程中会有一项自带环境变量设置，选中，不然后面无法识别git） 3安装hexo（以笔者的在e:/blog下为例） 在git bush中 1npm install hexo-cli -g 然后在输入 1npm install hexo --save 然后利用 hexo -v 验证安装是否成功 4.然后在要创建的目录下初始化hexo hexo init 5安装所需的组件和依赖组件 npm install 笔者当时一下子全部安装了很多扩展组件如: npm install hexo-deployer-git –save 在看看目录下应该产生如下目录 6 生成静态文件 hexo g 7 启动服务器，进行本地预览访问 hexo s 然后在浏览器中打开http://localhost:4000/，会出现一个默认的hexo主页 8 Hexo与github page 联系首先是配置Git个人信息 git config –global user.name “用户名”git config –global user.email “邮箱地址” 9 生成密钥 sh-keygen -t rsa -C “邮箱地址” 这里笔者遇到一个坑，默认是在administrator目录下生成一个.ssh文件夹里面包含结果没有，所以自己在该目录下创建一个.ssh文件夹 10 配置Deployment（以笔者的为例） deploy: type: gitrepository: http://github.com/slycmiaoxi/slycmiaoxi.github.io.gitbranch: master 这里的repository是git上对应的use ssh进行clone的 11 登录到git的use ssh将.ssh文件下的id_rsa.pub里的内容复制到改里面 12 写文章上传 hexo new post “article title” 新建一个文章，默认放再_post下 hexo clean 清空public里的文件，该文件夹是上传到git上 hexo g 生成到public文件夹中 hexo d 部署，此过程要输入用户名和密码， 笔者在hexo d过程中曾出现一致无权限，后来在google老师的指引下需要设置用户名和密码，在.ssh文件下生成known_hosts文件，如果没有遇到，那是比较幸运了 目前还是默认的主题，显然不好看，其次编写文章需要markdown语言，笔者使用的是小书匠，因为其组件丰富，操作简单 13 更换主题 首先需要cd到你的hexo根目录，然后 git clone https://github.com/iissnan/hexo-theme-next themes/next 我选择的是next主题，因为其功能，配置方面相对较强大，当然在主题配置方面一路是坑，这里推荐去next官网看配置，大部分都涉及到 如果我们启用next主题，只要在_config.yml（站配置文件中）找到theme，将默认的改成next即可， 另一方面，在theme文件夹下的next文件夹下的_config.yml(主题配置文件）进行主题的配置，当然里面其他文件也是可以配置的，当然google是最好的帮手 最后主题也配置好了，只需要输入yourname.github.io就可以访问你的博客了 当然笔者是一路踩坑过来，很多google也不一定适合自己，只有自己探索过的才是最适合自己的。 最后需要说一下，多说老是注册异常，后来干脆选择友言代替，总之theme里面有很多需要探索的，google是最好的老师]]></content>
    </entry>

    
  
  
</search>
