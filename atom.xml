<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2018-03-16T01:50:14.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>系统V1.0简单说明</title>
    <link href="http://www.myzwl.win/2018/03/10/sys_1/"/>
    <id>http://www.myzwl.win/2018/03/10/sys_1/</id>
    <published>2018-03-10T07:48:51.000Z</published>
    <updated>2018-03-16T01:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>该系统很不完善，由于一个人的精力和时间有限，有很多考虑不周到的地方，很多地方算法复杂度高，模块耦合性高，部分设计模式设计不合理，代码规范不达标等等请谅解</p>
<h4 id="系统部分"><a href="#系统部分" class="headerlink" title="系统部分"></a>系统部分</h4><p>其次自己租了11台linux服务器，内存1G以上有6台，以下是之前的架构，由于时间关系，展示如下<br>系统架构(旧)<br><img src="/images/imgs6/1.png" alt="Alt text"><br>所用技术栈(旧)<br><img src="/images/imgs6/2.png" alt="Alt text"><br>系统部分说明(旧)<br><img src="/images/imgs6/1.jpg" alt="Alt text"></p>
<h4 id="困难与解决"><a href="#困难与解决" class="headerlink" title="困难与解决"></a>困难与解决</h4><p><strong>1.留言板的数据存储如何存储与取出算法实现</strong><br>按照自己之前的经验，一个人写一条留言就记录下，然后就是垂直式的记录，很明显存在很多问题<br><img src="/images/imgs6/2.jpg" alt="Alt text"><br>解决方法 :<br>将问题抽象成伪B树数据结构，节点数以固定，不需要记录<br><img src="/images/imgs6/3.png" alt="Alt text"><br>很明显这样嵌套下去，深度非常大，就是一颗斜二叉树，还有就是留言板目前最多需要楼中楼加上前端写不出来，所以深度固定为2并且最后一层放在一个栈里（按照时间排序）</p>
<p>如何有效率的取出数据?<br>按照首先的想法（sql不是很好，所以按照笨方法来考虑），因为这里记录的是结点，而最后需要的是用户名等信息，也就是说还需要查数据库转换(如果加个相关字段除外),<br>也就是遍历到所有结点o(n)，然后每个结点查数据库转换为相关信息o（n），而且查数据库的字段保存的内存也大，还要查数据库n次，所以如果数据量极大，效率很不高</p>
<p>解决办法:<br> 干脆就遍历一次，将遍历的结果只要用户名和id，然后放在一张哈希表中，然后分成两块，一块是得到所有顶层父节点集合，另一层是所有的孩子结点，然后构造一个栈，通过父节点找到其下所有孩子节点，放到栈中，然后将栈放到一个集合中，循环遍历放入，最后只要把这个集合交给前台就好了</p>
<p><strong>2. 如何实时显示在线登录人数?</strong><br>首先怎么才算登录人数，一般规定用户登录后才算，但是登陆后会出现几种情况，用户主动退出登录，长时间不点击和主动关闭浏览器都会导致会话失效，另外并发登录人数限制和管理员在线踢出用户都会影响登录人数<br>而一般的做法就是写个servlet会话监听器去监听登录，当有会话建立时并且已经成功登录和先判断该用户是否已经正在线，统计相关信息，然后就是退出浏览器只能等会话失效才算离线。用这种方法去做，简单，但是实时效果不是太好但是发现我得session是用shiro管理的，大部分应用离不开shiro，而且shiro的sessionId每次是不一样的，也就是说，同一用户登录，在缓存中通过用户名产生的会话id不一样，造成同一用户登录重新登录会变成不同用户而在线人数不对。<br>而另一种更好并且统计更准确的是利用redis缓存信息（遇到了瓶颈，也是这个sessionId每次不一样，但是如果把shiro换掉或者做成分布式可以解决），大概是这样的想法，现在redis中放两组key，根据需求一组存放登陆用户的SessionId与ClientUser的Json数据，另一组存放存放登录用户的UID与SessionId对于的数据，然后利用该监听器，，只要一有会话差生，就从redis登记表（封装各类实时统计的方法）中查看，以一定规则查看是否登录，这里可以判断是游客还是会员，然后记录相关登记信息等等，放在session中，这种统计方法更实时，统计内容更多，但是因为shiro的问题，最终统计很不准确，因为这个sessionId还必须是准确才行<br>解决办法：<br>干脆就用shiro的缓存来统计，得解决这个并发登录人数控制。Shiro是这样做的，规定同一账号最大会话数，实际上是放在一个缓存队列中，如果其大小超过该会话数，就踢出头或尾会话，在加入该会话，然后就是这个缓存队列是通过ehcache中命名用户名设置的，然后将其放在shiro拦截器，放在登录请求中，这是如果有会话被提出，但是本地缓存sessionDAO中任然有那个被踢掉的缓存，需要个监听器根据那个用户名得到sessionId然后踢掉，缓存同步。<br>还有一个就是强制用户退出，就是根据sessionId让session失效，logout就行了。<br>最后就是实时统计在线列表了，这里比较棘手的就是的就是那个强制退出的会话怎么清除，如果不清除，缓存中会得到空指针，最头疼的是服务器崩溃，利用缓存中的方法可以得到所有活跃的会话，包括失效的，然后就是通过异常，测试居然可以通过，得到失效的会话，然后就是通过sessionid判断，更新缓存，删掉那个失效的会话，最后就是活跃的会话了，而关闭浏览器通过缩短会话存活时间保证，主动退出和会话正常死亡通过监听器解决<br>最后就是复杂度太高导致效率低下，不能完全模拟实时统计，可以用心跳方式解决</p>
<p><strong>3. 如何高效率执行并发在线编程?</strong><br>这个最终的解决办法并不是很好，但是探索的过程总是充满乐趣.<br>首先要解决的问题是怎么才能实现在线编程，参考了jdk的动态代理。大概就是将代码变成字符串，然后拿到当前编译器进行编译，最后将编译的结果输出即可。如果不加以控制的话，最后如果并发量大的话，同时写入和读出造成错误，同时如何保证编译更有效。<br>首先就是解决并发问题，首先使用lock写锁，控制。假设是单线程执行，一个用户写完还必须按照时间等待，并发量高效率很低。很自然想到线程池，封装一个线程池工具类，创建一个编译线程任务类，然后就是按照线程创建时间创建不同的文件夹，每个文件夹来自不同的用户线程，这样就解决了记录问题，剩下就是怎么保证每个用户都知道自己执行哪个编译线程，然后拿到对应的编译结果（在这里遇到了瓶颈）<br><img src="/images/imgs6/4.png" alt="Alt text"></p>
<p>最终是可以并行执行编译，而不是串行等待，但是编译的结果随机发给了等待的用户，当然可以直接用synchronized控制同步，但是代价和执行效果就不怎么好了。</p>
<p>解决办法<br>最后直接用synchronized控制同步，也就没有必要使用线程池了，只要保证不同用户编译和返回的结果是正确就行了，最后将该功能做出微服务，利用dubbo管理，这样尽可能降低并发带来的性能问题</p>
<p><strong>4. 如何实现算法建模和保证数据高效回显？</strong><br><img src="/images/imgs6/3.jpg" alt="Alt text"><br>该表依赖于算法类型表，核心是func_index。而存储redis需要两个key，一个是该对象序列化存储，选择list类型存储，以索引作为信息搜索。另一个是该类型与一个字符串（记录算法类型）类型组合成一个新对象,选择string类型存储</p>
<p>大概的入库的流程是，通过时间随机生成索引，一定不重复，然后先入本地数据库，而那个pkId就是通过存入redis库的那个list类型key取得长度+1，不存在则为0，这样解决了pkId重复问题，接下来先存储list类型key，然后存储那个String，按照一定规则转换<br>而取出算法时，也是先从redis中取出，异常走本地数据库，而取出时，先将那个String转换为对象，按照索引’取出符合要求的<br>遇到的问题：<br>业务过于复杂，各种存入redis数据存储和取出出现异常，每个特定的算法建模太耗内存</p>
<p>解决办法：<br>将算法建模做成微服务，算法信息存储通过redis主从复制，解决加载慢问题，同时算法运行计算在不同机器执行，通过集群解决并发量大问题</p>
<p><strong>5.如何细粒度的控制url，保证游客也能访问而又安全？</strong><br>事实上shiro已经通过身份角色进行安全控制，而这里需要的是一个通用url除了最后确定信息加密不一样外，其余都差不多，并且可以权限控制。<br>     大概的想法是：首先建立两个枚举类，一个是记录目前存在可以注入的加密算法名称，另一个是记录需要加密的页面名称（知识为了记录，事实上用不到），然后是一个简单工厂类，根据通过加密的索引号，返回枚举类中相应的加密算法名，然后就是一个加密模板类，该类中的加密索引号在spring中注入，反射路径是封装的加密类<br>   接下来，利用反射动态得到该加密类，然后通过索引号在简单工厂中得到加密算法名称，最后反射类循环方法，一旦相等，执行该方法，最后得到加密解密后的字符串，<br>   最后来一个页面跳转中转站，通过传入jsp文件的分支和名称进行跳转，可以内部转发或者重定向。这样一方面就可以通过改url，控制游客登录后台，而又得不到相关信息，进行细粒度控制<br>   遇到的棘手问题:<br>因为有些加密算法是需要密钥的，而每次随机生成，必须同一对象才能解密，但是解密的时候就不是之前那个对象了，所以有需要密钥的都不能解密<br>解决办法:<br>选择其中不需要密钥并且是对称加密的算法</p>
<p><strong>6..业务逻辑重复代码太多，如何合理解耦?</strong><br>首先对于实体类规定一个base类，所有实体必须继承它。主要有两个原因，<br>第一个就是为了业务层解耦，只要传入这个base类就行<br>第二个根据需要加入相关字段，而不要重写包装类<br>然后业务层一个基础业务类，抽象共同方法<br>然后抽象出一个含分页信息的工具类，里面规定传入继承基础类的类，返回分页后的集合信息，同时统一设置了保存在request域中的信息，</p>
<p><strong>7.论坛核心表如何设计?</strong><br>  如果放在一张表里，控制起来很复杂，所以干脆设置成三张表<br>  即文章表、评论表和楼中楼表<br>并且文章表必须包含用户id，评论表包含文章id，用户id，被回复者id，楼中楼包含那三个和评论id，这样就可以精确的进行记录了。然后就是给文章表设置一个状态值，用于标识普通帖、精贴等，在取出的时候通过规定的业务关系取出数据。同时相关文章数据要同步到es服务器索引库进行搜索查询<br>遇到的困难：<br>业务过于复杂，需要考虑各种细节关系和各种可能的情况，同时前端弄不出来<br>解决方法：<br>按照算法的思想，各个击破，尽可能考虑每种情况，同时寻找第三方优秀模板</p>
<p><strong>8. 其他非业务的简单实现</strong><br>   1.利用拦截器在登录请求出进行黑名单判断和日志统计<br>   2.利用activeMQ将推送的消息放入到队列中，并且实时发送到有初始化webSocket的页面<br>   3.文章访问量统计按照ip和用户的访问表进行登记判断，以一天为准，凌晨自动清空访问表，并且访问量记录在文章表中</p>
<h4 id="最后说明"><a href="#最后说明" class="headerlink" title="最后说明"></a>最后说明</h4><p>感谢您的阅读</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;该系统很不完善，由于一个人的精力和时间有限，有很多考虑不周到的地方，很多地方算法复杂度高，模块耦合性高，部分设计模式设计不合理，代码规范不达
    
    </summary>
    
      <category term="毕业设计" scheme="http://www.myzwl.win/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="毕业设计" scheme="http://www.myzwl.win/source/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>我的大学自学java体系二</title>
    <link href="http://www.myzwl.win/2017/12/31/study_02/"/>
    <id>http://www.myzwl.win/2017/12/31/study_02/</id>
    <published>2017-12-31T06:48:51.000Z</published>
    <updated>2018-03-15T15:40:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束，趁着今年最后一天把大学学的关于java方面的知识总结一下，一方面是解放自己释放压力，另一方面激励自己尽快找到实习，稳定生活和压力</p>
<p><img src="/images/imgs5/1.svg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束，趁着今年最后一天把大学学的关于java方面的知识总结一下，一方面
    
    </summary>
    
      <category term="个人感想" scheme="http://www.myzwl.win/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="学习总结" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的大学自学java体系一</title>
    <link href="http://www.myzwl.win/2017/12/30/study_01/"/>
    <id>http://www.myzwl.win/2017/12/30/study_01/</id>
    <published>2017-12-30T06:48:51.000Z</published>
    <updated>2018-03-15T14:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束。<br>回顾这三年多生活，大学前一年基本迷迷茫茫，太多的课程，让人不知道如何去选择一个方向学习，基本很迷茫，有一次为了表示对物理的尊敬和兴趣，特地网上买了物理上下答案，晚上或者周末一有时间就去自习室刷题，刷完一本后，突然发现除了内心的满足感，到现在再也没碰过物理了，从上中学开始就一直对数学情由独钟，也因此错过很多很多机会和干过很多愚蠢的事，自己当时心里就想着干自己喜欢的事，于是乎，除了几门极个别的课，基本上全在研究数学，看大学老师录的数学视频，刷奥数题，上头时为了手写和推出一元三次和四次方程的含复根求根公式，连续好几天乐此不疲，然后一次很重要的人生考试被自己的糊涂和幼稚错过了（除了那两张象征荣誉的奥数证书，后来已经撕了，现在觉得当时太傻，太傻，太傻，也成为了自己的一个警醒），后来大学填报专业时，第一志愿写了数学专业，家里也希望当个数学老师算了，后来阴差阳错的调剂到软件工程专业，慢慢的，慢慢地也就淡忘了对数学的热情。大学里，也迷茫过，包夜上网玩游戏已达上百次，也是因为兴趣上头，后来想想身体健康才是最主要的，娱乐要有度。<br>大学真正开始学习是从c、c++开始，当时第一次接触c语言，真的很兴奋，基本上就一直做数学程序题，后来接触了c++，用vc6.0做mfc程序，然后就是一直对着c++ primer plus学习，当时也算是有了一个目标。后来，也是改变了我的学习方向的一个时间，到现在都记忆犹新。有一次室友有事，让我代替他上一节php公选课（时间2015-10-20），第一次接触web，服务器，突然发现这才是自己喜欢做的，自己被深深的震撼到了，当时他也布置了一个任务，做一个简单的网页含后台，回去后，就像发现新大陆一样，通过百度搭建了php环境和wampserver服务器，然后就是着了迷一样的弄，几天后弄出来了一个个人主页网站<br><img src="/images/imgs5/33.jpg" alt="Alt text"><br><img src="/images/imgs5/34.jpg" alt="Alt text"></p>
<p>突然之间感觉自己有了学习兴趣和方向，像着了迷一样的学习。后来2016年初做的几次兼职深深的意识到了，学习比干苦力看重眼前利益有用些，后来听说了java（学校是在2016年10月才开设的唯一一门java基础课，后续没了java相关了），开始一脚踏进了深深的深渊，开始疯狂的自学中至今</p>
<h4 id="感谢韩顺平老师"><a href="#感谢韩顺平老师" class="headerlink" title="感谢韩顺平老师"></a>感谢韩顺平老师</h4><p>刚开始在图书馆借了一本<21天学通java>,因为之前有c和数据结构等基础，所以学习起来也轻松，没几天就看完和动手码完了<br>，后来无意中接触了java吧，看到了传播智客韩顺平老师的视频分享，于是一口气下完了，不得不说韩老师是我的java启蒙老师，也很荣幸他的视频讲的很细致，每集时间很长，他的视频我连续花了四个多月才消化完，其中java se搞了两个月（到现在仍然觉得java基础仍不足），而每天像打了鸡血一样，一天真的12小时以上，哪也不去，就是对着电脑先仔细听他说完一级，然后看着笔记认真动手操作每一集的每一个代码（当时，真的不复制，就是自己从头敲到尾，遇到卡住的，回头再看视频回顾细节），然后按照自己的想法把它的功能改成自己的，一直都记着韩老师的一句话（把别人的知识通过自己的语言描述出来就是自己的知识，一定要实践），记得三月底的一次运动会，宿舍人要么回家了，要么出去玩了。当时自己选择留在宿舍学习(也就是为了完成韩顺平老师的项目)，就这样连续五天在各种情形下度过了，也许当时会感觉很孤独，但是总觉得在一个目标和兴趣下，一切都是那么充实。每天晚上，总会在睡觉前在手机上观看韩顺平老师的笔记到一两年，就这样早上7点起来，晚上2点睡，持续了大半年。这期间（现在想来）有些技术踩坑了，比如swing当时要求自己手写所有的，很认真的花很多时间学习struts1.xml四种解析情况自己手写模拟（现在忘光了），而最多最多的就是自己踩坑，抗压学习，遇到问题，然后通过耐心的百度，谷歌解决，每个学习的知识和技能都要转化为自己的语言应用，哪怕花时间去网站上找相关辅助代码，一定要还原真实情况。正是这段时间的学习，让我对软件开发有一个很深很深的认识，唯一的代价就是失眠和孤独。后来在四月初，数据库老师布置了一个任务，让我们做一个的数据库课程设计，事实上就不说了，后来也许是兴趣或者正好可以用上，自己花了一个星期（事实上每天就睡4,5个小时）自己一行一行的敲，做了一个基于swing的宿舍管理系统，这是自己第一次进行设计和编码，不知道当时拿给老师是有多兴奋~，后来老师说功能写的可以，就是太乱。当时也不懂软件工程，于是回去后又花了一个星期改了一个基于socket的宿舍管理系统，也许是当时太想把网络知识应用上，后来老师说我回去得看看软件工程。后来发现的确，盲目编码很不规范，然后当时就有一个心愿写一个网站的宿舍系统，而当时也是参考了韩老师的学生管理系统，又是一个月的努力，在五月份的时候，第一次写了一个基于纯servlet和mvc模式的宿舍系统，当时也许是太单纯了，自己拿了四张A4纸把每个类和流程都手写出来，然后去验收，然后向同学借了几台电脑去验收，也许是老师看我太认真了，说了一句（学校没几个像你这样的，然后让我帮她帮一个学校做一个网站），当时因为着迷技术，推掉了（直到2017年2月帮做另一个项目，已完成），后来也许就是这句话，自己越学越有劲，总之韩顺平老师的课程帮助了我许多许多</21天学通java></p>
<h4 id="那些充实的日子"><a href="#那些充实的日子" class="headerlink" title="那些充实的日子"></a>那些充实的日子</h4><p>后来6月初，有个达内来的ios七天校内实训，然后做一个tom猫小程序。当时，真的很兴奋，从一开始就抱着不学ios，自己做一个基于web的tom动画程序，然后后来就各种jsdom做了一个，后来演示时，他直接说我私底下给他看了过了（贼笑），期间也和他聊了聊，从java se聊到ssh和自己的项目，他说我这样可以去实习和然后工作了，当时，仍然以兴趣和沉迷技术，根本没有想那么多（现在后悔了，早点实习，早点有工作经验真的很有益，而且有明确的学习方向）。学完韩顺平老师的以后，也陆续发现还有许多优秀的讲师，像马士兵老师，于是以同样的方式学习，突然发现马老师，彻底改变了我的学习方式，而且他的课程讲的很深，像jdk源码，设计模式等等，总之马士兵老师的视频将近花了三个多月，也是收获最多的，在16年五月初的时候自己就有种打算写一个个人博客，于是乎花了将近两个月时间，写了第一个基于s2sh的个人博客，过程就不说了，也第一次接触到了外网访问，当时用的是nat123，将服务器架在自己电脑上，而且刚上限就被黑客黑了，自己机子成了肉鸡（贼笑），后来也许是自己太得意和想摆脱孤独，发在了空间，第一次感受到了温暖<br>当然，代价是很严重的，就是自己的精神很萎靡和严重缺少睡眠和每天都失眠，基本就是宅在房里，没有交流<br>再到后来，陆陆续续不断学习李炎灰老师的前端体系，easy ui创始人的视频（这个帮助真大），北风网的优秀视频，黑马东哥视频，和java123视频，最终以一个课程设计猎图网（按照软件工程编写文档）而结束了2016年的学习。<br>回忆起来，这一年真的很充实和苦有所得</p>
<h4 id="持久以恒"><a href="#持久以恒" class="headerlink" title="持久以恒"></a>持久以恒</h4><p>2017年开始，自己就开始写博客来记录学习和知识，早在2015年3月，自己建了一个c++群，不过里面人很少，刚开始是用文档记录发到群里分享，后来直接用hexo博客写，自己也租了一台阿里云服务器，部署自己的网站。而之前也是利用业余时间看看经典书籍，而这一年更是如此，也很少看视频了，基本以经典书籍学习，像设计模式，多线程，数据结构与算法等等，也许是精力不行了，也没有了之前疯狂的学习热情，后来在3月到5月一直帮一个学校做项目（过程太累），第一次感受到真实项目的复杂合自己一个人做的挑战，最后改编成了毕业设计。然后到了7月，自己也许是爆发最后一次的能量，整个暑假出门不超过几十次，花了一个月终于完成了自己的个人论坛项目，带着渴望不孤独的心情第二次发到了空间，然而在之前，因为自己太痴迷于技术，错过了好多推荐的机会，现在后悔都来不及。到九月份，突然发现，自己投的简历都石沉大海，一次面试对方说出了详情，我们不需要有自己想法的人，就算你自己苦思冥想设计算法最后还是调用第三方库，如谷歌、百度。而且现在培训这么多，别人几个月会各种分布式技术，各种技术集群，而且只要基本的增删改查和基本操作就够了，而且我们只要有工作经验的，也许是自己之前的学习热情过头惹怒了面试官加上简历上写的0工作经验和找实习，要么是培训机构要么没有机会，加上自己又要考驾照和精神不够好胡思乱想，于是从十月份开始彻底废了，每天沉迷游戏，动漫，电影，自暴自弃，甚至考虑转行等等，期间也偶尔兴趣来了学习一下技术，后来慢慢的发现，自己太单纯了，自己的目标是一名工程师，技术会用和深入学习的时间性价比是天壤之别，而且这是一个很现实的社会</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>慢慢的，人总是会变的现实，很感激大学里陪伴我的严蔚敏老师、韩顺平老师、马士兵老师、李炎灰老师和其他免费开源的优秀老师以及那些经典书籍的作者，是他们陪伴我度过了最充实的大学生活。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束。&lt;br&gt;回顾这三年多生活，大学前一年基本迷迷茫茫，太多的课程，让
    
    </summary>
    
      <category term="个人感想" scheme="http://www.myzwl.win/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="学习总结" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>FastDFS+Nginx搭建分布式图片服务器</title>
    <link href="http://www.myzwl.win/2017/12/20/fastdfs_1/"/>
    <id>http://www.myzwl.win/2017/12/20/fastdfs_1/</id>
    <published>2017-12-20T06:48:51.000Z</published>
    <updated>2018-01-04T13:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>FastDFS是用c语言编写的一款开源的分布式文件系统。充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。其流程如下所示<br><img src="/images/imgs5/28.jpg" alt="Alt text"><br>其中tracker相当于一个管家，在storager与client之间进行交流，最终图片存在storager中。<br>而在传统图片存储中，一般都存在某个服务器的目录中，如果要集群的话，并发量大的话，另一台服务器就访问不到了，所以需要一个专门的图片服务器</p>
<h4 id="上传与下载流程"><a href="#上传与下载流程" class="headerlink" title="上传与下载流程"></a>上传与下载流程</h4><p>上传<br><img src="/images/imgs5/29.jpg" alt="Alt text"><br>下载<br><img src="/images/imgs5/30.jpg" alt="Alt text"></p>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>一.上传需要的软件到linux上<br><img src="/images/imgs5/31.jpg" alt="Alt text"><br>二.linux上安装必要的环境<br>1.安装gcc sudo apt-get install gcc<br>2.安装libevent工具包(ubuntu 16.04不能直接使用命令安装，具体也是谷歌了很久绕一大串才能安装)<br>三.安装libfastcommon（这里将所有文件放在了/usr/local/fast目录下）<br>1.解压缩到相应目录下<br>2.进行编译和安装<br>./make.sh &amp;&amp; ./make.sh install<br>3.把/usr/lib64/libfastcommon.so文件向/usr/lib/下复制一份<br>四。安装Tracker服务<br>1、解压缩<br>2、./make.sh<br>3、./make.sh install<br>安装后在/usr/bin/目录下有以fdfs开头的文件都是编译出来的。<br>配置文件都放到/etc/fdfs文件夹<br>4、把/conf目录下的所有的配置文件都复制到/etc/fdfs下<br>5、配置tracker服务。修改/etc/fdfs/tracker.conf文件。<br>找到base_path=/home/yuqing/fastdfs<br>把后面的路径修改成你服务器上的路径，并且这个目录必须存在。我的是/usr/local/fast/fastdfs<br>6、启动tracker。/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf<br>重启使用命令：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart<br>五。安装storage服务<br>1、如果是在不同的服务器安装，第四步的1~4需要重新执行。<br>2、配置storage服务。修改/etc/fdfs/storage.conf文件<br>需要修改几处。<br>base_path与store_path0改成自己的，我的是/usr/local/fast/storage<br>tracker_server改成自己主机的ip：22122<br>3、启动storage服务。<br>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart<br>六。安装测试<br>1、修改配置文件/etc/fdfs/client.conf将其中的base_path与tracker_server修改<br>2、测试<br>/usr/bin/fdfs_test /etc/fdfs/client.conf upload anti-steal.jpg<br>如果成功的话会提示图片存储路径<br>七。搭建nginx提供http服务<br>上传fastdfs-nginx-module_v1.16.tar.gz<br>1、解压插件压缩包<br>2、修改/fastdfs-nginx-module/src/config文件，把其中的local去掉，同时如果你的是64位的把lib改成lib64<br>3、对nginx重新config<br>./configure \<br>–prefix=/usr/local/nginx \<br>–pid-path=/var/run/nginx/nginx.pid \<br>–lock-path=/var/lock/nginx.lock \<br>–error-log-path=/var/log/nginx/error.log \<br>–http-log-path=/var/log/nginx/access.log \<br>–with-http_gzip_static_module \<br>–http-client-body-temp-path=/var/temp/nginx/client \<br>–http-proxy-temp-path=/var/temp/nginx/proxy \<br>–http-fastcgi-temp-path=/var/temp/nginx/fastcgi \<br>–http-uwsgi-temp-path=/var/temp/nginx/uwsgi \<br>–http-scgi-temp-path=/var/temp/nginx/scgi \<br>–add-module=/usr/local/fast/fastdfs-nginx-module/src<br>注意最后一个是安装的路径，第一个是你自己的nginx路径<br>4、make<br>5、make install<br>6、把/fastdfs-nginx-module/src/mod_fastdfs.conf文件复制到/etc/fdfs目录下。修改<br>tracker_server=192.168.1.172:22122//改成自己的服务器ip地址<br>url_have_group_name = true //改为true，启动组<br>store_path0=/fastdfs/storage //改成自己的图片存储路径<br>7、nginx的配置<br>server {<br>        listen       80;<br>        server_name  localhost;</p>
<pre><code>location /group1/M00/{
        #root /home/FastDFS/fdfs_storage/data;
        ngx_fastdfs_module;
}
</code></pre><p>}<br>8、将libfdfsclient.so拷贝至/usr/lib下<br>cp /usr/lib64/libfdfsclient.so /usr/lib/<br>9.启动nginx</p>
<h4 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h4><p>事情并非一帆风顺的，其中有几个坑需要注意<br>1.如果你的是64位，一定要把上面说的lib改成lib64<br>2.主要上面修改的配置文件中有http.server_port=8888默认的，改成你在nginx中配置的，我配置的是80，就全部改成80，另外cliet那个配置文件是8080，页改成80，不然会出现404错误<br>3.增加权限，在nginx.conf中第一行增加user root；权限<br>最后利用上传时显示的图片地址在浏览器中进行访问即可<br><img src="/images/imgs5/32.jpg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;FastDFS是用c语言编写的一款开源的分布式文件系统。充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用Fas
    
    </summary>
    
      <category term="分布式" scheme="http://www.myzwl.win/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="FastDFS" scheme="http://www.myzwl.win/source/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>pythonDiary_01之map与reduce</title>
    <link href="http://www.myzwl.win/2017/12/11/python_02/"/>
    <id>http://www.myzwl.win/2017/12/11/python_02/</id>
    <published>2017-12-11T06:48:51.000Z</published>
    <updated>2018-01-04T12:40:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br>比如：list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))<br>把这个list所有数字转为字符串</p>
<p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br>比方说对一个序列求和</p>
<blockquote>
<p>from functools import reduce<br>  def add(x, y):<br>  return x + y<br>reduce(add, [1, 3, 5, 7, 9])</p>
</blockquote>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>在一个有序集合，统计出现所有键的个数</p>
<blockquote>
<p>from functools import reduce<br>def func(lst):<br>  dic={}<br>  for k in lst:<br>   if not k in dic :<br>     dic[k]=1<br>   else :<br>     dic[k]+=1;<br>     return dic<br>lst=[1,1,2,3,2,3,3,5,6,7,7,6,5,5,5]<br>print(func(lst))<br>def func1(lst):<br> m=set(lst)<br> dic={}<br> for x in m:<br>    dic[x]=lst.count(x)<br> return dic<br>ls=[1,1,2,3,2,3,3,5,6,7,7,6,5,5,5]<br>print(func1(ls))<br>def func2(dic,p):<br>   if not p in dic :<br>     dic[p]=1<br>   else :<br>     dic[p]+=1;<br>     return dic<br>print(reduce(func2,ls,{}))</p>
</blockquote>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter()函数用于过滤序列。<br>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br>在一个list中，删掉偶数，只保留奇数，可以这么写：</p>
<blockquote>
<p>def is_odd(n):<br>    return n % 2 == 1<br>list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</p>
<h1 id="结果-1-5-9-15"><a href="#结果-1-5-9-15" class="headerlink" title="结果: [1, 5, 9, 15]"></a>结果: [1, 5, 9, 15]</h1></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator
    
    </summary>
    
      <category term="python" scheme="http://www.myzwl.win/categories/python/"/>
    
    
      <category term="python" scheme="http://www.myzwl.win/source/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pythonDiary_01之数据类型</title>
    <link href="http://www.myzwl.win/2017/12/10/python_01/"/>
    <id>http://www.myzwl.win/2017/12/10/python_01/</id>
    <published>2017-12-10T06:48:51.000Z</published>
    <updated>2017-12-24T05:20:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>人生苦短，我用python。最近为了丰富自己的技术栈，开始学习这门神奇的语言。我的是在linux环境下进行学习，参考了廖雪峰先生的教程进行学习，不多说，下面将介绍python中几种不熟悉的数据元素：列表、元组、字典、set</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表list是一种有序的集合，可以随时添加和删除其中的元素<br>1.1初始化列表</p>
<blockquote>
<p>list=[‘java’,’php’,’c’,’python’]</p>
</blockquote>
<p>1.2访问列表中的值<br>列表引用[索引号]，如list[0],下标从0开始，-1表示最后一个，依次类推</p>
<p>1.3更新列表<br>直接将列表中值重新赋值，如list[0]=‘c++’</p>
<p>1.4删除列表元素<br>del list[0]</p>
<p>1.5列表操作符</p>
<blockquote>
<p>[1,2]+[4,5]  #[1,2,4,5]<br>[‘h’]*4 #[‘h’,’h’,’h’,’h’]<br>1 in [1,2] #true<br>for yy in [‘x’,’y’] # ‘x’,’y’</p>
</blockquote>
<p>1.6列表截取</p>
<blockquote>
<p>list=[‘java’,’php’,’c’,’python’]<br>list[0] #java<br>list[-1] #python<br>list[1:3] # c python 其中list[：-1]默认第一个是从0开始，list[0:]最后一个不写默认是最后一个</p>
</blockquote>
<p>1.7列表函数与方法</p>
<blockquote>
<p>list.append(obj) #末尾添加新对象<br>list.count(obj)   #统计某个元素在列表中出现的次数<br>list.extend(seq)  #在列表末尾一次性追加里一个序列<br>list.index(obj)   #找出第一个匹配值的序列<br>list.insert(index,obj)  #指定索引位置插入<br>list.pop(index)       #按索引溢出列表中元素，默认最后一个<br>list.remove(obj)     #按值移除<br>list.reverse()      #倒转<br>list.sort()        #排序</p>
</blockquote>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组tuple和list非常类似，但是tuple一旦初始化就不能修改，而且元组使用（）定义，列表使用[]<br>初始化<br>tuple=(‘java’,’python’,’c’,’php’)<br>只有一个元素需要添加逗号<br>tuple=(‘java’,)<br>空元组<br>tuple=()</p>
<p>元组内置函数</p>
<blockquote>
<p>cmp(t1,t2) #比较两个元组元素<br>len(t)      #计算元组元素的个数<br>max(t)      #返回元组中元素最大值<br>min(t)      #。。最小值<br>tuple(seq)  #列表转化为元组</p>
</blockquote>
<p>其余操作和列表基本一致</p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度<br>1.1初始化字典<br>如dict={‘java’:’hello’,’c’:’world’,’python’:’hi’}<br>1.2 访问字典的值<br>dict[‘java’] #hello<br>1.3修改字典</p>
<blockquote>
<p>dict[‘java’]=’we’ #修改<br>dict[‘c++’]=’lol’ #增加<br>del dict[‘java’] #删除键<br>dict.clear()    #清空字典<br>del dict        #删除词典</p>
</blockquote>
<p>1.4字典内置函数</p>
<blockquote>
<p>1.cmp(dict1, dict2)<br>比较两个字典元素<br>2    len(dict)<br>计算字典元素个数，即键的总数。<br>3    str(dict)<br>输出字典可打印的字符串表示。<br>4    type(variable)<br>返回输入的变量类型，如果变量是字典就返回字典类型。<br>Python字典包含了以下内置方法：<br>1    dict.clear()<br>删除字典内所有元素<br>2    dict.copy()<br>返回一个字典的浅复制<br>3    dict.fromkeys(seq[, val])<br>创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值<br>4    dict.get(key, default=None)<br>返回指定键的值，如果值不在字典中返回default值<br>5    dict.has_key(key)<br>如果键在字典dict里返回true，否则返回false<br>6    dict.items()<br>以列表返回可遍历的(键, 值) 元组数组<br>7    dict.keys()<br>以列表返回一个字典所有的键<br>8    dict.setdefault(key, default=None)<br>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default<br>9    dict.update(dict2)<br>把字典dict2的键/值对更新到dict里<br>10    dict.values()<br>以列表返回字典中的所有值<br>11    pop(key[,default])<br>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。<br>12    popitem()<br>随机返回并删除字典中的一对键和值。</p>
</blockquote>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。<br>要创建一个set，需要提供一个list作为输入集合：<br>s = set([1, 2, 3])<br>其余和字典差不多</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;人生苦短，我用python。最近为了丰富自己的技术栈，开始学习这门神奇的语言。我的是在linux环境下进行学习，参考了廖雪峰先生的教程进行学
    
    </summary>
    
      <category term="python" scheme="http://www.myzwl.win/categories/python/"/>
    
    
      <category term="python" scheme="http://www.myzwl.win/source/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>solr笔记之二</title>
    <link href="http://www.myzwl.win/2017/11/10/solr_2/"/>
    <id>http://www.myzwl.win/2017/11/10/solr_2/</id>
    <published>2017-11-10T06:48:51.000Z</published>
    <updated>2017-12-18T10:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="solrj的基本使用"><a href="#solrj的基本使用" class="headerlink" title="solrj的基本使用"></a>solrj的基本使用</h4><p>环境准备<br>新建一个java工程，然后添加如下jar包<br><img src="/images/imgs5/27.jpg" alt="Alt text"><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//远程连接的solr服务器地址</div><div class="line">private static final String URL="http://111.230.246.33:8080/solr";</div><div class="line">	</div><div class="line">	public void search()throws Exception&#123;</div><div class="line">		//solr服务</div><div class="line">		SolrServer solr=new HttpSolrServer(URL);</div><div class="line">		//查询对象</div><div class="line">		SolrQuery query=new SolrQuery();</div><div class="line">		//设置查询条件,名称“q”是固定的且必须的</div><div class="line">		query.set("q", "title:zwl");</div><div class="line">		// 请求查询</div><div class="line">		QueryResponse res=solr.query(query);</div><div class="line">		// 查询结果</div><div class="line">		SolrDocumentList list=res.getResults();</div><div class="line">		// 查询文档总数</div><div class="line">		long num=list.getNumFound();</div><div class="line">		System.out.println(num);</div><div class="line">		for(SolrDocument sd :list)&#123;</div><div class="line">			String id=(String)sd.get("id");</div><div class="line">			//String title=(String)sd.get("title");</div><div class="line">			System.out.println(id);</div><div class="line">		//	System.out.println(title);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void del()throws Exception&#123;</div><div class="line">		SolrServer solr=new HttpSolrServer(URL);</div><div class="line">		solr.deleteById("5");</div><div class="line">		solr.commit();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void add() throws Exception&#123;</div><div class="line">		//实例化solr对象</div><div class="line">		SolrServer solr=new HttpSolrServer(URL);</div><div class="line">		SolrInputDocument doc1=new SolrInputDocument();</div><div class="line">		doc1.setField("id", "5");</div><div class="line">		doc1.setField("title", "dx");</div><div class="line">		solr.add(doc1);</div><div class="line">		solr.commit();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>注意：以上的索引都是在配置文件中已声明了，如：<br><!--IKAnalyzer Field--></p>
<p><field name="title_ik" type="text_ik" indexed="true" stored="true"></field></p>
<p><field name="content_ik" type="text_ik" indexed="true" stored="false" multivalued="true"><br>type可以为具体类型，也可以为一个分词器</field></p>
<h4 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h4><ol>
<li>q - 查询字符串，必须的，如果查询所有使用<em>:</em></li>
<li>fq - （filter<br>query）过虑查询，作用：在q查询符合结果中同时是fq查询符合的，例如product_price:[1 TO 20]<br>过滤查询价格从1到20的记录<br>3.sort - 排序，格式：sort=<field name="">+<desc|asc>[,<field name="">+<desc|asc>]…<br>如 product_price desc 按价格降序排序</desc|asc></field></desc|asc></field></li>
<li>start - 分页显示使用，开始记录下标，从0开始</li>
<li>rows - 指定返回结果最多有多少条记录，配合start来实现分页。</li>
<li>fl - 指定返回那些字段内容，用逗号或空格分隔多个<br>7.df-指定一个搜索Field</li>
<li>wt - (writer type)指定输出格式，可以有xml, json, php, phps, 后面solr<br>1.3增加的，要用通知我们，因为默认没有打开。</li>
<li>hl 是否高亮,设置高亮Field，设置格式前缀和后缀。<br>10 组合查询：使用and or等等</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;solrj的基本使用&quot;&gt;&lt;a href=&quot;#solrj的基本使用&quot; class=&quot;headerlink&quot; title=&quot;solrj的基本使用&quot;&gt;&lt;/a&gt;solrj的基本使用&lt;/h4&gt;&lt;p&gt;环境准备&lt;br&gt;新建一个java工程，然后添加如下jar包&lt;br&gt;&lt;img 
    
    </summary>
    
      <category term="solr" scheme="http://www.myzwl.win/categories/solr/"/>
    
    
      <category term="solr" scheme="http://www.myzwl.win/source/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>solr笔记之一</title>
    <link href="http://www.myzwl.win/2017/11/09/solr_1/"/>
    <id>http://www.myzwl.win/2017/11/09/solr_1/</id>
    <published>2017-11-09T06:48:51.000Z</published>
    <updated>2017-12-18T05:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>使用传统的数据库查询方式实现搜索无法满足一些高级需求，比如：搜索速度要快、搜索结果按相关度排序、搜索内容不固定，一般可以单独使用Lucene或者使用google或者百度接口或者使用solr实现全文检索。而solr是基于lucene，是一个服务器，在各方面都相对优越<br><img src="/images/imgs5/24.jpg" alt="Alt text"></p>
<h4 id="redis环境搭建"><a href="#redis环境搭建" class="headerlink" title="redis环境搭建"></a>redis环境搭建</h4><p>有如下步骤</p>
<blockquote>
<p>1.上传solr压缩包solr-4.10.3.tgz.tar到linux上<br>2.解压到/usr/local下，tar -zxvf solr-4.10.3.tgz.tar -C /usr/local/<br>3.进入目录: cd solr-4.10.3/example/webapps/<br>4.拷贝其下的war文件到tomcat的webapps中：cp solr.war /usr/local/tomcat/webapps/(tomcat启动，自动解压war包)<br>5.进入solr文件，修改其中一些文件: vim solr/WEB-INF/web.xml 找到nv-entry内容，解开注释，并修改solr/home的地址：我的是/usr/local/solr-4.10.3/example/solr<br>6.拷贝相关jar包到tomcat下 cd /usr/local/solr-4.10.3/example/lib/ext &amp;&amp; cp * /usr/local/tomcat/lib/<br>7.重启tomcat</p>
</blockquote>
<p>然后通过浏览器访问，如看到下面的solr主页即可<br><img src="/images/imgs5/25.jpg" alt="Alt text"><br>至此我们可以通过可视化页面对数据进行增删改查操作，其中solr是以id为标识的，并且根据不同的分词器进行分词，而索引字段是在服务器配置文件中已定义好的（可自定义）</p>
<h4 id="相关文件说明"><a href="#相关文件说明" class="headerlink" title="相关文件说明"></a>相关文件说明</h4><p>solrhome：目录中包括了运行solr实例的所有的配置文件和数据文件，是运行的主目录，可包括多个solrcore<br>solrcore：提供单独的搜索和索引服务<br>如可视化界面中的collection1</p>
<h4 id="solr索引"><a href="#solr索引" class="headerlink" title="solr索引"></a>solr索引</h4><p>schema.xml，在solrcore的conf目录下，它是solr数据表配置文件，它定义了加入索引的数据的数据类型。主要包括FiledTypes、Filed和其他的一些缺省设置<br><img src="/images/imgs5/26.jpg" alt="Alt text"><br>FieldType域类型<br>text_general是solr默认的域类型<br>子节点<br>name：是这个FieldType的名称<br>class：是Solr提供的包solr.TextField，solr.TextField<br>允许用户通过分析器来定制索引和查询，分析器包括一个分词器（tokenizer）<br>和多个过滤器（filter）<br>positionIncrementGap：可选属性，定义在同一个文档中此类型数据的空白<br>间隔，避免短语匹配错误，此值相当于Lucene的短语查询设置slop值，根据经<br>验设置为100。<br>在FieldType定义的时候最重要的就是定义这个类型的数据在建立索引和进<br>行查询的时候要使用的分析器analyzer,包括分词和过滤<br>索引分析器中：使用solr.StandardTokenizerFactory标准分词器，solr.StopFilte<br>rFactory停用词过滤器，solr.LowerCaseFilterFactory小写过滤器。<br>搜索分析器中：使用solr.StandardTokenizerFactory标准分词器，solr.StopFilte<br>rFactory停用词过滤器，这里还用到了solr.SynonymFilterFactory同义词过滤器</p>
<p>Field定义<br>在fields结点内定义具体的Field，filed定义包括name,type（为之前定义过的<br>各种FieldType）,indexed（是否被索引）,stored（是否被储存），multiValued（<br>是否存储多个值）等属性。<br>如下：</p>
<p><field name="name" type="text_general" indexed="true" stored="true"></field></p>
<p><field name="features" type="text_general" indexed="true" stored="true" multivalued="true"><br>multiValued：该Field如果要存储多个值时设置为true，solr允许一个Field存<br>储多个值，比如存储一个用户的好友id（多个），商品的图片（多个，大图和<br>小图），通过使用solr查询要看出返回给客户端是数组</field></p>
<p>uniqueKey<br>Solr中默认定义唯一主键key为id域，如下：<br>Solr在删除、更新索引时使用id域进行判断，也可以自定义唯一主键</p>
<p>copyField复制域<br>copyField复制域，可以将多个Field复制到一个Field中，以便进行统一的检索</p>
<p>dynamicField（动态字段）<br>动态字段就是不用指定具体的名称，只要定义字段名称的规则，例如定义<br>一个dynamicField，name<br>为*_i，定义它的type为text，那么在使用这个字段的时候，任何以_i结尾的字段<br>都被认为是符合这个定义的，例如：name_i，gender_i，school_i等</p>
<h4 id="配置中文分词器"><a href="#配置中文分词器" class="headerlink" title="配置中文分词器"></a>配置中文分词器</h4><p>具体步骤如下</p>
<blockquote>
<p>1.下载并解压IKAnalyzer<br>2.将IKAnalyzer2012FF_u1.jar拷贝到Tomcat的webapps/solr/WEB-INF/lib 下。<br>3在Tomcat的webapps/solr/WEB-INF/下创建classes目录<br>4.将IKAnalyzer.cfg.xml、ext_stopword.dic mydict.dic copy到Tomcat的webapps/solr/WEB-INF/classes<br>5.修改solr core的schema文件添加FieldType：<br><!-- IKAnalyzer--></p>
<p><fieldtype name="text_ik" class="solr.TextField"></fieldtype></p>
<p><analyzer type="index" ismaxwordlength="false" class="org.wltea.analyzer.lucene.IKAnalyzer"></analyzer></p>
<p><analyzer type="query" ismaxwordlength="true" class="org.wltea.analyzer.lucene.IKAnalyzer"><br><br>6.重启tomcat</analyzer></p>
</blockquote>
<p>这样配置后，中文分词就会有很好的分词效果</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;使用传统的数据库查询方式实现搜索无法满足一些高级需求，比如：搜索速度要快、搜索结果按相关度排序、搜索内容不固定，一般可以单独使用Lucene
    
    </summary>
    
      <category term="solr" scheme="http://www.myzwl.win/categories/solr/"/>
    
    
      <category term="solr" scheme="http://www.myzwl.win/source/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>FreeMarker笔记之基础知识</title>
    <link href="http://www.myzwl.win/2017/11/08/freemarker_1/"/>
    <id>http://www.myzwl.win/2017/11/08/freemarker_1/</id>
    <published>2017-11-08T06:48:51.000Z</published>
    <updated>2017-12-17T12:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>FreeMarker是一个模板引擎，一个基于模板生成文本输出的通用工具。简单比如来说，html作为只关心前台，无后台数据，而后台数据通过freemarker模板来定义数据，然后在html中取出数据</p>
<h4 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h4><p>不妨以一个hello world程序作为入门，然后在研究它<br>1.建立一个普通的java项目<br>2.引入freemarker.jar包<br>3.在项目目录下建立模板目录：templates<br>4.在templates目录下，建立一个xx.ftl文件，内容如下</p>
<blockquote>
<p>hello，${msg}</p>
</blockquote>
<p>5.然后建立一个测试类：</p>
<blockquote>
<p>public static void main(String[] args) throws Exception {<br>        //创建Freemarker配置实例<br>        Configuration cfg = new Configuration();<br>        cfg.setDirectoryForTemplateLoading(new File(“templates”));<br>        //创建数据模型<br>        Map root = new HashMap();<br>        root.put(“msg”, “world”);<br>        //加载模板文件<br>        Template t1 = cfg.getTemplate(“a.ftl”);<br>        //显示生成的数据,//将合并后的数据打印到控制台<br>        Writer out = new OutputStreamWriter(System.out);<br>        t1.process(root, out);<br>        out.flush();<br>    }</p>
</blockquote>
<p>输出结果：<br>hello，world</p>
<h4 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h4><p>不妨先看例子<br>测试类中添加如下语句<br>root.put(“random”, new Random().nextInt(100));</p>
<p>模板文件添加如下语句</p>
<blockquote>
<p>if语句测试：</p>
<h2 id="msg-是-lt-if-msg-”world”-gt-is-right-lt-if-gt"><a href="#msg-是-lt-if-msg-”world”-gt-is-right-lt-if-gt" class="headerlink" title="${msg}是&lt;#if msg==”world”&gt;is right&lt;/#if&gt;"></a>${msg}是&lt;#if msg==”world”&gt;is right&lt;/#if&gt;</h2><p>if else 语句测试：<br>&lt;#if random gt 60&gt;<br>    及格！<br>&lt;#else&gt;<br>    不及格！</p>
<h2 id="lt-if-gt"><a href="#lt-if-gt" class="headerlink" title="&lt;/#if&gt;"></a>&lt;/#if&gt;</h2><p>if else if else语句测试：<br>&lt;#if random gte 90&gt;<br>    优秀！<br>&lt;#elseif random gte 80&gt;<br>    良好！<br>&lt;#else&gt;<br>    一般！<br>&lt;/#if&gt;</p>
</blockquote>
<p>随机输出结果:<br>if语句测试：</p>
<h2 id="gt-world是is-right"><a href="#gt-world是is-right" class="headerlink" title="&gt;world是is right"></a>&gt;world是is right</h2><p>if else 语句测试：</p>
<pre><code>及格！
</code></pre><hr>
<p>if else if else语句测试：<br>    优秀！</p>
<p>其中运用了比较运算符</p>
<ol>
<li>=（或者==）： 判断两个值是否相等；</li>
<li>!=： 判断两个值是否不相等；<br>注： =和!=可以用作字符串、数值和日期的比较，但两边的数据类型必须相同。而且FreeMarker的比较是精确比较，不会忽略大小写及空格。</li>
<li><blockquote>
<p>（或者gt）： 大于</p>
</blockquote>
</li>
<li><blockquote>
<p>=（或者gte）： 大于等于</p>
</blockquote>
</li>
<li>&lt;（或者lt）： 小于</li>
<li>&lt;=（或者lte）： 小于等于<br>注： 上面这些比较运算符可以用于数字和日期，但不能用于字符串。大部分时候，使用gt比&gt;有更好的效果，因为FreeMarker会把&gt;解释成标签的结束字符。可以使用括号来避免这种情况，如：&lt;#if (x&gt;y)&gt;。</li>
</ol>
<h4 id="list指令"><a href="#list指令" class="headerlink" title="list指令"></a>list指令</h4><p>首先添加一个address类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Address &#123;</div><div class="line"></div><div class="line">	</div><div class="line">	private String country;</div><div class="line">	public String getCountry() &#123;</div><div class="line">		return country;</div><div class="line">	&#125;</div><div class="line">	public void setCountry(String country) &#123;</div><div class="line">		this.country = country;</div><div class="line">	&#125;</div><div class="line">	public String getCity() &#123;</div><div class="line">		return city;</div><div class="line">	&#125;</div><div class="line">	public void setCity(String city) &#123;</div><div class="line">		this.city = city;</div><div class="line">	&#125;</div><div class="line">	public Address(String country, String city) &#123;</div><div class="line">		super();</div><div class="line">		this.country = country;</div><div class="line">		this.city = city;</div><div class="line">	&#125;</div><div class="line">	private String city;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后测试类中添加如下语句</p>
<blockquote>
<p>List list = new ArrayList();<br>        list.add(new Address(“中国”,”北京”));<br>        list.add(new Address(“中国”,”上海”));<br>        list.add(new Address(“美国”,”纽约”));<br>        root.put(“lst”, list);</p>
</blockquote>
<p>模板文件添加如下</p>
<blockquote>
<p>测试list指令：<br>&lt;#list lst as temp &gt;<br>    <b>${temp.country}</b> <br><br>&lt;/#list&gt;</p>
</blockquote>
<h4 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h4><p>在templates目录下随便写一个文件，比如tt.txt，里面目前只有test字符<br>模板文件增加如下：<br>&lt;#include “tt.txt” /&gt;<br>将增加tt.txt里面的文本内容到该模板文件中</p>
<h4 id="macro指令"><a href="#macro指令" class="headerlink" title="macro指令"></a>macro指令</h4><p>该指令为宏指令，相当于定义函数和参数<br>第一个为函数名，后面为参数可有可无<br>如：</p>
<blockquote>
<p>&lt;#macro tt&gt;<br>hello<br>world<br>&lt;/#macro&gt;</p>
</blockquote>
<p>引用&lt;@tt /&gt;<br>输出结果<br>hello<br>world</p>
<p>定义待参宏指令<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-id">#macro</span> func <span class="selector-tag">a</span> b&gt;</div><div class="line">$&#123;a&#125;,$&#123;b&#125;</div><div class="line">&lt;/#macro&gt;</div><div class="line"></div><div class="line">&lt;@func a=<span class="string">'hello'</span> b=<span class="string">'world'</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>输出结果为hello，world</p>
<p>nested指令<br>该指定是插入引入的内容到相应位置如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-id">#macro</span> <span class="attribute">border</span>&gt; </div><div class="line"> before </div><div class="line">    &lt;#nested&gt; </div><div class="line">    after</div><div class="line">&lt;/#macro&gt;</div><div class="line"></div><div class="line">&lt;@<span class="attribute">border</span> &gt;now&lt;/@border&gt;</div></pre></td></tr></table></figure></p>
<p>输出结果为<br>before now after</p>
<p>命名空间<br>当运行 FTL 模板时，就会有使用 assign 和 macro 指令创建的变量的集合，当引用不同的模板，就需要使用import指令<br>比如创建如下b.ftl<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-id">#macro</span> copyright date&gt;</div><div class="line">  &lt;p&gt;Copyright (C) $&#123;date&#125; &lt;/p&gt; </div><div class="line">&lt;/#macro&gt; </div><div class="line">&lt;<span class="selector-id">#assign</span> mail = <span class="string">"zwl"</span>&gt;</div><div class="line"></div><div class="line">在测试模板中</div><div class="line">测试命名空间：</div><div class="line">&lt;<span class="selector-id">#import</span> <span class="string">"b.ftl"</span> as bb  /&gt;</div><div class="line">&lt;@bb<span class="selector-class">.copyright</span> date=<span class="string">"2013-2017"</span> /&gt;</div><div class="line">$&#123;bb.mail&#125;</div></pre></td></tr></table></figure></p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>一、直接指定值<br>直接指定值可以是字符串、数值、布尔值、集合及Map对象。</p>
<ol>
<li><p>字符串<br>直接指定字符串值使用单引号或双引号限定。字符串中可以使用转义字符”\”。如果字符串内有大量的特殊字符，则可以在引号的前面加上一个字母r，则字符串内的所有字符都将直接输出。</p>
</li>
<li><p>数值<br>数值可以直接输入，不需要引号。FreeMarker不支持科学计数法。</p>
</li>
<li><p>布尔值<br>直接使用true或false，不使用引号。</p>
</li>
<li><p>集合<br>集合用中括号包括，集合元素之间用逗号分隔。<br>使用数字范围也可以表示一个数字集合，如1..5等同于集合[1, 2, 3, 4, 5]；同样也可以用5..1来表示[5, 4, 3, 2, 1]。</p>
</li>
<li><p>Map对象<br>Map对象使用花括号包括，Map中的key-value对之间用冒号分隔，多组key-value对之间用逗号分隔。<br>注意：Map对象的key和value都是表达式，但key必须是字符串</p>
</li>
</ol>
<p>6.时间对象<br>如：root.put(“date1”, new Date());<br>输出:${date1?string(“yyyy-MM-dd HH:mm”)}<br>其中后面的为日期输出格式</p>
<ol>
<li>JAVABEAN的处理<br>Freemarker中对于javabean的处理跟EL表达式一致，类型可自动转化</li>
</ol>
<p>二、输出变量值<br>FreeMarker的表达式输出变量时，这些变量可以是顶层变量，也可以是Map对象的变量，还可以是集合中的变量，并可以使用点（.）语法来访问Java对象的属性。</p>
<ol>
<li>顶层变量<br>所谓顶层变量就是直接放在数据模型中的值。输出时直接用${variableName}即可</li>
</ol>
<p>输出集合元素<br>可 以根据集合元素的索引来输出集合元素，索引用中括号包括。如： 输出[“1”， “2”， “3”]这个名为number的集合，可以用${number[0]}来输出第一个数字。FreeMarker还支持用number[1..2]来表示原 集合的子集合[“2”， “3”]。</p>
<ol>
<li><p>输出Map元素<br>对于JavaBean实例，FreeMarker一样把它看作属性为key，属性值为value的Map对象。<br>输出Map对象时，可以使用点语法或中括号语法，如下面的几种写法的效果是一样的：</p>
<pre><code>book.author.name                                                                                book.author[&quot;name&quot;]                                                                              book[&quot;author&quot;].name                                                                            book[&quot;author&quot;][&quot;name&quot;]                                            
</code></pre><p>字符串操作</p>
</li>
<li>字符串连接<br>直接使用+连接<br>截取子串<br>截取子串可以根据字符串的索引来进行，如果指定一个索引值，则取得字符串该索引处的字符；如果指定两个索引值，则截取两个索引中间的字符串子串。如：<pre><code>&lt;#assign number=&quot;01234&quot;&gt;
${number[0]} &lt;#-- 输出字符0 --&gt;
${number[0..3]} &lt;#-- 输出子串“0123” --&gt;
</code></pre></li>
</ol>
<p>内建函数<br>FreeMarker提供了一些内建函数来转换输出，可以在任何变量后紧跟?，?后紧跟内建函数，就可以通过内建函数来转换输出变量。</p>
<p>字符串相关常用的内建函数：</p>
<ol>
<li>html： 对字符串进行HTML编码；</li>
<li>cap_first： 使字符串第一个字母大写；</li>
<li>lower_case： 将字符串转成小写；</li>
<li>upper_case： 将字符串转成大写；</li>
</ol>
<p>集合相关常用的内建函数：</p>
<ol>
<li>size： 获得集合中元素的个数；</li>
</ol>
<p>数字值相关常用的内建函数：</p>
<ol>
<li>int： 取得数字的整数部分。</li>
</ol>
<p>举例：<br>root.put(“htm2”, “<b>粗体</b>“);<br>内建函数：<br>${htm2?html}</p>
<p>其它类型<br>集合连接操作<br>Map连接操作<br>算术运算符<br>比较运算符<br>逻辑运算符<br>空值处理运算符</p>
<p>数据类型常见示例<br> 直接指定值<br>   字符串 ： “Foo”或 者’Foo’或”It’s \”quoted\””或r”C:\raw\string”<br>   数字：123.45<br>   布尔值：true, false<br>   序列：[“foo”, “bar”, 123.45], 1..100<br>   哈希表：{“name”:”green mouse”, “price”:150}<br>   检索变量    顶层变量：user<br>   从哈希表中检索数据：user.name, user[“name”]<br>   从序列中检索：products[5]<br>   特殊变量：.main<br>   字符串操作<br>   插值（或连接）：”Hello ${user}!”（或”Free” + “Marker”）<br>   获取一个字符：name[0]<br>   序列操作<br>   连接：users + [“guest”]<br>   序列切分：products[10..19]  或  products[5..]<br>   哈希表操作<br>   连接：passwords + {“joe”:”secret42”}<br>   算数运算: (x * 1.5 + 10) / 2 - y % 100<br>   比 较 运 算 ： x == y,   x != y,   x &lt; y,   x &gt; y,   x &gt;= y,   x &lt;= y,<br>x &lt; y,  等等<br>    逻辑操作：!registered &amp;&amp; (firstVisit || fromEurope)<br>    内建函数：name?upper_case<br>    方法调用：repeat(“What”, 3)<br>   处理不存在的值<br>   默认值：name!”unknown”  或者(user.name)!”unknown”  或者<br>name!  或者  (user.name)!<br>   检测不存在的值：name?? 或者(user.name)??</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;FreeMarker是一个模板引擎，一个基于模板生成文本输出的通用工具。简单比如来说，html作为只关心前台，无后台数据，而后台数据通过fr
    
    </summary>
    
      <category term="FreeMarker" scheme="http://www.myzwl.win/categories/FreeMarker/"/>
    
    
      <category term="FreeMarker" scheme="http://www.myzwl.win/source/tags/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记四之搭建伪集群</title>
    <link href="http://www.myzwl.win/2017/11/07/redis_4/"/>
    <id>http://www.myzwl.win/2017/11/07/redis_4/</id>
    <published>2017-11-07T06:48:51.000Z</published>
    <updated>2017-12-08T08:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在redis3.0之前，提供了哨兵的机制，即如果主服务器down掉，哨兵会监听到并且通知一个从服务器使其成为主服务器。但是可以通过集群解决这一问题，即分别分配多组不同的主从服务器，并且每次存储的业务数据不同与存储的机器也不一样，也就是真正的分布式系统，大大提高了容错率，由于笔者目前只有两台linux服务器，所以只是在其中一台上通过建立6个目录来模拟集群，真正的集群是将目录换成机器<br>不多说，实践是检验真理的唯一标准</p>
<h4 id="集群搭建步骤"><a href="#集群搭建步骤" class="headerlink" title="集群搭建步骤"></a>集群搭建步骤</h4><p>第一步：创建一个文件夹redis-cluster，然后在其下面分别创建6个文件夹如下：</p>
<blockquote>
<p>1.mkdir -p /usr/local/redis-cluster<br>2.mkdir 1001,mkdir 1002,mkdir 1003,mkdir 1004,mkdir 1005,mkdir 1006</p>
</blockquote>
<p>第二步：把之前的redis.conf配置文件分别copy到1001-1006文件夹下，然后需要修改下面信息，</p>
<blockquote>
<p>1.daemonize yes 后端启动<br>2 port 700*（分别对每个机器的端口号设置，注意每个文件夹这里不一样）</p>
<ol>
<li>bind 127.0.0.1(绑定当前机器的ip)</li>
<li>dir /usr/local/redis-cluster/700<em>/（指定数据文件的存放位置，每个文件夹对应不同文件）<br>5.cluster-enabled yes(启动集群模式)<br>6.cluster-config-file nodes700</em>.conf(集群的配置文件)<br>7.cluster-node-timeout 15000 集群失效时间<br>8.appendonly yes 开启aof日志方式</li>
</ol>
</blockquote>
<p>第三步：安装ruby（针对不同的linux版本，命令不一样）</p>
<blockquote>
<p>sudo apt-get install ruby<br> sudo apt-get install rubygems<br> gem install redis</p>
</blockquote>
<p> 第四步：分别启动6个redis实例，然后检查是否启动成功</p>
<blockquote>
<p>/usr/local/redis3/bin/redis-server /usr/local/redis-cluster/700*/redis.conf<br> 同时redis的同一个服务，但是对于的redis.conf不同<br> 查看是否启动成功<br> ps -ef | grep redis</p>
</blockquote>
<p> 第五步：找到redis的安装目录，在src下找到redis-trib.rb文件</p>
<blockquote>
<p>./redis-trib.rb create–replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006<br> 其中参数1是主从对应关系，也就说前面三个是主，后面三个是从，是1:1</p>
</blockquote>
<p> 第六步：检测集群是否成功<br> 使用命令netstat -tunp | grep redis<br> 如果出现上面几个端口，证明集群成功</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在redis3.0之前，提供了哨兵的机制，即如果主服务器down掉，哨兵会监听到并且通知一个从服务器使其成为主服务器。但是可以通过集群解决这
    
    </summary>
    
      <category term="分布式" scheme="http://www.myzwl.win/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="redis" scheme="http://www.myzwl.win/source/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记之三</title>
    <link href="http://www.myzwl.win/2017/11/06/redis_3/"/>
    <id>http://www.myzwl.win/2017/11/06/redis_3/</id>
    <published>2017-11-06T06:48:51.000Z</published>
    <updated>2017-12-07T06:56:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="redis高级命令及特性"><a href="#redis高级命令及特性" class="headerlink" title="redis高级命令及特性"></a>redis高级命令及特性</h4><p>1.返回满足的所有键keys <em>（可以模糊匹配）<br>2.exists是否存在指定的key<br>3.expire设置某个key的过期时间，使用ttl查看剩余时间<br>4.persist取消过期时间<br><img src="/images/imgs5/19.jpg" alt="Alt text"><br>5.select 选择数据库 数据库为0到15（一共16个数据库）默认进入的是0数据库<br>6 move key [数据库下标]将当前数据库中的key转移到其他数据库中<br>7.randomkey 随机返回数据库里的一个key<br>8.rename 重命名key<br><img src="/images/imgs5/20.jpg" alt="Alt text"><br>9.dbsize 查看数据库的key数量<br>10.info获取数据库信息<br>11.config get </em>返回所有配置<br>12 flushdb清空当前数据库，flushall清空所有数据库</p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>通俗的讲就是一个用户访问一台服务器，该服务器假设为主服务器，具有读写功能，而在该主服务器下关联了一台从服务器，该从服务只具有读功能不具有写功能，并且数据是从主服务器经过一些列同步算法到该服务器上<br>配置过程</p>
<blockquote>
<p>1.修改redis.conf文件下<br>找到slaveof <masterip> <masterport><br>该服务器为从服务器</masterport></masterip></p>
</blockquote>
<p>主从复制对比<br><img src="/images/imgs5/21.jpg" alt="Alt text"><br>分析：<br>1.master可以拥有多个slave<br>2.多个slave可以连接同一个master外，还可以连接其他的slave<br>3.主从复制不会阻塞master在同步数据时，master可以据需处理client请求<br>4提供系统的伸缩性<br>主从复制过程<br>1.slave与master建立连接，发送sync同步命令<br>2.master会开启一个后台进程，将数据库快照保存到文件中，同时master主进程会开始收集新的写命令并缓存<br>3.后台完成保存后，就将文件发送给slave<br>4.slave将此文件保存在硬盘上</p>
<h4 id="redis持久化机制"><a href="#redis持久化机制" class="headerlink" title="redis持久化机制"></a>redis持久化机制</h4><p>redis需要经常将内存中的数据同步到硬盘来保证持久化<br>1.快照（默认方式）<br>将内存中以快照的方式写入到二进制文件中，默认为dump.rdb，可以通过配置设置自动做快照持久化的方式。可以配置redis在n秒内如果超过m个key则修改就自动做快照<br>具体配置如下</p>
<blockquote>
<p>save 900 1 #900秒内如果超过1个key被修改 则发起快照保存<br>save 300 10<br>save 60 10000</p>
</blockquote>
<p>2.aof（日志方式）<br>由于快照方式是在一定时间间隔做一次，所以可能发生redis意外down的情况就会丢失最后一次快照后的所有修改的数据。使用aof时，redis会将每一个收到的写命令都通过write函数追加到命令中<br>aof设置</p>
<blockquote>
<p>appendonly yes //启动aof，有三种修改方式</p>
<p>#appendfsync always//收到命令就立即写入到磁盘，效率最慢，但是保证完全的持久化</p>
<p>#appendysync everysec//每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中</p>
<p>#appendysync no //完全依赖os性能，持久化没保证</p>
</blockquote>
<p>如图<br><img src="/images/imgs5/22.jpg" alt="Alt text"><br>有了aof我们就可以利用主从复制保证数据的完整性了</p>
<h4 id="发布与订阅消息"><a href="#发布与订阅消息" class="headerlink" title="发布与订阅消息"></a>发布与订阅消息</h4><p>使用subscribe [频道] 进行订阅监听<br>使用publish [频道] [发布内容] 进行发布消息广播<br><img src="/images/imgs5/23.jpg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;redis高级命令及特性&quot;&gt;&lt;a href=&quot;#redis高级命令及特性&quot; class=&quot;headerlink&quot; title=&quot;redis高级命令及特性&quot;&gt;&lt;/a&gt;redis高级命令及特性&lt;/h4&gt;&lt;p&gt;1.返回满足的所有键keys &lt;em&gt;（可以模糊匹配）&lt;br
    
    </summary>
    
      <category term="分布式" scheme="http://www.myzwl.win/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="redis" scheme="http://www.myzwl.win/source/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>nginx笔记之一</title>
    <link href="http://www.myzwl.win/2017/11/06/Nginx_1/"/>
    <id>http://www.myzwl.win/2017/11/06/Nginx_1/</id>
    <published>2017-11-06T06:48:51.000Z</published>
    <updated>2017-12-02T17:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Nginx是一款轻量级的web服务器/反向代理服务器及电子邮件代理服务器，其特点是占有内存少，并发能力强可以反向代理和负载均衡等等，总之功能强大</p>
<h4 id="linux下环境搭建"><a href="#linux下环境搭建" class="headerlink" title="linux下环境搭建"></a>linux下环境搭建</h4><p>不多说，实践是检验真理的唯一标准。</p>
<blockquote>
<p>1.上传文件到服务器（我用的是nginx-1.6.2.tar。gz）<br>2解压到特定文件下，tar -zxvf nginx-1.6.2.tar.gz -C /usr/local<br>3.下载需要的依赖库文件<br>安装gcc g++的依赖库<br>apt-get install build-essential<br>apt-get install libtool<br>安装 pcre依赖库<br>sudo apt-get update<br>sudo apt-get install libpcre3 libpcre3-dev<br>安装 zlib依赖库<br>apt-get install zlib1g-dev<br>安装 ssl依赖库<br>apt-get install openssl<br>4在解压后的nginx目录下进行configure配置 ./configure –prefix=/usr/local/nginx-1.13.0(此处如果报错，可能是缺少依赖库)<br>5编译与安装 make&amp;&amp;make install<br>6.启动nginx，在nignx目录下主要有四个文件<br>conf配置文件、html网页文件、logs日志文件、sbin主要二进制程序<br>启动命令：在sbin目录下 ./nginx<br>关闭命令 ./nginx -s stop 重启 ./nginx -s reload<br>7测试 输入你的服务器ip地址，如果出现欢迎页面表示安装成功</p>
</blockquote>
<p><img src="/images/imgs5/17.jpg" alt="Alt text"></p>
<h4 id="nginx配置文件简单说明"><a href="#nginx配置文件简单说明" class="headerlink" title="nginx配置文件简单说明"></a>nginx配置文件简单说明</h4><p>基本上完玩nginx就是在玩配置，首先得先了解一下配置中的一些说明,主要在conf目录下的ngnx.conf里<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line">#user  nobody;</div><div class="line"></div><div class="line">#开启进程数 &lt;=CPU数 </div><div class="line">worker_processes  1;</div><div class="line"></div><div class="line">#错误日志保存位置</div><div class="line">#error_log  logs/error.log;</div><div class="line">#error_log  logs/error.log  notice;</div><div class="line">#error_log  logs/error.log  info;</div><div class="line"></div><div class="line">#进程号保存文件</div><div class="line">#pid        logs/nginx.pid;</div><div class="line"></div><div class="line">#每个进程最大连接数（最大连接=连接数x进程数）每个worker允许同时产生多少个链接，默认1024</div><div class="line">events &#123;</div><div class="line">    worker_connections  1024;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">http &#123;</div><div class="line">	#文件扩展名与文件类型映射表</div><div class="line">    include       mime.types;</div><div class="line">	#默认文件类型</div><div class="line">    default_type  application/octet-stream;</div><div class="line"></div><div class="line">	#日志文件输出格式 这个位置相于全局设置</div><div class="line">    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</div><div class="line">                      '$status $body_bytes_sent "$http_referer" '</div><div class="line">                      '"$http_user_agent" "$http_x_forwarded_for"';</div><div class="line"></div><div class="line">	#请求日志保存位置</div><div class="line">    #access_log  logs/access.log  main;</div><div class="line">	</div><div class="line">	#打开发送文件</div><div class="line">    sendfile        on;</div><div class="line">    #tcp_nopush     on;</div><div class="line"></div><div class="line">    #keepalive_timeout  0;</div><div class="line">	#连接超时时间</div><div class="line">    keepalive_timeout  65;</div><div class="line"></div><div class="line">	#打开gzip压缩</div><div class="line">    #gzip  on;</div><div class="line">	</div><div class="line">	#设定请求缓冲</div><div class="line">	#client_header_buffer_size 1k;</div><div class="line">	#large_client_header_buffers 4 4k;</div><div class="line">	</div><div class="line">	#设定负载均衡的服务器列表</div><div class="line">	#upstream myproject &#123;</div><div class="line">		#weigth参数表示权值，权值越高被分配到的几率越大</div><div class="line">		#max_fails 当有#max_fails个请求失败，就表示后端的服务器不可用，默认为1，将其设置为0可以关闭检查</div><div class="line">		#fail_timeout 在以后的#fail_timeout时间内nginx不会再把请求发往已检查出标记为不可用的服务器</div><div class="line">	#&#125;</div><div class="line">	</div><div class="line">    #webapp</div><div class="line">    #upstream myapp &#123;   </div><div class="line">  	# server 192.168.1.171:8080 weight=1 max_fails=2 fail_timeout=30s;   </div><div class="line">	# server 192.168.1.172:8080 weight=1 max_fails=2 fail_timeout=30s;   </div><div class="line">    #&#125; </div><div class="line"></div><div class="line">	#配置虚拟主机，基于域名、ip和端口</div><div class="line">    server &#123;</div><div class="line">		#监听端口</div><div class="line">        listen       80;</div><div class="line">		#监听域名</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        #charset koi8-r;</div><div class="line">		</div><div class="line">		#nginx访问日志放在logs/host.access.log下，并且使用main格式（还可以自定义格式）</div><div class="line">        #access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">		#返回的相应文件地址</div><div class="line">        location / &#123;</div><div class="line">            #设置客户端真实ip地址</div><div class="line">            #proxy_set_header X-real-ip $remote_addr;		</div><div class="line">			#负载均衡反向代理</div><div class="line">			#proxy_pass http://myapp;</div><div class="line">			</div><div class="line">			#返回根路径地址（相对路径:相对于/usr/local/nginx/）</div><div class="line">            root   html;</div><div class="line">			#默认访问文件</div><div class="line">            index  index.html index.htm;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">		#配置反向代理tomcat服务器：拦截.jsp结尾的请求转向到tomcat</div><div class="line">        #location ~ \.jsp$ &#123;</div><div class="line">        #    proxy_pass http://192.168.1.171:8080;</div><div class="line">        #&#125;		</div><div class="line">		</div><div class="line">        #error_page  404              /404.html;</div><div class="line">        # redirect server error pages to the static page /50x.html</div><div class="line">        #</div><div class="line">		</div><div class="line">		#错误页面及其返回地址</div><div class="line">        error_page   500 502 503 504  /50x.html;</div><div class="line">        location = /50x.html &#123;</div><div class="line">            root   html;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">   </div><div class="line"></div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	#虚拟主机配置：</div><div class="line">	server &#123;</div><div class="line">		listen 1234;</div><div class="line">		server_name zwl.com;</div><div class="line">		location / &#123;		</div><div class="line">						</div><div class="line">			root zwl.com;</div><div class="line">			index index.html;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">		#配置访问日志</div><div class="line">		access_log logs/zwl.com.access.log main;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><p>access_log logs/zwl.com.access.log main;<br>其中第二个是日志路径相对于conf的，可以自定义，第三个是日志格式与下面对应</p>
<blockquote>
<p>#日志文件输出格式 这个位置相于全局设置<br>    log_format  main  ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>                      ‘$status $body_bytes_sent “$http_referer” ‘<br>                      ‘“$http_user_agent” “$http_x_forwarded_for”‘;</p>
</blockquote>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p><img src="/images/imgs5/18.jpg" alt="Alt text"><br>通俗的讲就是我们访问代理服务器，然后代理服务器为我们选择访问哪台服务器<br>而正向代理就是我们访问另一台服务器，但是过程是通过访问另一台代理服务器，代理服务器访问目标服务器，然后把结果返回给源服务器<br>这里有一个问题，就是如果不设置的话，返还给tomcat的就是代理服务器的ip，所以需要设置</p>
<p> #设置客户端真实ip地址<br> proxy_set_header X-real-ip $remote_addr;<br> 通过&lt;%=request.getHeader(“X-real-ip”) %&gt;得到真实服务器ip地址<br>简单的代理就是在location中通过关键字配置</p>
<blockquote>
<pre><code>location / {
     root   html;
     index  index.html index.htm;
 }
</code></pre><p>location /test  {<br> proxy_pass <a href="http://111.230.246.xx:8080/libra/" target="_blank" rel="external">http://111.230.246.xx:8080/libra/</a>;<br>}</p>
</blockquote>
<p>其中 location后面的配置可以使用正则表达式进行配置，这里含义是<a href="http://111.230.246.xx/与http://111.230.246.xx/test代理到不同的网址" target="_blank" rel="external">http://111.230.246.xx/与http://111.230.246.xx/test代理到不同的网址</a></p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>通俗的讲就是访问量大了，分担给其它服务器。nginx的负载均衡也是配置一下</p>
<blockquote>
<p>#设定负载均衡的服务器列表</p>
<pre><code>#upstream myproject {
    #weigth参数表示权值，权值越高被分配到的几率越大
    #max_fails 当有#max_fails个请求失败，就表示后端的服务器不可用，默认为1，将其设置为0可以关闭检查
    #fail_timeout 在以后的#fail_timeout时间内nginx不会再把请求发往已检查出标记为不可用的服务器
#}    
#webapp
#upstream myapp {   
  # server 192.168.1.171:8080 weight=1 max_fails=2 fail_timeout=30s;   
# server 192.168.1.172:8080 weight=1 max_fails=2 fail_timeout=30s;   
#} 
</code></pre></blockquote>
<p> 其中第二参数是带负载的服务器，其他参数的策略不止这些，这里只是简单的策略</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> nginx的功能远不止这些，它是一个高性能的服务器架设<br> 对于高性能网站 ,请求量大，可以通过nginx的一下方法支撑<br>1动静分离，在nginx里建立一个静态资源站点<br>2: 利用浏览器缓存等,减少查询.<br>3.对于不可避免的请求—-服务器集群+负载均衡来支撑.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Nginx是一款轻量级的web服务器/反向代理服务器及电子邮件代理服务器，其特点是占有内存少，并发能力强可以反向代理和负载均衡等等，总之功能
    
    </summary>
    
      <category term="分布式" scheme="http://www.myzwl.win/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="nginx" scheme="http://www.myzwl.win/source/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记之二</title>
    <link href="http://www.myzwl.win/2017/11/05/redis_2/"/>
    <id>http://www.myzwl.win/2017/11/05/redis_2/</id>
    <published>2017-11-05T06:48:51.000Z</published>
    <updated>2017-12-02T17:14:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Jedis初识"><a href="#Jedis初识" class="headerlink" title="Jedis初识"></a>Jedis初识</h4><p>通俗的讲就是通过java代码来操作redis<br>首先需要导入common-pool.jar会让jedis-2.7.0.jar<br>单实例连接</p>
<blockquote>
<p>//设置ip的端口号，已经开启linux上redis远程连接<br>Jedis redis=new Jedis(“111.230.246.xx”, 6379);<br>//设置数据<br>redis.set(“zwl”, “hello world”);<br>//获取数据，此时已经在linux客户端设置了键name的值<br>System.out.println(redis.get(“zwl”));<br>System.out.println(redis.get(“name”));<br>//释放资源<br>redis.close();</p>
</blockquote>
<p>连接池连接</p>
<blockquote>
<p>   //获取连接池配置对象，设置配置项<br>        JedisPoolConfig config=new JedisPoolConfig();<br>        //最大连接数<br>        config.setMaxTotal(30);<br>        //最大空闲连接数<br>        config.setMaxIdle(10);<br>        //获取连接池<br>        JedisPool jedispool=new JedisPool(config, “111.230.246.33”, 6379);<br>       //获取核心对象<br>        Jedis jedis=null;<br>        try {<br>            jedis=jedispool.getResource();<br>            jedis.set(“age”, “18”);<br>            System.out.println(jedis.get(“age”));<br>        } catch (Exception e) {<br>            // TODO: handle exception<br>        }finally{<br>            if(jedis!=null){<br>                jedis.close();<br>            }<br>            if(jedispool!=null)<br>                jedispool.close();<br>        }<br>    }</p>
</blockquote>
<p>当然jedis有很多接口，目前只应用一小部分</p>
<h4 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h4><p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这    便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。    在Redis中字符串类型的Value最多可以容纳的数据长度是512M<br><img src="/images/imgs5/9.jpg" alt="Alt text"><br>1）set key value：设定key持有指定的字符串value，如果该key存在则进行覆盖    操作。总是返回”OK”<br>2）get key：获取key的value。如果与该key关联的value不是String类型，redis    将返回错误信息，因为get命令只能用于获取String value；如果该key不存在，返回null。<br>3）getset key value：先获取该key的值，然后在设置该key的值。<br>4）incr key：将指定的key的value原子性的递增1.如果该key不存在，其初始值    为0，在incr之后其值为1。如果value的值不能转成整型，如hello，该操作将执    行失败并返回相应的错误信息。<br>5）decr key：将指定的key的value原子性的递减1.如果该key不存在，其初始值    为0，在incr之后其值为-1。如果value的值不能转成整型，如hello，该操作将执    行失败并返回相应的错误信息。<br><img src="/images/imgs5/10.jpg" alt="Alt text"></p>
<h4 id="存储list类型"><a href="#存储list类型" class="headerlink" title="存储list类型"></a>存储list类型</h4><p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表    一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不    存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移    除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是    4294967295<br><img src="/images/imgs5/11.jpg" alt="Alt text"><br>1）lpush key value1 value2…：在指定的key所关联的list的头部插入所有的    values，如果该key不存在，该命令在插入的之前创建一个与该key关联的空链    表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。<br>2）rpush key value1、value2…：在该list的尾部添加元素<br>3）lrange key start end：获取链表中从start到end的元素的值，start、end可    为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推…<br>4）lpushx key value：仅当参数中指定的key存在时（如果与key管理的list中没    有值时，则该key是不存在的）在指定的key所关联的list的头部插入value。<br>5）rpushx key value：在该list的尾部添加元素<br>6）lpop key：返回并弹出指定的key关联的链表中的第一个元素，即头部元素。<br>7）rpop key：从尾部弹出元素。<br><img src="/images/imgs5/12.jpg" alt="Alt text"></p>
<h4 id="存储sets类型"><a href="#存储sets类型" class="headerlink" title="存储sets类型"></a>存储sets类型</h4><p>在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我    们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要    说明的是，这些操作的时间是常量时间。Set可包含的最大元素数是4294967295<br>和List类型不同的是，Set集合中不允许出现重复的元素。和List类型相比，Set类    型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计    算操作，如unions、intersections和differences。由于这些操作均在服务端完成，    因此效率极高，而且也节省了大量的网络IO开销<br>1）sadd key value1、value2…：向set中添加数据，如果该key的值已有则不会      重复添加<br>2）smembers key：获取set中所有的成员<br>3）scard key：获取set中成员的数量<br>4）sismember key member：判断参数中指定的成员是否在该set中，1表示存      在，0表示不存在或者该key本身就不存在<br>5）srem key member1、member2…：删除set中指定的成员<br>6）srandmember key：随机返回set中的一个成员<br>7）sdiff sdiff key1 key2：返回key1与key2中相差的成员，而且与key的顺序有      关。即返回差集<br>8）sdiffstore destination key1 key2：将key1、key2相差的成员存储在              destination上<br>9）sinter key[key1,key2…]：返回交集。<br>10）sinterstore destination key1 key2：将返回的交集存储在destination上<br>11）sunion key1、key2：返回并集。</p>
<h4 id="存储sortedset"><a href="#存储sortedset" class="headerlink" title="存储sortedset"></a>存储sortedset</h4><p>Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出    现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分    数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然    而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)    却是可以重复的。<br>1）zadd key score member score2 member2 … ：将所有成员以及该成员的        分数存放到sorted-set中<br>2）zcard key：获取集合中的成员数量<br>3）zcount key min max：获取分数在[min,max]之间的成员<br>zincrby key increment member：设置指定成员的增加的分数。<br>zrange key start end [withscores]：获取集合中脚标为start-end的成员，[withscores]参数表明返回的成员包含其分数。<br>zrangebyscore key min max [withscores] [limit offset count]：返回分数在[min,max]的成员并按照分数从低到高排序。[withscores]：显示分数；[limit offset count]：offset，表明从脚标为offset的元素开始并返回count个成员。<br>zrank key member：返回成员在集合中的位置。<br>zrem key member[member…]：移除集合中指定的成员，可以指定多个成员。<br>zscore key member：返回指定成员的分数</p>
<h4 id="存储hash"><a href="#存储hash" class="headerlink" title="存储hash"></a>存储hash</h4><p>Redis中的Hashes类型可以看成具有String Key和String Value的map容器。所    以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果    Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash    可以存储4294967295个键值对。<br><img src="/images/imgs5/13.jpg" alt="Alt text"><br>1）hset key field value：为指定的key设定field/value对（键值对）。<br>  2）hgetall key：获取key中的所有filed-vaule<br>3）hget key field：返回指定的key中的field的值<br>4）hmset key fields：设置key中的多个filed/value<br>5）hmget key fileds：获取key中的多个filed的值<br>6）hexists key field：判断指定的key中的filed是否存在<br>7）hlen key：获取key所包含的field的数量<br>8）hincrby key field increment：设置key中filed的值增加increment，如：age增加20<br><img src="/images/imgs5/14.jpg" alt="Alt text"></p>
<h4 id="keys的通用操作"><a href="#keys的通用操作" class="headerlink" title="keys的通用操作"></a>keys的通用操作</h4><p>key pattern：获取所有与pattern匹配的key，返回所有与该key匹配的keys，*表示所有，？表示任意一个<br><img src="/images/imgs5/15.jpg" alt="Alt text"></p>
<h4 id="redis特性"><a href="#redis特性" class="headerlink" title="redis特性"></a>redis特性</h4><p>一个redis实例可以包括多个数据库，客户端可以连接某个redis实例的哪个数据库，就好比一个mysql中创建多个数据库，客户端连接时指定哪个数据库，一个redis最多提供16个数据库，默认是第0个数据库，命令太多，就不罗列了</p>
<h4 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h4><p>multi：开启事务用于标记事物的开始，其后执行的命令都将被存入命令队列，直到执行exec时，这些命令才会被原子的执行，类似关系型数据库中的begin transaction<br>exec：提交事务，类似commit<br>discard：类似rollback<br><img src="/images/imgs5/16.jpg" alt="Alt text"></p>
<h4 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h4><p>redis的高性能是由于其将所有数据存储在内存中，为了使redis重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，就是持久化，有两种持久化方式<br>1.RDB持久化（默认）<br>在指定的时间间隔内将内存中的数据快照写入磁盘<br>2。AOF持久化<br>以日志的形式记录服务器所处理的每一个操作，在redis服务器启动之初会读取该文件来重构数据库</p>
<p>RDB优势<br>1.性能最大化，避免每次都进行io操作<br>2,。如果数据集很大，启动效率更高<br>劣势：<br>会出现数据丢失</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>redis的功能和内容是丰富和强大的，这里只是做了一个最简单的总结</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Jedis初识&quot;&gt;&lt;a href=&quot;#Jedis初识&quot; class=&quot;headerlink&quot; title=&quot;Jedis初识&quot;&gt;&lt;/a&gt;Jedis初识&lt;/h4&gt;&lt;p&gt;通俗的讲就是通过java代码来操作redis&lt;br&gt;首先需要导入common-pool.jar会让j
    
    </summary>
    
      <category term="分布式" scheme="http://www.myzwl.win/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="redis" scheme="http://www.myzwl.win/source/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记之一</title>
    <link href="http://www.myzwl.win/2017/11/04/redis_1/"/>
    <id>http://www.myzwl.win/2017/11/04/redis_1/</id>
    <published>2017-11-04T06:48:51.000Z</published>
    <updated>2017-12-02T17:14:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介"></a>NoSQL简介</h4><p>全称是Not Only SQL,泛指菲关系型数据库，它是通过键值对存储数据并且将数据存储在内存中。而像mysql，sql server这些通过关系表存数据的就叫关系型数据库</p>
<h4 id="为什么需要NoSQL"><a href="#为什么需要NoSQL" class="headerlink" title="为什么需要NoSQL"></a>为什么需要NoSQL</h4><p>主要传统的关系型数据库暴露了许多问题<br>1.对数据库高并发读写的需求<br>高并发就是同一时间有许多用户访问同一网站造成访问量太大容易造成服务器崩溃，而传统的解决方法就是搭建集群，通俗的讲就是原先一个服务器提供服务，现在变成多个服务器提供服务</p>
<p>2.高负载-对海量数据的高效率存储和访问的需求<br>通俗的讲就是数据量非常大，造成没地方存储或者访问查询sql的语句超过上千万造成查询非常低下</p>
<p>3.高扩展-对数据库的高可扩展性和高可用性的需求<br>通俗的讲相当于银行窗口排队，刚开始一个窗口不能满足需求，后来增加多个窗口，而增加窗口不会造成业务上的不同，也就是集群起来很方便</p>
<h4 id="主流的NoSQL产品"><a href="#主流的NoSQL产品" class="headerlink" title="主流的NoSQL产品"></a>主流的NoSQL产品</h4><p>主要有四大类<br>1.键值（key-value）存储数据库<br>主流产品：redis<br>典型应用：内容缓存，主要用于处理大量数据的高访问负载<br>优势：快速查询<br>劣势：存储的数据缺少结构化</p>
<p>2.列存储数据库<br>主流产品：HBase<br>典型应用：分布式的文件系统<br>优势：查询速度快，可扩展性强，更容易进行分布式扩展<br>劣势：功能相对局限</p>
<p>3.文档数据库<br>主流产品：MongoDB<br>典型应用：web应用<br>优势：数据结构要求不严格<br>劣势：查询效率不高，而且缺乏统一的查询语法</p>
<p>4.图形数据库<br>主流产品：Neo4j<br>典型应用：社交网络<br>优势：利用图结构相关算法<br>劣势：不容易做分布式集群的方案</p>
<h4 id="NoSQL特点"><a href="#NoSQL特点" class="headerlink" title="NoSQL特点"></a>NoSQL特点</h4><p>在大数据存取上具备关系型数据库无法比拟的性能优势<br>1.易扩展<br>2.大数据量，高性能<br>3.灵活的数据模型<br>4.高可用</p>
<h4 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h4><p>redis是用c语言开发的一个开源的高性能键值对数据库它通过提供多种键值数据类型来适应不同场景下的存储需求，主要支持字符串、散列、列表、集合、有序集合数据类型<br>主要应用在如下场景<br>1.缓存（数据查询、商品内容等等）<br>2.聊天室的在线好友列表<br>3.任务队列（秒杀、抢购等等）<br>4.应用排行榜<br>5.网站访问统计<br>6.数据过期处理<br>7.分布式集群架构中的session分离</p>
<h4 id="redis的环境搭建"><a href="#redis的环境搭建" class="headerlink" title="redis的环境搭建"></a>redis的环境搭建</h4><p>在windows下很方便，直接解压windows版本redis，里面有个服务端和客户端，先开启服务端，在操控客户端即可<br>下面是在linux下的redis安装</p>
<blockquote>
<p>1.将redis-3.0.0.tar.gz上传到Linux系统中<br>2.安装gcc编译环境 sudo apt-get install gcc<br>3.解压到/usr/local下  tar -xvf redis-3.0.0.tar.gz -C /usr/local<br>4）进入redis-3.0.0目录 使用make命令编译redis<br>5.在redis-3.0.0目录中 使用make PREFIX=/usr/local/redis install命令安装redis到/usr/local/redis中<br>6）拷贝redis-3.0.0中的redis.conf到安装目录redis中<br>7）启动redis 在bin下执行命令redis-server redis.conf<br>8.测试，开启另一个客户端，在bin目录下执行 ./redis-cli<br>如果出现ip号则证明安装成功</p>
</blockquote>
<p>这里需要改进的几个地方，服务端是在前端启动应改为后端启动，可以通过修改配置文件 配置redis后台启动，即服务器启动了但不会    穿件控制台窗口<br>将redis.conf文件中的daemonize从false修改成true表示后台启动<br>如需远程连接redis，需配置redis端口6379在linux防火墙中开发<br>/sbin/iptables -I INPUT -p tcp –dport 6379 -j ACCEPT<br>最后通过测试发现远程连接也成功了</p>
<h4 id="redis停止"><a href="#redis停止" class="headerlink" title="redis停止"></a>redis停止</h4><p>有两种方法，一种是空过查询进程pid，然后杀死进程<br>ps -ef | grep redis<br>kill -9 pid</p>
<p>另一种是在客户端通过<br>shutdown命令关闭redis</p>
<p><img src="/images/imgs5/8.jpg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NoSQL简介&quot;&gt;&lt;a href=&quot;#NoSQL简介&quot; class=&quot;headerlink&quot; title=&quot;NoSQL简介&quot;&gt;&lt;/a&gt;NoSQL简介&lt;/h4&gt;&lt;p&gt;全称是Not Only SQL,泛指菲关系型数据库，它是通过键值对存储数据并且将数据存储在内存中。而
    
    </summary>
    
      <category term="分布式" scheme="http://www.myzwl.win/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="redis" scheme="http://www.myzwl.win/source/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云linux服务器上搭建javaweb站点</title>
    <link href="http://www.myzwl.win/2017/11/03/linux_2/"/>
    <id>http://www.myzwl.win/2017/11/03/linux_2/</id>
    <published>2017-11-03T06:48:51.000Z</published>
    <updated>2017-11-30T05:20:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我一直坚信没有过程就不会有好的结果。回顾大学期间的学习历程，关于别人访问自己的站点，从刚开始的基于swing的cs系统，到基于socket的聊天框，再到局域网访问的web与在分别虚拟机和双系统的linux下搭建web，到后来基于nat123的p2p访问，再到后来阿里云的window8 server服务器搭建java web站点，到最后的腾讯云linux服务器集成，每一次的探索，都是与踩坑做斗战，也是进步最快的方法。不多说，这里记录一下之前搭建的步骤</p>
<h4 id="远程连接工具"><a href="#远程连接工具" class="headerlink" title="远程连接工具"></a>远程连接工具</h4><p>故名思议，举世通过远程的方式去连接Linux并操作它，Linux远程的操作工具有很多。像xshell、Puttty、secureCRT、SSH Secure等，一般情况下习惯用命令去控制，所以这里选择了SSH Secure。该工具是免费的图形化界面及命令行窗口集一身的远程工具，具体可以去网上下载。</p>
<h4 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h4><p>步骤：<br>1）查看当前Linux系统是否已经安装java<br>输入 rpm -qa | grep java<br>2）卸载两个openJDK<br>输入rpm -e –nodeps 要卸载的软件<br>如果未安装直接跳过前面两个步骤<br>3）上传jdk到linux（我的是Ubuntu Server 16.04.1 LTS 64位注意版本问题）<br>4.解压jdk到/usr/local下 tar –xvf jdk-7u71-linux-i586.tar.gz –C /usr/local<br>5 配置jdk环境变量，打开/etc/profile配置文件，将下面配置拷贝进去，这个一定要用vi打开，gedit可能会不行</p>
<blockquote>
<p>#set java environment<br>    JAVA_HOME=/usr/local/jdk1.7.0_71<br>    CLASSPATH=.:$JAVA_HOME/lib.tools.jar<br>    PATH=$JAVA_HOME/bin:$PATH<br>    export JAVA_HOME CLASSPATH PATH</p>
</blockquote>
<p>6）重新加载/etc/profile配置文件 source /etc/profile</p>
<h4 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h4><p>必选要先安装jdk<br>1）上传Tomcat到linux上<br>2）解压Tomcat到/usr/local下<br>3.cd 到/usr/local下，将apache-tomcat-7.0.57改名成tomcat，为了方便，可自定义名<br>mv apache-tomcat-7.0.57 tomcat<br>4.开放Linux的对外访问的端口8080<br>/sbin/iptables -I INPUT -p tcp –dport 8080 -j ACCEPT<br>/etc/rc.d/init.d/iptables save 关闭防火墙，这里不成功没关系，我的没成功但是可以正常运行<br>5）启动关闭Tomcat<br>进入tomcat的bin下启动：./startup.sh<br>进入tomcat的bin下关闭：./shutdown.sh</p>
<h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><p>1 sudo apt-get install mysql-server<br>运行完这句命令后，不是root的话会要你输入root密码，密码输入正确后，系统就自动给你下载MySQL了<br>2.授权用户，并允许远程登录<br>mysql -u root -p<br>系统会要你输入密码，密码输入无误后，进入MySQL<br>远程登录mysql的权限<br>登录mysql后输入如下命令：<br>grant all privileges on <em>.</em> to ‘账户名称’ @’%’ identified by ‘密码’;<br>然后更新数据库<br>flush privileges;<br>用管理员权限编辑一下文件<br>sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf<br>添加’#’注释掉其中的”bind-address = 127.0.0.1”<br>注释后:wq保存，重启MySQL服务：<br>service mysql restart<br>但是这里仍然不能远程连接，后来找到了解决办法<br>更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”:<br>切换数据库,<br>mysql&gt;use mysql;<br>查看root账号的登录权限,<br>mysql&gt;select host, user from user;<br>修改登录权限<br>mysql&gt;update user set host = ‘%’ where user = ‘root’;<br>刷新,生效,最后一步,至关重要<br>mysql&gt;flush   privileges;</p>
<p>最后解决了</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>有时候别人的步骤不一定适合你，造成很多时候都需要自己去踩坑，去探索。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;我一直坚信没有过程就不会有好的结果。回顾大学期间的学习历程，关于别人访问自己的站点，从刚开始的基于swing的cs系统，到基于socket的
    
    </summary>
    
      <category term="linux" scheme="http://www.myzwl.win/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.myzwl.win/source/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux命令小结</title>
    <link href="http://www.myzwl.win/2017/11/02/linux_1/"/>
    <id>http://www.myzwl.win/2017/11/02/linux_1/</id>
    <published>2017-11-02T06:48:51.000Z</published>
    <updated>2017-11-29T07:43:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><img src="/images/imgs5/5.jpg" alt="Alt text"></p>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>cd 进入某个目录。 如cd use<br>cd ../    切换到上一层目录<br>cd /    切换到系统根目录<br>cd ~    切换到用户主目录<br>cd -    切换到上一个所在目录</p>
<h4 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h4><p>mkdir 创建文件夹<br>rmdir 删除文件夹 文件夹有内容时不可删</p>
<h4 id="查看目录"><a href="#查看目录" class="headerlink" title="查看目录"></a>查看目录</h4><p>ls 看到该目录下的所有的目录和文件<br>ls -a 可以看到该目录下的所有文件和目录，包括隐藏的<br>ls -l或者ll或者ls -alh 可以看到该目录下的所有目录和文件的详细信息<br>ls z* 显示所有文件名以z开头的文件<br>ls z? 显示文件名只有两个字母且第一个字符为z的文件<br>ls &gt;2.txt 重定向 将ls的内容显示在2.txt中<br>ls &gt;&gt;2.txt 将ls的内容追加在2.txt中</p>
<h4 id="寻找目录"><a href="#寻找目录" class="headerlink" title="寻找目录"></a>寻找目录</h4><p>find ./ -name ‘zw*’ 显示当前目录下文件名以zw的开头的文件</p>
<h4 id="修改目录的名称"><a href="#修改目录的名称" class="headerlink" title="修改目录的名称"></a>修改目录的名称</h4><p>mv 目录名称 新目录名称<br>如 mv zwl zwlzwl<br>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进重命名的操作</p>
<h4 id="移动目录的位置—剪切"><a href="#移动目录的位置—剪切" class="headerlink" title="移动目录的位置—剪切"></a>移动目录的位置—剪切</h4><p>mv 目录名称 目录的新位置<br>如 mv 1.txt ../<br>注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</p>
<h4 id="拷贝与删除目录"><a href="#拷贝与删除目录" class="headerlink" title="拷贝与删除目录"></a>拷贝与删除目录</h4><p>cp 复制文件，格式：cp 源文件 目标文件<br>rm 删除文件 （rm 文件夹 -r 递归删除文件夹内所有内容，并删除文件夹）<br>强制删除，使用rm -rf newTest</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>touch 1.txt 创建1.txt文件<br>cat 1.txt 查看1.txt里的内容<br>more 1.txt 1.txt内容过多时，分页显示<br>less 1.txt，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看<br>tail -10 1.txt 查看后10行，Ctrl+C结束</p>
<h4 id="解压打包"><a href="#解压打包" class="headerlink" title="解压打包"></a>解压打包</h4><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。<br>命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件<br>tar -zcvf xxx.tar.gz aaa.txt bbb.txt ccc.txt<br>或：tar -zcvf xxx.tar.gz /test/*<br>解压压缩包<br>tar -zxvf FileName.tar.gz 压缩到本目录<br>tar -zxvf xxx.tar.gz -C /usr——C代表指定解压的位置</p>
<h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><p>pwd 显示当前所在位置<br>grep 要搜索的字符串 要搜索的文件 –color（搜索命令）<br>ps -ef 查看当前系统中运行的进程<br>kill -9 进程的pid 强制杀死某进程<br>命令：|   将前一个命令的输出作为本次目录的输入<br>如 ps -ef | grep system 查看当前系统中所有的进程中包括system字符串的进程<br>ifconfig  查看当前系统的网卡信息<br>ping 查看与某台机器的连接情况<br>netstat -an 查看当前系统的端口使用</p>
<h4 id="Linux的权限命令"><a href="#Linux的权限命令" class="headerlink" title="Linux的权限命令"></a>Linux的权限命令</h4><p>之前用ll的命令可以查看文件的详细信息<br><img src="/images/imgs5/6.jpg" alt="Alt text"><br>d：代表目录<br>-：代表文件<br>l：代表链接（可以认为是window中的快捷方式）<br>后面的9位分为3组，每3位置一组，分别代表属主的权限，与当前用户同组的    用户的权限，其他用户的权限<br>r：代表权限是可读，r也可以用数字4表示<br>w：代表权限是可写，w也可以用数字2表示<br>x：代表权限是可执行，x也可以用数字1表示<br><img src="/images/imgs5/7.jpg" alt="Alt text"><br>修改文件/目录的权限的命令：chmod<br>chmod u=rwx，g=rw，o=r 1.txt<br>或者 chmod 764 2.txt</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/imgs5/5.jpg&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;cd&quot;
    
    </summary>
    
      <category term="linux" scheme="http://www.myzwl.win/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.myzwl.win/source/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>浅谈lucene</title>
    <link href="http://www.myzwl.win/2017/11/01/lucene_1/"/>
    <id>http://www.myzwl.win/2017/11/01/lucene_1/</id>
    <published>2017-11-01T06:48:51.000Z</published>
    <updated>2017-11-27T05:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不知不觉，从九月份后就已经很少写博总结了，有点小颓废了。好吧，回到正题，本着应用为主，了解原理为辅的原则总结。<br>以我的微型论坛中的文章内容检索为例作为应用<a href="http://www.slycmiaoxi.xyz" target="_blank" rel="external">网站链接</a></p>
<h4 id="全文检索定义"><a href="#全文检索定义" class="headerlink" title="全文检索定义"></a>全文检索定义</h4><p>全文检索首先对要搜索的文档进行分词，然后形成索引，通过查询索引来查询文档，比如：字典<br>字典的偏旁部首页，就类似于luence的索引<br>字典的具体内容，就类似于luence的文档内容<br>同时，Lucene是一个工具包，它不能独立运行，不能单独对外提供服务。说白了，就是几个jar包</p>
<h4 id="Lucene实现全文检索的流程"><a href="#Lucene实现全文检索的流程" class="headerlink" title="Lucene实现全文检索的流程"></a>Lucene实现全文检索的流程</h4><p><img src="/images/imgs5/1.jpg" alt="Alt text"><br>其主要分为索引流程和搜索流程<br>索引流程：采集数据—文档处理-存储到索引库中<br>搜索流程：输入查询条件—通过lucene的查询器查询索引—从索引库中取出结果</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>需求：对进入论坛的所有文章进行全文检索<br>首先我们利用jdbc采集数据库，为了方便直接利用中文查询器，只贴出核心代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public interface LuceneService &#123;</div><div class="line">	    //初始化采集本地数据</div><div class="line">		public void getIndex() throws Exception;</div><div class="line">		//增加一个term到本地数据</div><div class="line">		public void addIndex(Comment bc)  throws Exception ;</div><div class="line">		//删除一个term</div><div class="line">		public void deleteIndex(String blogId) throws Exception;</div><div class="line">		//更新本地数据</div><div class="line">		public void updateIndex(Blogcomment bc) throws Exception;</div><div class="line">		//根据条件查询数据		</div><div class="line">		public List&lt;Comment&gt; findAllIndex(String q)throws Exception;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 评论实体类</div><div class="line"> * @author zwl</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class Comment &#123;</div><div class="line">	</div><div class="line">    private Date commentDate;</div><div class="line">    </div><div class="line">	private String content;</div><div class="line">	</div><div class="line">	private int id;</div><div class="line">	</div><div class="line">	private String title;</div><div class="line">	</div><div class="line">	private String userIp;</div><div class="line">	</div><div class="line">	private String username;</div><div class="line">	</div><div class="line">	private int hasread;    //访问量</div><div class="line">	</div><div class="line">	private int state;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是其实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div></pre></td><td class="code"><pre><div class="line">@Service("luceneService")</div><div class="line">public class LuceneServiceImpl implements LuceneService &#123;</div><div class="line"></div><div class="line">	@Resource</div><div class="line">	private CommentMapper commentMapper;</div><div class="line">	</div><div class="line">	private Directory dir;</div><div class="line">	</div><div class="line">	//得到索引维护核心对象</div><div class="line">	private IndexWriter getWriter() throws Exception &#123;</div><div class="line">		File indexFile = new File("C:\\lucene\\");</div><div class="line">		Directory d=FSDirectory.open(indexFile);</div><div class="line">		 Analyzer analyzer =new IKAnalyzer();</div><div class="line">		 IndexWriterConfig conf=new IndexWriterConfig(Version.LUCENE_4_9_1, analyzer);</div><div class="line">			IndexWriter write=new IndexWriter(d, conf);</div><div class="line">			return write;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">	public void addIndex(Comment bc)  throws Exception &#123;</div><div class="line">		IndexWriter write=getWriter();</div><div class="line">		Document document=new Document();</div><div class="line">		</div><div class="line">		// store:如果是yes，则说明存储到文档域中</div><div class="line">		Field id=new TextField("id",String.valueOf(bc.getId()), Store.YES);</div><div class="line">		Field username=new TextField("username",bc.getUsername(),Store.YES);</div><div class="line">		Field blogCommentDate=new TextField("commentDate",bc.getCommentDate().toLocaleString(),Store.YES);</div><div class="line">		Field content=new TextField("content",bc.getContent(),Store.YES);</div><div class="line">		Field title=new TextField("title",bc.getTitle(),Store.YES);</div><div class="line">		Field hasread=new TextField("hasread",bc.getHasread()+"",Store.YES);</div><div class="line">		Field state=new TextField("state",bc.getState()+"",Store.YES);	</div><div class="line">	             </div><div class="line">     // 将field域设置到Document对象中</div><div class="line">		document.add(id);</div><div class="line">		document.add(username);</div><div class="line">		document.add(blogCommentDate);</div><div class="line">		document.add(content);</div><div class="line">		document.add(title);</div><div class="line">		document.add(hasread);</div><div class="line">		document.add(state);</div><div class="line">					</div><div class="line">					write.addDocument(document);</div><div class="line">	             write.close();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public List&lt;Comment&gt; findAllIndex(String q)throws Exception&#123;</div><div class="line">		File indexFile = new File("C:\\lucene\\");</div><div class="line">		dir=FSDirectory.open(indexFile);</div><div class="line">		IndexReader reader = DirectoryReader.open(dir);</div><div class="line">		IndexSearcher searcher = new IndexSearcher(reader);</div><div class="line">		QueryParser parser = new QueryParser("content",</div><div class="line">				 new IKAnalyzer());</div><div class="line">		Query query = parser.parse(q);</div><div class="line">		TopDocs topDocs = searcher.search(query, 5);</div><div class="line">		List&lt;Comment&gt; list=new ArrayList&lt;Comment&gt;();</div><div class="line">		Comment cc=null;</div><div class="line">		// 根据查询条件匹配出的记录总数</div><div class="line">		int count = topDocs.totalHits;</div><div class="line">		System.out.println("匹配出的记录总数:" + count);</div><div class="line">		// 根据查询条件匹配出的记录</div><div class="line">		ScoreDoc[] scoreDocs = topDocs.scoreDocs;</div><div class="line">		for (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">			// 获取文档的ID</div><div class="line">			int docId = scoreDoc.doc;</div><div class="line">			// 通过ID获取文档</div><div class="line">			Document doc = searcher.doc(docId);</div><div class="line">			cc=new Comment();</div><div class="line">			cc.setId(Integer.parseInt(doc.get("id")));</div><div class="line">			cc.setUsername( doc.get("username"));</div><div class="line">			cc.setTitle(doc.get("title"));</div><div class="line">			cc.setCommentDate(DateUtil.formatString(doc.get("commentDate"),"yyyy-MM-dd HH:mm"));</div><div class="line">			cc.setHasread(Integer.parseInt(doc.get("hasread")));	 </div><div class="line">		    cc.setContent(doc.get("content"));</div><div class="line">		    list.add(cc);</div><div class="line">		&#125;</div><div class="line">		// 关闭资源</div><div class="line">		reader.close();</div><div class="line">	return list;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//删除指定博客的索引</div><div class="line">			public void deleteIndex(String blogId) throws Exception &#123;</div><div class="line">				IndexWriter write=getWriter();</div><div class="line">				write.deleteDocuments(new Term("id",blogId));</div><div class="line">				write.commit();</div><div class="line">				write.close();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			//更新博客索引</div><div class="line">			public void updateIndex(Blogcomment bc) throws Exception &#123;</div><div class="line">				IndexWriter write=getWriter();</div><div class="line">				Document document=new Document();</div><div class="line">				</div><div class="line">				// store:如果是yes，则说明存储到文档域中</div><div class="line">							Field id=new TextField("id",String.valueOf(bc.getId()), Store.YES);</div><div class="line">							Field username=new TextField("username",bc.getUsername(),Store.YES);</div><div class="line">							Field blogCommentDate=new TextField("blogCommentDate",bc.getBlogCommentDate().toLocaleString(),Store.YES);</div><div class="line">							Field comments=new TextField("comments",bc.getComments(),Store.YES);</div><div class="line">							Field title=new TextField("title",bc.getComment().getTitle(),Store.YES);</div><div class="line">							Field hasread=new TextField("hasread",bc.getComment().getHasread()+"",Store.YES);</div><div class="line">							Field cid=new TextField("cid",bc.getComment().getId()+"",Store.YES);	</div><div class="line">			             </div><div class="line">							// 将field域设置到Document对象中</div><div class="line">							document.add(id);</div><div class="line">							document.add(username);</div><div class="line">							document.add(blogCommentDate);</div><div class="line">							document.add(comments);</div><div class="line">							document.add(title);</div><div class="line">							document.add(hasread);</div><div class="line">							document.add(cid);</div><div class="line">							</div><div class="line">							write.updateDocument(new Term("id",bc.getId()+""), document);</div><div class="line">			               write.close();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">	//初始化采集本地数据</div><div class="line">	public void getIndex() throws Exception&#123;</div><div class="line">	</div><div class="line">		// 采集数据</div><div class="line">				List&lt;Comment&gt; list=commentMapper.readAll();</div><div class="line">				</div><div class="line">				// 将采集到的数据封装到Document对象中</div><div class="line">				List&lt;Document&gt; docList=new ArrayList&lt;Document&gt;();</div><div class="line">				Document document=null;</div><div class="line">				for(Comment bc:list)&#123;</div><div class="line">					document=new Document();</div><div class="line">					// store:如果是yes，则说明存储到文档域中</div><div class="line">					Field id=new TextField("id",String.valueOf(bc.getId()), Store.YES);</div><div class="line">					Field username=new TextField("username",bc.getUsername(),Store.YES);</div><div class="line">					Field blogCommentDate=new TextField("commentDate",bc.getCommentDate().toLocaleString(),Store.YES);</div><div class="line">					Field content=new TextField("content",bc.getContent(),Store.YES);</div><div class="line">					Field title=new TextField("title",bc.getTitle(),Store.YES);</div><div class="line">					Field hasread=new TextField("hasread",bc.getHasread()+"",Store.YES);</div><div class="line">					Field state=new TextField("state",bc.getState()+"",Store.YES);</div><div class="line">					</div><div class="line">					</div><div class="line">					// 将field域设置到Document对象中</div><div class="line">					document.add(id);</div><div class="line">					document.add(username);</div><div class="line">					document.add(blogCommentDate);</div><div class="line">					document.add(content);</div><div class="line">					document.add(title);</div><div class="line">					document.add(hasread);</div><div class="line">					document.add(state);</div><div class="line">					</div><div class="line">					docList.add(document);			</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				IndexWriter write=this.getWriter();</div><div class="line">				// 通过IndexWriter对象将Document写入到索引库中</div><div class="line">				for(Document doc:docList)&#123;</div><div class="line">					write.addDocument(doc);</div><div class="line">				&#125;</div><div class="line">				// 关闭writer</div><div class="line">				write.close();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="索引文件的逻辑结构"><a href="#索引文件的逻辑结构" class="headerlink" title="索引文件的逻辑结构"></a>索引文件的逻辑结构</h4><p><img src="/images/imgs5/2.jpg" alt="Alt text"><br>通过图示，可以发现最重要的就是文档域和索引域<br>文档域存储的信息就是采集到的信息，通过Document对象来存储，具体说是通过Document对象中field域来存储数据。<br>比如：数据库中一条记录会存储一个一个Document对象，数据库中一列会存储成Document中一个field域。<br>索引域主要是为了搜索使用的。索引域内容是经过lucene分词之后存储的（这里的分词根据所引入的分词器不同，分词效果不一样）<br>传统方法是先找到文件，如何在文件中找内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大就搜索慢<br>但是lucene采用倒排索引结构，它是在索引中匹配搜索关键字，由于索引内容量有限并且采用固定优化算法搜索速度很快，找到了索引中的词汇，词汇与文档关联，从而最终找到了文档。</p>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p><img src="/images/imgs5/3.jpg" alt="Alt text"><br>其中，IndexWriter是索引过程的核心组件，通过IndexWriter可以创建新索引、更新索引、删除索引操作。IndexWriter需要通过Directory对索引进行存储操作。<br>Directory描述了索引的存储位置，底层封装了I/O操作，负责对索引进行存储。它是一个抽象类，它的子类常用的包括FSDirectory（在文件系统存储索引）、RAMDirectory（在内存存储索引）。</p>
<h4 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h4><p>Lucene中分词主要分为两个步骤：分词、过滤<br>分词：将field域中的内容一个个的分词。<br>过滤：将分好的词进行过滤，比如去掉标点符号、大写转小写、词的型还原（复数转单数、过去式转成现在式）、停用词过滤<br>停用词：单独应用没有特殊意义的词。比如的、啊、等，英文中的this is a the等等。</p>
<h4 id="搜索流程"><a href="#搜索流程" class="headerlink" title="搜索流程"></a>搜索流程</h4><p><img src="/images/imgs5/4.jpg" alt="Alt text"><br>Field的属性，主要有三个<br>是否分词（Tokenized）<br>是：对该field存储的内容进行分词，分词的目的，就是为了索引。<br>是否索引（Indexed）<br>是：将分好的词进行索引，索引的目的，就是为了搜索<br>是否存储（Stored）<br>是：将field域中的内容存储到文档域中。存储的目的，就是为了搜索页面显示取值用的。</p>
<h4 id="创建查询对象的方式"><a href="#创建查询对象的方式" class="headerlink" title="创建查询对象的方式"></a>创建查询对象的方式</h4><p>通过QueryParser来创建查询对象（其他方式就不介绍了）<br>通过QueryParser来创建query对象，可以指定分词器，搜索时的分词器和创建该索引的分词器一定要一致。还可以输入查询语句。<br>查询语法<br>1、基础的查询语法，关键词查询：<br>域名+“：”+搜索的关键字<br>例如：content:java<br>2、范围查询<br>域名+“:”+[最小值 TO 最大值]<br>例如：size:[1 TO 1000]<br>3、组合条件查询<br>条件1 AND 条件2<br>条件1 OR 条件2<br>条件1 NOT 条件2</p>
<h4 id="TopDocs"><a href="#TopDocs" class="headerlink" title="TopDocs"></a>TopDocs</h4><p>Lucene搜索结果可通过TopDocs遍历<br>earch方法需要指定匹配记录数量n：indexSearcher.search(query, n)<br>TopDocs.totalHits：是匹配索引库中所有记录的数量<br>TopDocs.scoreDocs：匹配相关度高的前边记录数组，scoreDocs的长度小于等于search方法指定的参数n</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当然lucene的知识体系远不止这些，这里只是通过应用主导学习来浅尝全文检索。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;不知不觉，从九月份后就已经很少写博总结了，有点小颓废了。好吧，回到正题，本着应用为主，了解原理为辅的原则总结。&lt;br&gt;以我的微型论坛中的文章
    
    </summary>
    
      <category term="全文检索" scheme="http://www.myzwl.win/categories/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"/>
    
    
      <category term="全文检索" scheme="http://www.myzwl.win/source/tags/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>jvm总结之三:虚拟机堆参数</title>
    <link href="http://www.myzwl.win/2017/10/24/jvm_3/"/>
    <id>http://www.myzwl.win/2017/10/24/jvm_3/</id>
    <published>2017-10-24T07:48:51.000Z</published>
    <updated>2018-03-13T15:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>事实上，我们对堆内存的管理是可控的，可通过对jvm虚拟机相关堆内存参数设置进行控制</p>
<h4 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a>参数含义</h4><p>-XX 对于系统级别的jvm配置 配置日志信息 垃圾回收器类型<br>非 -XX的 基本都是对 应用层面上的配置</p>
<ul>
<li>启用 - 禁用<br>-XX :PrintGC 使用这个参数，虚拟机启动后，只要遇到GC就会打印日志<br>-XX: +UserSerialGC 配置串行回收器<br>-XX:+PrintGCDetails：可以查看详细信息，包括各个区的情况<br>-Xms: 设置java程序启动时初始堆大小<br>-Xmx: 设置java程序能获得的最大堆大小<br>-Xloggc:路径 ：将打印出来的日志信息保存至指定的路径<br>-Xmn：设置堆的内存大小<br>-XX:SurvivorRatio=m:n调整Eden和Survivor的比例为m:n</li>
</ul>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class test2 &#123;		</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	</div><div class="line">		//-Xms20m -Xmx20m -Xmn10 -XX:+PrintGCDetails -Xloggc:d:\gc1.log</div><div class="line">		</div><div class="line">				//查看GC信息</div><div class="line">				System.out.println("max memory:" + Runtime.getRuntime().maxMemory());</div><div class="line">				System.out.println("free memory:" + Runtime.getRuntime().freeMemory());</div><div class="line">				System.out.println("total memory:" + Runtime.getRuntime().totalMemory());</div><div class="line">				</div><div class="line">				byte[] b1 = new byte[1*1024*1024];</div><div class="line">				System.out.println("分配了1M");</div><div class="line">				System.out.println("max memory:" + Runtime.getRuntime().maxMemory());</div><div class="line">				System.out.println("free memory:" + Runtime.getRuntime().freeMemory());</div><div class="line">				System.out.println("total memory:" + Runtime.getRuntime().totalMemory());</div><div class="line">				</div><div class="line">				byte[] b2 = new byte[4*1024*1024];</div><div class="line">				System.out.println("分配了4M");</div><div class="line">				System.out.println("max memory:" + Runtime.getRuntime().maxMemory());</div><div class="line">				System.out.println("free memory:" + Runtime.getRuntime().freeMemory());</div><div class="line">				System.out.println("total memory:" + Runtime.getRuntime().totalMemory());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>Memory: 4k page, physical 2076596k(144200k free), swap 4923560k(620956k free)<br>CommandLine flags: -XX:InitialHeapSize=5242880 -XX:MaxHeapSize=20971520 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:-UseLargePagesIndividualAllocation<br>0.418: [GC (Allocation Failure) 0.418: [DefNew: 655K-&gt;192K(1856K), 0.0049031 secs] 655K-&gt;466K(5952K), 0.0052607 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]<br>0.448: [GC (Allocation Failure) 0.448: [DefNew: 1282K-&gt;0K(1856K), 0.0044827 secs]0.453: [Tenured: 1490K-&gt;1490K(4096K), 0.0033471 secs] 1557K-&gt;1490K(5952K), [Metaspace: 80K-&gt;80K(4480K)], 0.0083429 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]<br>Heap<br> def new generation   total 1920K, used 68K [0x03a00000, 0x03c10000, 0x040a0000)<br>  eden space 1728K,   3% used [0x03a00000, 0x03a111f8, 0x03bb0000)<br>  from space 192K,   0% used [0x03bb0000, 0x03bb0000, 0x03be0000)<br>  to   space 192K,   0% used [0x03be0000, 0x03be0000, 0x03c10000)<br> tenured generation   total 8196K, used 5586K [0x040a0000, 0x048a1000, 0x04e00000)<br>   the space 8196K,  68% used [0x040a0000, 0x04614b70, 0x04614c00, 0x048a1000)<br> Metaspace       used 80K, capacity 2242K, committed 2368K, reserved 4480K</p>
</blockquote>
<p>其中from、to分别为s0、s1区</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;事实上，我们对堆内存的管理是可控的，可通过对jvm虚拟机相关堆内存参数设置进行控制&lt;/p&gt;
&lt;h4 id=&quot;参数含义&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="jvm" scheme="http://www.myzwl.win/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://www.myzwl.win/source/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm总结之二:回收策略</title>
    <link href="http://www.myzwl.win/2017/10/23/jvm_2/"/>
    <id>http://www.myzwl.win/2017/10/23/jvm_2/</id>
    <published>2017-10-23T07:48:51.000Z</published>
    <updated>2018-03-13T15:57:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们知道垃圾回收的主要内存区域是堆和方法区，因为这两块区域的内存分配相对于其他区域具有不确定性，而分配内存一般有两种方法，即指针碰撞和空闲列表</p>
<h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><p>在堆内存中主要分为年轻代和老年代（具体后面再说），先说一下年轻代<br><img src="/images/imgs5/37.jpg" alt="Alt text"><br>如图，主要分为Eden（对象都会在该区域内创建）同时也会在s0或s1中随机一个进行创建，经过一次GC后在s0和s1中使用复制算法保留存活下来的对象，那么它是如何复制的了<br><img src="/images/imgs5/38.jpg" alt="Alt text"><br><img src="/images/imgs5/39.jpg" alt="Alt text"><br>大概流程就是将可回收的垃圾对象进行标记，然后复制存活的对象到另一块空白区域，依次类推<br>很显然这种复制方式很浪费空间，但是年轻代是生命周期很短的，换句话说，如果年轻代不够放了就会放到老年代，一般规定经过15次GC后的年轻代就会进入老年区（可通过-XX：MaxTenuringThreshold=15设置多少次为老年代），而老年区一般存放存活时间比较久的对象，通过标记-清除-整理进行垃圾回收，如果老年代内存不足就会触发FULL GC.默认是占用了68%后收集（可通过-XX:CMSInitiatingOccupancyFraction=68设置），该GC非常影响性能</p>
<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>我们知道垃圾回收算法可自行判断一个对象是否已经生命周期达到结束，从而将其视为垃圾进行回收。那么在此算法出现之前，出现过可达性分析算法进行垃圾回收<br>算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起始点，从这些起始点开始向下搜索，所走过的路径称为引用链，如果一个对象到GC Roots没有任何引用链，那么这个对象是不可用的，就是说，程序中没有谁引用了这个对象，所以可以说从根节点到叶子结点是不可达的<br>而以下对象可作为GC Roots对象：<br>虚拟机栈（栈帧中本地变量表）中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中JNI（也就是native本地方法）引用的对象</p>
<p>现在我们已经知道了通过可达性分析判断对象是否还可用，但是是不是不可达的对象都是不可用呢？答案是未必。原因在于要宣告一个对象的死亡，需要两次标记（为什么需要两次标记呢？原因是如果一个对象没有与GC Roots结点相连，就会被第一次标记，而如果对象覆盖了finalize方法，并且在finalize方法中与某个对象建立了引用关系，那么第二次标记会失败，那么这个对象就会被移出“即将回收”的对象列表，移出之后这个对象就“活”了下来，如果在finalize方法中这个对相关仍然没有与一个对象建立引用关系，那么这个对象就真正死亡了）。</p>
<h4 id="回收方法区中的对象"><a href="#回收方法区中的对象" class="headerlink" title="回收方法区中的对象"></a>回收方法区中的对象</h4><p>方法区中的永久代的垃圾回收主要为两部分： 废弃常量和无用的类<br>废弃常量是指没有任何对象引用常量池中的某个对象，那么这个对象就会被回收，而对于常量池中的垃圾回收只要进行一次标记就可以进行判断<br>无用的类需要满足以下三个条件才可以宣判一个类的“死刑”：<br>    1.该类的所有实例都已经被回收，也就是Java堆中不存在该类的实例<br>    2.加载该类的ClassLoader已经被回收<br>    3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;我们知道垃圾回收的主要内存区域是堆和方法区，因为这两块区域的内存分配相对于其他区域具有不确定性，而分配内存一般有两种方法，即指针碰撞和空闲列
    
    </summary>
    
      <category term="jvm" scheme="http://www.myzwl.win/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://www.myzwl.win/source/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm总结之一:java内存区域</title>
    <link href="http://www.myzwl.win/2017/10/23/jvm_1/"/>
    <id>http://www.myzwl.win/2017/10/23/jvm_1/</id>
    <published>2017-10-23T06:48:51.000Z</published>
    <updated>2018-03-13T15:57:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>引用百度文库上对java虚拟机的定义.<br>虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行</p>
<h4 id="重要组成部分"><a href="#重要组成部分" class="headerlink" title="重要组成部分"></a>重要组成部分</h4><p><img src="/images/imgs5/35.jpg" alt="Alt text"></p>
<p><font size="5">类加载子系统</font><br>负责从文件系统或者网络中加载class信息，加载的信息存放在一块称之为方法区的内存空间</p>
<p><font size="5">方法区</font><br>存放类信息、常量信息、常量池信息、包括字符串常量和数字常量等</p>
<p><font size="5">java堆</font><br>在虚拟机启动的时候创建，此内粗区域的唯一目的就是存放对象实例，是所有线程共享的，同时，这块内存区域也是垃圾收集器的主要区域，也被成为GC堆</p>
<p><font size="5">Java虚拟机栈</font><br>每个java虚拟机线程都有一个私有的栈，其生命周期与线程相同，它描述了Java的方法执行模型，每个方法执行时都会创建一个栈帧。会抛出StackOverFlowError和OOM</p>
<p><font size="5">本地方法栈</font><br>与Java虚拟机栈类似，最大的不同就是它是用于本地方法调用，同常用c语言编写</p>
<p><font size="5">直接内存</font><br>NIO库允许java使用直接内存，通常速度由于java堆</p>
<p><font size="5">程序计数器</font><br>程序计数器可以理解为当前线程执行的字节码的行号指示器，字节码解释器就是通哟改变这个值来获取需要执行的下一条需要执行的字节码指令。对于多线程来说，每条线程都有自己的程序计数器，这样各线程之间的计数器互不影响，这类内存区域也叫作“私有内存”（可以看到其实并不是私有的），之所以这么设计，是因为在多线程的情况下，完全可能出现线程中断的情况，那么当被中断的线程需要回复执行的时候，怎么知道上次该线程执行到哪里了呢？这就需要程序计数器发挥作用了，由于每个线程都有自己的程序计数器，这样当CPU重新调度该线程的时候，从其计数器中取出下一条的字节码执行指令，于是就可以继续执行了</p>
<p><font size="5">执行引擎</font><br>负责执行虚拟机的字节码,先进行编译成机器码后执行</p>
<h4 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h4><p>事实上，堆解决的是数据存储的问题，即数据怎么做，放在哪里，而栈解决的是程序的运行问题，即程序如何执行或者说如何处理数据，而方法区则是辅助堆栈的永久区，解决堆栈信息的产生,比如我们现在要创建一个student类实例<br><img src="/images/imgs5/36.jpg" alt="Alt text"><br>其中栈中存放的是对象的引用</p>
<h4 id="对象创建详细过程"><a href="#对象创建详细过程" class="headerlink" title="对象创建详细过程"></a>对象创建详细过程</h4><p>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有就执行下一步</p>
<p>检查通过后，虚拟机会为新生的对象分配内存，主要由两种内存分配策略，一种是指针碰撞，一种是空闲列表。所谓指针碰撞就是把Java堆中的内存一分为二，一边是所有用过的内存（这部分内存不能被分配了），一边是空闲的内存，是可以被分配的，这样的话，在可用于不可用的内存之间会有一个分割点指示器，那么为对象分配内存实际上就是从这个分界点指示器往空闲内存的一边拨动一段空间就可以了。而空闲列表则没有这个假设，已使用的内存与空闲内存可能是交叉在一起的，那么使用指针碰撞的方式分配内存就会产生问题，但是虚拟机维护着一张列表，这张列表记录了哪些区域的内存是可用的，那么在分配内存的时候就从选择可以容纳对象要求大小的内存区域分配给这个对象</p>
<p>虚拟机将分配到的内存空间都初始化为零（不包括对象头），这里的初始化不同于我们在Java中利用构造函数进行初始化的过程，这里的初始化时保证Java的一些原生数据类型在不重新赋值的时候就可以直接使用，程序在使用这些对象的时候可以直接使用零值。</p>
<p>接下来，虚拟机要对对象一些必要的设置，进行这些设置的目的是可以知道这些对象是哪个类的实例、对象的哈希码、对象的GC分代年龄等信息，这些信息都存储在对象头中。</p>
<p>上面这些工作完成之后，从虚拟机的角度看，一个对象已经构造完成，但是从开发人员的角度看，还需要进行new对象之后初始化，接着执行init方法，到这里一个对象才算真正创建完毕</p>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>主要包括三部分的信息：对象头、实例数据和对齐填充</p>
<p>对象头又包括两部分信息，第一部分用于存储对象自身的运行时数据，比如哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等；第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>实例数据部分是对象真真好存储的有效信息，也是程序代码中所定义的各种类型的字段内容</p>
<p>第三部分不是必然存在的，只是起到占位符的作用，因为HotspotVM规定对象的起始地址必须是8字节的整数倍。所以很有可能以上两部分的大小不够8字节的整数倍，那么这个字段就可以发挥作用了。</p>
<h4 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h4><p>主要是通过Java栈中的reference数据，通过这个reference数据只是一个指向对象的引用，那么对象的访问方式就可以不同。目前主流的对象访问方式主要由句柄和直接指针两种。通过句柄访问的话，会在Java堆中划分出一块句柄池，句柄池中句柄存放了对象的实例数据和类型指针，而reference数据则存放了句柄的地址引用。使用直接指针访问对象，那么reference数据存放的就是对象的地址<br>使用句柄访问的最大好处是reference中存储的稳定的句柄地址，当对象的地址发生了改变可以不用去关心。而直接指针的最大好处是速度更快，在于节省了一次指针定位的时间</p>
<h4 id="OOM异常分类"><a href="#OOM异常分类" class="headerlink" title="OOM异常分类"></a>OOM异常分类</h4><p>Java堆溢出<br>虚拟机栈和本地方法栈溢出<br>方法区和运行常量池溢出<br>本机直接内存溢出</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;引用百度文库上对java虚拟机的定义.&lt;br&gt;虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机
    
    </summary>
    
      <category term="jvm" scheme="http://www.myzwl.win/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://www.myzwl.win/source/tags/jvm/"/>
    
  </entry>
  
</feed>
