<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2018-03-25T02:10:30.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深刻反思</title>
    <link href="http://www.myzwl.win/2018/03/24/dream_14/"/>
    <id>http://www.myzwl.win/2018/03/24/dream_14/</id>
    <published>2018-03-24T12:48:51.000Z</published>
    <updated>2018-03-25T02:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>说来也惭愧，刚上大学那会还挺着迷于算法的，也很喜欢c++（现在估计只会打开编辑器写个hello world了).自从接触java后，就很少在写算法了，导致熟练度直线下降，一遇到复杂的就是写不出来了。<br>说说这几次笔试吧，实际上自己也算是裸考吧。自己是3月10号左右投的很多校招大公司，有些因为学历关系被刷，毕竟hr从好学校选的基础好的概率大，而且计算机基础才是最重要的，有些有些机会，自己也是抱着试一试的态度去尝试，有些因为一些原因，放弃尝试了，就拿几次印象比较深的说一下</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>首先是CVTE，基础部分大概大部分就是java基础，数据库，操作系统、计算机网络，其中java基础很多都是关于反射、jvm和一些调优，而编程部分就是26个字母加密(AC),ipv4-ipv6加解密、问答短信、email危机。<br>然后就是美团，大概分为三个部分，智力题，主要是概率和找规律，话说这部分做的很带劲，但是时间花费太多~，然后就是计算机基础，不过涉及的基本都与java无关，c、c++居多，还是那些重要的基础课程，不过做的贼烂~，最后就是编程题，字符串求距离（AC)、数字字符<br>然后就是头条，五道编程题，说实话被虐的好惨，只做了前两道，求差值(AC),求最小路径次数(复杂度太高,20%)<br>最后不得不说，用java做太占内存了，很后悔丢了c++~</p>
<h4 id="部分"><a href="#部分" class="headerlink" title="部分"></a>部分</h4><p>当时也没多想，大概就跟着第一思路求解算法<br>求差值（暴力，效率很低)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/*给出两个相同长度的由字符 a 和 b 构成的字符串，</div><div class="line">	定义它们的距离为对应位置不同的字符的数量。</div><div class="line">	如串”aab”与串”aba”的距离为 2；串”ba”与串”aa”的距离为 1；</div><div class="line">	串”baa”和串”baa”的距离为 0。</div><div class="line">	下面给出两个字符串 S 与 T，其中 S 的长度不小于 T 的长度。</div><div class="line">	我们用|S|代表 S 的长度，|T|代表 T 的长度，那么在 S 中一共有|S|-|T|+1 个与T长度相同的子串，</div><div class="line">	现在你需要计算 T 串与这些|S|-|T|+1 个子串的距离的和。*/</div><div class="line">	public int distanceofStr(String s,String t)&#123;</div><div class="line">		if(s.length()&lt;t.length()||s.length()==0)return 0;</div><div class="line">		int count=0;</div><div class="line">		int k=0;</div><div class="line">		int slen=s.length();</div><div class="line">		int tlen=t.length();</div><div class="line">		for(int i=0;i&lt;slen-tlen+1;i++)</div><div class="line">			for(int j=0;j&lt;tlen;j++)&#123;</div><div class="line">				 k=i;//暴力后移</div><div class="line">				if(s.charAt(k+j)!=t.charAt(j))&#123;</div><div class="line">					count++;				</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		return count;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>求差值(具体不记得当时，怎么写的了，只是回忆了大概的)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public int chazhi(int n,int k,int[] a)&#123;</div><div class="line">        int count=1;</div><div class="line">        int s=1; //第一个值</div><div class="line">        Arrays.sort(a);</div><div class="line"> for(int i=0;i&lt;n&amp;&amp;s&lt;n;i++)&#123;</div><div class="line">	 int j=i;</div><div class="line">	 if(a[j]-a[s]==k||a[j]-a[s]==-k)&#123;</div><div class="line">		s++;</div><div class="line">	 &#125;else&#123;</div><div class="line">		 count++;</div><div class="line">		 j++;</div><div class="line">		 s++;</div><div class="line">	 &#125;</div><div class="line"> &#125;</div><div class="line"> return count;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>最小规则步数（内存消耗大)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">private static void getsm()&#123;</div><div class="line">		m=s;</div><div class="line">		s=s+s;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private static void gets()&#123;</div><div class="line">		s=s+m;</div><div class="line">	&#125;</div><div class="line">	public static String s="a";</div><div class="line">   public static String m=s;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		 Scanner in = new Scanner(System.in);</div><div class="line">	        int n = in.nextInt();</div><div class="line">	        List&lt;String&gt; list=new ArrayList&lt;String&gt;();</div><div class="line">	        while(s.length()!=n)&#123;</div><div class="line">	        	list.add(s);</div><div class="line">	        	list.add(m);</div><div class="line">	        	if(s.length()&lt;n)&#123;</div><div class="line">	        		if(n%2==0)&#123;</div><div class="line">	        		getsm();&#125;</div><div class="line">	        		else&#123;</div><div class="line">	        			gets();</div><div class="line">	        		&#125;</div><div class="line">	        	&#125;</div><div class="line">	        	else&#123;</div><div class="line">	        		int t=list.size()-1;</div><div class="line">	        		list.remove(t);</div><div class="line">	        		list.remove(t-1);</div><div class="line">	        		s=list.get(t-3);</div><div class="line">	        		m=list.get(t-2);</div><div class="line">	        		gets();</div><div class="line">	        	&#125;</div><div class="line">	        &#125;</div><div class="line">	        System.out.println(list.size()/2);</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>很多时候，一旦丢了某样东西，就很难在找回来了，也清楚的认识到自己的不足与别人的差距，也知道自己不该继续抱有幻想了，或许考研才是最适合我的，但是已经没有心态在考研了。剩下的日子也不多了，希望自己找到好工作</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;说来也惭愧，刚上大学那会还挺着迷于算法的，也很喜欢c++（现在估计只会打开编辑器写个hello world了).自从接触java后，就很少在
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>JVM总结</title>
    <link href="http://www.myzwl.win/2018/03/14/dream_1/"/>
    <id>http://www.myzwl.win/2018/03/14/dream_1/</id>
    <published>2018-03-14T07:48:51.000Z</published>
    <updated>2018-03-18T15:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="jvm有哪些分区"><a href="#jvm有哪些分区" class="headerlink" title="jvm有哪些分区"></a><a href="https://www.myzwl.win/2017/10/23/jvm_1/">jvm有哪些分区</a></h4><p>类加载子系统、方法区、java堆、java虚拟机栈、本地方法栈、程序计数器、执行引擎</p>
<h4 id="对象如何创建"><a href="#对象如何创建" class="headerlink" title="对象如何创建"></a>对象如何创建</h4><p>常量池中类符号引用<br>指针碰撞<br>把Java堆中的内存一分为二，一边是所有用过的内存（这部分内存不能被分配了），一边是空闲的内存，是可以被分配的，这样的话，在可用于不可用的内存之间会有一个分割点指示器，那么为对象分配内存实际上就是从这个分界点指示器往空闲内存的一边拨动一段空间就可以了</p>
<p>空闲列表<br>已使用的内存与空闲内存可能是交叉在一起的，那么使用指针碰撞的方式分配内存就会产生问题，但是虚拟机维护着一张列表，这张列表记录了哪些区域的内存是可用的，那么在分配内存的时候就从选择可以容纳对象要求大小的内存区域分配给这个对象</p>
<p>对象头设置一些必要信息，从虚拟机的角度看，一个对象已经构造完成，但是从开发人员的角度看，还需要进行new对象之后初始化，接着执行init方法，到这里一个对象才算真正创建完毕</p>
<h4 id="jvm的内存布局"><a href="#jvm的内存布局" class="headerlink" title="jvm的内存布局"></a>jvm的内存布局</h4><p>对象头、实例数据和对齐填充<br>对象头又包括两部分信息，第一部分用于存储对象自身的运行时数据，比如哈希码、GC分代年龄，第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</p>
<p>实例数据部分是对象真真好存储的有效信息，也是程序代码中所定义的各种类型的字段内容</p>
<p>第三部分不是必然存在的，只是起到占位符的作用，因为HotspotVM规定对象的起始地址必须是8字节的整数倍。所以很有可能以上两部分的大小不够8字节的整数倍，那么这个字段就可以发挥作用了。</p>
<h4 id="java如何进行对象访问"><a href="#java如何进行对象访问" class="headerlink" title="java如何进行对象访问"></a>java如何进行对象访问</h4><p>主要是通过Java栈中的reference数据，通过这个reference数据只是一个指向对象的引用，<br>目前主流的对象访问方式主要由句柄和直接指针两种<br>通过句柄访问的话，会在Java堆中划分出一块句柄池，句柄池中句柄存放了对象的实例数据和类型指针，而reference数据则存放了句柄的地址引用。使用直接指针访问对象，那么reference数据存放的就是对象的地址<br>使用句柄访问的最大好处是reference中存储的稳定的句柄地址，当对象的地址发生了改变可以不用去关心。而直接指针的最大好处是速度更快，在于节省了一次指针定位的时间</p>
<h4 id="OOM是啥，分析及解决"><a href="#OOM是啥，分析及解决" class="headerlink" title="OOM是啥，分析及解决"></a>OOM是啥，分析及解决</h4><p>内存泄露：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。<br>内存溢出：申请的内存超出了JVM能提供的内存大小，此时称之为溢出</p>
<p>java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，堆大小可以通过虚拟机参数-Xms,-Xmx等修改</p>
<p>java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</p>
<p>java.lang.StackOverflowError：一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小</p>
<h4 id="jvm堆内存情况"><a href="#jvm堆内存情况" class="headerlink" title="jvm堆内存情况"></a><a href="https://www.myzwl.win/2017/10/23/jvm_2/">jvm堆内存情况</a></h4><p>堆内存中主要分为年轻代和老年代,主要分为Eden（对象都会在该区域内创建）同时也会在s0或s1中随机一个进行创建，经过一次GC后在s0和s1中使用复制算法保留存活下来的对象<br>流程：年轻代:通过标记-复制-清除（15次GC，老年代）<br>老年区:通过标记-清除-整理进行垃圾回收，如果老年代内存不足就会触发FULL GC.默认是占用了68%后收集（可通过-XX:CMSInitiatingOccupancyFraction=68设置），该GC非常影响性能</p>
<h4 id="什么是可达性分析"><a href="#什么是可达性分析" class="headerlink" title="什么是可达性分析"></a>什么是可达性分析</h4><p>是通过一系列的称为“GC Roots”的对象作为起始点，从这些起始点开始向下搜索，所走过的路径称为引用链，如果一个对象到GC Roots没有任何引用链，那么这个对象是不可用的，就是说，程序中没有谁引用了这个对象，所以可以说从根节点到叶子结点是不可达的<br>虚拟机栈（栈帧中本地变量表）中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中JNI（也就是native本地方法）引用的对象</p>
<h4 id="为什么需要两次标记"><a href="#为什么需要两次标记" class="headerlink" title="为什么需要两次标记"></a>为什么需要两次标记</h4><p>原因是如果一个对象没有与GC Roots结点相连，就会被第一次标记，而如果对象覆盖了finalize方法，并且在finalize方法中与某个对象建立了引用关系，那么第二次标记会失败，那么这个对象就会被移出“即将回收”的对象列表，移出之后这个对象就“活”了下来，如果在finalize方法中这个对相关仍然没有与一个对象建立引用关系，那么这个对象就真正死亡了</p>
<h4 id="方法区中的什么对象可以被回收"><a href="#方法区中的什么对象可以被回收" class="headerlink" title="方法区中的什么对象可以被回收"></a>方法区中的什么对象可以被回收</h4><p>方法区中的永久代的垃圾回收主要为两部分： 废弃常量和无用的类<br>废弃常量是指没有任何对象引用常量池中的某个对象，那么这个对象就会被回收，而对于常量池中的垃圾回收只要进行一次标记就可以进行判断<br>无用的类需要满足以下三个条件才可以宣判一个类的“死刑”：<br>1.该类的所有实例都已经被回收，也就是Java堆中不存在该类的实例<br>2.加载该类的ClassLoader已经被回收<br>3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p>
<h4 id="jvm堆参数简单说明"><a href="#jvm堆参数简单说明" class="headerlink" title="jvm堆参数简单说明"></a>jvm堆参数简单说明</h4><p>-XX 对于系统级别的jvm配置 配置日志信息 垃圾回收器类型<br>非 -XX的 基本都是对 应用层面上的配置<br>    启用 - 禁用<br>    -XX :PrintGC 使用这个参数，虚拟机启动后，只要遇到GC就会打印日志<br>    -XX: +UserSerialGC 配置串行回收器<br>    -XX:+PrintGCDetails：可以查看详细信息，包括各个区的情况<br>    -Xms: 设置java程序启动时初始堆大小<br>    -Xmx: 设置java程序能获得的最大堆大小<br>    -Xloggc:路径 ：将打印出来的日志信息保存至指定的路径<br>    -Xmn：设置堆的内存大小<br>    -XX:SurvivorRatio=m:n调整Eden和Survivor的比例为m:n</p>
<h4 id="有哪些垃圾收集器"><a href="#有哪些垃圾收集器" class="headerlink" title="有哪些垃圾收集器"></a>有哪些垃圾收集器</h4><p>Serial收集器: 它是一种单线程垃圾收集器，这就意味着在其进行垃圾收集的时候需要暂停其他的线程</p>
<p>ParNew收集器: 为Serial收集器的多线程版本,能够与CMS收集器配合工作</p>
<p>Parallel Scavenge收集器:<br>其使用的算法是复制算法，也是并行的多线程收集器（所谓”并行”，就是指多条垃圾收集线程同时工作，但是用户仍处于等待状态)<br>更关注可控制的吞吐量，吞吐量等于运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)。</p>
<p>Serial Old收集器:<br>Parallel Old收集器<br>CMS收集器:获取最短回收停顿时间。在注重服务器的响应速度，希望停顿时间最短<br>G1收集器: G1收集器将Java堆划分为多个大小相等的Region（独立区域），新生代与老年代都是一部分Region的集合，G1的收集范围则是这一个个Region</p>
<h4 id="java类加载机制如何"><a href="#java类加载机制如何" class="headerlink" title="java类加载机制如何"></a><a href="https://www.myzwl.win/2017/07/31/reflaction_1/">java类加载机制如何</a></h4><p>1.并非一次性加载<br>2.需要的时候加载（运行期动态加载）<br>3.static语句块在加载后执行一次<br>4.dynamic语句块每次new新的对象都会执行（等同于构造方法中语句）</p>
<p>jdk中有各种各样的ClassLoad将类加载进内存<br>一：bootstrap class loader<br>它是最核心的类用于加载java中核心的类<br>二:extesion class loader<br>三:application class loader<br>也就是说它是java的核心类用于加载用户自定义的类和其他类<br>四:other class loaders<br>SecureClassLoader、URLClassLoader等等，该类是其他加载类加载其它类</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;jvm有哪些分区&quot;&gt;&lt;a href=&quot;#jvm有哪些分区&quot; class=&quot;headerlink&quot; title=&quot;jvm有哪些分区&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.myzwl.win/2017/10/23/jvm_1/&quot;&gt;jvm有哪些分区&lt;/a&gt;
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>Java并发总结</title>
    <link href="http://www.myzwl.win/2018/03/14/dream_2/"/>
    <id>http://www.myzwl.win/2018/03/14/dream_2/</id>
    <published>2018-03-14T04:48:51.000Z</published>
    <updated>2018-03-18T15:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="描述一下线程池ThreadPoolExecutor"><a href="#描述一下线程池ThreadPoolExecutor" class="headerlink" title="描述一下线程池ThreadPoolExecutor"></a>描述一下线程池ThreadPoolExecutor</h4><p>corepoolsize：核心池的大小，默认情况下，在创建了线程池之后，线程池中线程数为0，<br>当有任务来之后，就会创建一个线程去执行任务，当线程池中线程数达到corepoolsize 后，<br>就把任务放在任务缓存队列中。<br>Maximumpoolsize:线程池中最多创建多少个线程。<br>Keeplivetime：线程没有任务执行时，最多保存多久的时间会终止，默认情况下，当线程<br>池中线程数&gt;corepoolsize 时，Keeplivetime 才起作用，直到线程数不大于corepoolsize。<br>workQueue:阻塞队列，用来存放等待被执行的任务<br>threadFactory:线程工厂，用来创建线程。</p>
<p>继承关系<br>Executor 接口<br>ExecutoServicer 接口<br>AbstractExecutoServicer 抽象类<br>ThreadPoolExecutor</p>
<p>线程池的状态<br>1.当线程池创建后，初始为running 状态<br>2.调用shutdown 方法后，处shutdown 状态，此时不再接受新的任务，等待已有的任务执<br>行完毕<br>3.调用shutdownnow 方法后，进入stop 状态，不再接受新的任务，并且会尝试终止正在<br>执行的任务。<br>4.当处于shotdown 或stop 状态，并且所有工作线程已经销毁，任务缓存队列已清空，线<br>程池被设为terminated 状态</p>
<p>当有任务提交到线程池之后的一些操作：<br>1.若当前线程池中线程数&lt;corepoolsize，则每来一个任务就创建一个线程去执行。</p>
<ol>
<li>若当前线程池中线程数&gt;=corepoolsize，会尝试将任务添加到任务缓存队列中去，若添<br>加成功，则任务会等待空闲线程将其取出执行，若添加失败，则尝试创建线程去执行这个任<br>务。</li>
<li>若当前线程池中线程数&gt;= Maximumpoolsize，则采取拒绝策略（有4 种，1）abortpolicy 丢<br>弃任务，抛出RejectedExecutionException 2 ）discardpolicy 拒绝执行，不抛异常3 ）<br>discardoldestpolicy 丢弃任务缓存队列中最老的任务，并且尝试重新提交新的任务4）<br>callerrunspolicy 有反馈机制，使任务提交的速度变慢）。</li>
</ol>
<h4 id="什么是死锁，手撕代码模拟"><a href="#什么是死锁，手撕代码模拟" class="headerlink" title="什么是死锁，手撕代码模拟"></a>什么是死锁，手撕代码模拟</h4><p>如哲学家进餐问题，每个哲学家都在等右边哲学家方上筷子，处于僵持等待状态，称为死锁。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class LockTest implements Runnable&#123;</div><div class="line">	public int flag=1;</div><div class="line">	 static Object o1=new Object(),o2=new Object();</div><div class="line">	   </div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println("flag="+flag);</div><div class="line">		 if(flag==1)&#123;</div><div class="line">		 synchronized (o1) &#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(5000);</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			synchronized (o2) &#123;</div><div class="line">				System.out.println("1");</div><div class="line">			&#125;</div><div class="line">		 &#125;	 </div><div class="line">		&#125;</div><div class="line">		if(flag==0)&#123;</div><div class="line">			 synchronized (o2) &#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(5000);</div><div class="line">					&#125; catch (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					synchronized (o1) &#123;</div><div class="line">						System.out.println("0");</div><div class="line">					&#125;</div><div class="line">				 &#125;	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LockTest lt1=new LockTest();</div><div class="line">		LockTest lt2=new LockTest();</div><div class="line">		 lt1.flag=1;</div><div class="line">		 lt2.flag=0;</div><div class="line">		  Thread t1=new Thread(lt1);</div><div class="line">		  Thread t2=new Thread(lt2);</div><div class="line">		  t1.start();</div><div class="line">		  t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="手撕模拟生产者"><a href="#手撕模拟生产者" class="headerlink" title="手撕模拟生产者"></a>手撕模拟生产者</h4><p>模拟一个生产者利用生产食物放到篮子里，而一个消费者从篮子里消费食物<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">public class Food &#123; //食物类</div><div class="line"> int id;</div><div class="line"> public Food(int id)&#123;</div><div class="line">	 this.id=id;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">public class UtilStack &#123;//工具，用来放食物</div><div class="line">	int index=0; //食物计数变量</div><div class="line">	Food[] arrFD=new Food[4]; //最多工具能放食物容量</div><div class="line">	</div><div class="line">	public synchronized void push(Food fd)&#123; //生产食物，必须加锁，保证生产过程不被打断</div><div class="line">		while(index==arrFD.length)</div><div class="line">		&#123;</div><div class="line">			try &#123;</div><div class="line">				System.out.println("full");</div><div class="line">				this.wait();  //生产满了，就去休息区休息，等待被唤醒</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		this.notify();//唤醒当前在休息区的线程</div><div class="line">		arrFD[index]=fd;</div><div class="line">		index++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public synchronized Food pop()&#123; //消费</div><div class="line">		while(index==0) //消费完了，进休息区</div><div class="line">			try &#123;</div><div class="line">				System.out.println("empty");</div><div class="line">				this.wait();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		this.notify();</div><div class="line">		index--;</div><div class="line">		return arrFD[index];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Producer implements Runnable&#123;//生产者</div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Producer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=new Food(i);</div><div class="line">			ss.push(fd);</div><div class="line">			System.out.println("生产了"+fd.id);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(1000);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Consumer implements Runnable&#123;//消费者</div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Consumer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=ss.pop();</div><div class="line">			System.out.println("消费了"+fd.id);</div><div class="line">		 try &#123;</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="线程的状态是什么"><a href="#线程的状态是什么" class="headerlink" title="线程的状态是什么"></a>线程的状态是什么</h4><p>在任意一个时间点，一个线程只能有且只有其中的一种状态<br>1）新建：创建后尚未启动的线程处于这种状态。<br>2）运行：包括了OS 中Running 和Ready 状态，也就是处于次状态的线程可能正在运行，<br>也可能正在等待cpu 为他分配执行时间。<br>3）无限期等待:处于这种状态的线程不会被分配cpu 执行时间，要等待其他线程显示唤<br>醒。以下方法会让线程进入无限期等待：1.没有设置timeout 的object.wait()方法2.没有设<br>置timeout 参数的Thread.join()方法3.LockSupport.park();<br>4）有限期的等待：处于这种状态的线程也不会被分配cpu 执行时间，不过无需等待被<br>其他线程显示唤醒，而是在一定时间后，他们会由os 自动唤醒1.设置了timeout 的<br>object.wait() 方法2. 设置了timeout 参数的Thread.join() 3.LockSupport.parkNanos()<br>4.LockSupport.parkUnit()<br>5）阻塞：线程被阻塞了与“等待状态”的区别是：阻塞状态在等待获取一个排它锁，<br>这个事件将在另外一个线程放弃这个锁的时候发生。等待状态在等待一段时间或者唤醒动<br>作。<br>6）结束：已终止线程的线程状态，线程已经结束执行</p>
<h4 id="synchronized（S）VS-lock（L）"><a href="#synchronized（S）VS-lock（L）" class="headerlink" title="synchronized（S）VS lock（L）"></a>synchronized（S）VS lock（L）</h4><p>1）L 是接口，S 是关键字<br>2）S 在发生异常时，会自动释放线程占有的锁，不会发生死锁。L 在发生异常时，若没<br>有主动通过unlock（）释放锁，则很有可能造成死锁。所以用lock 时要在finally 中释放锁。<br>3)L 可以当等待锁的线程响应中断，而S 不行，使用S 时，等待的线程将会一直等下去，<br>不能响应中断。<br>4）通过L 可以知道是否成功获得锁，S 不可以。<br>5）L 可以提高多个线程进行读写操作的效率。</p>
<h4 id="简单并发中方法总结"><a href="#简单并发中方法总结" class="headerlink" title="简单并发中方法总结"></a>简单并发中方法总结</h4><p>继承thread或者Runnable，调用run方法，start启动<br>sleep：暂时停止线程当前的操作<br>wait-把线程放入休息室<br>notify方法-从休息区拿出线程<br>notifyAll从线程区中拿出所有线程<br>Lock lock=new ReentrantLock();读写锁<br>ReadWriteLock rwLock=new ReentrantReadWriteLock()；读-读不互斥，读-写互斥，写-写互斥，并发性提高<br>CountDownLatch: 倒数计时器<br>ReenTrantLock ：公平锁：线程先来，先得到锁，可在构造函数中设置<br>join方法。该方法主要作用是在该线程中的run方法结束后，才往下执行<br>yield方法。这个是线程本身的调度方法，使用时你可以在run方法执行完毕时，调用该方法，告知你已可以出让内存资源。<br>关键字volatile 是轻量级的同步机制。<br>Volatile 变量对于all 线程的可见性，指当一条线程修改了这个变量的值，新值对于其他<br>线程来说是可见的、立即得知的。</p>
<h4 id="什么是同步与公平锁"><a href="#什么是同步与公平锁" class="headerlink" title="什么是同步与公平锁"></a>什么是同步与公平锁</h4><p>同步：多个线程并发访问共享数据时，保证共享数据在同一个时刻，只被一个（or 一<br>些，使用信号量）线程使用，而互斥是实现同步的一种手段，临界区，互斥量，信号量都是<br>主要的互斥实现方式。互斥是因，同步是果；互斥是方法，同步是目的</p>
<p>公平锁：（先申请先得到）多个线程在等待同一个锁时，必须按照申请锁的时间顺序<br>来依次获取，而非公平锁则不保证这一点。Synchronized 不是公平锁，reetrantlock 默认下也<br>是非公平的，但是在构造函数中，可以设置为公平的。</p>
<h4 id="描述一下java自带的锁机制"><a href="#描述一下java自带的锁机制" class="headerlink" title="描述一下java自带的锁机制"></a>描述一下java自带的锁机制</h4><p>在java 设计中，每一个对象自打娘胎里出来就带了一把看不见的锁，即monitor 锁,有一张记录表记录线程锁住状况，<br>锁主要有4 中状态：无锁状态、偏向状态、轻量级状态、重量级状态。他们会随着竞争<br>的激烈而逐渐升级，锁可以升级但不可以降级<br>轻量级锁：传统的锁是重量级锁，他是用系统的互斥量来实现。轻量级锁的本意是在没<br>有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗<br>Synchronized 用的锁时存在java 对象头里。对象头包含标记字段和类型指针<br>JVM 可以通过对象的元数据信息确定对象的大小，但是无法从数组的元数据来确定数组<br>的大小</p>
<h4 id="乐观锁VS-悲观锁"><a href="#乐观锁VS-悲观锁" class="headerlink" title="乐观锁VS 悲观锁"></a>乐观锁VS 悲观锁</h4><p>悲观锁：就是很悲观，每次去拿数据的时候都认为别人会修改，<br>所以每次在拿数据的时候都会上锁。这样别人想拿这个数据就会block 直到它拿到锁。传统<br>的关系型数据库就用到了很多这种机制，比如行锁，写锁等，都是在操作之前上锁<br>2）乐观锁：就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新<br>的时候会判断一下在此期间别人有没有去更新这个数据。适用于多读</p>
<h4 id="解释一下同步阻塞，异步等"><a href="#解释一下同步阻塞，异步等" class="headerlink" title="解释一下同步阻塞，异步等"></a>解释一下同步阻塞，异步等</h4><p>同步阻塞，用户空间的应用程序执行一个系统调用，这意味着应用程序会一直阻塞，直<br>到系统调用完成为止（数据传输完成或者发生错误）<br>同步非阻塞，设备以非阻塞形式打开，这意味着io 操作不会立刻完成，需要应用程序<br>调用多次来等待完成<br>同步和异步1）同步：发出一个调用时，在没有得到结果前，该调用就不返回，一旦返<br>回就有结果。2）异步：调用在发出之后就直接返回，所以没有返回结果，换句话说，当一<br>个异步调用发生后，调用者不会立即得到结果，而是在调用发生后，被调用者通过状态通知<br>来通知调用者，或者通过回调函数来处理这个调用<br>阻塞和非阻塞1）阻塞：调用结果返回之前，当前线程会被挂起，调用线程只有在得到<br>结果之后才会返回。2）非阻塞：不能立刻得到结果之前，该调用不会阻塞当前线程</p>
<p>BIO：同步并阻塞，一个连接一个线程，适用于链接数量小且固定的架构。<br>NIO：同步非阻塞：一个请求一个线程，客户端发送的链接请求都会注册到多路复用器<br>上，多路复用器轮训到链接有io 请求时才启动一个线程进行处理，适用于链接比较多，比<br>较短<br>AIO：异步非阻塞，一个有效请求一个线程，适用于链接数目多且长。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;描述一下线程池ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#描述一下线程池ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;描述一下线程池ThreadPoolExecutor&quot;&gt;&lt;/a&gt;描述一下线程池Thre
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>设计模式总结</title>
    <link href="http://www.myzwl.win/2018/03/14/dream_3/"/>
    <id>http://www.myzwl.win/2018/03/14/dream_3/</id>
    <published>2018-03-14T02:48:51.000Z</published>
    <updated>2018-03-18T15:48:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说说ioc与aop"><a href="#说说ioc与aop" class="headerlink" title="说说ioc与aop"></a>说说ioc与aop</h4><p>IOC 控制反转容器控制程序对象之间的关系，而不是传统实现中，有程序代码之间控制，<br>又名依赖注入。All 类的创建，销毁都由Spring 来控制，也就是说控制对象生命周期的不是<br>引用他的对象，而是Spring。对于某个对象而言，以前是他控制其他对象，现在是all 对象<br>都被spring 控制，这就叫控制反转<br>依赖注入的思想时通过反射机制实现的。在实例化一个类时，它通过反射调用类中的set<br>方法将事先保存在hashmap 中的类属性注入到类中<br>Spring 实现aop：<br>将那些与业务无关，却为业务模块所公共调用的逻辑或责任封装起来，称其<br>为aspect，便于减少系统的重复代码。使用模块技术，aop 把软件系统分为两个部分：核心<br>关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注<br>点。实现aop 的两大技术：1）采用动态代理，利用截取消息的方式，对该消息进行装饰，<br>以获取原有对象行为的执行。2）采用静态织入，引入特定的语法创建切面，从而可以使编<br>译器可在编译期间织入有关切面的代码。<br>JDK 动态代理，cglib 动态代理。<br>JDK 动态代理：其代理对象必须是某个接口的实现，他是通过在运行期间创建一个接口<br>的实现类来完成对目标对象的代理。核心类有：InnovactionHandler，Proxy。<br>Cgib 动态代理：实现原理类似于jdk 动态代理，只是他在运行期间生成的代理对象是针<br>对目标类扩展的子类。MethodInterceptor</p>
<h4 id="说说代理模式"><a href="#说说代理模式" class="headerlink" title="说说代理模式"></a><a href="https://www.myzwl.win/2017/03/14/dyproxy3/">说说代理模式</a></h4><p>静态代理与继承代理<br>动态代理，javac和反射取出动态类<br>反射<br>1）proxy 类：<br>类的静态方法用来生成动态代理的实例<br>2）innovationhandler 接口有一个invoke 方法，用来<br>集中处理在动态代理类对象的方法调用，通常在该方法中实现对委托类的代理访问，每次生<br>成动态代理对象时都要指定一个对应的调用处理器<br>CGlib 动态代理：jdk 代理机制只能代理<br>实现了接口的类，而没有实现接口的类不能用jdk 动态代理。CGlib 是针对类来实现代理，<br>他的原理是对指定的目标类生成一个子类，并且覆盖其中方法实现增强，因为采用的是继承，<br>所以不能对final 修饰的类进行代理，methodinterceptor </p>
<h4 id="代理模式和装饰模式的区别？"><a href="#代理模式和装饰模式的区别？" class="headerlink" title="代理模式和装饰模式的区别？"></a>代理模式和装饰模式的区别？</h4><p>代理是<br>在内部生成一个代理对象，构造函数参数为空。装饰的构造函数参数有一个对象，就是对这<br>个对象进行装饰。</p>
<h4 id="jdk-中的设计模式："><a href="#jdk-中的设计模式：" class="headerlink" title="jdk 中的设计模式："></a>jdk 中的设计模式：</h4><p>1）单例，比如Runtime 类；<br>2）静态工厂Interger a=Integer.valueOf(intor String);<br>3) 迭代器模式Collection.interator();<br>4) 原型设计模式,clone 方法；<br>5 ）适配器 inputStreamReader 和outputStreamWriter；<br>6）桥接模式，jdbc，抽象部分与实现相分离；<br>7）装饰模式Reader 和bufferedBeader；<br>8）代理，jdk 动态代理；<br>9）观察者observable 和observer；<br>10）责任链，classloader 的双亲委派模型；<br>11 ）组合，某个类型的方法同时也接收自身类型作为参数<br>java.util.list.addall(collection);<br>12)抽象工厂，一个创建新对象的方法，返回的是接口或抽象类<br>Connection c=DriverManager.getConnection();<br>13) 工厂方法，返回一个具体对象的方法Proxy.newProxyInstance;<br>14)解释器模式，该模式通常定义了一个语言的语法,java.util.pattern</p>
<h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a><a href="https://www.myzwl.win/2017/02/23/danli/">单例设计模式</a></h4><p>饿汉式、懒汉式<br>双锁机制<br>public static Singleton getInstance()<br> {<br>     if(singleton==null)<br>     {<br>         synchronized(Singleton.class)<br>         {<br>     if(singleton==null){<br>         singleton=new Singleton();<br>     }<br>         }<br>     }<br>     return singleton;<br> }</p>
<h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><a href="https://www.myzwl.win/2017/03/08/simplefactory/">简单工厂</a></h4><p> 数据库模型</p>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><a href="https://www.myzwl.win/2017/03/09/factory/">工厂方法</a></h4><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><a href="https://www.myzwl.win/2017/03/10/abstractfactory/">抽象工厂</a></h4><h4 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a><a href="https://www.myzwl.win/2017/03/10/observer/">观察者设计模式</a></h4><p> 推模型，也就是被观察者根据状态发生改变时将所有信息都主动通知观察者<br> 拉模型，即观察者主动向被观察者索要信息<br> 观察者模式应用场景<br>1、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变<br>2、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节</p>
<h4 id="职责链设计模式"><a href="#职责链设计模式" class="headerlink" title="职责链设计模式 "></a><a href="https://www.myzwl.win/2017/03/07/filter/">职责链设计模式 </a></h4><p>模拟过滤器</p>
<h4 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a><a href="https://www.myzwl.win/2017/03/06/iterator/">迭代器设计模式</a></h4><p>模拟集合Iterator</p>
<h4 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h4><p>开闭原则：一个软件实体应当对开展开放，对修改关闭（玉帝招安美猴王）<br>面向对象解释： 不予以更改的是抽象层，但是可以扩展的是实现层<br>对可变性的封装原则： 找到一个系统的可变因素，将之封装起来<br>里氏代换原则： 任何基类可以出现的地方，子类一定可以出现<br>依赖倒转原则： 要依赖于抽象，不要依赖于实现<br>接口隔离原则： 应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说说ioc与aop&quot;&gt;&lt;a href=&quot;#说说ioc与aop&quot; class=&quot;headerlink&quot; title=&quot;说说ioc与aop&quot;&gt;&lt;/a&gt;说说ioc与aop&lt;/h4&gt;&lt;p&gt;IOC 控制反转容器控制程序对象之间的关系，而不是传统实现中，有程序代码之间控制，&lt;
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>数据库总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_4/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_4/</id>
    <published>2018-03-13T11:48:51.000Z</published>
    <updated>2018-03-21T08:17:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="mysql-使用的引擎"><a href="#mysql-使用的引擎" class="headerlink" title="mysql 使用的引擎"></a>mysql 使用的引擎</h4><p>A:1)MyIsam 不支持事务，适用于选择密集型，插入密集型，mysql 默认的引擎<br>2)innodb 使用于更新密集型，支持事务，自动灾难恢复，行级锁，外键约束<br>3）memory 出发点是速度采用的逻辑存储介质是内存<br>4）merge 一组myisam 表的组合</p>
<h4 id="mysql-索引使用的是B-的数据结构"><a href="#mysql-索引使用的是B-的数据结构" class="headerlink" title="mysql 索引使用的是B+的数据结构"></a>mysql 索引使用的是B+的数据结构</h4><p>索引：用于提高数据访问速度的数据库对象。<br>优点：1）索引可以避免全表扫描；<br>2）对于非聚集索引，有些查询甚至可以不访问数据项；<br>3）聚集索引可以避免数据插入操作集中于表的最后一个数据页；<br>4）一些情况下，索引还可以避免排序。<br>虽然索引可以提高查询速度，但是他们也会导致数据库更新数据的性能下降，因为大部<br>分数据更新时需要同时更新索引。</p>
<h4 id="连接关联"><a href="#连接关联" class="headerlink" title="连接关联"></a>连接关联</h4><p>A 的id 和b 的parent_id 关联<br>1）内连接<br>Select a.<em>,b.</em>from a inner join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>2）左外链接（左表all 元素都有）<br>Select a.<em>,b.</em>from a left join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>3 王五null<br>3）右外链接（右表all 元素都有）<br>Select a.<em>,b.</em>from a right join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>Null 3 34 2<br>4）完全链接（返回左边和右表中所有行，若某行在另外一个表中无匹配，则另一表的<br>选择列表列包含空值）<br>Select a.<em>,b.</em>from a full join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>Null 3 34 2<br>3 王五null<br>Not in 的例子：<br>Select emp_no from emplyees where emp_no not in (select emp_no from dept_manager)</p>
<h4 id="共享锁VS-排他锁"><a href="#共享锁VS-排他锁" class="headerlink" title="共享锁VS 排他锁"></a>共享锁VS 排他锁</h4><p>1）共享锁，<br>又称读锁，若事务T 对数据对象A 加了S 锁，则是事务T 可以读A 但不能修改A，其它事务只能再对他加S 锁，而不能加X 锁，直到T 释放A 上的S 锁。这保证了其他事务可以读A，但在事务T 释放S 锁之前，不能对A 做任何操作<br>2）排他锁，<br>又称写锁，若事务T 对数据对象加X 锁，事务T 可以读A 也可以修改A，其他事务<br>不能对A 加任何锁，直到T 释放A 上的锁。这保证了，其他事务在T 释放A 上的锁之前不<br>能再读取和修改A。</p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>Serializable(串行化)：一个事务在执行过程中完全看不到其他事务对数据库所做的更新。<br>Repeatable Read(可重复读)：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务对已有记录的更新。<br>Read Commited（读已提交数据）：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的对已有记录的更新<br>Read Uncomitted（读未提交数据）：一个事务在执行过程中可以拷打其他事务没有提交的新插入的记录，而且能看到其他事务没有提交的对已有记录的更新。</p>
<h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>回答思路：事务是干什么的&gt;事务的ACID特性&gt;事务的隔离级别<br>事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取。事务的正确执行使得数据库从一种状态转换成另一种状态<br>原子性、隔离性、持久性<br>脏读：一个事务读到另一个事务为提交的更新数据。<br>虚读：一个事务读到另一个事务已提交的新插入的数据。<br>不可重复读：一个事务读到另一个事务已提交的更新数据</p>
<h4 id="数据库设计三范式是什么"><a href="#数据库设计三范式是什么" class="headerlink" title="数据库设计三范式是什么"></a>数据库设计三范式是什么</h4><p>第一范式：字段还可以再分吗？如过不能，则是符合1NF的设计。<br>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>也就是说主键列与非主键列遵循完全函数依赖关系<br>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。<br>也就是说非主键列之间没有传递函数依赖关系<br>打个比方，比如评论表，如果你将用户ID，用户头像都放在这留言表中，就是不合适的了。用户头像是依赖于用户ID，而不依赖该评论。</p>
<h4 id="悲观锁和乐观锁的比较"><a href="#悲观锁和乐观锁的比较" class="headerlink" title="悲观锁和乐观锁的比较"></a>悲观锁和乐观锁的比较</h4><p>面试思路：什么是锁，用来干什么&gt;悲观锁乐观锁各自特点&gt;优缺点比较和各自应用场景<br>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。<br>悲观锁:<br>简单来说悲观锁认什么操作都可以改变数据，所以在改数据就锁住（在sql语句中加上for update就可以了）<br>乐观锁：<br>简单来说乐观锁很乐观 所以修改数据库后锁住 （一般在数据库中加上一个字段区别历史版本和当前版本）<br>update t_goods<br>set status=2,version=version+1<br>where id=#{id} and version=#{version};<br>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<h4 id="mysql实现分页的优化sql语句"><a href="#mysql实现分页的优化sql语句" class="headerlink" title="mysql实现分页的优化sql语句"></a>mysql实现分页的优化sql语句</h4><p>面试思路：数据库分页的简单实现&gt;数据量变大时的优化方案<br>sql语句是LIMIT m,n其中m是当前页，n是从当前页数n个记录，如果参数为一个就是数n个记录<br>一般我们都会这样写:当数据达到百万级的时候会慢死<br>    SELECT FROM table ORDER BY id LIMIT 1000000, 10;<br>    优化一：<br>    SELECT FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10;<br>    速度可以提升到0.x秒了<br>    优化二：<br>    SELECT FROM table WHERE id BETWEEN 1000000 AND 1000010;<br>    比上面提升5到10倍<br>    另外，如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询<br>    SELECT FROM table WHERE id IN(10000, 100000, 1000000…);</p>
<h4 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h4><p>1)对查询进行优化，要尽量避免全表扫描。在where 或order by 的列上加索<br>引。<br>2）尽量避免在where 子语句中有where num is null，这样不用索引，要全表扫描，可<br>用0 代替null。<br>3）避免在where 中用&lt;&gt;or!=,因为要全表扫描。<br>4）尽量避免在where 中用or，因为若一个字段有索引，一个没有，则要全表扫描。<br>5）like”%abc%”，全表扫描。<br>6）避免在where 子语句中对字段进行函数操作，因为要全表扫描。<br>7）使用复合索引时，必须用到该索引的第一个字段，否则索引不被使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;mysql-使用的引擎&quot;&gt;&lt;a href=&quot;#mysql-使用的引擎&quot; class=&quot;headerlink&quot; title=&quot;mysql 使用的引擎&quot;&gt;&lt;/a&gt;mysql 使用的引擎&lt;/h4&gt;&lt;p&gt;A:1)MyIsam 不支持事务，适用于选择密集型，插入密集型，my
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_5/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_5/</id>
    <published>2018-03-13T08:48:51.000Z</published>
    <updated>2018-03-21T08:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线性表之顺序表"><a href="#线性表之顺序表" class="headerlink" title="线性表之顺序表"></a><a href="https://www.myzwl.win/2017/07/08/sjjg_1/">线性表之顺序表</a></h4><p>数组是顺序存储的随机存取结构，占用一组连续的存储单元，通过下标识别元素，元素地址是下标的线性函数，一个下标能唯一确定一个元素<br>模拟ArrayList</p>
<h4 id="线性表之单链表"><a href="#线性表之单链表" class="headerlink" title="线性表之单链表 "></a><a href="https://www.myzwl.win/2017/07/08/sjjg_2/">线性表之单链表 </a></h4><p>线性表的链式存储是用若干地址分散的存储单元存储数据元素，逻辑上相连的数据元素在物理位置上不一定相连，必须采用附加信息表示数据元素之间的关系，并且存储单元至少包含两部分-数据域和地址域<br>单链表中结点只有一个地址并且指向后继结点<br>模拟SinglyLinkenList</p>
<h4 id="线性表之双链表"><a href="#线性表之双链表" class="headerlink" title="线性表之双链表"></a><a href="https://www.myzwl.win/2017/07/08/sjjg_3/">线性表之双链表</a></h4><p>双链表的每个结点有两个地址域，分别指向它的前驱结点和后继结点</p>
<h4 id="串之字符串"><a href="#串之字符串" class="headerlink" title="串之字符串 "></a><a href="https://www.myzwl.win/2017/07/09/sjjg_4/">串之字符串 </a></h4><p>串是由n(n&gt;=0)个字符组成的有限序列，它是一种特殊的线性表。而子串是指串s中任意连续字符组成的一个子序列组成的串。同时，串的比较通常由其字符编码的相关规则比较</p>
<p>常量字符串String<br>字符串采用字符数组作为存储结构，并且采用顺序存储结构，不过String类一次性申请了固定的空间，同时由于其存储结构为最终型，所以string不提供删除，插入子串<br>变量字符串StringBuffer<br>该字符数组的容量总是大于串长，并且能够修改</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a><a href="https://www.myzwl.win/2017/07/10/sjjg_5/">栈</a></h4><p>栈是一种特殊的线性表，其特殊之处在于插入和删除操作的位置受到限制，而且插入和删除只允许在线性表的一端进行，特点是后进先出<br>顺序栈、链式栈</p>
<h4 id="顺序与链式队列"><a href="#顺序与链式队列" class="headerlink" title="顺序与链式队列"></a><a href="https://www.myzwl.win/2017/07/11/sjjg_6/">顺序与链式队列</a></h4><p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行。特点是先进先出。<br>顺序队列使用数组存储数据元素<br>1.当队列空时，设置队头、队尾下标front=rear=-1，<br>2.当第一个元素入队时，front=rear=0，同时改变两个下标<br>3.进行入队、出队操作，front、rear随之变化<br>4.当入队的元素个数（包括已出队元素）超出数组容量时，rear下标越界，数据溢出，但是，由于之前已有若干元素出队，数组前部以空出许多存储单元，所以这种溢出并不是因为存储空间不够而产生的，称为假溢出<br>所以顺序队列有两个缺点：假溢出和存储单元没有重复使用机制<br>顺序循环队列<br>相比较顺序队列，有如下不同<br>1.队头、队尾元素按照如下循环规律变化，其中length表示数组长度<br>front=（front+1)%length;<br>rear=(rear+1)%length;<br>所以可以看出front和rear的取值范围为0~length-1<br>链式队列</p>
<h4 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a><a href="https://www.myzwl.win/2017/07/14/sjjg_8/">树和二叉树</a></h4><p>基本术语<br>孩子优先遍历<br>兄弟优先遍历<br>完全二叉树和满二叉树<br>顺序与链式存储<br>模拟二叉树类</p>
<h4 id="hash散列表"><a href="#hash散列表" class="headerlink" title="hash散列表 "></a><a href="https://www.myzwl.win/2017/07/14/sjjg_9/">hash散列表 </a></h4><p>散列（hash）表是一种支持高效的查找、插入和删除操作的数据结构，它是针对查找效率接近O（1）而专门设计的。它根据元素的关键字确定元素的存储位置，而其中主要解决两个问题，设计散列函数和处理冲突<br>散列函数实质上是关键字集合到地址集合的映射，如果这种映射是一一对应的，则查找效率是O（1），但是由于散列表是一个压缩映射，即存储容量有限，即映射关系是多对一的映射，所以会产生冲突<br>除留余数法<br>该散列函数定义为hash（k）=k%p，函数结果范围为0~p-1，图示就是采用这种方法，而p取值为小于散列表长度的最大素数，如散列表长度分别为8,16,128，则对应的p（最大素数）分别为7,13,127<br>开放定址法<br>链地址法<br>模拟HashSet类</p>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a><a href="https://www.myzwl.win/2017/07/27/BSTSort_1/">二叉排序树</a></h4><p>原理<br>AVL树</p>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a><a href="https://www.myzwl.win/2017/07/30/huffman_1/">哈夫曼树</a></h4><p>基本术语<br>哈弗曼编码<br>压缩与解压原理</p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a><a href="https://www.myzwl.win/2017/08/01/graph_2/">图</a></h4><p>基本术语<br>邻接矩阵<br>深度（先序）<br>广度（层序）</p>
<h4 id="集合简单总结"><a href="#集合简单总结" class="headerlink" title="集合简单总结"></a>集合简单总结</h4><p>java集合主要分为以下三种类型：<br>Set(集)：集合中的对象不按特定方式排序，且没有重复对象。它的有些实现类能对集合中的对象按照特地方式排序。<br>List(列表)：集合中的对象按照索引位置排序，可以有重复对象，允许使用索引检索对象。<br>Map(映射)：集合中的每一个元素都包含一对键对象和值对象（key-value），集合中的键对象是不能重复的,它的一些实现类能对集合中的键对象进行排序。<br>注意这里的不能重复与比较hashcode和equals有关</p>
<p>Collection接口<br>Collection接口是Set、List、Queue接口的父接口，提供了多数集合常用的方法声明，包括 add()、remove()、contains() 、size() 、iterator() 等</p>
<p>List接口<br>它的特点是有序可重复，使用此接口能够精确的控制每个元素插入的位置用户能够使用索引来访问List中的元素并且允许有可重复的元素</p>
<p>ArrayList<br>底层实现是一个动态的数组，查询快，增删慢，线程不安全，效率高</p>
<p>LinkedList<br>底层实现是一个双向循环链表，查询慢，增删快，线程不安全，效率较高</p>
<p>Vector<br>是ArrlyList的线程安全版，底层同它基本一致，但是效率低，现在基本很少</p>
<p>Set接口<br>它的特点就是唯一性并且不允许出现重复元素和是无序的</p>
<p>hashSet<br>底层是基于哈希表实现的，而其核心就是先比较hashCode（）值是否相同（相当于索引），然后在用equals比较是否相同，从而确定元素是否重复，所以当不希望集合中有重复值，并且不关心元素之间的顺序时可以使用此类</p>
<p>LinkedHashSet<br>底层实现是使用链表和哈希表，它由链表保证元素有序，哈希表保证元素唯一，因此当不希望集合中有重复值，并且希望按照元素的插入顺序进行迭代遍历时可采用此类</p>
<p>TreeSet<br>底层实现是红黑树，也就是一种平衡AVL树，通过比较返回值是否是0来保证元素唯一性，并且通过自然排序来保证元素的排序（自然排序也就是让元素所属的类实现Comparable接口，比如abc排在abd前面，总之就是和插入顺序无关，只和元素本身的内容和特质有关）</p>
<p>Queue接口<br>它的特点就是队列，即用于保存将要执行的任务列表</p>
<p>LinkedList<br>实现了该接口，可以实现先进先出的队列</p>
<p>PriorityQueue<br>底层采用某种排序的单链表存储队列元素，用来创建自然排序的优先级队列</p>
<p>Map接口<br>Map关心的是唯一的标识符，也就是将唯一的键映射到某个元素，以键值对形式存储，键唯一，值可重复</p>
<p>HashMap<br>底层实现是基于哈希表依赖于hashCode（）和equals（）方法，线程不安全，允许key和value为NULL，效率高</p>
<p>Hashtable<br>HashMap的线程安全版，效率低，不允许key和value为NULL</p>
<p>LinkedHashMap<br>底层是由链表和哈希表组成，链表保证元素有序，哈希表保证元素唯一，所以当需要键值对，并且关心插入顺序时可采用它</p>
<p>TreeMap<br>底层是由红黑树实现，当需要键值对，并关心元素的自然排序时可采用它</p>
<p>Collections<br>内置了一些常见的集合算法，像排序，查找算法等</p>
<p>13.并发集合类是什么？<br>Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。</p>
<h4 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h4><p>每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素<br>2-3树、2-3-4树<br>B树、B+树、</p>
<h4 id="说说红黑树"><a href="#说说红黑树" class="headerlink" title="说说红黑树"></a>说说红黑树</h4><p>红黑树—使二叉搜索树更加平衡：他是一种二叉搜索树，但在每个节点上增加一个存储<br>位表示节点的颜色，可是red 或black，红黑树的查找、插入、删除的时间复杂度最坏为O(lgn)。<br>因为由n 个节点随机生成的二叉搜索树的高度为lgn，所以二叉搜索树的一般操作的执行时<br>间为O(lgn)。如何保证一颗n 个节点的红黑树的高度始终为lgn，因为红黑树的5 个性质：<br>1）每个节点，要么红的，要么黑的<br>2）根节点是黑的<br>3）叶节点都是黑的，指的是NIL 指针<br>4）若一个节点时红的，则它的两个儿子都是黑的。<br>5）对于任意节点而言，其到叶节点数尾端NIL 指针的每条路径都包含相同数目的叶节点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;线性表之顺序表&quot;&gt;&lt;a href=&quot;#线性表之顺序表&quot; class=&quot;headerlink&quot; title=&quot;线性表之顺序表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.myzwl.win/2017/07/08/sjjg_1/&quot;&gt;线性表之顺序表&lt;/a&gt;&lt;/h
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>java基础总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_6/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_6/</id>
    <published>2018-03-13T06:48:51.000Z</published>
    <updated>2018-03-18T15:44:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><a href="https://www.myzwl.win/2017/07/16/yc_1/">异常处理</a></h4><p>从大的角度说主要分成两类：Error类代表了编译和系统的错误，不允许捕获，也就是我们自己无法主动去处理它；Exception类代表了我们可捕获并且可自己可处理异常，而Exception有包括两类，一个是你必须要处理的异常，如某个类有throws异常了，在未进入运行期就必须处理，另一类就是Runtime Exception（运行期异常），就是只有在运行时（也就是编译成class文件）时才知道，这个异常可处理或不处理</p>
<p>try-catch-finally 规则<br>1）在finally语句块中发生了异常。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）关闭CPU。</p>
<h4 id="java-IO简单总结"><a href="#java-IO简单总结" class="headerlink" title="java IO简单总结 "></a><a href="https://www.myzwl.win/2017/07/23/IO_1/">java IO简单总结 </a></h4><p>流：数据在数据源（文件）和程序（内存）之间经历的路径<br>输入流：数据从数据源到内存的路径<br>输出流：数据从内存到数据源的路径<br>字节流：可以用于读写二进制文件及任何类型的byte，也就是一个字节一个的读<br>字符流：可以用于读写文本文件，不能操作二进制文件，也就是两个字节两个字节的读<br>2.根据数据流向不同分为：输入流和输出流<br>3。节点流和处理流<br>节点流：直接与数据源相连，读入或读出，可以发现使用该流过于频繁操作硬件，从而使读写很不方便<br>处理流：处理流和节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。<br>Object流的意思将是像一根节点流插入一根Object流管道，专门操作Object，而它必须实现Serializable接口，该接口的意思是可序列化，就是说将一个对象流序列化成子节流写进网络或者文件，比如说游戏存盘，有各个游戏的记录，如果以面向对象来写进管道，它的各个成员变量，会在内存中被序列化成二进制写进去，而Serializable接口无方法，它只是个标记接口，编译器看到实现该接口的类就知道它应该被序列化，同样有一个transient关键字，是使可序列化的某个属性变成透明，也就是它不能变成字节写进去，那个属性只能为默认属性写进去</p>
<h4 id="反射机制简单"><a href="#反射机制简单" class="headerlink" title="反射机制简单"></a>反射机制简单</h4><p>classLoad、Class、Methods</p>
<h4 id="java基本数据类型"><a href="#java基本数据类型" class="headerlink" title="java基本数据类型"></a>java基本数据类型</h4><p>byte、short、int、long、float、double、char、boolean</p>
<h4 id="能否重写构造方法"><a href="#能否重写构造方法" class="headerlink" title="能否重写构造方法"></a>能否重写构造方法</h4><p>重载构造方法是可以的。<br>但是重写则不可以，因为被重写的前提是被继承，而构造方法根本就不能被继承，所以谈不上被重写。只能调用父类的构造方法</p>
<h4 id="构造代码块和构造方法的执行顺序"><a href="#构造代码块和构造方法的执行顺序" class="headerlink" title="构造代码块和构造方法的执行顺序"></a>构造代码块和构造方法的执行顺序</h4><p>父类静态块-自身静态块-父类块-父类构造器-自身块-自身构造器</p>
<h4 id="说说-amp-与-amp-amp-的区别"><a href="#说说-amp-与-amp-amp-的区别" class="headerlink" title="说说&amp;与&amp;&amp;的区别"></a>说说&amp;与&amp;&amp;的区别</h4><p>&amp;与&amp;&amp;都可以用作逻辑与（and）的运算符<br>&amp;&amp;具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。而&amp;则会同时计算<br>&amp;可以作为位运算符，当&amp;两边表达式不是boolean时，&amp;表示按位与操作，通常使用Ox0f来与一个整数&amp;运算，来取该整数的最低4个bit位</p>
<h4 id="Overload与Override的区别？Overload的方法是否可以改变返回值的类型？"><a href="#Overload与Override的区别？Overload的方法是否可以改变返回值的类型？" class="headerlink" title="Overload与Override的区别？Overload的方法是否可以改变返回值的类型？"></a>Overload与Override的区别？Overload的方法是否可以改变返回值的类型？</h4><p>重载表示方法名相同，但是参数个数或类型不同）<br>重写表示子类中的方法可以与父亲中某个方法的名称和参数完全相同，通过子类创建实例调用父类这个方法，也就是相当于覆盖了父类的这个方法，但是当父类是private时相当于子类增加了一个全新的方法，就不存在覆盖了。并且子类应该比父类抛出更少的异常或者拥有更大的权限<br>如果参数名不同会改变返回类型，但是如果都一样肯定不会改变返回类型</p>
<h4 id="abstractclass和interface语法上有什么区别？"><a href="#abstractclass和interface语法上有什么区别？" class="headerlink" title="abstractclass和interface语法上有什么区别？"></a>abstractclass和interface语法上有什么区别？</h4><p>1.抽象类可以有构造方法，接口不能有构造方法<br>2.抽象类中可以有普通成员方法，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。<br>4.抽象类中的抽象方法访问类型可以是public、protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型<br>5.抽象类中可以包含静态方法，接口中不能包含静态方法<br>6.抽象类和接口类中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以是任意，但是接口中定义的变量只能是public static final类型<br>7一个类可以实现多个接口，但只能继承一个抽象类</p>
<h4 id="什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？"><a href="#什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？" class="headerlink" title="什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？"></a>什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？</h4><p>将一个对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如将一个java对象存储到硬盘或者送给网络上的其他计算机，可以用代码把一个java对象变成某个格式的字节流在传输<br>如果要让java自动帮我们做，就需要实现serializable接口，编译的类才被writeObject方法操作，例如，在web中，如果对象被保存在了session中，tomcat在重启时要把session对象序列化到硬盘</p>
<h4 id="hashcode与equals"><a href="#hashcode与equals" class="headerlink" title="hashcode与equals"></a><a href="https://www.cnblogs.com/jesonjason/p/5492208.html" target="_blank" rel="external">hashcode与equals</a></h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;异常处理&quot;&gt;&lt;a href=&quot;#异常处理&quot; class=&quot;headerlink&quot; title=&quot;异常处理&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.myzwl.win/2017/07/16/yc_1/&quot;&gt;异常处理&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;从大的角度说主要分
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_7/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_7/</id>
    <published>2018-03-13T04:48:51.000Z</published>
    <updated>2018-03-18T15:46:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1"><a href="#网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1" class="headerlink" title="网络编程简单总结(https://www.myzwl.win/2017/07/29/socket_1/)"></a>网络编程简单总结(<a href="https://www.myzwl.win/2017/07/29/socket_1/">https://www.myzwl.win/2017/07/29/socket_1/</a>)</h4><p>tcp/ip分层<br>链接层（ARP欺诈）-网络层（ip、icmp（ping））-传送层（tcp、udp）-应用层（POP3、Http、FTP，SSH、SMTP）<br>ip协议<br>ip层就是唯一确定了一台机器，就像我们住的房间地址一样，唯一确定了我们的住处<br>这里需要注意的是，ip地址由四位字节组成，每个字节由8位二进制组成，同时有a，b，c三类地址，如图由网络号和主机号组成，当然这是公网，如果是局域网的话，就需要配网关和子网掩码了，如192.168.1.1和255.255.0.0那么255.255就是确定了ip地址哪几位字节是网络号，如192.168就是网络号<br>TCP与UDP协议<br>tcp协议<br>有65536个端口 0号是保留端口<br>1-1024是固定端口<br>又叫有名端口，即被某些程序固定使用，一般程序员不使用。<br>22：SSH远程登录协议 23：telnet使用 21：ftp使用<br>25：smtp服务使用 80：iis使用 7：echo服务<br>1025-65535是动态端口<br>UDP协议<br>UDP向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接。<br>简单来说，就是只发一次数据，不管对方有没有接收到都不会再发了，但是有时候效率会很高，像网络拥堵时</p>
<p>url<br>统一资源定义符也被称为网页地址。Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL地址，这种地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是Internet上的站点，简单地说，URL就是Web地址，俗称“网址”，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法，如：<br><a href="http://www.sina.com:8080/index.html" target="_blank" rel="external">http://www.sina.com:8080/index.html</a><br>1、协议；2、ip地址(32位)；3、端口号(16位)0-65535；4、资源名称。</p>
<p>单工、半双工和全双工<br>Socket编程（模拟socket编程）</p>
<h4 id="tcp-如何保证传输的可靠性"><a href="#tcp-如何保证传输的可靠性" class="headerlink" title="tcp 如何保证传输的可靠性"></a>tcp 如何保证传输的可靠性</h4><p>tcp 是面向连接，可靠的字节流服务<br>面向连接意味着两个使用tcp 的应用（通常是一个客户端和一个服务器）在彼此交换数<br>据之前必须先建立一个tcp 连接。在一个tcp 连接中，仅有两方进行彼此通信，广播和多播<br>不能用于tcp。<br>Tcp 通过下列方式提供可靠性：<br>1）将应用数据分割为tcp 认为最合适发送的数据块；<br>2）超时重传：当tcp 发出一个段后，他启动一个定时器，等待目的端确认收到这个报<br>文段。若不能及时收到一个确认，将重发这个报文段。<br>3）当tcp 收到发自tcp 链接另一端的数据时，它将发送一个确认（对于收到的请求，给<br>出确认响应）。这个确认不是立即发送，通常将推迟几分之一秒（之所以推迟，可能是要对<br>包做完校验）；<br>4）若tcp 收到包，校验出包有错，丢弃报文段，不给出响应，tcp 发送端会超时重传；<br>5）对于失序数据进行重新排序，然后交给应用层（tcp 报文段作为ip 数据报进行传输，<br>而ip 数据报的到达会失序，因此tcp 报文段的到达也可能失序。若必要，tcp 将对收到的数<br>据进行重新排列，以正确的顺序交给应用层）。<br>6）对于重复数据，直接丢弃。<br>7）tcp 可以进行流量控制，防止较快主机致使较慢主机的缓冲区溢出<br>字节流服务：两个应用程序通过tcp 连接，tcp 不在字节中插入记录标识符，我们将这<br>种为字节流服务。<br>Tcp 对字节流的内容不做任何解释，tcp 不知道传输的字节流数据是二进制数据还是ascii<br>字符或其他类型数据，对字节流的解释由tcp 连接双方的应用层。</p>
<h4 id="简单描述一下https"><a href="#简单描述一下https" class="headerlink" title="简单描述一下https"></a>简单描述一下https</h4><p>https 其实是由两部分组成：http+ssl/tls，也就是在http 上又加了一层处理加密信息的<br>模块，服务端和客户端的信息传输都会通过tls 加密，传输的数据都是加密后的数据。加解<br>密过程：<br>1）客户端发起https 请求（就是用户在浏览器里输入一个https 网址，然后连接到server<br>的443 端口）<br>2）服务端的配置（采用https 协议的服务器必须要有一塔数字证书，可以自己制作，<br>也可以向组织申请，这套证书就是一对公钥和私钥）。<br>3）传输证书（这个证书就是公钥，只是包含了很多信息）<br>4）客户端解析证书（由客户端tls 完成，首先验证公钥是否有效，若发现异常，则弹出<br>一个警示框，提示证书存在问题，若无问题，则生成一个随机值，然后用证书对随机值进行<br>加密）<br>5）传输加密信息（这里传输的是加密后的随机值，目的是让服务端得到这个随机值，<br>以后客户端和服务端的通信就可以通过这个随机值来进行加密了）<br>6）服务端解密信息（服务端用私钥解密后得到了客户端传来的随机值，then 把内容通<br>过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混在一起，这样除非<br>知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法<br>够彪悍，私钥够复杂，数据就够安全）<br>7）传输加密的信息<br>8）客户端解密信息，用随机数来解。</p>
<p>短链接一般只会在client/server 间传递一次读写操作。<br>Tcp 保活功能，主要为服务器应用程序提供，服务器应用程序需要知道客户主机是否崩<br>溃，从而可以代表客户使用资源.<br>tcp 保护功能是探测长连接存活状况。<br>Tcp 的keep-alive 是检查当前tcp 是否还活着；http 的keep-alive 是让一个tcp 连接活多<br>久，他们是不同层次的概念。</p>
<p>a 发送给b 一个信息，但是a 不承认他发送了，防止这个可用数字签名<br>DNS 即使用tcp，又使用udp<br>https 若在浏览器端抓包，是可以看到数据的，并没有加密，抓到的是加密之前的</p>
<h4 id="http-请求过程——当我们在浏览器输入www-baidu-com，然后回车之后的详解"><a href="#http-请求过程——当我们在浏览器输入www-baidu-com，然后回车之后的详解" class="headerlink" title="http 请求过程——当我们在浏览器输入www.baidu.com，然后回车之后的详解"></a>http 请求过程——当我们在浏览器输入www.baidu.com，然后回车之后的详解</h4><p>1）域名解析（域名www.baidu.com 变为ip 地址）。<br>2）发起tcp 的三次握手，建立tcp 连接。浏<br>览器会以一个随机端口（1024-65535）向服务端的web 程序80 端口发起tcp 的连接.这个请<br>求（原始的http 请求，经过原始的tcp/ip 四层模型层层封装），到达服务器端后，进入网<br>卡，然后进入内核的协议栈（一层一层拨开），然后到达web 应用程序，最终建立了tcp/ip<br>链接。<br>3）建立tcp 连接后发起http 请求。<br>4）服务器响应http 请求，客户端得到html 代码。<br>服务器web 应用程序收到http 请求后，就开始处理请求，处理之后就返回给浏览器html<br>文件。<br>5）浏览器解析html 代码，并请求html 中的资源。<br>6）浏览器对页面进行渲染，并呈现给用户。</p>
<h4 id="什么是正向代理和反向代理"><a href="#什么是正向代理和反向代理" class="headerlink" title="什么是正向代理和反向代理"></a>什么是正向代理和反向代理</h4><p>正向代理：我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代<br>理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要哪<br>个无法访问的网站的内容，代理服务器取回来给我。server 不知道client。<br>反向代理：client 不知道server，并不是URL 中请求的那个资源，而是不知道从什么地方来<br>的。以代理服务器来接收internet 上的请求，然后将请求转发给内部网络的服务器，并将从<br>服务器上得到的结果返回给internet 上请求的客户，此时代理服务器对外就表现为一个服务<br>器。1）保证内网安全、2）负载均衡，nginx 通过proxy-pass-http 配置代理站点，upstream<br>实现负载均衡。</p>
<h4 id="怎么用udp-实现tcp"><a href="#怎么用udp-实现tcp" class="headerlink" title="怎么用udp 实现tcp"></a>怎么用udp 实现tcp</h4><p>由于在传输层udp 已经是不可靠的，那就要在应用层自己实现一<br>些保证可靠传输的机制，简单来说，要使用udp 来构建可靠的面向连接的数据传输，就要<br>实现类似于tcp 的超时重传（定时器），拥塞控制（滑动窗口），有序接收（添加包序号），<br>应答确认（ack 和seq）。目前已经有了实现udp 可靠运输的机制——udt：主要目的高速广<br>域网海量数据传输，他是应用层协议</p>
<p>Tcp：<br>1）流量控制：防止较快主机使较慢主机缓冲区溢出，是点对点；<br>2）拥塞控制：全局性，防止过多的数据注入网络。<br>tcp 采用滑动窗口进行流量控制，滑动窗口大小可变，窗口大小的单位是字节。</p>
<h4 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h4><p>在分布式集群中，对机器的添加和删除或机器故障后自动脱离集群，这些操作是分布式<br>集群管理最基本的功能，若采用常用的hash(object)%N 算法，那么在有机器添加或删除以后，<br>很多原有的数据就无法找到，所以出现一致性哈希算法——<br>1）环形hash 空间：按照常用的<br>hash 算法来将对应的key 哈希到一个具有232 个桶的空间，即（0-232 -1）的数字空间中，现<br>在我们将这些数字头尾相连，想象成一个闭合的环形。<br>2）把数据通过一定的hash 算法映射到环上。<br>3）将机器通过一定的hash 算法映射到环上。<br>4）节点按顺时针转动，遇到的第一个机器，就把数据放在该机器上</p>
<h4 id="Nginx负载均衡五种配置"><a href="#Nginx负载均衡五种配置" class="headerlink" title="Nginx负载均衡五种配置"></a>Nginx负载均衡五种配置</h4><p>1）轮询（默认），每个请求按时间顺序逐一分配到不同的后端服务器，如果后端<br>服务器down 掉，能自动剔除；<br>2）指定权重，指定轮询几率。权重越大，轮询几率越大，<br>用于后端服务器性能不均的情况。<br>3）ip 绑定ip_path，每个请求按访问ip 的哈希结果分配，<br>这样每个客户固定访问一个服务器，可以解决session 问题。<br>4）fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>5）url_hash 按访问的url 结果来分配请<br>求，使每个url 定位到同一个后端服务器。后端服务器为缓存时比较有效</p>
<h4 id="三次握手-手动画出图解"><a href="#三次握手-手动画出图解" class="headerlink" title="三次握手(手动画出图解)"></a>三次握手(手动画出图解)</h4><p> 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p>完成三次握手，客户端与服务器开始传送数据</p>
<p> 关闭TCP连接：改进的三次握手</p>
<p>对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：</p>
<p>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p>
<p>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p>
<p>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p>
<p>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放</p>
<h4 id="两次握手不行吗"><a href="#两次握手不行吗" class="headerlink" title="两次握手不行吗"></a>两次握手不行吗</h4><p>A发送报文滞留过长导致失效，然后b发送链接请求，A不理睬</p>
<h4 id="TIME-WAIT为什么是2MSL"><a href="#TIME-WAIT为什么是2MSL" class="headerlink" title="TIME-WAIT为什么是2MSL"></a>TIME-WAIT为什么是2MSL</h4><p>确保最后一个报文发到b，没有则重传<br>防止已失效的报文链接出现在本链接中</p>
<h4 id="为什么TCP释放连接需要四次"><a href="#为什么TCP释放连接需要四次" class="headerlink" title="为什么TCP释放连接需要四次"></a>为什么TCP释放连接需要四次</h4><p>  TCP建立连接要进行三次握手，而断开连接要进行四次。这是由于TCP的半关闭造成的。因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个方向的连接</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1&quot;&gt;&lt;a href=&quot;#网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>javaweb基础总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_8/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_8/</id>
    <published>2018-03-13T02:48:51.000Z</published>
    <updated>2018-03-21T08:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说一说servlet的生命周期"><a href="#说一说servlet的生命周期" class="headerlink" title="说一说servlet的生命周期"></a>说一说servlet的生命周期</h4><p>1）构造函数：<br>只有第一次请求servlet 时，创建servlet 实例，调用构造器，这说明servlet 是单例的，所以又线程安全<br>问题，只被调用一次<br>2）init：<br>只被调用一次，在创建好实例后，立即被调用，用来初始化servlet<br>3）service：<br>被多次调用，每次请求都会调用service，实际响应请求。<br>4）destory：<br>只被调用一次，在当前servlet 所在的web 应用被卸载前调用，用于释放当前servlet 所占用的资源。</p>
<h4 id="servlet-API中forward（）与redirect（）区别"><a href="#servlet-API中forward（）与redirect（）区别" class="headerlink" title="servlet API中forward（）与redirect（）区别"></a>servlet API中forward（）与redirect（）区别</h4><p>从地址栏显示来说：<br>forward是服务器请求的地址资源，通过内部转发方式最后只返回一次内容，而redirect是重新转发，也就是需要经过两次请求与响应<br>从数据共享来说<br>forward可以共享request里的数据，而redirect不行，forward是服务器内部的一种操作，而redirect是服务器通知客户端，然后客户端重新发起请求<br>从运用地方<br>forward一般用于用户登录的时候，根据角色转发到相应的模块<br>redirect一般用于用户注销登录时返回主页和跳转到其它的网站<br>从效率上<br>forward高，redirect低</p>
<h4 id="request-getAttribute-和request-getParameter-有什么区别"><a href="#request-getAttribute-和request-getParameter-有什么区别" class="headerlink" title="request.getAttribute()和request.getParameter()有什么区别"></a>request.getAttribute()和request.getParameter()有什么区别</h4><p>后者取得通过容器的实现来取得通过类似post，get等方式传入的数据<br>前者返回对象，后者返回字符串</p>
<h4 id="Http中get和post方法区别"><a href="#Http中get和post方法区别" class="headerlink" title="Http中get和post方法区别"></a>Http中get和post方法区别</h4><p>1.get请求的数据会被浏览器缓存起来，并以明文方式出现在url中，不太安全而post则更安全<br>2get传输数据有大小限制get请求的参数会跟在url后进行传递</p>
<h4 id="说说Cookie"><a href="#说说Cookie" class="headerlink" title="说说Cookie"></a>说说Cookie</h4><p>http 都是无状态的协议，web 服务器不能识别出哪些请求是同一个浏览器发的，浏览器的每一次请求都是完全独立的<br>Cookie 放在浏览器端，浏览器第一次范围服务器时，没有cookie，then 服务器给浏览<br>器一个cookie，以后每次浏览器访问服务器都要带上这个cookie。Jsp 是服务端<br>&lt;% 1.创建一个cookie 对象Cookie cookie =new Cookie(“name”,”jhb”);<br>2.调用response 的一个方法把cookie 传输给客户端<br>Response.addCookie（cookie）;%&gt;<br>默认情况下cookie 是会话级别，存储在浏览器内存中，用户退出浏览器之后被删除，<br>若希望浏览器将cookie 存在磁盘上，则要使用maxage，并给一个以秒为单位的时间，表示<br>cookie 的存活时间。<br>Cookie 作用范围：可以作用当前目录和当前目录的子目录，但不能作用与当前目录的上<br>一级。<br>Cookie:在客户端保持http 状态信息的方案，会话跟踪。</p>
<h4 id="说说session"><a href="#说说session" class="headerlink" title="说说session"></a>说说session</h4><p>在服务器端保持http 状态信息<br>当浏览器第一次范围服务器时，没有cookie，服务器也就得不到JSession_id，then 服<br>务器创建一个session 对象，并返回一个JSession_id 给浏览器，通过cookie 返回，下次浏览<br>器再访问服务器时就带上cookie（其中有JSession_id），服务器就能找到对应的session 对<br>象。JSession_id 可以通过cookie 传输，也可以通过url 传送。</p>
<p>一个session，对应一个sessionID</p>
<p>Session：浏览器和服务器的一次会话，若浏览器不关，至始至终都是一个session，因<br>为用cookie 传送。<br>当程序需要为某给客户端的请求创建session 时，服务器首先检查这个客户端的请<br>求是否包含一个session 标识，即JSession_id，如果包含，则说明以前已经为此客户创建过<br>JSession_id，服务器就按照这个JSession_id 检索出来（若检索不到，可能会新建一个，这种<br>情况下可能会出现在服务器已经删除了该用户对应的session 对象。但用户人为的在请求的<br>URL 上附加衣蛾JSession_id 的参数。）如不包含则创建一个session，并生成与这个session<br>有关的JSession_id，这个JSession_id 将在本次响应中返回给客户端。<br>默认session 用cookie</p>
<p>若第一次访问某web 应用程序的一个jsp 页面，且该jsp 页面的page 指定session=true，<br>服务器会创建一个httpsession 对象。<br>注：关闭浏览器只是使存储在浏览器内存中的session cookie 失效，不会使服务器端的<br>session 对象失效</p>
<h4 id="xml-解析技术"><a href="#xml-解析技术" class="headerlink" title="xml 解析技术"></a>xml 解析技术</h4><p>1）dom：必须在解析之前把整个文档装入内存，处理大型文件时，性能低，适合xml 随机访问。<br>2）sax：事件驱动，它顺序读取xml 文件，不需要一次全部载入整个文件。当遇到文件开头，文档结束or 标签开头or 标签结束时，他会触发一个事件，用户通过在其回调事件中写入处理代码来处理xml 文件，适合顺序访问</p>
<h4 id="多个请求映射到同一个jsp-页面"><a href="#多个请求映射到同一个jsp-页面" class="headerlink" title="多个请求映射到同一个jsp 页面"></a>多个请求映射到同一个jsp 页面</h4><p>1）这几个请求的名字都为xxx.do,all 以.do 结尾的都映射到同一个servlet。<br>2）用request 获得path，即/xxx.do。<br>3）去掉后面的.do 和前面的”/”，得到方法名,即xxx。<br>4）利用反射调用相关方法</p>
<h4 id="Httpsession-生命周期"><a href="#Httpsession-生命周期" class="headerlink" title="Httpsession 生命周期"></a>Httpsession 生命周期</h4><p>1）什么时候创建httpsession？<br>答案：1.是否浏览器访问服务器<br>的任何一个jsp 或者servlet，服务器都会创建一个httpsession？不一定，设置session=false，<br>若当前jsp 是客户端访问的当前web 应用的第一个资源，且page 指定的session=false，则服<br>务器不会为jsp 创建session 对象。若当前jsp 不是客户端访问的当前web 应用的第一个资源，<br>且其他页面已经创建了其他httpsession 对象，则返回一个和当前会话相关的httpsession 对<br>象，不创建一个新对象。</p>
<p>2.session=false 是什么意思<br>当前jsp 页面禁用session 隐含变量，但可以使用其他的显示的httpsession 的对象</p>
<p>3.对于servlet，若servlet 是客户端访问的第<br>一个web 应用资源，只有调用request.getSession（）或除了1 和2 以外，只要访问jsp，则<br>要创建session 对象。</p>
<p>4.什么时候销毁session 对象<br>1.直接调用httpsession 的invalidate 方法，该方法使httpsession 失效。<br>2.当前web 应用被卸载。<br>3.超出httpsession 的过期时间。</p>
<h4 id="JavaWeb-servlet-监听器"><a href="#JavaWeb-servlet-监听器" class="headerlink" title="JavaWeb-servlet 监听器"></a>JavaWeb-servlet 监听器</h4><p>监听器：专门用与对其他对象身上发生的事件或状态的改变进行监听or 相应处理的对象。<br>当被监视的对象发生情况时，立即采取相应的行动<br>Servlet 监听器：一种特殊的类，用于ServletContext，httpsession，Servletrequest 等域<br>对象的创建与销毁事情，以及监听这些对象中的属性发生修改的事件<br>监听域对象的创建和销毁<br>    创建时间                            销毁时间<br>ServletContext（application）  web 应用被加载web 应用被销毁<br>Httpsession（session）<br>Servletrequest（request）   每次请求开始时创建每次访问结束后销毁</p>
<p>ServletContextListener 最为常用，监听ServletContext 对象创建or 销毁的Servlet 监听器，可以在当前web 应用被加载时对当前web 应用的相关资源进行初始化，比如：创建数据库连接池<br>HttpsessionListener：sessioncreated 在session 被创建后调用，sessionDestoryed 在session被销毁前调用。</p>
<h4 id="域对象生命周期"><a href="#域对象生命周期" class="headerlink" title="域对象生命周期"></a>域对象生命周期</h4><p>1）request：是一个请求，当一个相应返回时被销毁，发一个请求时被创建<br>1.forword 只有一个请求，只有一个request<br>2.response 有两个request<br>2）session：当第<br>一次访问web 应用的一个jsp 或Servlet 时，且该jsp 和Servlet 中还需要创建session 对象，<br>此时服务器会创建一个session 对象<br>3）application：ServletContext 对象。当前web 应用被<br>加载时创建，web 应用被卸载时销毁。</p>
<h4 id="说说Filter"><a href="#说说Filter" class="headerlink" title="说说Filter"></a>说说Filter</h4><p>1）目的：调用目标资源前让一段代码执行，是否允许用户调用目标资源，调<br>用目标资源之后让一段代码执行<br>2）编写java 类，实现filter 接口，配置filter-mapping，<br>说明对哪些资源进行拦截。<br>3）每次拦截时，都调用filter 的dofilter 方法<br>4）filter 创建和销毁由servlet 容器，在web 应用启动时，创建实例，并调用init 方法，filter 对象只创建一<br>次，init 只执行一次。Destory，容器卸载filter 对象前被调用。<br>5）用户在配置filter 时，可<br>以使用<init-param>为filter 配置一些初始化参数，当web 容器实例化filter 对象时，调用其<br>init 方法，会把封装了filter 初始化参数的filter config 对象初始化，所以开发人员在写filter<br>时，可以用filter config 对象的方法来获得初始化对象。<br>6）应用：统一全站的字符编码；禁止浏览器缓存；实现url 级别的权限认证</init-param></p>
<h4 id="说说拦截器"><a href="#说说拦截器" class="headerlink" title="说说拦截器"></a>说说拦截器</h4><p>拦截器，在AOP中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作<br>启动顺序 :监听器 &gt; 过滤器 &gt; 拦截器<br>拦截器与过滤器的区别：<br>过滤器Filter依赖于Servlet容器，基于回调函数，过滤范围大。<br>拦截器Interceptor依赖于框架容器，基于反射机制，只过滤请求</p>
<h4 id="说说集群"><a href="#说说集群" class="headerlink" title="说说集群"></a>说说集群</h4><p>1）伸缩性：系统适应不断增长的用户数的能力。<br>2)高可用性:避免单一服务器的单点失效<br>3)负载均衡:把请求发给不同服务器<br>4）失效转移：当一个节点失效后，通过选择集<br>群中的另一个节点，处理将会继续而不会终止。httpssession 失效转移，用来保证当某台服<br>务器失效以后，会话状态不会丢失，为了支持会话转移，web 服务器将在一定的时候把会话<br>对象备份到其他地方，以防丢失。这个其他地方有jdbc 数据库、其他所有服务器、任意选<br>择其他一台web server、中央server</p>
<h4 id="Ajax的实现流程是主怎样的"><a href="#Ajax的实现流程是主怎样的" class="headerlink" title="Ajax的实现流程是主怎样的"></a>Ajax的实现流程是主怎样的</h4><p>1创建XMLHttpRequest对象，也就是创建一个异步调用对象<br>2.创建一个新的HTTp请求，并指定该HTTP请求的方法，url及验证信息<br>3设置http请求状态变化的函数<br>4.发送HTTp请求<br>5获取异步调用返回的数据<br>6.使用javascript和DOM实现局部刷新</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说一说servlet的生命周期&quot;&gt;&lt;a href=&quot;#说一说servlet的生命周期&quot; class=&quot;headerlink&quot; title=&quot;说一说servlet的生命周期&quot;&gt;&lt;/a&gt;说一说servlet的生命周期&lt;/h4&gt;&lt;p&gt;1）构造函数：&lt;br&gt;只有第一次请求
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>基本框架基础总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_9/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_9/</id>
    <published>2018-03-13T00:48:51.000Z</published>
    <updated>2018-03-21T08:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="谈谈你对struts的理解"><a href="#谈谈你对struts的理解" class="headerlink" title="谈谈你对struts的理解"></a>谈谈你对struts的理解</h4><p>1.structs本质就是一个servlet，而这个servlet就是ActionServlet或是其子类，即将所有请求都交给servlet去处理，而该servlet参考配置文件将请求分发给不同action处理<br>2.在把请求交给action之前，会将参数封装成一个frombean对象，而该对象只有通过validate方法，才能将对象传递给execute方法，否则将返回一个错误页面，并且这个页面由input属性指定<br>3.action执行完之后要返回显示的结果视图，这个结果一个actionForward来表示，而其是通过在struts配置文件中配置获得返回页面</p>
<h4 id="谈谈struts的优缺点"><a href="#谈谈struts的优缺点" class="headerlink" title="谈谈struts的优缺点"></a>谈谈struts的优缺点</h4><p>优点：<br>1.实现mvc模式，结构清晰，使开发者只关注业务逻辑的实现<br>2有丰富的tag可以使用，大大提高开发效率<br>3.页面导航使系统的脉络更加清晰<br>4.提供Exception处理机制<br>缺点：<br>1.structs的action是一种thread-safe方式，它仅仅允许一个实例处理所有的请求。容易引起线程安全问题<br>2 测试不方便。struts的每个action都同web层耦合在一起，这样它的测试依赖于web容器，单元测试很难实现<br>3.对servlet的依赖性过强，struts处理action时必须依赖servletRequest和servletRespouse，所以它摆脱不了servlet容器</p>
<h4 id="谈谈你对hibernate的理解"><a href="#谈谈你对hibernate的理解" class="headerlink" title="谈谈你对hibernate的理解"></a>谈谈你对hibernate的理解</h4><p>1.使用hibernate的基本流程：配置Configuration对象、产生sessionfactory、创建session对象、启动事务，完成CRUD操作，提交事务，关闭session<br>2.使用hibernate时，先要配置hibernate.cfg.xml文件，其中配置数据库连接信息和方言，还要为每个实体配置相应的hbm.xml文件<br>3.在应用hibernate时，重点要了解session的缓存原理，级联，延迟加载和hql语句</p>
<h4 id="介绍一下hibernate的二级缓存"><a href="#介绍一下hibernate的二级缓存" class="headerlink" title="介绍一下hibernate的二级缓存"></a>介绍一下hibernate的二级缓存</h4><p>回答思路：1.首先说清楚什么是缓存<br>2.再说有了hibernate的session就是一级缓存，即有了一级缓存，为什么还要有二级缓存<br>3.最后说如何配置hibernate的二级缓存</p>
<p>1.缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中，这个数据结构通常类似于hashmap，当以后要使用某个对象时，先查询缓存中是否有这个对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在缓存中，以便下次使用<br>2.hibernate的session就是一级缓存，当想要使用session从数据库中查询出的一个对象时，session也是先从自己内部查看是否存在这个对象，存在则直接返回，不存在则查询数据库<br>由于session代表依次会话，一个session与一个数据库连接的相关性，通常仅用一个事务，用完就关闭，由于一级缓存是线程不安全的，要被多个线程共享，而二级缓存是全局缓存，可以被多个线程和事务共享<br>3二级缓存是独立于hibernate的软件部件，如ehcache</p>
<h4 id="hibernate中sessionFactory是线程安全吗？session是线程安全的吗"><a href="#hibernate中sessionFactory是线程安全吗？session是线程安全的吗" class="headerlink" title="hibernate中sessionFactory是线程安全吗？session是线程安全的吗"></a>hibernate中sessionFactory是线程安全吗？session是线程安全的吗</h4><p>sessionfactory对应一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。一般在启动的时候通过单例模式进行封装便于访问<br>session是一个轻量级的非线程安全的对象，线程间不能共享session，session默认会延迟获取数据库连接</p>
<h4 id="简单说一下mybatis的一级缓存和二级缓存"><a href="#简单说一下mybatis的一级缓存和二级缓存" class="headerlink" title="简单说一下mybatis的一级缓存和二级缓存"></a>简单说一下mybatis的一级缓存和二级缓存</h4><p>mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从从缓存取出返回结果集。mybatis内部缓存使用一个hashmap，key为hashcode+sqlid+sql语句。value从查询出来映射生成java对象<br>mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个namespace中查询sql可以从缓存中存取数据，二级缓存是可以跨sqlsession的</p>
<h4 id="mybatis中的动态SQL是什么意思"><a href="#mybatis中的动态SQL是什么意思" class="headerlink" title="mybatis中的动态SQL是什么意思"></a>mybatis中的动态SQL是什么意思</h4><p>动态sql主要包括if、choose、when、otherwise、trim、where、set、foreach</p>
<h4 id="mybatis和hibernate有什么不同"><a href="#mybatis和hibernate有什么不同" class="headerlink" title="mybatis和hibernate有什么不同"></a>mybatis和hibernate有什么不同</h4><p>相同点：<br>都屏蔽了jdbc api底层访问细节，编程流程固定，还将sql语句与java代码混杂在一起<br>不同点<br>半自动，将sql语句与代码进行分离，提供了将结果集自动封装成为实体对象和对象集合的功能<br>全自动，hibernate，提供hql语句</p>
<h4 id="谈谈你对spring的理解"><a href="#谈谈你对spring的理解" class="headerlink" title="谈谈你对spring的理解"></a>谈谈你对spring的理解</h4><p>1.spring是实现了工厂模式的工厂类，这个类为beanFactory，通常为其子类applicationContext，spring相当于一个大的工厂类，在其配置文件中通过元素配置用于创建实例对象名和实例对象的属性<br>2.spring提供了对IOC的良好支持，利用IOC可以很好的实现模块间的解耦<br>3.spring提供了对AOP技术的良好封装，即把系统中很多不相干的类的方法，在这些众多的方法中加入某种系统功能的代码，例如，加入日志，权限判断，异常处理等等，称为AOP<br>4实现AOP采用代理类，在jdk中采用proxy类产生动态代理的方式为某个接口生成实现类</p>
<h4 id="使用spring框架的好处是什么"><a href="#使用spring框架的好处是什么" class="headerlink" title="使用spring框架的好处是什么"></a>使用spring框架的好处是什么</h4><p>轻量级、控制反转、面向切面编程（AOP）、容器（包含并管理应用中对象的生命周期和配置）、mvc框架、事务管理、异常处理</p>
<h4 id="什么是spring的依赖注入？有哪些方法进行依赖注入？"><a href="#什么是spring的依赖注入？有哪些方法进行依赖注入？" class="headerlink" title="什么是spring的依赖注入？有哪些方法进行依赖注入？"></a>什么是spring的依赖注入？有哪些方法进行依赖注入？</h4><p>你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件和服务，之后一个容器负责把他们组装起来<br>构造器依赖注入、setter方法注入</p>
<h4 id="解释spring框架中bean的生命周期"><a href="#解释spring框架中bean的生命周期" class="headerlink" title="解释spring框架中bean的生命周期"></a>解释spring框架中bean的生命周期</h4><p>1.spring容器从XML文件中读取bean的定义，并实例化bean<br>2.spring根据bean的定义填充所有的属性<br>3.如果bean实现了beanNameAware接口，spring传递bean的ID到setBeanName方法<br>4.如果Bean实现了BeanFactoryAware接口，spring传递beanfactory给setBeanFactory<br>5.如果有任何与bean相关联的beanpostprocessors，spring会在postprocesserBeforeInitalzation（）方法内部调用他们<br>6.如果bean实现了intialzingBean了，调用它的afterPropertySet方法，如果bean声明初始化方法，调用此初始化方法<br>7.如果bean实现了disposableBean，它将调用destroy（）方法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;谈谈你对struts的理解&quot;&gt;&lt;a href=&quot;#谈谈你对struts的理解&quot; class=&quot;headerlink&quot; title=&quot;谈谈你对struts的理解&quot;&gt;&lt;/a&gt;谈谈你对struts的理解&lt;/h4&gt;&lt;p&gt;1.structs本质就是一个servlet，而这个
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>时髦框架基础总结</title>
    <link href="http://www.myzwl.win/2018/03/12/dream_10/"/>
    <id>http://www.myzwl.win/2018/03/12/dream_10/</id>
    <published>2018-03-12T10:48:51.000Z</published>
    <updated>2018-03-21T08:33:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="redis和普通缓存区别"><a href="#redis和普通缓存区别" class="headerlink" title="redis和普通缓存区别"></a>redis和普通缓存区别</h4><p>cached：本质是一个内存key-value 数据库，但<br>不支持数据持久化，服务器关闭后，数据全丢失。只支持key-value 结构<br>Redis：将大部分数据放在内存中，支持的数据类型有：字符串、hash 表、链表、集合、<br>有序集合以及基于这些数据类型的相关操作。Redis 内部使用一个redisobject 对象来表示all<br>key 和value。<br>他们的区别：<br>1)redis 中并不是all 数据都一直存储在内存中<br>2）redis 不仅仅支持简单的key-value 类型的数据，同时还支持字符串、hash表、链表、集合、有序集合<br>3）redis 支持数据备份，即master-slave 模式的备份<br>4）redis 支持数据的持久化，可以将内存中的数据保存在磁盘上，重启的时候可以再次加载进内存使用。<br>5）cached 挂掉后，数据不可以恢复，redis数据丢失后可通过AOF 恢复（灾难恢复）。</p>
<h4 id="为什么需要NoSQL"><a href="#为什么需要NoSQL" class="headerlink" title="为什么需要NoSQL"></a>为什么需要NoSQL</h4><p>1.对数据库高并发读写的需求<br>高并发就是同一时间有许多用户访问同一网站造成访问量太大容易造成服务器崩溃，而传统的解决方法就是搭建集群，通俗的讲就是原先一个服务器提供服务，现在变成多个服务器提供服务<br>2.高负载-对海量数据的高效率存储和访问的需求<br>通俗的讲就是数据量非常大，造成没地方存储或者访问查询sql的语句超过上千万造成查询非常低下<br>.高扩展-对数据库的高可扩展性和高可用性的需求<br>通俗的讲相当于银行窗口排队，刚开始一个窗口不能满足需求，后来增加多个窗口，而增加窗口不会造成业务上的不同，也就是集群起来很方便</p>
<h4 id="redis应用"><a href="#redis应用" class="headerlink" title="redis应用"></a>redis应用</h4><p>主要应用在如下场景<br>1.缓存（数据查询、商品内容等等）<br>2.聊天室的在线好友列表<br>3.任务队列（秒杀、抢购等等）<br>4.应用排行榜<br>5.网站访问统计<br>6.数据过期处理<br>7.分布式集群架构中的session分离</p>
<h4 id="了解redis主从复制"><a href="#了解redis主从复制" class="headerlink" title="了解redis主从复制"></a>了解redis主从复制</h4><p>通俗的讲就是一个用户访问一台服务器，该服务器假设为主服务器，具有读写功能，而在该主服务器下关联了一台从服务器，该从服务只具有读功能不具有写功能，并且数据是从主服务器经过一些列同步算法到该服务器上<br>分析：<br>1.master可以拥有多个slave<br>2.多个slave可以连接同一个master外，还可以连接其他的slave<br>3.主从复制不会阻塞master在同步数据时，master可以据需处理client请求<br>4提供系统的伸缩性<br>5.slave挂掉重启后不是slave<br>主从复制过程<br>1.slave与master建立连接，发送sync同步命令<br>2.master会开启一个后台进程，将数据库快照保存到文件中，同时master主进程会开始收集新的写命令并缓存<br>3.后台完成保存后，就将文件发送给slave<br>4.slave将此文件保存在硬盘上</p>
<h4 id="了解redis持久化机制"><a href="#了解redis持久化机制" class="headerlink" title="了解redis持久化机制"></a>了解redis持久化机制</h4><p>edis需要经常将内存中的数据同步到硬盘来保证持久化<br>1.快照（默认方式）<br>将内存中以快照的方式写入到二进制文件中，默认为dump.rdb，可以通过配置设置自动做快照持久化的方式。可以配置redis在n秒内如果超过m个key则修改就自动做快照<br>save 900 1 #900秒内如果超过1个key被修改 则发起快照保存<br>2.aof（日志方式）<br>由于快照方式是在一定时间间隔做一次，所以可能发生redis意外down的情况就会丢失最后一次快照后的所有修改的数据。使用aof时，redis会将每一个收到的写命令都通过write函数追加到命令中<br>aof设置<br>appendonly yes //启动aof，有三种修改方式</p>
<p>#appendfsync always//收到命令就立即写入到磁盘，效率最慢，但是保证完全的持久化</p>
<p>#appendysync everysec//每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中</p>
<p>#appendysync no //完全依赖os性能，持久化没保证</p>
<h4 id="Redis的回收策略"><a href="#Redis的回收策略" class="headerlink" title="Redis的回收策略"></a>Redis的回收策略</h4><p>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰<br>从已设置过期时间的数据集中挑选将要过期的数据淘汰<br>从已设置过期时间的数据集中任意选择数据淘汰<br>从数据集中挑选最近最少使用的数据淘汰<br>从数据集中任意选择数据淘汰<br>禁止驱逐数据</p>
<h4 id="redis常见性能问题和解决方案"><a href="#redis常见性能问题和解决方案" class="headerlink" title="redis常见性能问题和解决方案"></a>redis常见性能问题和解决方案</h4><p>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件<br>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次<br>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内<br>尽量避免在压力很大的主库上增加从库<br>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…<br>这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变</p>
<h4 id="了解分布式锁"><a href="#了解分布式锁" class="headerlink" title="了解分布式锁"></a>了解分布式锁</h4><p>可靠性<br>互斥性。在任意时刻，只有一个客户端能持有锁。<br>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。<br>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。<br>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了<br>基本原理 : 用一个状态值表示锁，对锁的占用和释放通过状态值来标识。<br>redis+setnx实现?<br>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放<br>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？<br>同时把setnx和expire合成一条指令来用的<br>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？<br>使用keys指令可以扫出指定模式的key列表<br>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。<br>如果有大量的key需要设置同一时间过期，一般需要注意什么？<br>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h4 id="redis其他功能"><a href="#redis其他功能" class="headerlink" title="redis其他功能"></a>redis其他功能</h4><p>Redis是单进程单线程的，利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销<br>数据分片、分库<br>发布订阅<br>集群<br>各种配置</p>
<h4 id="Nginx负载均衡方式"><a href="#Nginx负载均衡方式" class="headerlink" title="Nginx负载均衡方式"></a>Nginx负载均衡方式</h4><p>可以根据客户端的ip 进行负载均衡，在upstream 里设置ip_path，负载均衡五种配置<br>1）轮询（默认），每个请求按时间顺序逐一分配到不同的后端服务器，如果后端<br>服务器down 掉，能自动剔除<br>2）指定权重，指定轮询几率。权重越大，轮询几率越大，用于后端服务器性能不均的情况<br>3）ip 绑定ip_path，每个请求按访问ip 的哈希结果分配，这样每个客户固定访问一个服务器，可以解决session 问题<br>4）fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配<br>5）url_hash 按访问的url 结果来分配请求，使每个url 定位到同一个后端服务器。后端服务器为缓存时比较有效</p>
<h4 id="nginx其他"><a href="#nginx其他" class="headerlink" title="nginx其他"></a>nginx其他</h4><p>反向代理<br>文件服务器<br>静态资源<br>ssl配置<br>各种其他配置</p>
<h4 id="了解shiro"><a href="#了解shiro" class="headerlink" title="了解shiro"></a>了解shiro</h4><p>主要为解决以下四个问题<br>1、 认证-用户身份识别，常被称为用户登录<br>2、 授权-访问控制<br>3、 密码加密-保护或隐藏数据防止被偷窥<br>4、 会话管理-每用户相关的时间敏感的状态<br>原理图<br>token令牌、认证与授权、缓存机制（Ehcache）、散列算法（MD5）、匹配、会话<br>拦截器和相关配置、shiro标签<br>shiro会话管理（sessionDao和监听器)</p>
<h4 id="了解lucene"><a href="#了解lucene" class="headerlink" title="了解lucene"></a>了解lucene</h4><p>全文检索首先对要搜索的文档进行分词，然后形成索引，通过查询索引来查询文档，比如：字典<br>字典的偏旁部首页，就类似于luence的索引<br>字典的具体内容，就类似于luence的文档内容<br>原理图:<br>其主要分为索引流程和搜索流程<br>索引流程：采集数据—文档处理-存储到索引库中<br>搜索流程：输入查询条件—通过lucene的查询器查询索引—从索引库中取出结果<br>逻辑结构<br>索引-文档域（document-field）<br>分词、过滤、各种查询语法</p>
<h4 id="了解elasticsearch"><a href="#了解elasticsearch" class="headerlink" title="了解elasticsearch"></a>了解elasticsearch</h4><p>字典树（结合图形)<br>根节点不包含字符，除根节点外每一个节点都只包含一个字符。<br>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>每个节点的所有子节点包含的字符都不相同。<br>其它参考lucene学习的</p>
<h4 id="了解dubbo"><a href="#了解dubbo" class="headerlink" title="了解dubbo"></a>了解dubbo</h4><p>那张原理图,主要是暴露服务，提供接口<br>Consumer服务消费者，Provider服务提供者。Container服务容器,Monitor这是一个监控,Registry注册中心<br>Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？<br>可以的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用<br>注册中心对等集群，任意一台宕掉后，会自动切换到另一台<br>注册中心全部宕掉，服务提供者和消费者仍可以通过本地缓存通讯<br>服务提供者无状态，任一台 宕机后，不影响使用<br>服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复</p>
<p>Dubbo在安全机制方面是如何解决的<br>Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方</p>
<h4 id="了解activeMQ"><a href="#了解activeMQ" class="headerlink" title="了解activeMQ"></a>了解activeMQ</h4><p>发布-订阅(topic)一对多<br>p2p(Queue)点对点<br>配置参数相关设置，如处理过期，心跳等设置</p>
<h4 id="了解websocket"><a href="#了解websocket" class="headerlink" title="了解websocket"></a>了解websocket</h4><p>ajax轮询  : 让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息<br>long poll :  客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始,取的是阻塞模型<br>Websocket :主动推送，建立一次握手</p>
<h4 id="了解fastdfs"><a href="#了解fastdfs" class="headerlink" title="了解fastdfs"></a>了解fastdfs</h4><p>原理图<br>clint-tracker（相当于一个管家，在storager与client之间进行交流）-storager（存储图片)<br>配合Nginx按照一定规则存储和取出图片<br>一般有图片到tomcat服务器或者第三方（如七牛云），或者自己搭建图片服务器</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>技术是学不完的，总是为解决某些问题而产生，技术只是工具，而如何去解决问题才是关键,而我认为计算机基础课程才是最主要的，对一个人在计算机领域的发展和学习技术至关重要</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>希望自己找到一份好的实习</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;redis和普通缓存区别&quot;&gt;&lt;a href=&quot;#redis和普通缓存区别&quot; class=&quot;headerlink&quot; title=&quot;redis和普通缓存区别&quot;&gt;&lt;/a&gt;redis和普通缓存区别&lt;/h4&gt;&lt;p&gt;cached：本质是一个内存key-value 数据库，但&lt;
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>linux基础总结三</title>
    <link href="http://www.myzwl.win/2018/03/10/dream_13/"/>
    <id>http://www.myzwl.win/2018/03/10/dream_13/</id>
    <published>2018-03-10T12:48:51.000Z</published>
    <updated>2018-03-25T02:10:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><p>安装iptables<br>systemctil disable firewalld<br>yum install -y iptables-services<br>systemctl start iptables<br>ystemctl status iptables查看状态<br>iptables -I INPUT -p tcp –dport 80 -m state –state NEW -j ACCEPT(开放80)<br>/sbin/iptables -I INPUT -p tcp –dport 80 -j ACCEPT<br>保存 /etc/rc.d/init.d/iptables save<br>查看打开的端口 /etc/init.d/iptables status<br>关闭防火墙<br>1） 永久性生效，重启后不会复原<br>开启： chkconfig iptables on<br>关闭： chkconfig iptables off<br>2） 即时生效，重启后复原<br>开启： service iptables start<br>关闭： service iptables stop<br>查看防火墙状态： service iptables status</p>
<h4 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h4><p>firewall-cmd –add-port=8080/tcp –permanent<br>irewall-cmd –remove-port=8080/udp –permanent<br>firewall-cmd –reload 重启防火墙<br>开启firewall：systemctl start firewalld.service<br>停止firewall：systemctl stop firewalld.service<br>禁止firewall开机启动：systemctl disable firewalld.service<br> 查看默认防火墙状态：firewall-cmd –state</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;iptables&quot;&gt;&lt;a href=&quot;#iptables&quot; class=&quot;headerlink&quot; title=&quot;iptables&quot;&gt;&lt;/a&gt;iptables&lt;/h4&gt;&lt;p&gt;安装iptables&lt;br&gt;systemctil disable firewalld&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.myzwl.win/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.myzwl.win/source/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux基础总结二</title>
    <link href="http://www.myzwl.win/2018/03/10/dream_12/"/>
    <id>http://www.myzwl.win/2018/03/10/dream_12/</id>
    <published>2018-03-10T11:48:51.000Z</published>
    <updated>2018-03-25T02:09:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ssh登录远程服务器"><a href="#ssh登录远程服务器" class="headerlink" title="ssh登录远程服务器"></a>ssh登录远程服务器</h4><p>yum install ssh<br>ssh -p 端口 服务器用户名@服务器 ip<br>rpm -qa | grep ssh 查看SSH是否安装<br>vi /etc/ssh/sshd_config(修改用户权限文件）<br>service sshd restart</p>
<h4 id="用户命令"><a href="#用户命令" class="headerlink" title="用户命令"></a>用户命令</h4><p>useradd 用户名 -m （添加用户)<br>useradd  -g group –G adm,root 用户名(属组)<br>passwd 用户口令的管理<br>userdel -r 用户名 (删除账号)<br>su 用户名 切到其他用户<br>groupadd  用户组<br>groupdel 用户组<br>groupmod  用户组<br>su 用户名 切到其他用户<br>usermod -a -G 组名 用户名 修改用户所在组。。必须在adm和sudo组的用户才能拥有root权限<br>usermod -g root user(添加至组）<br>chmod 776 文件名 则表示当前用户和当前用户组拥有可读可写可执行权限，其他用户拥有可读可写权限<br>chown 用户 文件名 表示修改文件所有者<br>chgrp 用户组 文件名 表示修改用户所在用户组<br>sudo su - ，即可获得root权限进行操作</p>
<h4 id="与用户账号有关的系统文件"><a href="#与用户账号有关的系统文件" class="headerlink" title="与用户账号有关的系统文件"></a>与用户账号有关的系统文件</h4><p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等<br>/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段<br>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell<br>1）”用户名”是代表用户账号的字符串。<br>2）“口令”一些系统中，存放着加密后的用户口令字<br>3）“用户标识号”是一个整数，系统内部用它来标识用户。<br>4）“组标识号”字段记录的是用户所属的用户组。<br>5)“注释性描述”字段记录着用户的一些个人情况。<br>6)“主目录”，也就是用户的起始工作目录。<br>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。<br>8)系统中有一类用户称为伪用户（psuedo users）。</p>
<h4 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="Linux 磁盘管理"></a>Linux 磁盘管理</h4><p>df -h 列出文件系统的整体磁盘使用量<br>du 检查磁盘空间使用量<br>fdisk 用于磁盘分区<br> mount s1 s2 磁盘挂载<br> umount s1 磁盘卸载<br>free -h(-m) 查看内存使用情况<br>ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head (获取占用内存资源最多的10个进程)</p>
<h4 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h4><p>yum是一个软件包管理器,基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包<br> 1.列出所有可更新的软件清单命令：yum check-update<br>2.更新所有软件命令：yum update<br>3.仅安装指定的软件命令：yum install package<br>4.仅更新指定的软件命令：yum update package<br>5.列出所有可安裝的软件清单命令：yum list<br>6.删除软件包命令：yum remove package<br>7.查找软件包 命令：yum search <keyword> </keyword></p>
<ol>
<li>清除缓存目录下的软件包 yum clean packages</li>
<li>安装rpm包 rpm -ivh 包名<br>10.卸载rpm包 rpm -e 包名<br>如:yum remove mysql mysql-server mysql-libs compat-mysql51(删除mysql)<br>安装JDK1.8<br>查看可安装JDK版本： yum list java<em><br>安装指定1.8版本： yum -y install java-1.8.0-openjdk</em><br>查看是否安装成功：java -version<br>设置环境变量vi /etc/profile<br>让修改生效 source /etc/profile</li>
</ol>
<h4 id="更换yum源"><a href="#更换yum源" class="headerlink" title="更换yum源"></a>更换yum源</h4><p>默认源：ll /etc/yum.repos.d<br>备份/etc/yum.repos.d/CentOS-Base.repo<br>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<br>载对应版本repo文件, 放入/etc/yum.repos.d/<br>CentOS5 ：<a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo" target="_blank" rel="external">http://mirrors.163.com/.help/CentOS5-Base-163.repo</a><br>CentOS6 ：<a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo" target="_blank" rel="external">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a><br>生成缓存<br>yum clean all<br>yum makecache</p>
<h4 id="常见文件命令"><a href="#常见文件命令" class="headerlink" title="常见文件命令"></a>常见文件命令</h4><p>tar -zxvf FileName.tar 解压<br>tar -zcvf FileName.tar DirName 打包并压缩<br>unrar e file.rar 解压rar<br>unzip file.zip 解压zip<br>scp -r 要传输的 用户名@目标地址:目标目录（远程传输）<br>wget 网络地址（下载网络文件）<br>ifconfig（内网）<br>curl ifconfig.me(外网）<br>查看进程 ps -ef | grep <em> 或 ps -aux | grep </em><br>-aux 显示所有状态<br>查看端口 netstat -nap | grep 端口号<br>ps 显示当前进程信息<br>top 动态显示显示当前系统进程信息<br>kill 根据进程id杀死进程<br>kill -9 强制杀死某进程<br>export PATH=/usr/bin:/usr/sbin:/bin:/sbin(保证命令行命令暂时可以使用)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;ssh登录远程服务器&quot;&gt;&lt;a href=&quot;#ssh登录远程服务器&quot; class=&quot;headerlink&quot; title=&quot;ssh登录远程服务器&quot;&gt;&lt;/a&gt;ssh登录远程服务器&lt;/h4&gt;&lt;p&gt;yum install ssh&lt;br&gt;ssh -p 端口 服务器用户名@服务
    
    </summary>
    
      <category term="linux" scheme="http://www.myzwl.win/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.myzwl.win/source/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux基础总结一</title>
    <link href="http://www.myzwl.win/2018/03/10/dream_11/"/>
    <id>http://www.myzwl.win/2018/03/10/dream_11/</id>
    <published>2018-03-10T10:48:51.000Z</published>
    <updated>2018-03-25T02:09:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="系统启动过程"><a href="#系统启动过程" class="headerlink" title="系统启动过程"></a>系统启动过程</h4><p>其过程分为5个阶段<br>1.内核的引导<br>bios启动、然后读取/boot内核下的所有文件<br>2.运行init<br>init 进程是系统所有进程的起点<br>CentOS 7,配置文件：/usr/lib/systemd/system、 /etc/systemd/system<br>在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）<br>3.系统初始化<br>4.建立终端<br>5.用户登录系统<br>命令行登录<br>ssh登录<br>图形界面登录</p>
<p>正确顺序为<br>操作系统-/boot-init进程-运行级别-/etc/init.d-用户登录-login shell</p>
<h4 id="Linux关机"><a href="#Linux关机" class="headerlink" title="Linux关机"></a>Linux关机</h4><p>sync 将数据由内存同步到硬盘中。<br>shutdown 关机指令<br>Shutdown –h now 立马关机<br>Shutdown –h 20:25 系统会在今天20:25关机<br>Shutdown –h +10 十分钟后关机<br>Shutdown –r now 系统立马重启<br>Shutdown –r +10 系统十分钟后重启<br>reboot 重启<br>halt 关闭系统</p>
<h4 id="Linux系统目录结构"><a href="#Linux系统目录结构" class="headerlink" title="Linux系统目录结构"></a>Linux系统目录结构</h4><p>/bin<br>存放最经常使用的命令<br>/boot<br>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件<br>/dev<br>该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的<br>/etc<br>这个目录用来存放所有的系统管理所需要的配置文件和子目录<br>/home<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的<br>/lib<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库<br>/lost+found：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件<br>/media<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下<br>/mnt：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了<br>/opt：<br> 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的<br> /proc：<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息<br>/root：<br>该目录为系统管理员，也称作超级权限者的用户主目录<br>/sbin：<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序<br>srv：<br> 该目录存放一些服务启动之后需要提取的数据。<br> /tmp：<br>这个目录是用来存放一些临时文件的<br>/usr：<br> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录<br> /var：<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;系统启动过程&quot;&gt;&lt;a href=&quot;#系统启动过程&quot; class=&quot;headerlink&quot; title=&quot;系统启动过程&quot;&gt;&lt;/a&gt;系统启动过程&lt;/h4&gt;&lt;p&gt;其过程分为5个阶段&lt;br&gt;1.内核的引导&lt;br&gt;bios启动、然后读取/boot内核下的所有文件&lt;br&gt;2.
    
    </summary>
    
      <category term="linux" scheme="http://www.myzwl.win/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.myzwl.win/source/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>系统V1.0简单说明</title>
    <link href="http://www.myzwl.win/2018/03/10/sys_1/"/>
    <id>http://www.myzwl.win/2018/03/10/sys_1/</id>
    <published>2018-03-10T07:48:51.000Z</published>
    <updated>2018-03-21T09:03:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>该系统为2.0版本但是很不完善，由于一个人的精力和时间有限，有很多考虑不周到的地方，很多地方算法复杂度高，模块耦合性高，部分设计模式设计不合理，代码规范不达标等等请谅解<br>但是在设计和代码上都做了充分考虑，等找到实习稳定下来，将详细发到github供大家一起学习研究（ps，github全删，原因代码太烂和有效代码不完美)</p>
<h4 id="系统部分"><a href="#系统部分" class="headerlink" title="系统部分"></a>系统部分</h4><p>其次自己租了11台linux服务器，内存1G以上有6台，以下是之前的架构，由于时间关系，展示如下<br>系统架构(旧)<br><img src="/images/imgs6/1.png" alt="Alt text"><br>所用技术栈(旧)<br><img src="/images/imgs6/2.png" alt="Alt text"><br>系统部分说明(旧)<br><img src="/images/imgs6/1.jpg" alt="Alt text"></p>
<h4 id="困难与解决"><a href="#困难与解决" class="headerlink" title="困难与解决"></a>困难与解决</h4><p><strong>1.留言板的数据存储如何存储与取出算法实现</strong><br>按照自己之前的经验，一个人写一条留言就记录下，然后就是垂直式的记录，很明显存在很多问题<br><img src="/images/imgs6/2.jpg" alt="Alt text"><br>解决方法 :<br>将问题抽象成伪B树数据结构，节点数以固定，不需要记录<br><img src="/images/imgs6/3.png" alt="Alt text"><br>很明显这样嵌套下去，深度非常大，就是一颗斜二叉树，还有就是留言板目前最多需要楼中楼加上前端写不出来，所以深度固定为2并且最后一层放在一个栈里（按照时间排序）</p>
<p>如何有效率的取出数据?<br>按照首先的想法（sql不是很好，所以按照笨方法来考虑），因为这里记录的是结点，而最后需要的是用户名等信息，也就是说还需要查数据库转换(如果加个相关字段除外),<br>也就是遍历到所有结点o(n)，然后每个结点查数据库转换为相关信息o（n），而且查数据库的字段保存的内存也大，还要查数据库n次，所以如果数据量极大，效率很不高</p>
<p>解决办法:<br> 干脆就遍历一次，将遍历的结果只要用户名和id，然后放在一张哈希表中，然后分成两块，一块是得到所有顶层父节点集合，另一层是所有的孩子结点，然后构造一个栈，通过父节点找到其下所有孩子节点，放到栈中，然后将栈放到一个集合中，循环遍历放入，最后只要把这个集合交给前台就好了</p>
<p><strong>2. 如何实时显示在线登录人数?</strong><br>首先怎么才算登录人数，一般规定用户登录后才算，但是登陆后会出现几种情况，用户主动退出登录，长时间不点击和主动关闭浏览器都会导致会话失效，另外并发登录人数限制和管理员在线踢出用户都会影响登录人数<br>而一般的做法就是写个servlet会话监听器去监听登录，当有会话建立时并且已经成功登录和先判断该用户是否已经正在线，统计相关信息，然后就是退出浏览器只能等会话失效才算离线。用这种方法去做，简单，但是实时效果不是太好但是发现我得session是用shiro管理的，大部分应用离不开shiro，而且shiro的sessionId每次是不一样的，也就是说，同一用户登录，在缓存中通过用户名产生的会话id不一样，造成同一用户登录重新登录会变成不同用户而在线人数不对。<br>而另一种更好并且统计更准确的是利用redis缓存信息（遇到了瓶颈，也是这个sessionId每次不一样，但是如果把shiro换掉或者做成分布式可以解决），大概是这样的想法，现在redis中放两组key，根据需求一组存放登陆用户的SessionId与ClientUser的Json数据，另一组存放存放登录用户的UID与SessionId对于的数据，然后利用该监听器，，只要一有会话差生，就从redis登记表（封装各类实时统计的方法）中查看，以一定规则查看是否登录，这里可以判断是游客还是会员，然后记录相关登记信息等等，放在session中，这种统计方法更实时，统计内容更多，但是因为shiro的问题，最终统计很不准确，因为这个sessionId还必须是准确才行<br>解决办法：<br>干脆就用shiro的缓存来统计，得解决这个并发登录人数控制。Shiro是这样做的，规定同一账号最大会话数，实际上是放在一个缓存队列中，如果其大小超过该会话数，就踢出头或尾会话，在加入该会话，然后就是这个缓存队列是通过ehcache中命名用户名设置的，然后将其放在shiro拦截器，放在登录请求中，这是如果有会话被提出，但是本地缓存sessionDAO中任然有那个被踢掉的缓存，需要个监听器根据那个用户名得到sessionId然后踢掉，缓存同步。<br>还有一个就是强制用户退出，就是根据sessionId让session失效，logout就行了。<br>最后就是实时统计在线列表了，这里比较棘手的就是的就是那个强制退出的会话怎么清除，如果不清除，缓存中会得到空指针，最头疼的是服务器崩溃，利用缓存中的方法可以得到所有活跃的会话，包括失效的，然后就是通过异常，测试居然可以通过，得到失效的会话，然后就是通过sessionid判断，更新缓存，删掉那个失效的会话，最后就是活跃的会话了，而关闭浏览器通过缩短会话存活时间保证，主动退出和会话正常死亡通过监听器解决<br>最后就是复杂度太高导致效率低下，不能完全模拟实时统计，可以用心跳方式解决</p>
<p><strong>3. 如何高效率执行并发在线编程?</strong><br>这个最终的解决办法并不是很好，但是探索的过程总是充满乐趣.<br>首先要解决的问题是怎么才能实现在线编程，参考了jdk的动态代理。大概就是将代码变成字符串，然后拿到当前编译器进行编译，最后将编译的结果输出即可。如果不加以控制的话，最后如果并发量大的话，同时写入和读出造成错误，同时如何保证编译更有效。<br>首先就是解决并发问题，首先使用lock写锁，控制。假设是单线程执行，一个用户写完还必须按照时间等待，并发量高效率很低。很自然想到线程池，封装一个线程池工具类，创建一个编译线程任务类，然后就是按照线程创建时间创建不同的文件夹，每个文件夹来自不同的用户线程，这样就解决了记录问题，剩下就是怎么保证每个用户都知道自己执行哪个编译线程，然后拿到对应的编译结果（在这里遇到了瓶颈）<br><img src="/images/imgs6/4.png" alt="Alt text"></p>
<p>最终是可以并行执行编译，而不是串行等待，但是编译的结果随机发给了等待的用户，当然可以直接用synchronized控制同步，但是代价和执行效果就不怎么好了。</p>
<p>解决办法<br>最后直接用synchronized控制同步，也就没有必要使用线程池了，只要保证不同用户编译和返回的结果是正确就行了，最后将该功能做出微服务，利用dubbo管理，这样尽可能降低并发带来的性能问题</p>
<p><strong>4. 如何实现算法建模和保证数据高效回显？</strong><br><img src="/images/imgs6/3.jpg" alt="Alt text"><br>该表依赖于算法类型表，核心是func_index。而存储redis需要两个key，一个是该对象序列化存储，选择list类型存储，以索引作为信息搜索。另一个是该类型与一个字符串（记录算法类型）类型组合成一个新对象,选择string类型存储</p>
<p>大概的入库的流程是，通过时间随机生成索引，一定不重复，然后先入本地数据库，而那个pkId就是通过存入redis库的那个list类型key取得长度+1，不存在则为0，这样解决了pkId重复问题，接下来先存储list类型key，然后存储那个String，按照一定规则转换<br>而取出算法时，也是先从redis中取出，异常走本地数据库，而取出时，先将那个String转换为对象，按照索引’取出符合要求的<br>遇到的问题：<br>业务过于复杂，各种存入redis数据存储和取出出现异常，每个特定的算法建模太耗内存</p>
<p>解决办法：<br>将算法建模做成微服务，算法信息存储通过redis主从复制，解决加载慢问题，同时算法运行计算在不同机器执行，通过集群解决并发量大问题</p>
<p><strong>5.如何细粒度的控制url，保证游客也能访问而又安全？</strong><br>事实上shiro已经通过身份角色进行安全控制，而这里需要的是一个通用url除了最后确定信息加密不一样外，其余都差不多，并且可以权限控制。<br>     大概的想法是：首先建立两个枚举类，一个是记录目前存在可以注入的加密算法名称，另一个是记录需要加密的页面名称（知识为了记录，事实上用不到），然后是一个简单工厂类，根据通过加密的索引号，返回枚举类中相应的加密算法名，然后就是一个加密模板类，该类中的加密索引号在spring中注入，反射路径是封装的加密类<br>   接下来，利用反射动态得到该加密类，然后通过索引号在简单工厂中得到加密算法名称，最后反射类循环方法，一旦相等，执行该方法，最后得到加密解密后的字符串，<br>   最后来一个页面跳转中转站，通过传入jsp文件的分支和名称进行跳转，可以内部转发或者重定向。这样一方面就可以通过改url，控制游客登录后台，而又得不到相关信息，进行细粒度控制<br>   遇到的棘手问题:<br>因为有些加密算法是需要密钥的，而每次随机生成，必须同一对象才能解密，但是解密的时候就不是之前那个对象了，所以有需要密钥的都不能解密<br>解决办法:<br>选择其中不需要密钥并且是对称加密的算法</p>
<p><strong>6..业务逻辑重复代码太多，如何合理解耦?</strong><br>首先对于实体类规定一个base类，所有实体必须继承它。主要有两个原因，<br>第一个就是为了业务层解耦，只要传入这个base类就行<br>第二个根据需要加入相关字段，而不要重写包装类<br>然后业务层一个基础业务类，抽象共同方法<br>然后抽象出一个含分页信息的工具类，里面规定传入继承基础类的类，返回分页后的集合信息，同时统一设置了保存在request域中的信息，</p>
<p><strong>7.论坛核心表如何设计?</strong><br>  如果放在一张表里，控制起来很复杂，所以干脆设置成三张表<br>  即文章表、评论表和楼中楼表<br>并且文章表必须包含用户id，评论表包含文章id，用户id，被回复者id，楼中楼包含那三个和评论id，这样就可以精确的进行记录了。然后就是给文章表设置一个状态值，用于标识普通帖、精贴等，在取出的时候通过规定的业务关系取出数据。同时相关文章数据要同步到es服务器索引库进行搜索查询<br>遇到的困难：<br>业务过于复杂，需要考虑各种细节关系和各种可能的情况，同时前端弄不出来<br>解决方法：<br>按照算法的思想，各个击破，尽可能考虑每种情况，同时寻找第三方优秀模板</p>
<p><strong>8. 其他非业务的简单实现</strong><br>   1.利用拦截器在登录请求出进行黑名单判断和日志统计<br>   2.利用activeMQ将推送的消息放入到队列中，并且实时发送到有初始化webSocket的页面<br>   3.文章访问量统计按照ip和用户的访问表进行登记判断，以一天为准，凌晨自动清空访问表，并且访问量记录在文章表中</p>
<h4 id="最后说明"><a href="#最后说明" class="headerlink" title="最后说明"></a>最后说明</h4><p>感谢您的阅读</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;该系统为2.0版本但是很不完善，由于一个人的精力和时间有限，有很多考虑不周到的地方，很多地方算法复杂度高，模块耦合性高，部分设计模式设计不合
    
    </summary>
    
      <category term="毕业设计" scheme="http://www.myzwl.win/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="毕业设计" scheme="http://www.myzwl.win/source/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>我的大学自学java体系二</title>
    <link href="http://www.myzwl.win/2017/12/31/study_02/"/>
    <id>http://www.myzwl.win/2017/12/31/study_02/</id>
    <published>2017-12-31T06:48:51.000Z</published>
    <updated>2018-03-15T15:40:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束，趁着今年最后一天把大学学的关于java方面的知识总结一下，一方面是解放自己释放压力，另一方面激励自己尽快找到实习，稳定生活和压力</p>
<p><img src="/images/imgs5/1.svg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束，趁着今年最后一天把大学学的关于java方面的知识总结一下，一方面
    
    </summary>
    
      <category term="个人感想" scheme="http://www.myzwl.win/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="学习总结" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的大学自学java体系一</title>
    <link href="http://www.myzwl.win/2017/12/30/study_01/"/>
    <id>http://www.myzwl.win/2017/12/30/study_01/</id>
    <published>2017-12-30T06:48:51.000Z</published>
    <updated>2018-03-15T14:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束。<br>回顾这三年多生活，大学前一年基本迷迷茫茫，太多的课程，让人不知道如何去选择一个方向学习，基本很迷茫，有一次为了表示对物理的尊敬和兴趣，特地网上买了物理上下答案，晚上或者周末一有时间就去自习室刷题，刷完一本后，突然发现除了内心的满足感，到现在再也没碰过物理了，从上中学开始就一直对数学情由独钟，也因此错过很多很多机会和干过很多愚蠢的事，自己当时心里就想着干自己喜欢的事，于是乎，除了几门极个别的课，基本上全在研究数学，看大学老师录的数学视频，刷奥数题，上头时为了手写和推出一元三次和四次方程的含复根求根公式，连续好几天乐此不疲，然后一次很重要的人生考试被自己的糊涂和幼稚错过了（除了那两张象征荣誉的奥数证书，后来已经撕了，现在觉得当时太傻，太傻，太傻，也成为了自己的一个警醒），后来大学填报专业时，第一志愿写了数学专业，家里也希望当个数学老师算了，后来阴差阳错的调剂到软件工程专业，慢慢的，慢慢地也就淡忘了对数学的热情。大学里，也迷茫过，包夜上网玩游戏已达上百次，也是因为兴趣上头，后来想想身体健康才是最主要的，娱乐要有度。<br>大学真正开始学习是从c、c++开始，当时第一次接触c语言，真的很兴奋，基本上就一直做数学程序题，后来接触了c++，用vc6.0做mfc程序，然后就是一直对着c++ primer plus学习，当时也算是有了一个目标。后来，也是改变了我的学习方向的一个时间，到现在都记忆犹新。有一次室友有事，让我代替他上一节php公选课（时间2015-10-20），第一次接触web，服务器，突然发现这才是自己喜欢做的，自己被深深的震撼到了，当时他也布置了一个任务，做一个简单的网页含后台，回去后，就像发现新大陆一样，通过百度搭建了php环境和wampserver服务器，然后就是着了迷一样的弄，几天后弄出来了一个个人主页网站<br><img src="/images/imgs5/33.jpg" alt="Alt text"><br><img src="/images/imgs5/34.jpg" alt="Alt text"></p>
<p>突然之间感觉自己有了学习兴趣和方向，像着了迷一样的学习。后来2016年初做的几次兼职深深的意识到了，学习比干苦力看重眼前利益有用些，后来听说了java（学校是在2016年10月才开设的唯一一门java基础课，后续没了java相关了），开始一脚踏进了深深的深渊，开始疯狂的自学中至今</p>
<h4 id="感谢韩顺平老师"><a href="#感谢韩顺平老师" class="headerlink" title="感谢韩顺平老师"></a>感谢韩顺平老师</h4><p>刚开始在图书馆借了一本<21天学通java>,因为之前有c和数据结构等基础，所以学习起来也轻松，没几天就看完和动手码完了<br>，后来无意中接触了java吧，看到了传播智客韩顺平老师的视频分享，于是一口气下完了，不得不说韩老师是我的java启蒙老师，也很荣幸他的视频讲的很细致，每集时间很长，他的视频我连续花了四个多月才消化完，其中java se搞了两个月（到现在仍然觉得java基础仍不足），而每天像打了鸡血一样，一天真的12小时以上，哪也不去，就是对着电脑先仔细听他说完一级，然后看着笔记认真动手操作每一集的每一个代码（当时，真的不复制，就是自己从头敲到尾，遇到卡住的，回头再看视频回顾细节），然后按照自己的想法把它的功能改成自己的，一直都记着韩老师的一句话（把别人的知识通过自己的语言描述出来就是自己的知识，一定要实践），记得三月底的一次运动会，宿舍人要么回家了，要么出去玩了。当时自己选择留在宿舍学习(也就是为了完成韩顺平老师的项目)，就这样连续五天在各种情形下度过了，也许当时会感觉很孤独，但是总觉得在一个目标和兴趣下，一切都是那么充实。每天晚上，总会在睡觉前在手机上观看韩顺平老师的笔记到一两年，就这样早上7点起来，晚上2点睡，持续了大半年。这期间（现在想来）有些技术踩坑了，比如swing当时要求自己手写所有的，很认真的花很多时间学习struts1.xml四种解析情况自己手写模拟（现在忘光了），而最多最多的就是自己踩坑，抗压学习，遇到问题，然后通过耐心的百度，谷歌解决，每个学习的知识和技能都要转化为自己的语言应用，哪怕花时间去网站上找相关辅助代码，一定要还原真实情况。正是这段时间的学习，让我对软件开发有一个很深很深的认识，唯一的代价就是失眠和孤独。后来在四月初，数据库老师布置了一个任务，让我们做一个的数据库课程设计，事实上就不说了，后来也许是兴趣或者正好可以用上，自己花了一个星期（事实上每天就睡4,5个小时）自己一行一行的敲，做了一个基于swing的宿舍管理系统，这是自己第一次进行设计和编码，不知道当时拿给老师是有多兴奋~，后来老师说功能写的可以，就是太乱。当时也不懂软件工程，于是回去后又花了一个星期改了一个基于socket的宿舍管理系统，也许是当时太想把网络知识应用上，后来老师说我回去得看看软件工程。后来发现的确，盲目编码很不规范，然后当时就有一个心愿写一个网站的宿舍系统，而当时也是参考了韩老师的学生管理系统，又是一个月的努力，在五月份的时候，第一次写了一个基于纯servlet和mvc模式的宿舍系统，当时也许是太单纯了，自己拿了四张A4纸把每个类和流程都手写出来，然后去验收，然后向同学借了几台电脑去验收，也许是老师看我太认真了，说了一句（学校没几个像你这样的，然后让我帮她帮一个学校做一个网站），当时因为着迷技术，推掉了（直到2017年2月帮做另一个项目，已完成），后来也许就是这句话，自己越学越有劲，总之韩顺平老师的课程帮助了我许多许多</21天学通java></p>
<h4 id="那些充实的日子"><a href="#那些充实的日子" class="headerlink" title="那些充实的日子"></a>那些充实的日子</h4><p>后来6月初，有个达内来的ios七天校内实训，然后做一个tom猫小程序。当时，真的很兴奋，从一开始就抱着不学ios，自己做一个基于web的tom动画程序，然后后来就各种jsdom做了一个，后来演示时，他直接说我私底下给他看了过了（贼笑），期间也和他聊了聊，从java se聊到ssh和自己的项目，他说我这样可以去实习和然后工作了，当时，仍然以兴趣和沉迷技术，根本没有想那么多（现在后悔了，早点实习，早点有工作经验真的很有益，而且有明确的学习方向）。学完韩顺平老师的以后，也陆续发现还有许多优秀的讲师，像马士兵老师，于是以同样的方式学习，突然发现马老师，彻底改变了我的学习方式，而且他的课程讲的很深，像jdk源码，设计模式等等，总之马士兵老师的视频将近花了三个多月，也是收获最多的，在16年五月初的时候自己就有种打算写一个个人博客，于是乎花了将近两个月时间，写了第一个基于s2sh的个人博客，过程就不说了，也第一次接触到了外网访问，当时用的是nat123，将服务器架在自己电脑上，而且刚上限就被黑客黑了，自己机子成了肉鸡（贼笑），后来也许是自己太得意和想摆脱孤独，发在了空间，第一次感受到了温暖<br>当然，代价是很严重的，就是自己的精神很萎靡和严重缺少睡眠和每天都失眠，基本就是宅在房里，没有交流<br>再到后来，陆陆续续不断学习李炎灰老师的前端体系，easy ui创始人的视频（这个帮助真大），北风网的优秀视频，黑马东哥视频，和java123视频，最终以一个课程设计猎图网（按照软件工程编写文档）而结束了2016年的学习。<br>回忆起来，这一年真的很充实和苦有所得</p>
<h4 id="持久以恒"><a href="#持久以恒" class="headerlink" title="持久以恒"></a>持久以恒</h4><p>2017年开始，自己就开始写博客来记录学习和知识，早在2015年3月，自己建了一个c++群，不过里面人很少，刚开始是用文档记录发到群里分享，后来直接用hexo博客写，自己也租了一台阿里云服务器，部署自己的网站。而之前也是利用业余时间看看经典书籍，而这一年更是如此，也很少看视频了，基本以经典书籍学习，像设计模式，多线程，数据结构与算法等等，也许是精力不行了，也没有了之前疯狂的学习热情，后来在3月到5月一直帮一个学校做项目（过程太累），第一次感受到真实项目的复杂合自己一个人做的挑战，最后改编成了毕业设计。然后到了7月，自己也许是爆发最后一次的能量，整个暑假出门不超过几十次，花了一个月终于完成了自己的个人论坛项目，带着渴望不孤独的心情第二次发到了空间，然而在之前，因为自己太痴迷于技术，错过了好多推荐的机会，现在后悔都来不及。到九月份，突然发现，自己投的简历都石沉大海，一次面试对方说出了详情，我们不需要有自己想法的人，就算你自己苦思冥想设计算法最后还是调用第三方库，如谷歌、百度。而且现在培训这么多，别人几个月会各种分布式技术，各种技术集群，而且只要基本的增删改查和基本操作就够了，而且我们只要有工作经验的，也许是自己之前的学习热情过头惹怒了面试官加上简历上写的0工作经验和找实习，要么是培训机构要么没有机会，加上自己又要考驾照和精神不够好胡思乱想，于是从十月份开始彻底废了，每天沉迷游戏，动漫，电影，自暴自弃，甚至考虑转行等等，期间也偶尔兴趣来了学习一下技术，后来慢慢的发现，自己太单纯了，自己的目标是一名工程师，技术会用和深入学习的时间性价比是天壤之别，而且这是一个很现实的社会</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>慢慢的，人总是会变的现实，很感激大学里陪伴我的严蔚敏老师、韩顺平老师、马士兵老师、李炎灰老师和其他免费开源的优秀老师以及那些经典书籍的作者，是他们陪伴我度过了最充实的大学生活。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束。&lt;br&gt;回顾这三年多生活，大学前一年基本迷迷茫茫，太多的课程，让
    
    </summary>
    
      <category term="个人感想" scheme="http://www.myzwl.win/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="学习总结" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>jvm总结之三:虚拟机堆参数</title>
    <link href="http://www.myzwl.win/2017/12/23/jvm_3/"/>
    <id>http://www.myzwl.win/2017/12/23/jvm_3/</id>
    <published>2017-12-23T07:48:51.000Z</published>
    <updated>2018-03-17T10:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>事实上，我们对堆内存的管理是可控的，可通过对jvm虚拟机相关堆内存参数设置进行控制</p>
<h4 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a>参数含义</h4><p>-XX 对于系统级别的jvm配置 配置日志信息 垃圾回收器类型<br>非 -XX的 基本都是对 应用层面上的配置</p>
<ul>
<li>启用 - 禁用<br>-XX :PrintGC 使用这个参数，虚拟机启动后，只要遇到GC就会打印日志<br>-XX: +UserSerialGC 配置串行回收器<br>-XX:+PrintGCDetails：可以查看详细信息，包括各个区的情况<br>-Xms: 设置java程序启动时初始堆大小<br>-Xmx: 设置java程序能获得的最大堆大小<br>-Xloggc:路径 ：将打印出来的日志信息保存至指定的路径<br>-Xmn：设置堆的内存大小<br>-XX:SurvivorRatio=m:n调整Eden和Survivor的比例为m:n</li>
</ul>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class test2 &#123;		</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	</div><div class="line">		//-Xms20m -Xmx20m -Xmn10 -XX:+PrintGCDetails -Xloggc:d:\gc1.log</div><div class="line">		</div><div class="line">				//查看GC信息</div><div class="line">				System.out.println("max memory:" + Runtime.getRuntime().maxMemory());</div><div class="line">				System.out.println("free memory:" + Runtime.getRuntime().freeMemory());</div><div class="line">				System.out.println("total memory:" + Runtime.getRuntime().totalMemory());</div><div class="line">				</div><div class="line">				byte[] b1 = new byte[1*1024*1024];</div><div class="line">				System.out.println("分配了1M");</div><div class="line">				System.out.println("max memory:" + Runtime.getRuntime().maxMemory());</div><div class="line">				System.out.println("free memory:" + Runtime.getRuntime().freeMemory());</div><div class="line">				System.out.println("total memory:" + Runtime.getRuntime().totalMemory());</div><div class="line">				</div><div class="line">				byte[] b2 = new byte[4*1024*1024];</div><div class="line">				System.out.println("分配了4M");</div><div class="line">				System.out.println("max memory:" + Runtime.getRuntime().maxMemory());</div><div class="line">				System.out.println("free memory:" + Runtime.getRuntime().freeMemory());</div><div class="line">				System.out.println("total memory:" + Runtime.getRuntime().totalMemory());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>Memory: 4k page, physical 2076596k(144200k free), swap 4923560k(620956k free)<br>CommandLine flags: -XX:InitialHeapSize=5242880 -XX:MaxHeapSize=20971520 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:-UseLargePagesIndividualAllocation<br>0.418: [GC (Allocation Failure) 0.418: [DefNew: 655K-&gt;192K(1856K), 0.0049031 secs] 655K-&gt;466K(5952K), 0.0052607 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]<br>0.448: [GC (Allocation Failure) 0.448: [DefNew: 1282K-&gt;0K(1856K), 0.0044827 secs]0.453: [Tenured: 1490K-&gt;1490K(4096K), 0.0033471 secs] 1557K-&gt;1490K(5952K), [Metaspace: 80K-&gt;80K(4480K)], 0.0083429 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]<br>Heap<br> def new generation   total 1920K, used 68K [0x03a00000, 0x03c10000, 0x040a0000)<br>  eden space 1728K,   3% used [0x03a00000, 0x03a111f8, 0x03bb0000)<br>  from space 192K,   0% used [0x03bb0000, 0x03bb0000, 0x03be0000)<br>  to   space 192K,   0% used [0x03be0000, 0x03be0000, 0x03c10000)<br> tenured generation   total 8196K, used 5586K [0x040a0000, 0x048a1000, 0x04e00000)<br>   the space 8196K,  68% used [0x040a0000, 0x04614b70, 0x04614c00, 0x048a1000)<br> Metaspace       used 80K, capacity 2242K, committed 2368K, reserved 4480K</p>
</blockquote>
<p>其中from、to分别为s0、s1区</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;事实上，我们对堆内存的管理是可控的，可通过对jvm虚拟机相关堆内存参数设置进行控制&lt;/p&gt;
&lt;h4 id=&quot;参数含义&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="jvm" scheme="http://www.myzwl.win/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://www.myzwl.win/source/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm总结之二:回收策略</title>
    <link href="http://www.myzwl.win/2017/12/22/jvm_2/"/>
    <id>http://www.myzwl.win/2017/12/22/jvm_2/</id>
    <published>2017-12-22T07:48:51.000Z</published>
    <updated>2018-03-17T10:29:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们知道垃圾回收的主要内存区域是堆和方法区，因为这两块区域的内存分配相对于其他区域具有不确定性，而分配内存一般有两种方法，即指针碰撞和空闲列表</p>
<h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><p>在堆内存中主要分为年轻代和老年代（具体后面再说），先说一下年轻代<br><img src="/images/imgs5/37.jpg" alt="Alt text"><br>如图，主要分为Eden（对象都会在该区域内创建）同时也会在s0或s1中随机一个进行创建，经过一次GC后在s0和s1中使用复制算法保留存活下来的对象，那么它是如何复制的了<br><img src="/images/imgs5/38.jpg" alt="Alt text"><br><img src="/images/imgs5/39.jpg" alt="Alt text"><br>大概流程就是将可回收的垃圾对象进行标记，然后复制存活的对象到另一块空白区域，依次类推<br>很显然这种复制方式很浪费空间，但是年轻代是生命周期很短的，换句话说，如果年轻代不够放了就会放到老年代，一般规定经过15次GC后的年轻代就会进入老年区（可通过-XX：MaxTenuringThreshold=15设置多少次为老年代），而老年区一般存放存活时间比较久的对象，通过标记-清除-整理进行垃圾回收，如果老年代内存不足就会触发FULL GC.默认是占用了68%后收集（可通过-XX:CMSInitiatingOccupancyFraction=68设置），该GC非常影响性能</p>
<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>我们知道垃圾回收算法可自行判断一个对象是否已经生命周期达到结束，从而将其视为垃圾进行回收。那么在此算法出现之前，出现过可达性分析算法进行垃圾回收<br>算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起始点，从这些起始点开始向下搜索，所走过的路径称为引用链，如果一个对象到GC Roots没有任何引用链，那么这个对象是不可用的，就是说，程序中没有谁引用了这个对象，所以可以说从根节点到叶子结点是不可达的<br>而以下对象可作为GC Roots对象：<br>虚拟机栈（栈帧中本地变量表）中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中JNI（也就是native本地方法）引用的对象</p>
<p>现在我们已经知道了通过可达性分析判断对象是否还可用，但是是不是不可达的对象都是不可用呢？答案是未必。原因在于要宣告一个对象的死亡，需要两次标记（为什么需要两次标记呢？原因是如果一个对象没有与GC Roots结点相连，就会被第一次标记，而如果对象覆盖了finalize方法，并且在finalize方法中与某个对象建立了引用关系，那么第二次标记会失败，那么这个对象就会被移出“即将回收”的对象列表，移出之后这个对象就“活”了下来，如果在finalize方法中这个对相关仍然没有与一个对象建立引用关系，那么这个对象就真正死亡了）。</p>
<h4 id="回收方法区中的对象"><a href="#回收方法区中的对象" class="headerlink" title="回收方法区中的对象"></a>回收方法区中的对象</h4><p>方法区中的永久代的垃圾回收主要为两部分： 废弃常量和无用的类<br>废弃常量是指没有任何对象引用常量池中的某个对象，那么这个对象就会被回收，而对于常量池中的垃圾回收只要进行一次标记就可以进行判断<br>无用的类需要满足以下三个条件才可以宣判一个类的“死刑”：<br>    1.该类的所有实例都已经被回收，也就是Java堆中不存在该类的实例<br>    2.加载该类的ClassLoader已经被回收<br>    3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;我们知道垃圾回收的主要内存区域是堆和方法区，因为这两块区域的内存分配相对于其他区域具有不确定性，而分配内存一般有两种方法，即指针碰撞和空闲列
    
    </summary>
    
      <category term="jvm" scheme="http://www.myzwl.win/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://www.myzwl.win/source/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm总结之一:java内存区域</title>
    <link href="http://www.myzwl.win/2017/12/21/jvm_1/"/>
    <id>http://www.myzwl.win/2017/12/21/jvm_1/</id>
    <published>2017-12-21T06:48:51.000Z</published>
    <updated>2018-03-17T10:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>引用百度文库上对java虚拟机的定义.<br>虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行</p>
<h4 id="重要组成部分"><a href="#重要组成部分" class="headerlink" title="重要组成部分"></a>重要组成部分</h4><p><img src="/images/imgs5/35.jpg" alt="Alt text"></p>
<p><font size="5">类加载子系统</font><br>负责从文件系统或者网络中加载class信息，加载的信息存放在一块称之为方法区的内存空间</p>
<p><font size="5">方法区</font><br>存放类信息、常量信息、常量池信息、包括字符串常量和数字常量等</p>
<p><font size="5">java堆</font><br>在虚拟机启动的时候创建，此内粗区域的唯一目的就是存放对象实例，是所有线程共享的，同时，这块内存区域也是垃圾收集器的主要区域，也被成为GC堆</p>
<p><font size="5">Java虚拟机栈</font><br>每个java虚拟机线程都有一个私有的栈，其生命周期与线程相同，它描述了Java的方法执行模型，每个方法执行时都会创建一个栈帧。会抛出StackOverFlowError和OOM</p>
<p><font size="5">本地方法栈</font><br>与Java虚拟机栈类似，最大的不同就是它是用于本地方法调用，同常用c语言编写</p>
<p><font size="5">直接内存</font><br>NIO库允许java使用直接内存，通常速度由于java堆</p>
<p><font size="5">程序计数器</font><br>程序计数器可以理解为当前线程执行的字节码的行号指示器，字节码解释器就是通哟改变这个值来获取需要执行的下一条需要执行的字节码指令。对于多线程来说，每条线程都有自己的程序计数器，这样各线程之间的计数器互不影响，这类内存区域也叫作“私有内存”（可以看到其实并不是私有的），之所以这么设计，是因为在多线程的情况下，完全可能出现线程中断的情况，那么当被中断的线程需要回复执行的时候，怎么知道上次该线程执行到哪里了呢？这就需要程序计数器发挥作用了，由于每个线程都有自己的程序计数器，这样当CPU重新调度该线程的时候，从其计数器中取出下一条的字节码执行指令，于是就可以继续执行了</p>
<p><font size="5">执行引擎</font><br>负责执行虚拟机的字节码,先进行编译成机器码后执行</p>
<h4 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h4><p>事实上，堆解决的是数据存储的问题，即数据怎么做，放在哪里，而栈解决的是程序的运行问题，即程序如何执行或者说如何处理数据，而方法区则是辅助堆栈的永久区，解决堆栈信息的产生,比如我们现在要创建一个student类实例<br><img src="/images/imgs5/36.jpg" alt="Alt text"><br>其中栈中存放的是对象的引用</p>
<h4 id="对象创建详细过程"><a href="#对象创建详细过程" class="headerlink" title="对象创建详细过程"></a>对象创建详细过程</h4><p>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有就执行下一步</p>
<p>检查通过后，虚拟机会为新生的对象分配内存，主要由两种内存分配策略，一种是指针碰撞，一种是空闲列表。所谓指针碰撞就是把Java堆中的内存一分为二，一边是所有用过的内存（这部分内存不能被分配了），一边是空闲的内存，是可以被分配的，这样的话，在可用于不可用的内存之间会有一个分割点指示器，那么为对象分配内存实际上就是从这个分界点指示器往空闲内存的一边拨动一段空间就可以了。而空闲列表则没有这个假设，已使用的内存与空闲内存可能是交叉在一起的，那么使用指针碰撞的方式分配内存就会产生问题，但是虚拟机维护着一张列表，这张列表记录了哪些区域的内存是可用的，那么在分配内存的时候就从选择可以容纳对象要求大小的内存区域分配给这个对象</p>
<p>虚拟机将分配到的内存空间都初始化为零（不包括对象头），这里的初始化不同于我们在Java中利用构造函数进行初始化的过程，这里的初始化时保证Java的一些原生数据类型在不重新赋值的时候就可以直接使用，程序在使用这些对象的时候可以直接使用零值。</p>
<p>接下来，虚拟机要对对象一些必要的设置，进行这些设置的目的是可以知道这些对象是哪个类的实例、对象的哈希码、对象的GC分代年龄等信息，这些信息都存储在对象头中。</p>
<p>上面这些工作完成之后，从虚拟机的角度看，一个对象已经构造完成，但是从开发人员的角度看，还需要进行new对象之后初始化，接着执行init方法，到这里一个对象才算真正创建完毕</p>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>主要包括三部分的信息：对象头、实例数据和对齐填充</p>
<p>对象头又包括两部分信息，第一部分用于存储对象自身的运行时数据，比如哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等；第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>实例数据部分是对象真真好存储的有效信息，也是程序代码中所定义的各种类型的字段内容</p>
<p>第三部分不是必然存在的，只是起到占位符的作用，因为HotspotVM规定对象的起始地址必须是8字节的整数倍。所以很有可能以上两部分的大小不够8字节的整数倍，那么这个字段就可以发挥作用了。</p>
<h4 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h4><p>主要是通过Java栈中的reference数据，通过这个reference数据只是一个指向对象的引用，那么对象的访问方式就可以不同。目前主流的对象访问方式主要由句柄和直接指针两种。通过句柄访问的话，会在Java堆中划分出一块句柄池，句柄池中句柄存放了对象的实例数据和类型指针，而reference数据则存放了句柄的地址引用。使用直接指针访问对象，那么reference数据存放的就是对象的地址<br>使用句柄访问的最大好处是reference中存储的稳定的句柄地址，当对象的地址发生了改变可以不用去关心。而直接指针的最大好处是速度更快，在于节省了一次指针定位的时间</p>
<h4 id="OOM异常分类"><a href="#OOM异常分类" class="headerlink" title="OOM异常分类"></a>OOM异常分类</h4><p>Java堆溢出<br>虚拟机栈和本地方法栈溢出<br>方法区和运行常量池溢出<br>本机直接内存溢出</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;引用百度文库上对java虚拟机的定义.&lt;br&gt;虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机
    
    </summary>
    
      <category term="jvm" scheme="http://www.myzwl.win/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://www.myzwl.win/source/tags/jvm/"/>
    
  </entry>
  
</feed>
