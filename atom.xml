<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2017-08-08T12:17:58.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用集合类简单总结</title>
    <link href="http://www.myzwl.win/2017/07/21/jihes_1/"/>
    <id>http://www.myzwl.win/2017/07/21/jihes_1/</id>
    <published>2017-07-21T05:48:51.000Z</published>
    <updated>2017-08-08T12:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在没有集合之前我们都是直接用数组存放对象，但是这样操作会很不方便，于是利用数据结构封装了一些列集合，而集合中不存放输几局的基本类型，只存放对象的引用，如图（部分集合源码分析在之前的总结中已经简单研究过）<br><img src="/images/imgs4/1.png" alt="Alt text"><br>java集合主要分为以下三种类型：<br>Set(集)：集合中的对象不按特定方式排序，且没有重复对象。它的有些实现类能对集合中的对象按照特地方式排序。<br>List(列表)：集合中的对象按照索引位置排序，可以有重复对象，允许使用索引检索对象。<br>Map(映射)：集合中的每一个元素都包含一对键对象和值对象（key-value），集合中的键对象是不能重复的,它的一些实现类能对集合中的键对象进行排序。</p>
<p>注意这里的不能重复与比较hashcode和equals有关</p>
<h4 id="集合底层概述"><a href="#集合底层概述" class="headerlink" title="集合底层概述"></a>集合底层概述</h4><p><strong>Collection接口</strong><br>Collection接口是Set、List、Queue接口的父接口，提供了多数集合常用的方法声明，包括 add()、remove()、contains() 、size() 、iterator() 等</p>
<p><strong>List接口</strong><br>它的特点是有序可重复，使用此接口能够精确的控制每个元素插入的位置用户能够使用索引来访问List中的元素并且允许有可重复的元素</p>
<p><strong>ArrayList</strong><br>底层实现是一个动态的数组，查询快，增删慢，线程不安全，效率高</p>
<p><strong>LinkedList</strong><br>底层实现是一个双向循环链表，查询慢，增删快，线程不安全，效率较高</p>
<p><strong>Vector</strong><br>是ArrlyList的线程安全版，底层同它基本一致，但是效率低，现在基本很少用</p>
<p><strong>Set接口</strong><br>它的特点就是唯一性并且不允许出现重复元素和是无序的</p>
<p><strong>hashSet</strong><br>底层是基于哈希表实现的，而其核心就是先比较hashCode（）值是否相同（相当于索引），然后在用equals比较是否相同，从而确定元素是否重复，所以当不希望集合中有重复值，并且不关心元素之间的顺序时可以使用此类</p>
<p><strong>LinkedHashSet</strong><br>底层实现是使用链表和哈希表，它由链表保证元素有序，哈希表保证元素唯一，因此当不希望集合中有重复值，并且希望按照元素的插入顺序进行迭代遍历时可采用此类</p>
<p><strong>TreeSet</strong><br>底层实现是红黑树，也就是一种平衡AVL树，通过比较返回值是否是0来保证元素唯一性，并且通过自然排序来保证元素的排序（自然排序也就是让元素所属的类实现Comparable接口，比如abc排在abd前面，总之就是和插入顺序无关，只和元素本身的内容和特质有关）</p>
<p><strong>Queue接口</strong><br>它的特点就是队列，即用于保存将要执行的任务列表</p>
<p><strong>LinkedList</strong><br>实现了该接口，可以实现先进先出的队列</p>
<p><strong>PriorityQueue</strong><br>底层采用某种排序的单链表存储队列元素，用来创建自然排序的优先级队列</p>
<p><strong>Map接口</strong><br>Map关心的是唯一的标识符，也就是将唯一的键映射到某个元素，以键值对形式存储，键唯一，值可重复</p>
<p><strong>HashMap</strong><br>底层实现是基于哈希表依赖于hashCode（）和equals（）方法，线程不安全，允许key和value为NULL，效率高</p>
<p><strong>Hashtable</strong><br>HashMap的线程安全版，效率低，不允许key和value为NULL</p>
<p><strong>LinkedHashMap</strong><br>底层是由链表和哈希表组成，链表保证元素有序，哈希表保证元素唯一，所以当需要键值对，并且关心插入顺序时可采用它</p>
<p><strong>TreeMap</strong><br>底层是由红黑树实现，当需要键值对，并关心元素的自然排序时可采用它</p>
<p><strong>Collections</strong><br>内置了一些常见的集合算法，像排序，查找算法等</p>
<h4 id="如何选择哪种集合"><a href="#如何选择哪种集合" class="headerlink" title="如何选择哪种集合"></a>如何选择哪种集合</h4><p>1 首先看是否是键值对形式<br>  是的话就选择Map<br>   然后再看是否需要排序：<br>     是的话就是TreeMap<br>     不是的话就是HashMap<br>     一般情况下都使用HashMap<br>   不是键值对的话就选择Collection<br>     再看元素是否唯一：<br>       是的话就选set<br>         元素是否需要排序<br>           是的话就选TreeSet<br>           反之选择HashSet<br>          一般情况选择HashSet<br>        不是元素唯一就选List<br>          再看是否是否需要线程安全：<br>           是的话就选Vector<br>            不是的话就选择ArrayList或者LinkedList<br>             增删选择：LinkedList<br>              查询选择ArrayList<br>              一般情况下都选择ArrayList</p>
<h4 id="集合常见方法"><a href="#集合常见方法" class="headerlink" title="集合常见方法"></a>集合常见方法</h4><p><strong>Collection的常见方法</strong></p>
<blockquote>
<p>1，添加。<br>    boolean add(Object obj):<br>    boolean addAll(Collection coll):<br>2，删除。<br>    boolean remove(object obj):<br>    boolean removeAll(Collection coll);<br>    void clear();<br>3，判断：<br>    boolean contains(object obj):<br>    boolean containsAll(Colllection coll);<br>    boolean isEmpty():判断集合中是否有元素。<br>4，获取：<br>    int size():<br>    Iterator iterator():取出元素的方式：迭代器。<br> 5，其他：<br>    boolean retainAll(Collection coll);取交集。<br>    Object[] toArray():将集合转成数组。 </p>
</blockquote>
<p><strong>Map的常见方法</strong></p>
<blockquote>
<p> 1，添加。<br>          value put(key,value):返回前一个和key关联的值，如果没有返回null.<br> 2，删除。<br>            void  clear():清空map集合。<br>            value remove(key):根据指定的key翻出这个键值对。<br> 3，判断。<br>                boolean containsKey(key):<br>                boolean containsValue(value):<br>                boolean isEmpty();<br> 4，获取。<br>                value get(key):通过键获取值，如果没有该键返回null。                        当然可以通过返回null，来判断是否包含指定键。<br>                int size(): 获取键值对的个数。<br>5.特殊方法： Collection<v> values() 包含的值的 Collection 视图。<br>             Set<map.entry<k,v>&gt; entrySet()方法：返回一个set集合，里面装的是Map.Entry接口类型的键值对象</map.entry<k,v></v></p>
</blockquote>
<p><strong>Map遍历方法</strong></p>
<blockquote>
<p>  第一种遍历的方法<br>  Set<k> keySet()：返回键的set集合<br> 取出map中的所有元素。<br> 原理，通过keySet方法获取map中所有的键所在的Set集合，在通过Set的迭代器获取到每一个键，<br>  在对每一个键通过map集合的get方法获取其对应的值即可。<br>    Set<integer> keySet = map.keySet();<br>        System.out.println(keySet);//键的set集合<br>        Iterator<integer> it = keySet.iterator();//迭代keySet<br>        while(it.hasNext()){<br>            Integer key = it.next();<br>            String value = map.get(key);<br>            System.out.println(key+”:”+value);<br>        }</integer></integer></k></p>
<p>第二种遍历map的方式：通过看API:Set<map.entry<k,v>&gt; entrySet()：Map.Entry<k,v>接口类型，<br>  里面有K getKey() 返回与此项对应的键。 V getValue()  返回与此项对应的值。<br>  Set<map.entry<integer, string="">&gt;entrySet = map.entrySet();<br>        System.out.println(entrySet);//键值对对象<br>        Iterator<map.entry<integer, string="">&gt;it = entrySet.iterator();<br>        while(it.hasNext()){<br>            Map.Entry<integer, string=""> entryMap = it.next();<br>            Integer key = entryMap.getKey();//获取键<br>            String value = entryMap.getValue();//获取值<br>            System.out.println(key+”:”+value);<br>  }</integer,></map.entry<integer,></map.entry<integer,></k,v></map.entry<k,v></p>
</blockquote>
<h4 id="collections常用方法"><a href="#collections常用方法" class="headerlink" title="collections常用方法"></a>collections常用方法</h4><p>由于该集合工具类方法太多，只总结出部分<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">sort</span><span class="params">(Collection)</span></span>：对集合进行自然排序</div><div class="line"><span class="function"><span class="title">reverse</span><span class="params">()</span></span>：反转集合中元素的顺序</div><div class="line"><span class="function"><span class="title">shuffle</span><span class="params">(Collection)</span></span>：对集合进行随机排序</div><div class="line"><span class="function"><span class="title">fill</span><span class="params">(List list,Object o)</span></span>：用对象o替换集合list中的所有元素</div><div class="line"><span class="function"><span class="title">copy</span><span class="params">(List m,List n)</span></span>：将集合n中的元素全部复制到m中,并且覆盖相应索引的元素</div><div class="line"><span class="function"><span class="title">min</span><span class="params">(Collection)</span></span>,min(Collection,Comparator)：前者采用Collection内含自然比较法，后者采用Comparator进行比较</div><div class="line"><span class="function"><span class="title">max</span><span class="params">(Collection)</span></span>,max(Collection,Comparator)：同上</div><div class="line"><span class="function"><span class="title">indexOfSubList</span><span class="params">(List list,List subList)</span></span>：查找subList在list中首次出现位置的索引</div><div class="line"><span class="function"><span class="title">swap</span><span class="params">(List list,int i,int j)</span></span>：交换集合中指定元素索引的位置</div><div class="line">.binarySearch(Collection,Object)：查找指定集合中的元素，返回所查找元素的索引</div><div class="line"><span class="function"><span class="title">replaceAll</span><span class="params">(List list,Object old,Object new)</span></span>：替换批定元素为某元素,若要替换的值存在刚返回true,反之返回false</div></pre></td></tr></table></figure></p>
<p>最后不得不说集合容器是在太复杂了，它包装了许许多多的数据结构和算法，也正是因为如此，才大大简化了难度，但同时也说明了数据结构与算法的重要性，只有我们真正理解了算法和数据结构，才能更好的驾驭集合类</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在没有集合之前我们都是直接用数组存放对象，但是这样操作会很不方便，于是利用数据结构封装了一些列集合，而集合中不存放输几局的基本类型，只存放对
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String与StringBuffer常用方法总结</title>
    <link href="http://www.myzwl.win/2017/07/20/StringBuf_1/"/>
    <id>http://www.myzwl.win/2017/07/20/StringBuf_1/</id>
    <published>2017-07-20T05:48:51.000Z</published>
    <updated>2017-08-07T06:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>String与StringBuffer的区别，简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。</p>
<h4 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h4><p>在之前的数据结构与算法中已经模拟了部分String常用的方法</p>
<blockquote>
<p>public final class Stringextends Objectimplements Serializable, Comparable<string>, CharSequence</string></p>
</blockquote>
<p><strong>构造方法</strong></p>
<blockquote>
<p>public String()：初始化一个新创建的 String 对象，使其表示一个空字符序列。注意，由于 String 是不可变的，所以无需使用此构造方法。<br> public String(String original）：创建一个String对象为original的拷贝<br> public String(char[] value)：用一个字符数组创建一个String对象<br> public String(char[] value, int offset,int count)：用一个字符数组从offset项开始的count个字符序列创建一个String对象</p>
</blockquote>
<p><strong>普通方法</strong></p>
<blockquote>
<p>public char charAt(int index):返回字符串中第index个字符<br> public int length():返回字符串的长度<br> public int indexOf(String str):返回字符串中出现str的第一个位置<br> public int indexOf(String str,int fromIndex):返回字符串中从fromIndex开始起出现str的第一个位置<br> public boolean equalsIgnoreCase(String another):比较字符串与another是否一样（忽略大小写）<br> public String replace(char oldChar,char newChar):在字符串中用newChar替换oldChar<br> public boolean startWith(String prefix):判断字符串是否以prefix字符串开头<br> public boolean endsWith(String suffix):判断字符串是否以suffix为结尾<br> public String toLowerCase():返回一个字符串为该字符串的小写形式<br> public String substring(int beginIndex):返回该字符串从beginIndex开始到结尾的字符串<br> public String substring(int beginIndex,int endIndex):返回该字符串从beginIndex开始到endIndex结尾的字符串<br> public String trim():返回将该字符串去掉开头和结尾空格后的字符串</p>
</blockquote>
<p><strong>静态重载方法</strong></p>
<blockquote>
<p>public static String valueOf(..):将基本类型数据转化为字符串，如<br> public static String valueOf(double d)</p>
</blockquote>
<p><strong>其它常用方法</strong></p>
<blockquote>
<p>public String[] split(String regix):可以将一个字符串按照指定的分隔符分隔，返回分隔后的字符串数组<br>public String concat(String str)//将参数中的字符串str连接到当前字符串的后面，效果等价于”+”；<br>contains(String str)//判断参数s是否被包含在字符串中，并返回一个布尔类型的值。<br>字符串转换为基本类型<br>java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：<br>1)public static byte parseByte(String s)<br>2)public static short parseShort(String s)<br>3)public static short parseInt(String s)<br>4)public static long parseLong(String s)<br>5)public static float parseFloat(String s)<br>6)public static double parseDouble(String s)</p>
</blockquote>
<p><strong>字符串比较</strong></p>
<blockquote>
<p>1)public int compareTo(String anotherString)//该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。<br>2)public int compareToIgnore(String anotherString)//与compareTo方法相似，但忽略大小写。<br>3)public boolean equals(Object anotherObject)//比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。<br>4)public boolean equalsIgnoreCase(String anotherString)//与equals方法相似，但忽略大小写。</p>
</blockquote>
<h4 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h4><p><strong>构造方法</strong></p>
<blockquote>
<p>StringBuffer() ：构造一个没有任何字符的StringBuffer类。<br>StringBuffer(int length) ：：构造一个没有任何字符的StringBuffer类，并且，其长度为length。<br>StringBuffer(String str) ：以str为初始值构造一个StringBuffer类。</p>
</blockquote>
<p><strong>append方法</strong><br>为该对象添加字符序列，返回添加后的该对象引用，同时是调用了toString方法转化为字符串</p>
<blockquote>
<ol>
<li>StringBuffer append(boolean b)</li>
<li>StringBuffer append(char c)</li>
<li>StringBuffer append(char[] str)</li>
<li>StringBuffer append(char[] str, int offset, int len)</li>
<li>StringBuffer append(double d)</li>
<li>StringBuffer append(float f)</li>
<li>StringBuffer append(int i)</li>
<li>StringBuffer append(long l)</li>
<li>StringBuffer append(Object obj)</li>
<li>StringBuffer append(String str)</li>
<li>StringBuffer append(StringBuffer sb)</li>
</ol>
</blockquote>
<p><strong>其他方法</strong></p>
<blockquote>
<p>12.int capacity() ：返回当前StringBuffer对象（字符串缓冲区）的总空间，而非字符号串的长度。</p>
<ol>
<li>char charAt(int index) ：在当前StringBuffer对象中取索引号为index的字符。第一个字符的索引为“0”</li>
<li>StringBuffer delete(int start, int end) ：删除当前StringBuffer对象中以索引号start开始，到end结束的子串。</li>
<li>StringBuffer deleteCharAt(int index) ：删除当前StringBuffer对象中索引号为index的字符。</li>
<li>void ensureCapacity(int minimumCapacity) ：重新设置字符号串缓冲区的总空间。如果minimumCapacity大于当前的总空间，则新的空间被设置：一种结果是minimumCapacity；另一种结果是{“老空间”乘2加2}<br>17.void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) ：从当前StringBuffer对象的索引号srcBegin开始，到srcEnd结束的子串，赋值到字符数组dst中，并且从dst的索引号dstBegin开始</li>
<li>int indexOf(String str) ：返回当前StringBuffer对象中，第一个满足str子串的位置。</li>
<li>int indexOf(String str, int fromIndex) ：从当前StringBuffer对象的fromIndex开始查找，返回第一个满足str子串的位置。</li>
<li>StringBuffer insert(int offset, boolean b)</li>
<li>StringBuffer insert(int offset, char c)</li>
<li>StringBuffer insert(int offset, char[] str)</li>
<li>StringBuffer insert(int index, char[] str, int offset, int len)</li>
<li>StringBuffer insert(int offset, double d)</li>
<li>StringBuffer insert(int offset, float f)</li>
<li>StringBuffer insert(int offset, int i)</li>
<li>StringBuffer insert(int offset, long l)</li>
<li>StringBuffer insert(int offset, Object obj)</li>
<li>StringBuffer insert(int offset, String str)</li>
<li>int lastIndexOf(String str) ：返回当前StringBuffer对象中，最后一个满足str子串的位置。</li>
<li>int lastIndexOf(String str, int fromIndex) ：从当前StringBuffer对象的fromIndex开始查找，返回最后一个满足str子串的位置。</li>
<li>int length() ：返回当前StringBuffer对象（字符缓冲区）中，字符串的长度。注意：此方法与capacity() 不同。</li>
<li>StringBuffer replace(int start, int end, String str) ：替换当前StringBuffer对象的字符串。从start开始，到end结束的位置替换成str。</li>
<li>StringBuffer reverse() ：将字符串翻转。</li>
<li>void setCharAt(int index, char ch) ：设置索引号index的字符为ch。</li>
<li>void setLength(int newLength) ：重新设置字符串缓冲区中字符串的长度，如果newLength小于当前的字符串长度，将截去多余的字符。</li>
<li>String substring(int start) ：取当前StringBuffer对象中，从start开始到结尾的子串。</li>
<li>String substring(int start, int end) ：取当前StringBuffer对象中，从start开始到end的子串。</li>
<li>String toString() ：将当前StringBuffer对象转换成String对象。</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;String与StringBuffer的区别，简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Brute-Force与KMP算法</title>
    <link href="http://www.myzwl.win/2017/07/19/suanfa_2/"/>
    <id>http://www.myzwl.win/2017/07/19/suanfa_2/</id>
    <published>2017-07-19T05:48:51.000Z</published>
    <updated>2017-08-07T05:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设有两个串：目标串target和模式串pattern，在目标串中查找与模式串pattern相等得一个子串并确定孩子串位置的操作称为串的模式匹配。而匹配的结果有两种，如果target中存在等于pattern的子串，则匹配成功，给出孩子串在target中的位置，否则匹配失败</p>
<h4 id="Brute-Force算法"><a href="#Brute-Force算法" class="headerlink" title="Brute-Force算法"></a>Brute-Force算法</h4><p><img src="/images/imgs4/16.gif" alt="Alt text"><br>算法描述：如图，该算法的核心就是在target中从begin位置，这里begin=0开始，比较ti与pi是否相等，如果有一个不相等，则begin开始从之前的下一个字符开始匹配，同时pattern中退回到第一个字符，在依次比较，知道存在相等字符，返回相应位置，可以发现该算法是一个回溯算法。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//模式匹配，pattern为待匹配子串，begin为起始匹配位置</div><div class="line">public int indexOf(MyString pattern,int begin)&#123;</div><div class="line">	//待匹配子串不为空并且长度大于0和目标串大于等于带匹配子串</div><div class="line">	if(pattern!=null&amp;&amp;pattern.length()&gt;0&amp;&amp;this.length()&gt;=pattern.length())</div><div class="line">	&#123;</div><div class="line">		int i=begin,j=0; //记录i为开始位置，j为待匹配子串计数器</div><div class="line">		while(i&gt;this.length())&#123; //目标串全部匹配完，退出</div><div class="line">			if(this.charAt(i)==pattern.charAt(j))//如果，有字符相等</div><div class="line">			&#123;</div><div class="line">				i++; //计数器都加1，并且开始比较后一个字符</div><div class="line">				j++;</div><div class="line">			&#125;</div><div class="line">			else&#123;</div><div class="line">				i=i+j+1; //i回溯，变成上一个目标串匹配字符的下一个字符</div><div class="line">				j=0;    //待匹配字符，回溯为0</div><div class="line">			&#125;</div><div class="line">			if(j==pattern.length())</div><div class="line">				return i-j; //返回匹配到的位置</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	           return -1; //匹配失败</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回当前目标串的首次位置，从第一个位置开始</div><div class="line">public int indexOf(MyString pattern)&#123;</div><div class="line">	return this.indexOf(pattern, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="模式匹配应用"><a href="#模式匹配应用" class="headerlink" title="模式匹配应用"></a>模式匹配应用</h4><p>一般我们要替换或者删除相关子串时，首先就是查找是否存在此串，然后在进行相关操作<br>首先是替换操作<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//返回当前串替换之后的串</div><div class="line">public MyString replaceFirst(MyString pattern,MyString replacement)&#123;</div><div class="line">	int i=this.indexOf(pattern, 0);//找到要替换串的下标</div><div class="line">	 if(i==-1)</div><div class="line">		 return this; //不存在要替换的部分，返回当前串</div><div class="line">	 //连接三个串</div><div class="line">	 return this.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length()));		 </div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyString replaceAll(MyString pattern,MyString replacement)&#123;</div><div class="line">	MyString temp=new MyString(this);</div><div class="line">	 int i=this.indexOf(pattern, 0);</div><div class="line">	  while(1!=-1)</div><div class="line">	  &#123;</div><div class="line">		  temp=temp.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length()));</div><div class="line">		  i=temp.indexOf(pattern, i+replacement.length());//从下一个字符开始继续寻找匹配</div><div class="line">	  &#125;</div><div class="line">	  return temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，String是不变类型，也就是一个新的字符串是在堆栈上又开辟了一个新空间，不是原来的对象<br>下面是删除操作<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public MyString deleteFirst(MyString target,MyString pattern)&#123;</div><div class="line">	int i=target.indexOf(pattern);</div><div class="line">	 if(i==-1)</div><div class="line">		 return target;</div><div class="line">	  return target.substring(0, i)+target.substring(i+pattern.length());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyString deleteAll(MyString target,MyString pattern)&#123;</div><div class="line">	int i=target.indexOf(pattern);</div><div class="line">	 while(i!=-1)</div><div class="line">	 &#123;</div><div class="line">		 target=target.substring(0, i)+target.substring(i+pattern.length());</div><div class="line">		  i=target.indexOf(pattern, i);</div><div class="line">	 &#125;</div><div class="line">	 return target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心思想就是先模式匹配，然后在构造一个新的串</p>
<p>最后分析一下该模式匹配算法，假设模式串长度为m，可以发现他的时间复杂度为O(m);并且匹配中存在很多重复，所以算法效率是很低的</p>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>由之前的算法我们知道，它存在重复匹配，如之前的pattern=abc，此时p的各个字符都不相等，而在匹配时target=ababdabcd中，第一次从a匹配，到第三位不等，开始从第二位匹配，但由于第一次已经知道pi各位不等，所以第二位就不用匹配了，他肯定与第一位不等，所以可省略，而这恰恰是KMP算法的核心</p>
<p><strong>next数组</strong><br>next数组的作用就是研究pattern串，依次确定如果不匹配下一次target串从哪一位开始匹配。并且这样定义next数组</p>
<blockquote>
<p>next[J]=-1，当j=0；<br>next[j]=k 当0&lt;=k&lt;f时且使p_0..p_k-1=p_j-k..p_j-1的最大整数</p>
</blockquote>
<p><img src="/images/imgs4/17.gif" alt="Alt text"><br>如图：pattern=”abcabc”，当j=0时，next[0]=-1；当j=1,2,3时，”a”,”ab”,”abc”都没有相同前缀子串和后缀子串next[j]=k=0；当j=4时，”abca”钟相同的前缀子串和后缀子串是”a”，所以k=1；当j=5时，为”ab”，所以k=2，依次类推<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private int[] getNext(String pattern)&#123;  //求next</div><div class="line">		int j=0,k=-1;                   //初始化j，k，next</div><div class="line">		int[] next=new int[pattern.length()];</div><div class="line">		next[0]=-1;</div><div class="line">		while(j&lt;pattern.length()-1)    //当j遍历完pattern字符串，结束</div><div class="line">		&#123;</div><div class="line">			if(k==-1||pattern.charAt(j)==pattern.charAt(k)) //k为初始值或者pattern的后缀字符与前缀相同</div><div class="line">			&#123; </div><div class="line">				j++;           //j后移，k加一，同时第j个字符的next值为k</div><div class="line">				k++;</div><div class="line">				next[j]=k;</div><div class="line">			&#125; </div><div class="line">			else              //否则，k重新回到前缀值，继续比较</div><div class="line">				k=next[k];</div><div class="line">			return next;</div><div class="line">		&#125;</div><div class="line">		return next;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下面是KMP的算法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int indexOf(String target,String pattern,int begin)&#123;</div><div class="line">		if(pattern!=null&amp;&amp;pattern.length()&gt;0&amp;&amp;this.length()&gt;=pattern.length())</div><div class="line">		&#123;</div><div class="line">		int i=begin,j=0;</div><div class="line">		int[] next=getNext(pattern); //求得next数组，这样就可以避免一些重复比较了</div><div class="line">		while(i&lt;target.length())&#123;</div><div class="line">			if(j==-1||target.charAt(i)==pattern.charAt(j))</div><div class="line">			&#123;</div><div class="line">				i++;</div><div class="line">				j++;</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">				j=next[j]; //退回到next[J]个字符开始比较</div><div class="line">			if(j==pattern.length())</div><div class="line">				return i-j;</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		return -1;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h4 id="改进的KMP算法"><a href="#改进的KMP算法" class="headerlink" title="改进的KMP算法"></a>改进的KMP算法</h4><p>当target=”aaaabcde”时，pattern=”aaaax”时，发现，a重复了，按照之前的算法，当i=5时，有重复比较四个a，所以可改进<br><img src="/images/imgs4/18.gif" alt="Alt text"><br>如图：改进的nextval是在next数组基础上，这里约定的next初始值为-1，所以如j=3，与next[j]+1比较，如果相等，则其值等于next[j]+1的next值，否则，保持原next值不变<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private int[] getNext(String pattern)&#123;</div><div class="line">		int j=0,k=-1;</div><div class="line">		int[] next=new int[pattern.length()];</div><div class="line">		next[0]=-1;</div><div class="line">		while(j&lt;pattern.length()-1)</div><div class="line">		&#123;</div><div class="line">			if(k==-1||pattern.charAt(j)==pattern.charAt(k))</div><div class="line">			&#123;</div><div class="line">				j++;</div><div class="line">				k++;</div><div class="line">				if(pattern.charAt(j)!=pattern.charAt(k))//改进之处</div><div class="line">				next[j]=k;</div><div class="line">				else</div><div class="line">					next[j]=next[k];</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">				k=next[k];</div><div class="line">			return next;</div><div class="line">		&#125;</div><div class="line">		return next;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>由此发现KMP算法的时间复杂度为O(n);</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;设有两个串：目标串target和模式串pattern，在目标串中查找与模式串pattern相等得一个子串并确定孩子串位置的操作称为串的模式匹
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>冒泡与选择排序</title>
    <link href="http://www.myzwl.win/2017/07/18/suanfa_1/"/>
    <id>http://www.myzwl.win/2017/07/18/suanfa_1/</id>
    <published>2017-07-18T05:48:51.000Z</published>
    <updated>2017-08-06T12:56:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>算法描述：冒泡排序是一种交换排序，它的基本思想就是两两比较相邻的关键字，如果反序则交换，直到没有反序的记录为止<br><img src="/images/imgs4/14.gif" alt="Alt text"><br>就像冒泡一样，第一次先把最大的选出来冒到最后，依次类推，从下个继续冒最大的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int a[])&#123;</div><div class="line">		int temp;  //临时变量，用于交换</div><div class="line">		for(int i=a.length-1;i&gt;0;i--) //外层循环，用于控制需要冒泡的个数</div><div class="line">			for(int j=0;j&lt;=i-1;j++) //内存循环</div><div class="line">				if(a[j]&gt;a[j+1]) //如果需要交换，则交换</div><div class="line">				&#123;</div><div class="line">					temp=a[j+1];</div><div class="line">					a[j+1]=a[j];</div><div class="line">					a[j]=temp;</div><div class="line">				&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出这个冒泡的实现是很简单的，但是效率上存在严重问题，比如有序数列2,1,3,4,5这个除了第一个，其余都已经是有序了，但是根据算法还是不断循环，比较增加了冗余，所以需要改进<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int a[])&#123;</div><div class="line">	int temp;</div><div class="line">	boolean flag=true; //用来作为标记</div><div class="line">	for(int i=a.length-1;i&gt;0&amp;&amp;flag;i--)&#123; //如果flag为false，也就是已经有序了，退出</div><div class="line">		flag=false;  //初始化为false</div><div class="line">		for(int j=0;j&lt;=i-1;j++)</div><div class="line">			if(a[j]&gt;a[j+1])</div><div class="line">			&#123;</div><div class="line">				temp=a[j+1];</div><div class="line">				a[j+1]=a[j];</div><div class="line">				a[j]=temp;</div><div class="line">				flag=true;  //如果有数据交换，则设为true</div><div class="line">			&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>显然从效率上提高了许多，由内外循环次数可以得出其时间复杂度为o(n^2)</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>算法描述：选择排序就是通过n-i此关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换<br><img src="/images/imgs4/15.gif" alt="Alt text"><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void ChooseSort(int[] a)&#123;</div><div class="line">	int min,temp;  //分别为每一次循环的当前最小变量和临时变量</div><div class="line">	for(int i=0;i&lt;a.length;i++)&#123;</div><div class="line">		 min=i; //初始化最小变量，为当前循环的第一个变量</div><div class="line">	 for(int j=i+1;j&lt;a.length;j++)</div><div class="line">	 &#123;</div><div class="line">		 if(a[j]&lt;a[i])  //找到比当前循环的最小变量小的记录，并记录下标</div><div class="line">			 min=j;</div><div class="line">	 &#125;</div><div class="line">	 if(min!=i) //如果有比当前最小变量小，则交换记录</div><div class="line">	 &#123;</div><div class="line">		 temp=a[min];</div><div class="line">		 a[min]=a[i];</div><div class="line">		 a[i]=temp;			 </div><div class="line">	 &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出它的时间复杂度仍然是O(n^2)</p>
<h4 id="约瑟夫环的另一种解法"><a href="#约瑟夫环的另一种解法" class="headerlink" title="约瑟夫环的另一种解法"></a>约瑟夫环的另一种解法</h4><p>至于问题描述就不描述了，在之前的数据结构总结中已经有了这个问题的描述<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public static void Count3Quit()&#123;</div><div class="line">		boolean[] arr=new boolean[500]; //初始化500个人围成圈</div><div class="line">		 for(int i=0;i&lt;arr.length;i++) //假设每个人值都为true</div><div class="line">	      arr[i]=true;</div><div class="line">		    int len=arr.length; //记录总人数</div><div class="line">		    int index=0;  //记录每个人的索引</div><div class="line">		    int count=0;  //记录数数变量，这里是数三退一</div><div class="line">		     while(len&gt;1)//直到只剩最后一个人为止</div><div class="line">		     &#123;</div><div class="line">		    	 if(arr[index]==true) //人还在圈内</div><div class="line">		    	 &#123;</div><div class="line">		    		 count++; //数数加一</div><div class="line">		    		 if(count==3) //数到三时，退一个人</div><div class="line">		    		 &#123;</div><div class="line">		    			 count=0; //计数重置为0</div><div class="line">		    			  arr[index]=false; //该人退出</div><div class="line">		    			   len--; //总人数减一</div><div class="line">		    		 &#125;</div><div class="line">		    	 &#125;</div><div class="line">		    	 index++; //索引加一</div><div class="line">		    	 if(index==arr.length)//索引超出人数长度，循环从0开始</div><div class="line">		    		 index=0;</div><div class="line">		     &#125;</div><div class="line">		     for(int i=0;i&lt;arr.length;i++)//输出最后一个人</div><div class="line">		    	 if(arr[i]==true)</div><div class="line">		    		 System.out.println(i);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h4&gt;&lt;p&gt;算法描述：冒泡排序是一种交换排序，它的基本思想就是两两比较相邻的关键字，如果反序则交换，直到没有反序的记录为止&lt;br&gt;&lt;im
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java异常处理二</title>
    <link href="http://www.myzwl.win/2017/07/17/yc_2/"/>
    <id>http://www.myzwl.win/2017/07/17/yc_2/</id>
    <published>2017-07-17T05:48:51.000Z</published>
    <updated>2017-08-05T10:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过一已经初步了解了异常的一些原理和相关性质，当然在平时写程序时被各种各样的异常类型弄得叫苦不堪<br><img src="/images/imgs4/12.gif" alt="Alt text"></p>
<h4 id="java常见异常"><a href="#java常见异常" class="headerlink" title="java常见异常"></a>java常见异常</h4><p>从api文档中可以看出，java已经为我们内置了很多异常<br><img src="/images/imgs4/13.gif" alt="Alt text"><br>先来看看RuntimeException中常见异常</p>
<blockquote>
<p>  1java.lang.ArrayIndexOutOfBoundsException<br>    数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。<br>    2、java.lang.ArithmeticException<br>    算术条件异常。譬如：整数除零等。<br>    3、java.lang.NullPointerException<br>    空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等<br>    4、java.lang.ClassNotFoundException<br>    找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。<br>   5、java.lang.NegativeArraySizeException  数组长度为负异常<br>   6、java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常<br>   7、java.lang.SecurityException 安全性异常<br>   8、java.lang.IllegalArgumentException 非法参数异常</p>
</blockquote>
<p><strong>IOException</strong></p>
<blockquote>
<p>IOException：操作输入流和输出流时可能出现的异常。<br>  EOFException   文件已结束异常<br>  FileNotFoundException   文件未找到异常</p>
</blockquote>
<p><strong>其他异常</strong></p>
<blockquote>
<p> ClassCastException    类型转换异常类<br>   ArrayStoreException  数组中包含不兼容的值抛出的异常<br>    SQLException   操作数据库异常类<br>    NoSuchFieldException   字段未找到异常<br>    NoSuchMethodException   方法未找到抛出的异常<br>    NumberFormatException    字符串转换为数字抛出的异常<br>    StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常<br>    IllegalAccessException  不允许访问某类异常<br>    InstantiationException  当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</p>
</blockquote>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>在Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。<br> 所有异常都必须是 Throwable 的子类。<br> 如果希望写一个检查性异常类，则需要继承 Exception 类。<br> 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。<br> 如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class MyException extends Exception&#123;</div><div class="line"></div><div class="line">	private int id;</div><div class="line">	</div><div class="line">	public MyException()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyException(String msg,int id)&#123;</div><div class="line">		super(msg);</div><div class="line">		this.id=id;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int getId()&#123;</div><div class="line">		return this.id;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Ttest &#123;</div><div class="line">  public void regist(int num) throws MyException&#123;</div><div class="line">	  if(num&lt;0)&#123;</div><div class="line">		  throw new MyException("不能为负数",404);</div><div class="line">	  &#125;</div><div class="line">	  System.out.println("it is"+num);		  </div><div class="line">  &#125;</div><div class="line">  public void manager()&#123;</div><div class="line">	  try &#123;</div><div class="line">		regist(-10);</div><div class="line">	&#125; catch (MyException e) &#123;</div><div class="line">		System.out.println("Error Code"+e.getId());</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">	  System.out.println("over");</div><div class="line">  &#125;</div><div class="line">  public static void main(String args[])&#123;</div><div class="line">	  Ttest t=new Ttest();</div><div class="line">	  t.manager();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果有异常时运行结果如下：</p>
<blockquote>
<p>com.test.QQ.MyException: 不能为负数<br>    at com.test.QQ.Ttest.regist(Ttest.java:6)<br>    at com.test.QQ.Ttest.manager(Ttest.java:12)<br>    at com.test.QQ.Ttest.main(Ttest.java:21)<br>Error Code404<br>over</p>
</blockquote>
<p>将regist（-10）改为regist（10），如下</p>
<blockquote>
<p>it is10<br>over</p>
</blockquote>
<h4 id="spring异常处理"><a href="#spring异常处理" class="headerlink" title="spring异常处理"></a>spring异常处理</h4><p>前面我们都是用try..catch来捕获异常，造成业务逻辑较多，而spring通过注解式使捕获异常更方便。核心如下：</p>
<blockquote>
<p>  @ExceptionHandler：统一处理某一类异常，从而能够减少代码重复率和复杂度<br>    @ControllerAdvice：异常集中处理，更好的使业务逻辑与异常处理剥离开<br>    @ResponseStatus：可以将某种异常映射为HTTP状态码</p>
</blockquote>
<p>@ExceptionHandler源码如下：</p>
<blockquote>
<p>@Target({ElementType.METHOD})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface ExceptionHandler {<br>    Class&lt;? extends Throwable&gt;[] value() default {};<br> }</p>
</blockquote>
<p> 首先是注解的说明：<br> @Retention: 定义注解的保留策略<br>@Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在class字节码文件中不包含<br>@Retention(RetentionPolicy.CLASS)     // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，<br>@Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到</p>
<p>@Target：定义注解的作用目标<br>@Target(ElementType.TYPE)   //接口、类、枚举、注解<br>@Target(ElementType.FIELD) //字段、枚举的常量<br>@Target(ElementType.METHOD) //方法<br>@Target(ElementType.PARAMETER) //方法参数<br>@Target(ElementType.CONSTRUCTOR)  //构造函数<br>@Target(ElementType.LOCAL_VARIABLE)//局部变量<br>@Target(ElementType.ANNOTATION_TYPE)//注解<br>@Target(ElementType.PACKAGE) ///包    </p>
<p>@Document：说明该注解将被包含在javadoc中<br>@Inherited：说明子类可以继承父类中的该注解</p>
<p>该注解作用对象为方法，并且在运行时有效，value()可以指定异常类<br>方法返回值可以为：<br>    ModelAndView对象<br>    Model对象<br>    Map对象<br>    View对象<br>    String对象<br>    还有@ResponseBody、HttpEntity&lt;?&gt;或ResponseEntity&lt;?&gt;，以及void</p>
<p>如</p>
<blockquote>
<p>@ControllerAdvice //在所有的controller中执行该异常<br>public class DefaultExceptionHandler {<br>    /**</p>
<pre><code> * 没有权限 异常
 * &lt;p/&gt;
 * 后续根据不同的需求定制即可
 */
@ExceptionHandler({UnauthorizedException.class}) //不同的异常处理
@ResponseStatus(HttpStatus.UNAUTHORIZED)
public String processUnauthenticatedException(NativeWebRequest request, UnauthorizedException e) {
    System.out.println(&quot;un&quot;);
    return null;
</code></pre><p>}</p>
</blockquote>
<pre><code>@ExceptionHandler(RuntimeException.class)
@ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)  
public String handleUnexpectedServerError(RuntimeException ex) { 
    System.out.println(&quot;500&quot;);
    return null;
}

@ExceptionHandler(ServletException.class)
@ResponseStatus(value = HttpStatus.NOT_FOUND)  
public String handleNotFoundError() {     
       System.out.println(&quot;404&quot;);
      return null;       
}
</code></pre><p>}</p>
<p>如上的500和404错误，先给出错误的异常，在给出错误的状态码并且异常与状态码必须是对应的，该类的源码在org.springframework.http下，如</p>
<blockquote>
<p>public enum HttpStatus {<br>成功<br>   OK(200, “OK”),<br>   创建<br>   CREATED(201, “Created”),<br>   /接受<br>   ACCEPTED(202, “Accepted”),<br>   BAD_REQUEST(400, “Bad Request”),<br>   没有认证权限<br>   UNAUTHORIZED(401, “Unauthorized”),</p>
</blockquote>
<p>   PAYMENT_REQUIRED(402, “Payment Required”),<br>   禁止<br>   FORBIDDEN(403, “Forbidden”),</p>
<p>   NOT_FOUND(404, “Not Found”),</p>
<p>   有了上述全局处理的异常，就不许要在每个类里面重复写了，同时如果我们是在页面中需要捕获异常，如页面的404和500，只需在web.xml中配置一下（在spring配置文件中注入无效，也不知道怎么回事），如下：</p>
<blockquote>
<p><error-page><br>        <error-code>404</error-code><br>        <location>/404.jsp</location><br>    </error-page><br>    <error-page><br>    <error-code>500</error-code><br>     <location>/500.jsp</location><br> </error-page></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过一已经初步了解了异常的一些原理和相关性质，当然在平时写程序时被各种各样的异常类型弄得叫苦不堪&lt;br&gt;&lt;img src=&quot;/images/
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java异常处理一</title>
    <link href="http://www.myzwl.win/2017/07/16/yc_1/"/>
    <id>http://www.myzwl.win/2017/07/16/yc_1/</id>
    <published>2017-07-16T05:48:51.000Z</published>
    <updated>2017-08-05T05:27:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不得不说，我们平时在写程序时遇到最多的情形或者最头疼的事情就是遇到异常，然后各种调试，各种方法用尽最后才解决它，那么异常主要分为几类，每个类又有什么特征了（如图）<br><img src="/images/imgs4/11.gif" alt="Alt text"><br>从大的角度说主要分成两类：Error类代表了编译和系统的错误，不允许捕获，也就是我们自己无法主动去处理它；Exception类代表了我们可捕获并且可自己可处理异常，而Exception有包括两类，一个是你必须要处理的异常，如某个类有throws异常了，在未进入运行期就必须处理，另一类就是Runtime Exception（运行期异常），就是只有在运行时（也就是编译成class文件）时才知道，这个异常可处理或不处理</p>
<h4 id="处理异常机制"><a href="#处理异常机制" class="headerlink" title="处理异常机制"></a>处理异常机制</h4><p>在java应用程序中，异常处理机制主要为两种:抛出异常和捕获异常<br><strong>抛出异常</strong><br>简单的说，就是不处理异常，将异常不断抛给上一级，直至某一级有有处理异常措施，一般用throws、throw如</p>
<blockquote>
<p>public readFile() throws IOException{<br>    throw new xxx();<br>}</p>
</blockquote>
<p><strong>捕获异常</strong><br>定义是这样说的，在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。<br>一般有try..catch语句块，其语法格式如下：</p>
<blockquote>
<p>   try {<br>        // 可能会发生异常的程序代码<br>    } catch (Type1 id1){<br>        // 捕获并处置try抛出的异常类型Type1<br>    }<br>    catch (Type2 id2){<br>         //捕获并处置try抛出的异常类型Type2<br>    }  </p>
</blockquote>
<pre><code>如果，不管异常有没有捕获，都要执行某段代码，如数据库查询后都要关闭等等，就可以用finally，上面修改
</code></pre><blockquote>
<p>   try {<br>        // 可能会发生异常的程序代码<br>    } catch (Type1 id1){<br>        // 捕获并处置try抛出的异常类型Type1<br>    }<br>    catch (Type2 id2){<br>         //捕获并处置try抛出的异常类型Type2<br>    }  finally{<br>        //必须执行的代码<br>    }</p>
</blockquote>
<h4 id="try-catch-finally-规则"><a href="#try-catch-finally-规则" class="headerlink" title="try-catch-finally 规则"></a>try-catch-finally 规则</h4><pre><code>try块：用于捕获异常。其后可接0个或多个catch块，如果没有catch块，则必须跟一个finally块
catch块：用于处理try捕获到的异常。
finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行：
</code></pre><p>1）在finally语句块中发生了异常。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）关闭CPU。</p>
<p>try..catch..拥有执行顺序，即第一个catch之后，后面不在执行catch，所以一般将较详细的catch放在最前面，如先捕获IOException在捕获Exception</p>
<h4 id="throws规则"><a href="#throws规则" class="headerlink" title="throws规则"></a>throws规则</h4><p>1) 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</p>
<p>2）必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</p>
<p>3)仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出</p>
<p>4）调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。<br>如下</p>
<blockquote>
<pre><code>void method1() throws IOException{}  //合法    
</code></pre></blockquote>
<pre><code>//编译错误，必须捕获或声明抛出IOException    
void method2(){    
  method1();    
}    

//合法，声明抛出IOException    
void method3()throws IOException {    
  method1();    
}    

//合法，声明抛出Exception，IOException是Exception的子类    
void method4()throws Exception {    
  method1();    
}    

//合法，捕获IOException    
void method5(){    
 try{    
    method1();    
 }catch(IOException e){…}    
}    

//编译错误，必须捕获或声明抛出Exception    
void method6(){    
  try{    
    method1();    
  }catch(IOException e){throw new Exception();}    
}    

//合法，声明抛出Exception    
void method7()throws Exception{    
 try{    
  method1();    
 }catch(IOException e){throw new Exception();}    
}   

这里需要注意的是throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象
</code></pre><p><strong>Throwable类源码分析</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div></pre></td><td class="code"><pre><div class="line">/**  </div><div class="line">    *   </div><div class="line">    * Throwable是所有Error和Exceptiong的父类  </div><div class="line">    * 注意它有四个构造函数:  </div><div class="line">    * Throwable()  </div><div class="line">    * Throwable(String message)  </div><div class="line">    * Throwable(Throwable cause)  </div><div class="line">    * Throwable(String message, Throwable cause)  </div><div class="line">    *   </div><div class="line">    */    </div><div class="line">    public class Throwable implements Serializable &#123;    </div><div class="line">          private static final long serialVersionUID = -3042686055658047285L;    </div><div class="line">        </div><div class="line">          /**  </div><div class="line">           * Native code saves some indication of the stack backtrace in this slot.  </div><div class="line">           */    </div><div class="line">          private transient Object backtrace;     </div><div class="line">          /** </div><div class="line">       * 描述此异常的信息 </div><div class="line">       */  </div><div class="line">      private String detailMessage;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 表示当前异常由那个Throwable引起 </div><div class="line">        * 如果为null表示此异常不是由其他Throwable引起的 </div><div class="line">        * 如果此对象与自己相同,表明此异常的起因对象还没有被初始化 </div><div class="line">       */  </div><div class="line">      private Throwable cause = this;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 描述异常轨迹的数组 </div><div class="line">       */  </div><div class="line">      private StackTraceElement[] stackTrace;  </div><div class="line">      /** </div><div class="line">       * 构造函数,起因对象没有被初始化可以在以后使用initCause进行初始化 </div><div class="line">        * fillInStackTrace可以用来初始化它的异常轨迹的数组 </div><div class="line">       */  </div><div class="line">      public Throwable() &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数 </div><div class="line">       */  </div><div class="line">      public Throwable(String message) &#123;  </div><div class="line">         //填充异常轨迹数组  </div><div class="line">          fillInStackTrace();  </div><div class="line">         //初始化异常描述信息  </div><div class="line">          detailMessage = message;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数,cause表示起因对象 </div><div class="line">       */  </div><div class="line">      public Throwable(String message, Throwable cause) &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">          detailMessage = message;  </div><div class="line">          this.cause = cause;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数 </div><div class="line">       */  </div><div class="line">      public Throwable(Throwable cause) &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">          detailMessage = (cause==null ? null : cause.toString());  </div><div class="line">          this.cause = cause;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 获取详细信息 </div><div class="line">       */  </div><div class="line">      public String getMessage() &#123;  </div><div class="line">          return detailMessage;  </div><div class="line">      &#125;  </div><div class="line"></div><div class="line">      /** </div><div class="line">       * 获取详细信息 </div><div class="line">       */  </div><div class="line">      public String getLocalizedMessage() &#123;  </div><div class="line">          return getMessage();  </div><div class="line">      &#125;  </div><div class="line">       /** </div><div class="line">       * 获取起因对象 </div><div class="line">       */  </div><div class="line">      public Throwable getCause() &#123;  </div><div class="line">          return (cause==this ? null : cause);  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 初始化起因对象,这个方法只能在未被初始化的情况下调用一次 </div><div class="line">       */  </div><div class="line">      public synchronized Throwable initCause(Throwable cause) &#123;  </div><div class="line">         //如果不是未初始化状态则抛出异常  </div><div class="line">          if (this.cause != this)  </div><div class="line">              throw new IllegalStateException("Can't overwrite cause");  </div><div class="line">          </div><div class="line">         //要设置的起因对象与自身相等则抛出异常  </div><div class="line">          if (cause == this)  </div><div class="line">              throw new IllegalArgumentException("Self-causation not permitted");  </div><div class="line">          </div><div class="line">         //设置起因对象  </div><div class="line">          this.cause = cause;  </div><div class="line">         //返回设置的起因的对象  </div><div class="line">          return this;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 字符串表示形式 </div><div class="line">       */  </div><div class="line">      public String toString() &#123;       </div><div class="line">          String s = getClass().getName();          </div><div class="line">          String message = getLocalizedMessage();        </div><div class="line">          return (message != null) ? (s + ": " + message) : s;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace() &#123;   </div><div class="line">          printStackTrace(System.err);  </div><div class="line">      &#125;  </div><div class="line"></div><div class="line">       /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace(PrintStream s) &#123;  </div><div class="line">          synchronized (s) &#123;  </div><div class="line">            //调用当前对象的toString方法  </div><div class="line">              s.println(this);  </div><div class="line">            //获取异常轨迹数组  </div><div class="line">              StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">              </div><div class="line">            //打印出每个元素的字符串表示  </div><div class="line">              for (int i=0; i &lt; trace.length; i++)  </div><div class="line">                s.println("\tat " + trace[i]);  </div><div class="line">  </div><div class="line">            //获取起因对象  </div><div class="line">              Throwable ourCause = getCause();  </div><div class="line">              </div><div class="line">            //递归的打印出起因对象的信息  </div><div class="line">              if (ourCause != null)  </div><div class="line">                ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">       /** </div><div class="line">       * 打印起因对象的信息 </div><div class="line">       * @param s 打印的流 </div><div class="line">        * @param causedTrace 有此对象引起的异常的异常轨迹  </div><div class="line">       */  </div><div class="line">      private void printStackTraceAsCause(PrintStream s,  </div><div class="line">                                          StackTraceElement[] causedTrace)  </div><div class="line">      &#123;  </div><div class="line">         //获得当前的异常轨迹  </div><div class="line">          StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">         //m为当前异常轨迹数组的最后一个元素位置,   </div><div class="line">         //n为当前对象引起的异常的异常轨迹数组的最后一个元素  </div><div class="line">          int m = trace.length-1, n = causedTrace.length-1;  </div><div class="line">         //分别从两个数组的后面做循环,如果相等则一直循环,直到不等或数组到头  </div><div class="line">          while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(causedTrace[n])) &#123;  </div><div class="line">              m--; n--;  </div><div class="line">         &#125;  </div><div class="line">          </div><div class="line">         //相同的个数  </div><div class="line">          int framesInCommon = trace.length - 1 - m;  </div><div class="line">          </div><div class="line">         //打印出不同的错误轨迹  </div><div class="line">          s.println("Caused by: " + this);  </div><div class="line">          for (int i=0; i &lt;= m; i++)  </div><div class="line">              s.println("\tat " + trace[i]);  </div><div class="line">          //如果有相同的则打印出相同的个数  </div><div class="line">          if (framesInCommon != 0)  </div><div class="line">              s.println("\t... " + framesInCommon + " more");  </div><div class="line">  </div><div class="line">         //获得此对象的起因对象,并递归打印出信息  </div><div class="line">          Throwable ourCause = getCause();  </div><div class="line">          if (ourCause != null)  </div><div class="line">              ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace(PrintWriter s) &#123;   </div><div class="line">          synchronized (s) &#123;  </div><div class="line">              s.println(this);  </div><div class="line">              StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">              for (int i=0; i &lt; trace.length; i++)  </div><div class="line">                  s.println("\tat " + trace[i]);  </div><div class="line">  </div><div class="line">              Throwable ourCause = getCause();  </div><div class="line">              if (ourCause != null)  </div><div class="line">                  ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 打印起因对象的信息 </div><div class="line">        */  </div><div class="line">      private void printStackTraceAsCause(PrintWriter s,  </div><div class="line">                                          StackTraceElement[] causedTrace)  </div><div class="line">      &#123;  </div><div class="line">          // assert Thread.holdsLock(s);  </div><div class="line">  </div><div class="line">          // Compute number of frames in common between this and caused  </div><div class="line">          StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">          int m = trace.length-1, n = causedTrace.length-1;  </div><div class="line">          while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(causedTrace[n])) &#123;  </div><div class="line">              m--; n--;  </div><div class="line">          &#125;  </div><div class="line">          int framesInCommon = trace.length - 1 - m;  </div><div class="line">  </div><div class="line">          s.println("Caused by: " + this);  </div><div class="line">          for (int i=0; i &lt;= m; i++)  </div><div class="line">              s.println("\tat " + trace[i]);  </div><div class="line">          if (framesInCommon != 0)  </div><div class="line">              s.println("\t... " + framesInCommon + " more");  </div><div class="line">  </div><div class="line">          // Recurse if we have a cause  </div><div class="line">          Throwable ourCause = getCause();  </div><div class="line">          if (ourCause != null)  </div><div class="line">              ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 填充异常轨迹 </div><div class="line">       */  </div><div class="line">      public synchronized native Throwable fillInStackTrace();  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 返回当前的异常轨迹的拷贝 </div><div class="line">       */  </div><div class="line">      public StackTraceElement[] getStackTrace() &#123;  </div><div class="line">          return (StackTraceElement[]) getOurStackTrace().clone();  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      </div><div class="line">      /** </div><div class="line">       * 获取当前的异常轨迹 </div><div class="line">        */  </div><div class="line">      private synchronized StackTraceElement[] getOurStackTrace() &#123;  </div><div class="line">         //如果第一次调用此方法则初始化异常轨迹数组  </div><div class="line">          if (stackTrace == null) &#123;  </div><div class="line">            //获得异常轨迹深度  </div><div class="line">              int depth = getStackTraceDepth();  </div><div class="line">            //创建新的异常轨迹数组,并填充它  </div><div class="line">              stackTrace = new StackTraceElement[depth];  </div><div class="line">              </div><div class="line">            for (int i=0; i &lt; depth; i++)  </div><div class="line">                stackTrace[i] = getStackTraceElement(i);//获取指定位标的异常轨迹  </div><div class="line">          &#125;  </div><div class="line">          </div><div class="line">          return stackTrace;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 设置异常轨迹 </div><div class="line">       */  </div><div class="line">      public void setStackTrace(StackTraceElement[] stackTrace) &#123;  </div><div class="line">         //拷贝设置参数  </div><div class="line">          StackTraceElement[] defensiveCopy =  </div><div class="line">              (StackTraceElement[]) stackTrace.clone();  </div><div class="line">          </div><div class="line">         //如果设置参数有空元素则抛出异常  </div><div class="line">          for (int i = 0; i &lt; defensiveCopy.length; i++)  </div><div class="line">              if (defensiveCopy[i] == null)  </div><div class="line">                  throw new NullPointerException("stackTrace[" + i + "]");  </div><div class="line">  </div><div class="line">         //设置当前对象的异常轨迹  </div><div class="line">          this.stackTrace = defensiveCopy;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 异常轨迹的深度,0表示无法获得 </div><div class="line">       */  </div><div class="line">      private native int getStackTraceDepth();  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 获取指定位标的异常轨迹 </div><div class="line">       */  </div><div class="line">      private native StackTraceElement getStackTraceElement(int index);  </div><div class="line">  </div><div class="line">      </div><div class="line">      private synchronized void writeObject(java.io.ObjectOutputStream s)  </div><div class="line">          throws IOException  </div><div class="line">      &#123;  </div><div class="line">          getOurStackTrace();  </div><div class="line">          s.defaultWriteObject();  </div><div class="line">      &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上源码分析来自于互联网，同时由于目前是jdk1.8和这个源码有一小部分不一样，但不影响整体分析。当然，我们真正关心的是他的下面几个方法</p>
<blockquote>
<p>e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息:<br>   getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。<br>　 getMeage()：返回异常的消息信息。<br>　 printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。<br>而当我们出现异常时，就形成一条异常链，一个一个堆栈的打印出相关信息和异常</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;不得不说，我们平时在写程序时遇到最多的情形或者最头疼的事情就是遇到异常，然后各种调试，各种方法用尽最后才解决它，那么异常主要分为几类，每个类
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://www.myzwl.win/2017/07/15/sjjg_10/"/>
    <id>http://www.myzwl.win/2017/07/15/sjjg_10/</id>
    <published>2017-07-15T05:48:51.000Z</published>
    <updated>2017-07-27T14:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>查找操作，通俗的讲，就是给定一个值key，在一个数据结构中找出关键字为key的元素。而基于线性表的查找算法有顺序查找（O（n）），二分查找和分块查找</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>主要用于已排序的顺序表<br>算法描述：假定顺序表已按照升序排列，从表的中间位置开始比较，如果当前元素的关键字等于给定值，则查找成功，否则，若给定的值小于当前元素关键字，则在表的前半段继续查找，反之，在后半段查找，以此重复，直到获得查找结果<br><img src="/images/imgs4/10.gif" alt="Alt text"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class BSArray &#123;</div><div class="line"></div><div class="line">	//在升序排列的数组中，若找到关键字，则返回相应下标，否则返回-1</div><div class="line">	public static&lt;T&gt; int binarySearch(Comparable&lt;T&gt;[] value,T key)&#123;</div><div class="line">		return binarySearch(value,0,value.length-1,key);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static&lt;T&gt; int binarySearch(Comparable&lt;T&gt;[] value,int begin,int end,T key)&#123;</div><div class="line">		if(key!=null)</div><div class="line">			while(begin&lt;=end)&#123;    //边界有效</div><div class="line">				int mid=(begin+end)/2;  //中间位置，当前比较元素位置</div><div class="line">		System.out.println(value[mid]+"?");</div><div class="line">		if(value[mid].compareTo(key)==0) //对象比较大小</div><div class="line">			return mid;                  //查找成功</div><div class="line">		if(value[mid].compareTo(key)&gt;0)  </div><div class="line">			end=mid-1;                    //缩小到前半段</div><div class="line">		else</div><div class="line">			begin=mid+1;                 //缩小到后半段</div><div class="line">	&#125; </div><div class="line">	return -1;                           //查找不成功</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;查找操作，通俗的讲，就是给定一个值key，在一个数据结构中找出关键字为key的元素。而基于线性表的查找算法有顺序查找（O（n）），二分查找和
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>hash散列表</title>
    <link href="http://www.myzwl.win/2017/07/14/sjjg_9/"/>
    <id>http://www.myzwl.win/2017/07/14/sjjg_9/</id>
    <published>2017-07-14T05:48:51.000Z</published>
    <updated>2017-07-27T11:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>散列（hash）表是一种支持高效的查找、插入和删除操作的数据结构，它是针对查找效率接近O（1）而专门设计的。它根据元素的关键字确定元素的存储位置，而其中主要解决两个问题，设计散列函数和处理冲突</p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>在数据元素的关键字和该元素的存储位置之间建立一种对应关系，称为散列函数，而由散列函数决定元素存储位置的存储结构称为散列表，散列函数声明为</p>
<blockquote>
<p>public int hash(int key) //散列函数，确定关键字为key元素的散列地址</p>
</blockquote>
<p>散列函数实质上是关键字集合到地址集合的映射，如果这种映射是一一对应的，则查找效率是O（1），但是由于散列表是一个压缩映射，即存储容量有限，即映射关系是多对一的映射，所以会产生冲突<br><img src="/images/imgs4/9.gif" alt="Alt text"></p>
<h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>设两个关键字k1和k2（k1！=k2），如果有hash（k1）=hash（k2），即它们的散列值相同，表示不同关键字的多个元素映射到同一个存储位置，称为冲突，如图，所设的关键字序列是（1,4,3,11,12,6,14,74,16,96），元素个数是10，关键字范围是0~99，如果散列值的容量是100，很明显是一对一不会产生冲突，但是空间利用率此时只有10%，如果容量是10或者20，冲突差生的频率会减少</p>
<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>该散列函数定义为hash（k）=k%p，函数结果范围为0~p-1，图示就是采用这种方法，而p取值为小于散列表长度的最大素数，如散列表长度分别为8,16,128，则对应的p（最大素数）分别为7,13,127</p>
<h4 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h4><p><strong>开放定址法</strong><br>当产生冲突时，开放定址法在散列表内寻找另一个位置存储冲突的元素，如利用线性探查发实现，即设一个元素关键字为k，其散列地址为i=hash（k），若散列表中i位置已存储元素，则产生冲突，探测下一个位置i+1是否为空，。。直到找到一个空位置，但是它的缺陷就是在散列表内处理冲突，使得一个存储地址i可被任意一个元素抢占，这样就破坏了散列函数i=hash（k）的规则</p>
<p><strong>链地址法</strong><br><img src="/images/imgs4/12.jpg" alt="Alt text"><br>该方法是将多个冲突的元素存储在一条单链表中（称为同义词单链表），如图示<br>而对链地址法表进行插入、删除、查找等操作主要分两步完成<br>1.计算元素的散列函数值<br>2.根据元素的散列函数值，对某一条同义词单链表进行插入、删除和查找操作<br>规定查找成功的平均查找长度为（根据图示）ASL=(9<em>1+3</em>2)/12<br>并且有如下结论：<br>1.查找操作的时间复杂度为O（m），其中m为一条痛一次单链表的长度，插入操作为O(1),删除操作为O(m)</p>
<h4 id="模拟HashSet类"><a href="#模拟HashSet类" class="headerlink" title="模拟HashSet类"></a>模拟HashSet类</h4><p>这里同义词单链表采用单链表<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class HashSet&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	private SinglyLinkenList&lt;T&gt;[] table;    //散列表，同义词单链表对象数组</div><div class="line">	public HashSet(int size)&#123;               //构造指定容量的散列表</div><div class="line">		this.table=new SinglyLinkenList[Math.abs(size)];</div><div class="line">		for(int i=0;i&lt;table.length;i++)</div><div class="line">			table[i]=new SinglyLinkenList&lt;T&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public HashSet()&#123; //构造最大质数为97的容量</div><div class="line">		this(97);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private int hash(T x)&#123;  //散列函数，确定关键字为key元素的散列地址</div><div class="line">		int key=Math.abs(x.hashCode()); //每个对象的hashcode（）方法返回散列码，并且每个对象不同</div><div class="line">		return key%table.length; //出留余数法，除数是散列表长度</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void insert(T x)&#123;//插入x元素</div><div class="line">		table[hash(x)].insert(0, x);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void remove(T x)&#123; //删除x元素</div><div class="line">		table[hash(x)].remove((Integer) x);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public T search(T key)&#123; //返回查找到的关键字为key元素，查找不成功返回null</div><div class="line">		return table[hash(key)].search(key);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean contain(T key)&#123; //判断散列表是否包含关键字为key元素</div><div class="line">		return this.search(key)!=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String toString()&#123;</div><div class="line">		String str="";</div><div class="line">		for(int i=0;i&lt;table.length;i++)  //遍历各同义词单链表</div><div class="line">			if(!table[i].isEmpty())</div><div class="line">				str+=table[i].toString()+"\n";</div><div class="line">		return str;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;散列（hash）表是一种支持高效的查找、插入和删除操作的数据结构，它是针对查找效率接近O（1）而专门设计的。它根据元素的关键字确定元素的存储
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树和二叉树</title>
    <link href="http://www.myzwl.win/2017/07/13/sjjg_8/"/>
    <id>http://www.myzwl.win/2017/07/13/sjjg_8/</id>
    <published>2017-07-13T05:48:51.000Z</published>
    <updated>2017-07-27T07:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>树是数据元素（结点）之间具有层次关系的非线性结构。在树结构中，除根以外的结点只有一个前驱结点，可以有零至多个后继结点，根结点没有前驱结点</p>
<h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><p><img src="/images/imgs4/7.jpg" alt="Alt text"><br>1.父母、孩子、兄弟结点<br>2.度（结点所拥有的子树数目），如A的度为3<br>3.结点的层次（结点处于树中的位置，约定根结点层次为1），树的高度（树中结点的最大层次数）如图中树高度为3<br>4.边（设X结点是y结点的父母结点，有序对（X，y）称为这两个结点的边，路径如A到E结点，表示为（A，B，E），路径长度（路径上的边数）为2<br>5.无序数与有序树（区别子树之间有没有次序）<br>6.森林（删除根结点）</p>
<h4 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h4><p><img src="/images/imgs4/8.jpg" alt="Alt text"><br>二叉树最多有两颗子树，分别为左右子树<br>性质1：若根结点的层次为1，则二叉树第i层最多有2^(i-1)(i&gt;1)个结点<br>性质2：在高度为h的二叉树中，最多有2^h-1个结点（h&gt;=0)<br>性质3：设一棵二叉树的叶子结点数为n0,2度结点数为n2，则n0=n2+1<br>性质4：一颗具有n个结点的完全二叉树，其高度为h=[log以2为底数n为参数]+1；其中[]是高斯取整函数<br>性质5：一颗具有n个结点的完全二叉树，对序号为i（0&lt;=i<n)的结点，有 1.若i="0，则i为根结点，无父母结点：若i">0，则i的父母结点序号为[(i+1)/2]<br>2.若2<em>i+1&lt;n，则i的左孩子结点序号为2</em>i+1；否则无左孩子<br>3.若2<em>i+2&lt;n，则i的右孩子结点序号为2</em>i+2，否则i无右孩子</n)的结点，有></p>
<h4 id="二叉树的遍历规则"><a href="#二叉树的遍历规则" class="headerlink" title="二叉树的遍历规则"></a>二叉树的遍历规则</h4><p><strong>孩子优先遍历</strong><br>二叉树的遍历是按照一定规则和次序访问二叉树中的所有结点，并且每个结点仅被访问一次，同时遍历二叉树访问结点的次序是线性的。<br>1.先根次序：访问根结点，遍历左子树，遍历右子树（124536）<br>2.中根次序：遍历左子树，访问根结点，遍历右子树（425136）<br>3.后根次序：遍历左子树，遍历右子树，访问根结点（452631）</p>
<p><strong>兄弟优先遍历</strong><br>该遍历是按照层次进行的，遍历历程是从根结点开始，逐层深入，从左至右依次访问完当前层的所有结点，在访问下一层</p>
<h4 id="二叉树抽象数据类型和存储结构"><a href="#二叉树抽象数据类型和存储结构" class="headerlink" title="二叉树抽象数据类型和存储结构"></a>二叉树抽象数据类型和存储结构</h4><p><strong>顺序存储结构</strong><br><img src="/images/imgs4/9.jpg" alt="Alt text"><br>二叉树的顺序存储结构仅适用于完全二叉树和满二叉树，如图所示。根据之前的性质，可以实现对应关系一一对应个。<br>而对于非完全二叉树，如果采取顺序存储，可以将其补成一个完全二叉树，对于空结点利用特殊符号代替，但是会造成空间浪费，并且线性映射关系不明确</p>
<p><strong>链式存储结构</strong><br><img src="/images/imgs4/11.jpg" alt="Alt text"><br>二叉链表采用两条链分别连接左右孩子结点，每个结点有三个域：data存储数据元素，left、right分别指向左右孩子结点<br>三叉链表在二叉链表基础上增加一条链parent连接父母结点<br><img src="/images/imgs4/10.jpg" alt="Alt text"></p>
<p><strong>二叉链表结点</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class BinaryNode&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	public T data;                 //数据域，存储数据元素</div><div class="line">	public BinaryNode&lt;T&gt; left,right;   //链域，分别指向左、右孩子结点</div><div class="line">	</div><div class="line">	public BinaryNode(T data,BinaryNode&lt;T&gt; left,BinaryNode&lt;T&gt; right)&#123;</div><div class="line">		this.data=data;</div><div class="line">		this.left=left;</div><div class="line">		this.right=right;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode(T data)&#123;</div><div class="line">		this(data,null,null);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode()&#123;</div><div class="line">		this(null,null,null);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>抽象数据类型</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface BinaryTTree&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	boolean isEmpty();           //判断二叉树是否为空</div><div class="line">	int count();                 //返回二叉树的结点个数</div><div class="line">	int height();                //返回二叉树的高度</div><div class="line">	void preOrder();             //先根次序遍历二叉树</div><div class="line">	void inOrder();              //中根次序遍历二叉树</div><div class="line">	void postOrder();            //后根次序遍历二叉树</div><div class="line">	void levelOrder();           //按层次遍历二叉树</div><div class="line">	BinaryNode&lt;T&gt; search(T key);   //查找并返回首次出现关键字为key元素结点</div><div class="line">	BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; node);      //返回node的父母结点</div><div class="line">	void insertRoot(T x);            //插入元素x作为根结点</div><div class="line">	BinaryNode&lt;T&gt; insertChild(BinaryNode&lt;T&gt; p,T x,boolean leftChild); //插入孩子节点</div><div class="line">	void removeChild(BinaryNode&lt;T&gt; p,boolean leftChild); //删除p结点的左或右子树</div><div class="line">	void removeAll();  //删除二叉树</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是其实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line">public class BinaryTree&lt;T&gt; implements BinaryTTree&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	public BinaryNode&lt;T&gt; root;   //根结点，结点结构为二叉链表</div><div class="line">	public BinaryTree()&#123;         //构造空二叉树</div><div class="line">		this.root=null;</div><div class="line">	&#125;</div><div class="line">	public boolean isEmpty() &#123;  //判断二叉树是否为空</div><div class="line">		return this.root==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int count() &#123;</div><div class="line">		return count(root);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int count(BinaryNode&lt;T&gt; p)&#123; //返回以p结点为根的子树的结点个数</div><div class="line">		if(p==null)</div><div class="line">			return 0;</div><div class="line">		return 1+count(p.left)+count(p.right);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int height() &#123;</div><div class="line">		return height(root);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int height(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p==null)</div><div class="line">			return 0;</div><div class="line">		int lh=height(p.left); //返回左子树高度</div><div class="line">		int rh=height(p.right); //返回右子树高度</div><div class="line">		return (lh&gt;=rh)?lh+1:rh+1; //当前子树高度为较高子树高度加1</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void preOrder() &#123;</div><div class="line">		System.out.println("先根次序遍历二叉树:  ");</div><div class="line">		preOrder(root);</div><div class="line">		System.out.println();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void preOrder(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p!=null)</div><div class="line">		&#123;</div><div class="line">			System.out.println(p.data.toString()+" ");//访问当前结点</div><div class="line">			preOrder(p.left); //按先根次序遍历当前结点左子树，递归调用</div><div class="line">			preOrder(p.right); //按先根次序遍历当前结点右子树，递归调用</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void inOrder() &#123;</div><div class="line">		System.out.println("中根次序遍历二叉树 :   ");</div><div class="line">		inOrder(root);</div><div class="line">		System.out.println();	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void inOrder(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p!=null)</div><div class="line">		&#123;</div><div class="line">			inOrder(p.left);</div><div class="line">			System.out.println(p.data.toString()+" ");</div><div class="line">			inOrder(p.right);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void postOrder() &#123;</div><div class="line">	</div><div class="line">		System.out.println("后根次序遍历二叉树 :   ");</div><div class="line">		inOrder(root);</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void postOrder(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p!=null)&#123;</div><div class="line">			postOrder(p.left);</div><div class="line">			postOrder(p.right);</div><div class="line">			System.out.println(p.data.toString()+" ");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void levelOrder() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public BinaryNode&lt;T&gt; search(T key) &#123;</div><div class="line">		return search(root,key);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode&lt;T&gt; search(BinaryNode&lt;T&gt; p,T key) &#123;</div><div class="line">		if(p==null||key==null)</div><div class="line">			return null;</div><div class="line">		if(p.data.equals(key))  //查找成功，返回找到结点</div><div class="line">			return p;</div><div class="line">		BinaryNode&lt;T&gt; find=search(p.left,key);//在左子树中查找，递归调用</div><div class="line">		if(find==null)</div><div class="line">			find=search(p.right,key);//左子树中未找到，在右子树中继续递归查找</div><div class="line">		return find;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; node) &#123;</div><div class="line">	if(root==null||node==null||node==root)</div><div class="line">		return null;</div><div class="line">	 return getParent(root,node);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; p,BinaryNode&lt;T&gt; node) &#123;</div><div class="line">	if(p==null)</div><div class="line">		return null;</div><div class="line">	if(p.left==node||p.right==node)</div><div class="line">		return p;</div><div class="line">	BinaryNode&lt;T&gt; find=getParent(p.left,node);</div><div class="line">	if(find==null)</div><div class="line">		find=getParent(p.right,node);</div><div class="line">		return find;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void insertRoot(T x) &#123;</div><div class="line">		root=new BinaryNode&lt;T&gt;(x, root, null);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	//插入元素x作为p结点的孩子，若leftChild为true,插入结点作为左孩子，否则作为右孩子</div><div class="line">	public BinaryNode&lt;T&gt; insertChild(BinaryNode&lt;T&gt; p,T x,boolean leftChild)&#123;</div><div class="line">		if(p==null||x==null)</div><div class="line">			return null;</div><div class="line">		if(leftChild)</div><div class="line">		&#123;</div><div class="line">			p.left=new BinaryNode&lt;T&gt;(x, p.left, null);//插入x作为p的左孩子，p原左孩子变为x左孩子</div><div class="line">			return p.left;</div><div class="line">		&#125;</div><div class="line">		p.right=new BinaryNode&lt;T&gt;(x,null,p.right); //插入x结点作为p的右孩子</div><div class="line">		return p.right;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line">	public void removeChild(BinaryNode&lt;T&gt; p, boolean leftChild) &#123;</div><div class="line">	if(p!=null)</div><div class="line">		if(leftChild)</div><div class="line">			p.left=null;</div><div class="line">		else</div><div class="line">			p.right=null;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">		this.root=null;</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;树是数据元素（结点）之间具有层次关系的非线性结构。在树结构中，除根以外的结点只有一个前驱结点，可以有零至多个后继结点，根结点没有前驱结点&lt;/
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>优先队列与递归</title>
    <link href="http://www.myzwl.win/2017/07/12/sjjg_7/"/>
    <id>http://www.myzwl.win/2017/07/12/sjjg_7/</id>
    <published>2017-07-12T05:48:51.000Z</published>
    <updated>2017-07-26T14:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果按照队列的特点，即先来先服务原则，在很多情况下不能实现相关设计，比如操作系统中的进程调度管理，就是按照优先级大小来进行调度</p>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>若一个队列中的每个元素都有一个优先级，每次出队的是具有优先级最高的元素，则称该队列为优先队列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class PriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; implements QQueue&#123;</div><div class="line"></div><div class="line">	private SortedSinglyLinkedList&lt;T&gt; list; //使用排序单链表存储队列元素</div><div class="line">	</div><div class="line">	public PriorityQueue()&#123;   //构造空队列</div><div class="line">		this.list=new SortedSinglyLinkedList&lt;T&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123; //判断队列是否为空</div><div class="line">		return list.isEmpty();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(Object x) &#123; //元素x入队，根据元素大小插入在单链表适当位置</div><div class="line">		list.insert(x);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object dequeue() &#123;//出队，返回对头元素</div><div class="line"></div><div class="line">		return list.remove(0);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String toString()&#123;</div><div class="line">		return list.toString();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进程按优先级调度管理<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Process implements Comparable&lt;Process&gt;&#123;</div><div class="line"></div><div class="line">	private String name;   //进程名</div><div class="line">	private int priority;  //优先级</div><div class="line"></div><div class="line"></div><div class="line">	public Process(String name, int priority) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.priority = priority;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	public int compareTo(Process o) &#123;//比较两个进程的大小，约定进程排队次序的规则</div><div class="line"></div><div class="line">		return this.priority-o.priority;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>从形式上，递归的定义可如下所示<br><img src="/images/imgs4/6.jpg" alt="Alt text"><br>同时递归定义必须满足以下两个条件<br>1.边界条件：至少有一条初始定义是非递归的。<br>2.递归通式： 由已知函数值逐步递推计算出未知函数值</p>
<p>递归算法是指直接或者间接调用自身的算法<br>如用递归算法求fibonacci数列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Factorial &#123;</div><div class="line"></div><div class="line">	public static int factorial(int n)</div><div class="line">	&#123;</div><div class="line">		if(n&lt;0)</div><div class="line">			throw new IllegalArgumentException("n="+n);</div><div class="line">		if(n==0||n==1)</div><div class="line">			return n;</div><div class="line">		return factorial(n-1)+factorial(n-2);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String args[])&#123;</div><div class="line">		for(int i=0;i&lt;=24;i++)</div><div class="line">			System.out.print(factorial(i)+" ");</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<blockquote>
<p>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 </p>
</blockquote>
<p>再如将之前的SinglyLinkenList类增加一个复制方法，采用递归法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private Node&lt;T&gt; copy(Node&lt;T&gt; p)&#123;</div><div class="line">	Node&lt;T&gt; q=null; //新结点</div><div class="line">	if(p!=null)  //要复制的结点非空</div><div class="line">	&#123;</div><div class="line">		q=new Node&lt;T&gt;(p.data,null); //相当于q.data=p.data，q.next=null</div><div class="line">		q.next=copy(p.next);//递归，q1.data=p.next.data，q1.next=null，先返回q1，q.next=q1</div><div class="line">		//可以看成一棵二叉树</div><div class="line">	&#125;</div><div class="line">	return q;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果按照队列的特点，即先来先服务原则，在很多情况下不能实现相关设计，比如操作系统中的进程调度管理，就是按照优先级大小来进行调度&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>顺序与链式队列</title>
    <link href="http://www.myzwl.win/2017/07/11/sjjg_6/"/>
    <id>http://www.myzwl.win/2017/07/11/sjjg_6/</id>
    <published>2017-07-11T05:48:51.000Z</published>
    <updated>2017-07-26T07:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行。特点是先进先出。</p>
<h4 id="队列抽象数据类型"><a href="#队列抽象数据类型" class="headerlink" title="队列抽象数据类型"></a>队列抽象数据类型</h4><p><img src="/images/imgs4/5.jpg" alt="Alt text"><br>其中，像队列中插入元素的过程称为入队（enqueue），删除元素的过程称为出队（dequeue），允许入队的一端称为队尾（rear），允许出队的一头称为对头（front），没有元素的队列称为空队列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface QQueue&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	boolean isEmpty();          //判断队列是否为空</div><div class="line">	void enqueue(T x);          //元素x入队</div><div class="line">	T dequeue();                //出队，返回对头元素</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>顺序队列使用数组存储数据元素<br>1.当队列空时，设置队头、队尾下标front=rear=-1，<br>2.当第一个元素入队时，front=rear=0，同时改变两个下标<br>3.进行入队、出队操作，front、rear随之变化<br>4.当入队的元素个数（包括已出队元素）超出数组容量时，rear下标越界，数据溢出，但是，由于之前已有若干元素出队，数组前部以空出许多存储单元，所以这种溢出并不是因为存储空间不够而产生的，称为假溢出</p>
<p>所以顺序队列有两个缺点：假溢出和存储单元没有重复使用机制</p>
<h4 id="顺序循环队列"><a href="#顺序循环队列" class="headerlink" title="顺序循环队列"></a>顺序循环队列</h4><p>相比较顺序队列，有如下不同<br>1.队头、队尾元素按照如下循环规律变化，其中length表示数组长度<br>front=（front+1)%length;<br>rear=(rear+1)%length;<br>所以可以看出front和rear的取值范围为0~length-1；</p>
<p>2.约定rear是下一个入队元素位置，队列空条件是front==rear，即入队只改变rear，出队只改变front<br>3.约定队列满条件是队列中仍然有一个空位置，即front==（rear+1）%length，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class SeqQueue&lt;T&gt; implements QQueue&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Object element[];  //存储队列数据元素的数组</div><div class="line">	private int front,rear;    //分别为对头和队尾元素</div><div class="line">	</div><div class="line">	public SeqQueue(int length)&#123;        //构造容量为length的空队列</div><div class="line">		if(length&lt;64)</div><div class="line">			length=64;</div><div class="line">		this.element=new Object[Math.abs(length)];</div><div class="line">		this.front=this.rear=0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public SeqQueue()&#123;       //构造默认容量空队列</div><div class="line">		this(64);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;     //判断队列是否为空</div><div class="line">		return this.front==this.rear;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(T x) &#123;   //元素x入队，空对象不能入队</div><div class="line">	if(x==null)</div><div class="line">		return;</div><div class="line">	if(this.front==(this.rear+1)%this.element.length) //当队满时，扩充容量</div><div class="line">	&#123;</div><div class="line">		Object[] temp=this.element;</div><div class="line">		this.element=new Object[temp.length*2];</div><div class="line">		int i=this.front,j=0;</div><div class="line">		while(i!=this.rear)&#123;        //按照队列元素次序复制数组元素</div><div class="line">			this.element[j]=temp[i];</div><div class="line">			i=(i+1)%temp.length;</div><div class="line">			j++;</div><div class="line">		&#125;</div><div class="line">		this.front=0;</div><div class="line">		this.rear=j;</div><div class="line">	&#125;</div><div class="line">		this.element[this.rear]=x;</div><div class="line">		this.rear=(this.rear+1)%this.element.length;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T dequeue() &#123;         //出队，返回队头元素，若队列空则返回null</div><div class="line">   if(isEmpty())</div><div class="line">		return null;</div><div class="line">    T temp=(T)this.element[this.front];</div><div class="line">      this.front=(this.front+1)%this.element.length;  //取得队头元素</div><div class="line">     return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p>以不带头结点的单链表实现链式队列，设指针front和rear分别指向队头和队尾结点，初始空队列的状态设置为front=rear=null；队列空条件是front==null&amp;&amp;rear==null</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class LinkedQueue&lt;T&gt; implements QQueue&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Node&lt;T&gt; front,rear;        //分别指向队头和队尾</div><div class="line">	</div><div class="line">	public LinkedQueue()&#123;             //构造空队列</div><div class="line">		this.front=this.rear=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;        //判断队列是否为空</div><div class="line">		return this.front==null&amp;&amp;this.rear==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(T x) &#123;       //元素x入队，空对象入队</div><div class="line">		if(x==null)  </div><div class="line">			return;</div><div class="line">		Node&lt;T&gt; q=new Node&lt;T&gt;(x,null);  </div><div class="line">		 if(this.front==null)</div><div class="line">			 this.front=q;   //空队入队</div><div class="line">		 else</div><div class="line">			 this.rear.next=q; //插入在队尾之后</div><div class="line">		 this.rear=q;		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T dequeue() &#123;  //出队，返回对头元素，若队列元素为空，返回null</div><div class="line">		if(isEmpty())</div><div class="line">			return null;</div><div class="line">		T temp=this.front.data;    //取得队头元素</div><div class="line">		this.front=this.front.next;    //删除队头结点</div><div class="line">		if(this.front==null)</div><div class="line">			this.rear=null;</div><div class="line">		return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行。特点是先进先出。&lt;/p&gt;
&lt;h4 id=&quot;队列抽象数据类型&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://www.myzwl.win/2017/07/10/sjjg_5/"/>
    <id>http://www.myzwl.win/2017/07/10/sjjg_5/</id>
    <published>2017-07-10T05:48:51.000Z</published>
    <updated>2017-07-26T05:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈是一种特殊的线性表，其特殊之处在于插入和删除操作的位置受到限制，而且插入和删除只允许在线性表的一端进行，特点是后进先出</p>
<h4 id="栈抽象数据类型"><a href="#栈抽象数据类型" class="headerlink" title="栈抽象数据类型"></a>栈抽象数据类型</h4><p><img src="/images/imgs4/8.gif" alt="Alt text"><br>其中允许操作的一端为栈顶（top），不允许操作的一端为栈底（bottom），栈中插入元素的操作称为入栈（push），删除元素的操作为出栈（pop），没有元素的栈称为空栈</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface SStack&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	boolean isEmpty();  //判断是否为空栈</div><div class="line">	void push(T x);     //元素x入栈</div><div class="line">	T pop();            //出栈，返回当前栈顶元素</div><div class="line">	T get();            //取栈顶元素，未出栈</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>采用顺序存储结构的栈称为顺序栈<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class SeqStack&lt;T&gt; implements SStack&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Object element[];    //存取栈数据元素的数组</div><div class="line">	private int top;             //栈顶元素下标</div><div class="line">	</div><div class="line">	public SeqStack(int size)&#123;    //构造容量为size的空栈</div><div class="line">		this.element=new Object[Math.abs(size)];</div><div class="line">		this.top=-1;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public SeqStack()&#123;         //构造默认容量的空栈</div><div class="line">		this(64);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123; //判断栈是否为空</div><div class="line">		</div><div class="line">		return this.top==-1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void push(T x) &#123;    //元素x入栈，空对象不能入栈</div><div class="line">		if(x==null)</div><div class="line">			return;</div><div class="line">		if(this.top==element.length-1)   //栈满，扩充栈容量</div><div class="line">		&#123;</div><div class="line">			Object[] temp=this.element;</div><div class="line">			this.element=new Object[temp.length*2];</div><div class="line">			for(int i=0;i&lt;temp.length;i++)</div><div class="line">				this.element[i]=temp[i];</div><div class="line">		&#125;</div><div class="line">		this.top++;</div><div class="line">		this.element[this.top]=x;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T pop() &#123;  //出栈</div><div class="line">		</div><div class="line">		return this.top==-1?null:(T)this.element[this.top--];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get() &#123;		//取栈顶元素</div><div class="line">		return this.top==-1?null:(T)this.element[this.top];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上，push（），pop（），get（）方法的时间复杂度为O（1），而需要扩充容量时，复杂度为O（n）；</p>
<h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>采用链式存储结构的栈称为链式栈，这里采用单链表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class LinkedStack&lt;T&gt; implements SStack&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Node&lt;T&gt; top;         //栈顶结点</div><div class="line">	</div><div class="line">	public LinkedStack()&#123;        //构造空栈</div><div class="line">		this.top=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;     //判断栈是否为空</div><div class="line">		return this.top==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void push(T x) &#123;</div><div class="line">		if(x!=null)</div><div class="line">			this.top=new Node(x, this.top);  //头插入，x结点作为新的栈顶结点</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T pop() &#123;         //出栈，返回栈顶元素</div><div class="line">		if(this.top==null)</div><div class="line">			return null;</div><div class="line">		T temp=this.top.data;</div><div class="line">		this.top=this.top.next;</div><div class="line">		return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get() &#123;</div><div class="line">		return this.top==null?null:this.top.data;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;栈是一种特殊的线性表，其特殊之处在于插入和删除操作的位置受到限制，而且插入和删除只允许在线性表的一端进行，特点是后进先出&lt;/p&gt;
&lt;h4 i
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>串之字符串</title>
    <link href="http://www.myzwl.win/2017/07/09/sjjg_4/"/>
    <id>http://www.myzwl.win/2017/07/09/sjjg_4/</id>
    <published>2017-07-09T05:48:51.000Z</published>
    <updated>2017-07-23T15:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>串是由n(n&gt;=0)个字符组成的有限序列，它是一种特殊的线性表。而子串是指串s中任意连续字符组成的一个子序列组成的串。同时，串的比较通常由其字符编码的相关规则比较</p>
<h4 id="常量字符串String"><a href="#常量字符串String" class="headerlink" title="常量字符串String"></a>常量字符串String</h4><p>字符串采用字符数组作为存储结构，并且采用顺序存储结构，不过String类一次性申请了固定的空间，同时由于其存储结构为最终型，所以string不提供删除，插入子串<br>如下是模仿String类的部分<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public final class MyString implements Comparable&lt;MyString&gt;,Serializable&#123;</div><div class="line"></div><div class="line">	private final char[] value;         //字符数组，只能赋值一次</div><div class="line">	</div><div class="line">	public MyString()&#123;  //构造一个空串</div><div class="line">		this.value=new char[0];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyString(String original)&#123; //将字符串常量变成字符数组</div><div class="line">		this.value=original.toCharArray();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//以value数组中构造从begin开始的count个字符的字符串对象</div><div class="line">	public MyString(char[] value,int begin,int count)&#123;</div><div class="line">		this.value=new char[count];</div><div class="line">		 for(int i=begin;i&lt;begin+count;i++)</div><div class="line">			 this.value[i]=value[i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//以value数组中字符构造字符串</div><div class="line">	public MyString(char[] value)&#123;</div><div class="line">		this(value,0,value.length);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyString(MyString str)&#123;//复制对象</div><div class="line">		this(str.value);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int length()&#123;  //返回字符串长度</div><div class="line">		return this.value.length;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public char charAt(int i)&#123; //返回第i个字符</div><div class="line">		if(i&lt;0||i&gt;=this.value.length)</div><div class="line">			 throw new StringIndexOutOfBoundsException(i);</div><div class="line">		return this.value[i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String toString()&#123;</div><div class="line">		return new String(this.value);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">		public MyString concat(MyString str)&#123; //返回当前串与指定串str连接生成的新串</div><div class="line">		if(str==null||str.length()==0)     //要连接的串为空时，返回当前串</div><div class="line">			return this;</div><div class="line">		  char[] buffer=new char[this.value.length+str.length()];</div><div class="line">		   int i;</div><div class="line">		    for(i=0;i&lt;this.value.length;i++)  //复制当前串</div><div class="line">		    buffer[i]=this.value[i];</div><div class="line">		     for(int j=0;j&lt;str.value.length;j++)  //复制指定串</div><div class="line">		    	 buffer[i+j]=str.value[j];</div><div class="line">		       return new MyString(buffer); //以字符数组构造串</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int compareTo(MyString o) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由上述模拟过程知道，有四种构造方法构造串对象</p>
<blockquote>
<p>MyString s1=new MyString();<br> MyString s2=new MyString(“abc”);<br> char[] letters={a,b,c,d}<br> MyString s3=new MyString(“letters);<br> MyString s4=new MyString(s3);</p>
</blockquote>
<p> 此外在数组复制时，java提供了两种方法</p>
<blockquote>
<p>java.lang.System.arraycopy(value,0,this.value,0,value.length);<br> this.value=java.util.Arrays.copyOf(value,value.length)</p>
</blockquote>
<h4 id="求字串"><a href="#求字串" class="headerlink" title="求字串"></a>求字串</h4> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public MyString substring(int begin,int end)&#123;//返回传中从begin到end-1的子串</div><div class="line">	if(begin&lt;0)</div><div class="line">		begin=0;</div><div class="line">	if(end&gt;this.value.length)</div><div class="line">		end=this.value.length;</div><div class="line">	if(begin&gt;end)</div><div class="line">		throw new StringIndexOutOfBoundsException(end-begin);</div><div class="line">	if(begin==0&amp;&amp;end==this.value.length)</div><div class="line">		return this;</div><div class="line">	char[] buffer=new char[end-begin];</div><div class="line">	 for(int i=0;i&lt;buffer.length;i++)</div><div class="line">		 buffer[i]=this.value[i+begin];</div><div class="line">	   return new MyString(buffer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyString substring (int begin)&#123;//返回串中序号从begin到末尾的子串</div><div class="line">	return substring(begin,this.value.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="比较串相等与大小"><a href="#比较串相等与大小" class="headerlink" title="比较串相等与大小"></a>比较串相等与大小</h4> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object obj)&#123;</div><div class="line">	if(this==obj)</div><div class="line">		return true;</div><div class="line">	if(obj instanceof MyString)</div><div class="line">		&#123;MyString str=(MyString)obj;</div><div class="line">	if(this.value.length==str.value.length)&#123;</div><div class="line">		for(int i=0;i&lt;this.value.length;i++)</div><div class="line">			if(this.value[i]!=str.value[i])</div><div class="line">				return false;</div><div class="line">	      return true;&#125;</div><div class="line">&#125;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//返回两个字符串之间的差值，返回0表示相等</div><div class="line">public int compareTo(MyString o) &#123;</div><div class="line">	for(int i=0;i&lt;this.value.length&amp;&amp;i&lt;o.value.length;i++)</div><div class="line">		if(this.value[i]!=o.value[i])</div><div class="line">			 return this.value[i]-o.value[i]; //返回两串第一个不同字符的差值</div><div class="line">	return this.value.length-o.value.length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="变量字符串StringBuffer"><a href="#变量字符串StringBuffer" class="headerlink" title="变量字符串StringBuffer"></a>变量字符串StringBuffer</h4><p>该字符数组的容量总是大于串长，并且能够修改<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public class MyStringBuffer implements Serializable&#123;</div><div class="line">    </div><div class="line">	   private char[] value;     //字符数组</div><div class="line">	    private int len;         //串长度</div><div class="line">	     </div><div class="line">	    public MyStringBuffer(int size)&#123;    //构造指定容量的空串</div><div class="line">	    	this.value=new char[size&lt;16?16:size];</div><div class="line">	    	this.len=0;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public MyStringBuffer()&#123;      //以默认容量构造空串</div><div class="line">	    	this(16);</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public MyStringBuffer(String str)&#123;  //以字符串常量构造对象</div><div class="line">	    	this(str.length()+16);</div><div class="line">	    	 </div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public int length()&#123;</div><div class="line">	    	return this.len;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public synchronized char charAt(int i)&#123;</div><div class="line">	    	if(i&lt;0||i&gt;=this.len)</div><div class="line">	    		throw new StringIndexOutOfBoundsException(i);</div><div class="line">	    	return this.value[i];</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public void setCharAt(int i,char ch)&#123;</div><div class="line">	    	if(i&lt;0||i&gt;=this.len)</div><div class="line">	    		throw new StringIndexOutOfBoundsException(i);</div><div class="line">	    	this.value[i]=ch;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public synchronized MyStringBuffer insert(int i,MyStringBuffer str)&#123;</div><div class="line">	    	if(i&lt;0) i=0;</div><div class="line">	    	if(i&gt;this.len) i=this.len;</div><div class="line">	    	if(str==null) return this;</div><div class="line">	    	char temp[]=this.value;</div><div class="line">	    	if(this.value.length-this.len&lt;str.len) //当前容量不足，自动扩充</div><div class="line">	    	&#123;</div><div class="line">	    		this.value=new char[this.value.length+str.len*2];</div><div class="line">	    		for(int j=0;j&lt;i;j++)  //复制当前串前i-1个字符</div><div class="line">	    			this.value[j]=temp[j];</div><div class="line">	    	&#125;</div><div class="line">	    		for(int j=i;j&lt;this.len;j++)</div><div class="line">	    			this.value[str.len+j]=temp[j];//从i开始向后移动j个字符</div><div class="line">	    		for(int j=0;j&lt;str.len;j++)     //复制字符串str</div><div class="line">	    			this.value[i+j]=str.value[j];</div><div class="line">	    		this.len+=str.len;</div><div class="line">	    		return this;</div><div class="line">	    	&#125;</div><div class="line">	   </div><div class="line">	    public synchronized MyStringBuffer delete(int begin,int end)&#123;</div><div class="line">	    	if(begin&gt;0)</div><div class="line">	    		begin=0;</div><div class="line">	    	if(end&gt;this.len)</div><div class="line">	    		end=this.len;</div><div class="line">	    	if(begin&gt;end)</div><div class="line">	    		throw new StringIndexOutOfBoundsException(end-begin);</div><div class="line">	    	for(int i=0;i&lt;this.len-end;i++) //从end开始至串尾的子串向前移动</div><div class="line">	    		this.value[begin+1]=this.value[end+i];</div><div class="line">	    	this.len=end-begin;</div><div class="line">	    	return this;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public synchronized String toString()&#123;</div><div class="line">	    	return new String(this.value,0,this.len);</div><div class="line">	    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;串是由n(n&amp;gt;=0)个字符组成的有限序列，它是一种特殊的线性表。而子串是指串s中任意连续字符组成的一个子序列组成的串。同时，串的比较通
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性表之双链表</title>
    <link href="http://www.myzwl.win/2017/07/08/sjjg_3/"/>
    <id>http://www.myzwl.win/2017/07/08/sjjg_3/</id>
    <published>2017-07-08T05:48:51.000Z</published>
    <updated>2017-07-22T07:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>双链表的每个结点有两个地址域，分别指向它的前驱结点和后继结点<br><img src="/images/imgs4/4.jpg" alt="Alt text"></p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>双链表的结点声明如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class DLinkNode&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	public T data;  //数据元素</div><div class="line">	public DLinkNode&lt;T&gt; prev,next; //prev指向前驱结点，next指向后继结点</div><div class="line">	</div><div class="line">	public DLinkNode(T data, DLinkNode&lt;T&gt; prev, DLinkNode&lt;T&gt; next) &#123;</div><div class="line">		super();</div><div class="line">		this.data = data;</div><div class="line">		this.prev = prev;</div><div class="line">		this.next = next;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public DLinkNode()&#123;</div><div class="line">		this(null,null,null);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若带头结点的双链表为空双链表，则有head.next=null&amp;&amp;head.prev=null;</p>
<p>若p指向双链表中非两端的某个结点，则有p=p.next.prev=p.prev.next;</p>
<h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>如果双链表的最后一个结点的next链指向头结点，头结点的prev链指向最后一个结点，则称为循环双链表，<br>对于空双链表有head.next=head&amp;&amp;head.prev=head<br>下面是循环双链表CirDoublyLinkedList的实现类<br>只有插入和删除和单链表不一样<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class CirDoublyLinkedList&lt;T&gt; implements LList&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	public DLinkNode&lt;T&gt; head;</div><div class="line">	</div><div class="line">	public CirDoublyLinkedList()&#123;</div><div class="line">		this.head=new DLinkNode&lt;T&gt;();</div><div class="line">		this.head.prev=head;</div><div class="line">		this.head.next=head;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void insert(int i, T x) &#123;//将x对象插入在序号为i的结点</div><div class="line">	if(x==null)</div><div class="line">		return;</div><div class="line">	DLinkNode&lt;T&gt; p=this.head;</div><div class="line">	for(int j=0;p.next!=this.head&amp;&amp;j&lt;i;j++) //寻找插入位置</div><div class="line">		p=p.next;                           //循环停止时，p指向第i-1个结点</div><div class="line">	 DLinkNode&lt;T&gt; q=new DLinkNode&lt;T&gt;(x,p,p.next);//插入在p结点之后</div><div class="line">	 p.next.prev=q;</div><div class="line">	 p.next=q;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void append(T x) &#123;</div><div class="line">	 if(x==null)</div><div class="line">		 return;</div><div class="line">	 DLinkNode&lt;T&gt; q=new DLinkNode&lt;T&gt;(x,head.prev,head);</div><div class="line">	 head.prev.next=q; //插入在头结点之前，相当于尾插入</div><div class="line">	 head.prev=q;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T remove(int i) &#123;</div><div class="line">	if(i&gt;0)</div><div class="line">	&#123;</div><div class="line">		DLinkNode&lt;T&gt; p=this.head.next;</div><div class="line">		for(int j=0;p!=head&amp;&amp;j&lt;i;j++)  //定位到待删除结点</div><div class="line">			p=p.next;</div><div class="line">		if(p!=head)</div><div class="line">		&#123; </div><div class="line">			T old=p.data;     //获得原对象</div><div class="line">			p.prev.next=p.next;  //删除p结点自己</div><div class="line">			p.next.prev=p.prev;</div><div class="line">			return old;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">		this.head.prev=head;</div><div class="line">		this.head.next=head;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	。。。其余方法和单链表一样</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;双链表的每个结点有两个地址域，分别指向它的前驱结点和后继结点&lt;br&gt;&lt;img src=&quot;/images/imgs4/4.jpg&quot; alt=&quot;
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性表之单链表</title>
    <link href="http://www.myzwl.win/2017/07/07/sjjg_2/"/>
    <id>http://www.myzwl.win/2017/07/07/sjjg_2/</id>
    <published>2017-07-07T05:48:51.000Z</published>
    <updated>2017-07-22T07:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线性表的链式存储是用若干地址分散的存储单元存储数据元素，逻辑上相连的数据元素在物理位置上不一定相连，必须采用附加信息表示数据元素之间的关系，并且存储单元至少包含两部分-数据域和地址域<br><img src="/images/imgs4/2.jpg" alt="Alt text"></p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表中结点只有一个地址并且指向后继结点<br><img src="/images/imgs4/3.jpg" alt="Alt text"></p>
<p>单链表结点类Node声明如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Node&lt;T&gt; &#123;  //单链表结点类</div><div class="line"></div><div class="line">	public T data;            //数据域，保存数据元素</div><div class="line">	public Node&lt;T&gt; next;      //地址域，引用后继结点</div><div class="line">	</div><div class="line">	public Node(T data,Node&lt;T&gt; next)&#123;</div><div class="line">		this.data=data;</div><div class="line">		this.next=next;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Node()&#123;</div><div class="line">		this(null,null);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于java不支持指针类型，但提供引用方式保存包括地址在内的结构化信息<br>通常通过node结点建立两个结点之间的链接，如p结点的下一个结点是q结点</p>
<blockquote>
<p>Node<string> p=new Node<string>(‘A’,null);<br>  Node<string> q=new Node<string>(‘B’,null);<br>  p.next=q;</string></string></string></string></p>
</blockquote>
<p>  单链表的头指针head也是一个结点引用</p>
<blockquote>
<p>Node<t> head=null;</t></p>
</blockquote>
<p>  当head==null时，为空单链表</p>
<p><strong>单链表的遍历操作 </strong><br>  遍历单链表是指从第一个结点开始，沿着结点的next链，依次访问单链表中的每个结点，并且每个结点只访问一次</p>
<blockquote>
<p>Node<t> p=head;<br>while(p!=null){<br>    p=p.next;<br>}</t></p>
</blockquote>
<p><strong>单链表的插入操作 </strong><br>对单链表进行插入操作，只要该表节点间的链接关系，不需要移动数据元素<br><strong>空表插入/头插入 </strong></p>
<blockquote>
<p>if(head==null)<br> head=new Node<t>(x,null);  //空表插入<br> else{<br> Node<t> q=new Node<t>(x,null); //头插入<br> q.next=head;<br> }</t></t></t></p>
</blockquote>
<p><strong>中间插入 </strong><br>若p指向非空单链表的某个结点，在p结点之后插入q结点</p>
<p>&lt; Node<t> q=new Node<t>(x,null);<br>q.next=p.next;             //q的后继结点应是p的原后继结点<br>p.next=q;                  //q作为p的后继结点</t></t></p>
<p><strong>尾插入 </strong></p>
<p><strong>单链表的删除操作 </strong><br>删除单链表的指定结点，只需改变结点的next域</p>
<p><strong>头删除 </strong></p>
<blockquote>
<p>head=head.next;</p>
</blockquote>
<p><strong>中间/尾删除 </strong></p>
<blockquote>
<p>if(p.next!=null)<br> p.next=p.next.next;</p>
</blockquote>
<h4 id="单链表实现类"><a href="#单链表实现类" class="headerlink" title="单链表实现类"></a>单链表实现类</h4> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line">public class SinglyLinkenList&lt;T&gt; implements LList&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	public Node&lt;T&gt; head;  //头指针</div><div class="line">	</div><div class="line">	public SinglyLinkenList()&#123; //构造空链表</div><div class="line">		this.head=new Node&lt;T&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public SinglyLinkenList(T[] element)&#123;//尾插入构造单链表</div><div class="line">		this();</div><div class="line">		Node&lt;T&gt; rear=this.head; //指向单链表最后一个结点</div><div class="line">		for(int i=0;i&lt;element.length;i++)&#123;</div><div class="line">			rear.next=new Node&lt;T&gt;(element[i],null); //尾插入</div><div class="line">			rear=rear.next;     //指向新的链尾结点</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;</div><div class="line">		</div><div class="line">		return this.head.next==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int length() &#123;</div><div class="line">		</div><div class="line">		int i=0;</div><div class="line">		Node&lt;T&gt; p=this.head.next;  //p从单链表第一个结点开始</div><div class="line">		while(p!=null)&#123;            //若单链表未结束</div><div class="line">			i++;</div><div class="line">			p=p.next;             //p的后继结点</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		return i;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String toString()&#123;</div><div class="line">		String str="(";</div><div class="line">		Node&lt;T&gt; p=this.head.next;</div><div class="line">		while(p!=null)&#123;</div><div class="line">			str+=p.data.toString();</div><div class="line">			if(p.next!=null)</div><div class="line">				str+=",";  //不是最后一个结点时加分隔符</div><div class="line">			p=p.next;</div><div class="line">		&#125;</div><div class="line">		return str+")";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get(int i) &#123;  //返回第i个元素，若i指定序号无效，则返回null</div><div class="line">	  if(i&gt;=0)</div><div class="line">	  &#123;</div><div class="line">		  Node&lt;T&gt; p=this.head.next;</div><div class="line">		   for(int j=0;p!=null&amp;&amp;j&lt;i;j++)</div><div class="line">			   p=p.next;</div><div class="line">		    if(p!=null)</div><div class="line">		    	return p.data;</div><div class="line">	  &#125;</div><div class="line">		</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//设置第i个元素值为x，若i指定序号无效则抛出序号越界异常</div><div class="line">	public void set(int i, T x) &#123;</div><div class="line">		if(x==null)</div><div class="line">			return;            //不能设置空对象</div><div class="line">		if(i&gt;=0)</div><div class="line">		&#123;</div><div class="line">			Node&lt;T&gt; p=this.head.next;</div><div class="line">			 for(int j=0;p!=null&amp;&amp;j&lt;i;j++)</div><div class="line">				 p=p.next;</div><div class="line">			 if(p!=null)</div><div class="line">				 p.data=x;        //p指向第i个节点</div><div class="line">		&#125;</div><div class="line">		else throw new IndexOutOfBoundsException(i+"");</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void insert(int i, T x) &#123;//将x对象插入在序号为i的结点前</div><div class="line"></div><div class="line">		if(x==null)</div><div class="line">			return;</div><div class="line">		Node&lt;T&gt; p=this.head;  //p指向头结点</div><div class="line">		for(int j=0;p.next!=null&amp;&amp;j&lt;i;j++) //寻找插入位置</div><div class="line">			p=p.next;  //循环停止时，p指向第i-1结点或最后一个结点</div><div class="line">		p.next=new Node&lt;T&gt;(x,p.next);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//单链表最后添加对象</div><div class="line">	public void append(T x) &#123;</div><div class="line">		insert(Integer.MAX_VALUE,x);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	public T remove(int i) &#123;</div><div class="line">		if(i&gt;=0)</div><div class="line">		&#123;</div><div class="line">			Node&lt;T&gt; p=this.head;</div><div class="line">			 for(int j=0;p.next!=null&amp;&amp;j&lt;i;j++)//找到待删除的结点i的前驱结点i-1</div><div class="line">				 p=p.next;</div><div class="line">			 if(p.next!=null)</div><div class="line">			 &#123;</div><div class="line">				 T old=p.next.data;     //获取原对象</div><div class="line">				  p.next=p.next.next;    //删除p的后继结点</div><div class="line">				   return old;</div><div class="line">			 &#125;</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">	this.head.next=null;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int indexOf(T key) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public boolean contain(T key) &#123;</div><div class="line">		</div><div class="line">		return this.search(key)!=null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T search(T key) &#123;</div><div class="line">	 if(key==null)</div><div class="line">		 return null;</div><div class="line">	 Node&lt;T&gt; p=this.head.next;</div><div class="line">	 while(p!=null)</div><div class="line">	 &#123;</div><div class="line">		 if(p.data.equals(key))</div><div class="line">			 return p.data;</div><div class="line">		 p=p.next;</div><div class="line">	 &#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单链表求解约瑟夫环"><a href="#单链表求解约瑟夫环" class="headerlink" title="单链表求解约瑟夫环"></a>单链表求解约瑟夫环</h4><p>只需更改一处</p>
<blockquote>
<p>//LList<string> list=new seqList<string>(number);<br>  LList<string> list=new SinglyLinkenList<string>();</string></string></string></string></p>
</blockquote>
<p> 得到如下结果</p>
<blockquote>
<p>初始化约瑟夫环:(5,0,2)<br>删除B(A,C,D,E)<br>删除D(A,C,E)<br>删除A(C,E)<br>删除E(C)<br>最后的被赦免者是:C</p>
</blockquote>
<p>此外单链表相比较于顺序表在插入和删除时只要改变少量结点的链，不需要移动数据元素，也避免了顺序表因存在空间不足扩充空间和复制元素的过程，提高了运行效率和空间利用率</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;线性表的链式存储是用若干地址分散的存储单元存储数据元素，逻辑上相连的数据元素在物理位置上不一定相连，必须采用附加信息表示数据元素之间的关系，
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性表之顺序表</title>
    <link href="http://www.myzwl.win/2017/07/06/sjjg_1/"/>
    <id>http://www.myzwl.win/2017/07/06/sjjg_1/</id>
    <published>2017-07-06T05:48:51.000Z</published>
    <updated>2017-07-22T07:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据结构是指数据间存在的关系，通常包含三个方面。数据的逻辑结构（线性结构、树、图），数据的存储结构（顺序存储和链式存储），数据操作（对数据结构中的元素进行各种运算和处理），而通常所说的算法是建立在数据结构之上，读数据结构的操作需要用算法来描述。而算法的分析又主要包括时间代价和空间代价两方面</p>
<h4 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h4><p><img src="/images/imgs4/1.jpg" alt="Alt text"></p>
<p>数组是顺序存储的随机存取结构，占用一组连续的存储单元，通过下标识别元素，元素地址是下标的线性函数，一个下标能唯一确定一个元素<br> 不妨构造一个顺序表接口类来模仿顺序表<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface LList&lt;T&gt; &#123;</div><div class="line">	boolean isEmpty();       //判断线性表是否为空</div><div class="line">	int length();            //返回线性表长度</div><div class="line">	T get(int i);            //返回第i(i&gt;=0)个元素</div><div class="line">	void set(int i,T x);     //设置第i个元素值为x</div><div class="line">	void insert(int i,T x);  //插入x作为第i个元素</div><div class="line">	void append(T x);        //在线性表最后插入第i个元素</div><div class="line">	T remove(int i);         //删除第i个元素并返回被删除对象</div><div class="line">	void removeAll();        //删除线性表所有元素</div><div class="line">	int indexOf(T key);      //顺序查找关键字为key的元素，返回首次出现的位置</div><div class="line">	boolean contain(T key);  //是否包含关键字</div><div class="line">	T search(T key);         //顺序查找关键字为key的元素，返回首次出现的元素</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是其实现类<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">public class seqList&lt;T&gt; implements LList&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Object[] element; //存放线性表元素的一维数组</div><div class="line">	private int len;       //顺序表长度，记载元素个数</div><div class="line">	</div><div class="line">	public seqList(int size)&#123;            //创建容量为size的空表</div><div class="line">		//若size&lt;0，java将抛出负数组长度异常</div><div class="line">		this.element=new Object[size];</div><div class="line">		this.len=0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public seqList()&#123;     //创建默认容量的空表，这里是64</div><div class="line">		this(64);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;</div><div class="line">		</div><div class="line">		return this.len==0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int length() &#123;</div><div class="line">	</div><div class="line">		return this.len;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get(int i) &#123; //返回第i个元素（i&gt;=0),若i指定元素无效，则返回null</div><div class="line">	if(i&gt;=0&amp;&amp;i&lt;this.len)</div><div class="line">		return (T)this.element[i];</div><div class="line">    return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//设置第i(i&gt;=0)个元素的值为x，若i指定序号无效则抛出序号越界异常</div><div class="line">	public void set(int i, T x) &#123;</div><div class="line">		if(x==null)</div><div class="line">			return;</div><div class="line">		if(i&gt;=0&amp;&amp;i&lt;this.len)</div><div class="line">			this.element[i]=x;</div><div class="line">		else</div><div class="line">			throw new IndexOutOfBoundsException(i+"");</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">/**</div><div class="line"> * 在顺序表元素ai位置插入元素x，首选必须将i到n个元素后移，空出一个位置，然后插入元素x</div><div class="line"> */</div><div class="line">	public void insert(int i, T x) &#123;</div><div class="line">		if(x==null)</div><div class="line">			return ;           //不能添加null</div><div class="line">		if(this.len==element.length)	 //若数组满，则扩充顺序表容量</div><div class="line">		&#123; </div><div class="line">			Object[] temp=this.element;</div><div class="line">			this.element=new Object[temp.length*2]; //容量扩充2倍</div><div class="line">			for(int j=0;j&lt;temp.length;j++)&#123; </div><div class="line">				this.element[i]=temp[i];  //复制数组元素</div><div class="line">			&#125;</div><div class="line">			if(i&lt;0)                      //下标容错</div><div class="line">				i=0;</div><div class="line">			if(i&gt;this.len)</div><div class="line">				i=this.len;</div><div class="line">			for(int j=this.len-1;j&gt;=i;j--)       //元素后移，平均移动len/2</div><div class="line">				this.element[j+1]=this.element[j];</div><div class="line">			this.element[i]=x;</div><div class="line">			this.len++;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void append(T x) &#123;</div><div class="line">		insert(this.len,x);	   //在顺序表最后插入x对象</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 删除元素ai，必须将元素i+1到n向前移动</div><div class="line">	 */</div><div class="line">	public T remove(int i) &#123; //删除成功返回被删除对象，否则返回null</div><div class="line">		if(this.len==0||i&lt;0||i&gt;this.len)</div><div class="line">			return null;</div><div class="line">		T old=(T)this.element[i];</div><div class="line">		 for(int j=i;j&lt;this.len-1;j++)     //元素前移，平均移动len/2</div><div class="line">			 this.element[j]=this.element[j+1];</div><div class="line">		 this.element[this.len-1]=null;</div><div class="line">		 this.len--;</div><div class="line">		return old;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">		</div><div class="line">		this.len=0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//顺序查找关键字为key的元素，返回首次出现的位置，若查找不成功返回-1</div><div class="line">	public int indexOf(T key) &#123;</div><div class="line">		if(key!=null)</div><div class="line">			for(int i=0;i&lt;this.len;i++)</div><div class="line">				if(this.element[i].equals(key))</div><div class="line">					return i;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//判断线性表是否包含关键字为key元素</div><div class="line">	public boolean contain(T key) &#123;</div><div class="line">		</div><div class="line">		return this.indexOf(key)&gt;=0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//查找，返回首次出现的关键字为key的元素</div><div class="line">	public T search(T key) &#123;</div><div class="line">	 int find=this.indexOf(key);</div><div class="line">		return find==-1?null:(T)this.element[find];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h4><p> 问题描述：古代某法官要判决n个犯人的死刑，他有一条荒唐的法律：将犯人站成一个圆圈，从第s个人开始数起，每数到第d个犯人，就拉出来处决，在从下一个开始数d个，数到的人在处决。。。直到数到最后一个人就开始赦免</p>
<p><img src="/images/imgs4/7.gif" alt="Alt text"><br>上面是假设n=5，s=1，d=2，并且起始位置是从第一个人开始数起，因为该圆圈可以看成顺序表进行模拟<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Josephus &#123;</div><div class="line"></div><div class="line">	public Josephus(int number,int start,int distance)&#123;</div><div class="line">		seqList&lt;String&gt; list=new seqList&lt;String&gt;(number); //初始化顺序表</div><div class="line">		for(int i=0;i&lt;number;i++)                      </div><div class="line">		//依次添加犯人，这里记为A,B.C,D,E</div><div class="line">			list.append((char)('A'+i)+"");</div><div class="line">		System.out.println("初始化约瑟夫环:"+'('+number+','+start+','+distance+')');</div><div class="line">		int i=start;            //起始数起的人</div><div class="line">		while(list.length()&gt;1)&#123;        //多于一个犯人时数起</div><div class="line">			i=(i+distance-1)%list.length(); </div><div class="line">			System.out.print("删除"+list.remove(i).toString()+"");</div><div class="line">			System.out.println(list.toString());</div><div class="line">		&#125;</div><div class="line">		System.out.println("最后的被赦免者是:"+list.get(0).toString());	</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String args[])&#123;</div><div class="line">		new Josephus(5,0,2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果</p>
<blockquote>
<p>初始化约瑟夫环:(5,0,2)<br>删除B(A,C,D,E)<br>删除D(A,C,E)<br>删除A(C,E)<br>删除E(C)<br>最后的被赦免者是:C</p>
</blockquote>
<h4 id="顺序表的效率分析"><a href="#顺序表的效率分析" class="headerlink" title="顺序表的效率分析"></a>顺序表的效率分析</h4><p>由之前的源码易看出，存取任何一个元素，即set（）、get（）方法的时间复杂度为O（1），而插入或者删除很耗时，不妨假设在第i个位置插入元素，并且概率为p<em>{i},表长度为n；则平均移动次数为\sum</em>{i=0}^n{(n-i)}*{p_i};<br>如果插入元素的概率相同，即都是1/(n+1);最后求得时间复杂度为O(n);同理删除的时间复杂度也为O(n);<br>所以得出一个结论:顺序表的动态操作效率极低</p>
<h4 id="顺序表比较相等"><a href="#顺序表比较相等" class="headerlink" title="顺序表比较相等"></a>顺序表比较相等</h4><p>首先简单说一下深拷贝和浅拷贝，浅拷贝类似于只引用某个对象，和原对象指向相同的空间，而深拷贝是开辟了新空间并且复制原来对象的数据<br>而两个顺序表的相等是指，他们对应的元素相等并且长度也相同<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object obj)&#123;</div><div class="line">		if(this==obj)</div><div class="line">			return true;</div><div class="line">		if(obj instanceof seqList)&#123;</div><div class="line">			seqList&lt;T&gt; list=(seqList&lt;T&gt;)obj;</div><div class="line">			if(this.length()==list.length())&#123;</div><div class="line">				for(int i=0;i&lt;this.length();i++)</div><div class="line">					if(!(this.get(i).equals(list.get(i))))</div><div class="line">						return false;</div><div class="line">				return true;</div><div class="line">			&#125;</div><div class="line">				</div><div class="line">		&#125;</div><div class="line">			return true;</div><div class="line">	</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;数据结构是指数据间存在的关系，通常包含三个方面。数据的逻辑结构（线性结构、树、图），数据的存储结构（顺序存储和链式存储），数据操作（对数据结
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>shiro之会话管理</title>
    <link href="http://www.myzwl.win/2017/07/05/shiro_5/"/>
    <id>http://www.myzwl.win/2017/07/05/shiro_5/</id>
    <published>2017-07-05T05:48:51.000Z</published>
    <updated>2017-07-16T01:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shiro提供了完整的会话功能，不依赖于底层容器，即直接使用shiro的会话管理可以直接替换掉web容器的会话管理</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。</p>
<p><strong>获取会话</strong></p>
<blockquote>
<p>Subject subject = SecurityUtils.getSubject();<br>Session session = subject.getSession();  </p>
</blockquote>
<p><strong>获取当前会话的唯一标识</strong></p>
<blockquote>
<p>session.getId(); </p>
</blockquote>
<p><strong>获取当前Subject的主机地址</strong></p>
<blockquote>
<p>session.getHost();</p>
</blockquote>
<p><strong>获取/设置当前Session的过期时间</strong></p>
<blockquote>
<p>session.getTimeout();<br>session.setTimeout(毫秒); </p>
</blockquote>
<p><strong>获取会话的启动时间及最后访问时间</strong></p>
<blockquote>
<p>session.getStartTimestamp();<br>session.getLastAccessTime();</p>
</blockquote>
<p><strong>更新会话最后访问时间及销毁会话</strong></p>
<blockquote>
<p>session.touch();<br>session.stop();</p>
</blockquote>
<p>当Subject.logout()时会自动调用stop方法来销毁会话</p>
<p><strong>设置/获取/删除会话属性</strong></p>
<blockquote>
<p>session.setAttribute(“key”, “WORD”);<br>session.getAttribute(“key”);<br>session.removeAttribute(“key”); </p>
</blockquote>
<h4 id="会话管理器"><a href="#会话管理器" class="headerlink" title="会话管理器"></a>会话管理器</h4><p>会话管理器管理着应用中所有subject的会话的创建、维护、删除、失效、验证等工作。它是shiro的核心，顶层组件SecurityManager直接继承了SessionManager，且提供了SessionsSecurityManager实现直接把会话管理委托给相应的SessionManager，DefaultSecurityManager及DefaultWebSecurityManager默认SecurityManager都继承了SessionsSecurityManager。</p>
<p><strong>SecurityManager</strong></p>
<blockquote>
<p>Session start(SessionContext context); //启动会话<br>Session getSession(SessionKey key) throws SessionException; //根据会话Key获取会话 </p>
</blockquote>
<p><strong>WebSessionManager</strong></p>
<blockquote>
<p>boolean isServletContainerSessions();//是否使用Servlet容器的会话  </p>
</blockquote>
<p><strong>ValidatingSessionManager</strong></p>
<blockquote>
<p>void validateSessions();//验证所有会话是否过期 </p>
</blockquote>
<p><img src="/images/imgs4/5.gif" alt="Alt text"></p>
<p>Shiro提供了三个默认实现：</p>
<p>DefaultSessionManager：DefaultSecurityManager使用的默认实现，用于JavaSE环境；</p>
<p>ServletContainerSessionManager：DefaultWebSecurityManager使用的默认实现，用于Web环境，其直接使用Servlet容器的会话；</p>
<p>DefaultWebSessionManager：用于Web环境的实现，可以替代ServletContainerSessionManager，自己维护着会话，直接废弃了Servlet容器的会话管理。</p>
<p><strong>全局会话时间</strong><br>在web.xml中设置(单位：分钟)</p>
<blockquote>
<p><session-config><br>  <session-timeout>30</session-timeout><br></session-config> </p>
</blockquote>
<h4 id="会话监听器"><a href="#会话监听器" class="headerlink" title="会话监听器"></a>会话监听器</h4><p>会话监听器用于监听会话创建、过期及停止事件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MySessionListener1 implements SessionListener &#123;  </div><div class="line">     @Override  </div><div class="line">     public void onStart(Session session) &#123;//会话创建时触发  </div><div class="line">         System.out.println("会话创建：" + session.getId());  </div><div class="line">     &#125;  </div><div class="line">     @Override  </div><div class="line">     public void onExpiration(Session session) &#123;//会话过期时触发  </div><div class="line">         System.out.println("会话过期：" + session.getId());  </div><div class="line">     &#125;  </div><div class="line">     @Override  </div><div class="line">     public void onStop(Session session) &#123;//退出/会话过期时触发  </div><div class="line">         System.out.println("会话停止：" + session.getId());  </div><div class="line">     &#125;    </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>如果只想监听某一个事件，可以继承SessionListenerAdapter实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class MySessionListener2 extends SessionListenerAdapter &#123;  </div><div class="line">    @Override  </div><div class="line">    public void onStart(Session session) &#123;  </div><div class="line">        System.out.println("会话创建：" + session.getId());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="会话存储-持久化"><a href="#会话存储-持久化" class="headerlink" title="会话存储/持久化"></a>会话存储/持久化</h4><p>Shiro提供SessionDAO用于会话的CRUD</p>
<blockquote>
<pre><code>//如DefaultSessionManager在创建完session后会调用该方法；如保存到关系数据库/文件系统/NoSQL数据库；即可以实现会话的持久化；返回会话ID；主要此处返回的ID.equals(session.getId())；  
Serializable create(Session session);  
//根据会话ID获取会话  
Session readSession(Serializable sessionId) throws UnknownSessionException;  
//更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用  
void update(Session session) throws UnknownSessionException;  
//删除会话；当会话过期/会话停止（如用户退出时）会调用  
void delete(Session session);  
//获取当前所有活跃用户，如果用户量多此方法影响性能  
Collection&lt;Session&gt; getActiveSessions();   
</code></pre></blockquote>
<p><img src="/images/imgs4/6.gif" alt="Alt text"></p>
<p>AbstractSessionDAO提供了SessionDAO的基础实现，如生成会话ID等；CachingSessionDAO提供了对开发者透明的会话缓存的功能，只需要设置相应的CacheManager即可；MemorySessionDAO直接在内存中进行会话维护；而EnterpriseCacheSessionDAO提供了缓存功能的会话维护，默认情况下使用MapCache实现，内部使用ConcurrentHashMap保存缓存的会话。</p>
<pre><code>如果自定义实现SessionDAO，继承CachingSessionDAO即可
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class MySessionDAO extends CachingSessionDAO &#123;  </div><div class="line">    private JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate();  </div><div class="line">     protected Serializable doCreate(Session session) &#123;  </div><div class="line">        Serializable sessionId = generateSessionId(session);  </div><div class="line">        assignSessionId(session, sessionId);  </div><div class="line">        String sql = "insert into sessions(id, session) values(?,?)";  </div><div class="line">        jdbcTemplate.update(sql, sessionId, SerializableUtils.serialize(session));  </div><div class="line">        return session.getId();  </div><div class="line">    &#125;  </div><div class="line">protected void doUpdate(Session session) &#123;  </div><div class="line">    if(session instanceof ValidatingSession &amp;&amp; !((ValidatingSession)session).isValid()) &#123;  </div><div class="line">        return; //如果会话过期/停止 没必要再更新了  </div><div class="line">    &#125;  </div><div class="line">        String sql = "update sessions set session=? where id=?";  </div><div class="line">        jdbcTemplate.update(sql, SerializableUtils.serialize(session), session.getId());  </div><div class="line">    &#125;  </div><div class="line">    protected void doDelete(Session session) &#123;  </div><div class="line">        String sql = "delete from sessions where id=?";  </div><div class="line">        jdbcTemplate.update(sql, session.getId());  </div><div class="line">    &#125;  </div><div class="line">    protected Session doReadSession(Serializable sessionId) &#123;  </div><div class="line">        String sql = "select session from sessions where id=?";  </div><div class="line">        List&lt;String&gt; sessionStrList = jdbcTemplate.queryForList(sql, String.class, sessionId);  </div><div class="line">        if(sessionStrList.size() == 0) return null;  </div><div class="line">        return SerializableUtils.deserialize(sessionStrList.get(0));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h4><p>Shiro提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话，Shiro提供了会话验证调度器SessionValidationScheduler来验证</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//分页获取会话并验证  </div><div class="line">String sql = "select session from sessions limit ?,?";  </div><div class="line">int start = 0; //起始记录  </div><div class="line">int size = 20; //每页大小  </div><div class="line">List&lt;String&gt; sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);  </div><div class="line">while(sessionList.size() &gt; 0) &#123;  </div><div class="line">  for(String sessionStr : sessionList) &#123;  </div><div class="line">    try &#123;  </div><div class="line">      Session session = SerializableUtils.deserialize(sessionStr);  </div><div class="line">      Method validateMethod =   </div><div class="line">        ReflectionUtils.findMethod(AbstractValidatingSessionManager.class,   </div><div class="line">            "validate", Session.class, SessionKey.class);  </div><div class="line">      validateMethod.setAccessible(true);  </div><div class="line">      ReflectionUtils.invokeMethod(validateMethod,   </div><div class="line">        sessionManager, session, new DefaultSessionKey(session.getId()));  </div><div class="line">    &#125; catch (Exception e) &#123;  </div><div class="line">        //ignore  </div><div class="line">    &#125;  </div><div class="line">  &#125;  </div><div class="line"> start = start + size;  </div><div class="line">  sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>sessionFactory</strong><br>sessionFactory是创建会话的工厂，根据相应的Subject上下文信息来创建会话；默认提供了SimpleSessionFactory用来创建SimpleSession会话。<br>自定义一个session</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class OnlineSession extends SimpleSession &#123;  </div><div class="line">    public static enum OnlineStatus &#123;  </div><div class="line">        on_line("在线"), hidden("隐身"), force_logout("强制退出");  </div><div class="line">        private final String info;  </div><div class="line">        private OnlineStatus(String info) &#123;  </div><div class="line">            this.info = info;  </div><div class="line">        &#125;  </div><div class="line">        public String getInfo() &#123;  </div><div class="line">            return info;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    private String userAgent; //用户浏览器类型  </div><div class="line">    private OnlineStatus status = OnlineStatus.on_line; //在线状态  </div><div class="line">    private String systemHost; //用户登录时系统IP   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义SessionFactory<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class OnlineSessionFactory implements SessionFactory &#123;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public Session createSession(SessionContext initData) &#123;  </div><div class="line">        OnlineSession session = new OnlineSession();  </div><div class="line">        if (initData != null &amp;&amp; initData instanceof WebSessionContext) &#123;  </div><div class="line">            WebSessionContext sessionContext = (WebSessionContext) initData;  </div><div class="line">            HttpServletRequest request = (HttpServletRequest) sessionContext.getServletRequest();  </div><div class="line">            if (request != null) &#123;  </div><div class="line">                session.setHost(IpUtils.getIpAddr(request));  </div><div class="line">                session.setUserAgent(request.getHeader("User-Agent"));  </div><div class="line">                session.setSystemHost(request.getLocalAddr() + ":" + request.getLocalPort());  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return session;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;shiro提供了完整的会话功能，不依赖于底层容器，即直接使用shiro的会话管理可以直接替换掉web容器的会话管理&lt;/p&gt;
&lt;h4 id=&quot;
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro之jstl标签</title>
    <link href="http://www.myzwl.win/2017/07/04/shiro_4/"/>
    <id>http://www.myzwl.win/2017/07/04/shiro_4/</id>
    <published>2017-07-04T05:48:51.000Z</published>
    <updated>2017-07-15T12:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shiro提供了JSTL标签用于在页面进行权限控制</p>
<h4 id="导入标签库"><a href="#导入标签库" class="headerlink" title="导入标签库"></a>导入标签库</h4><blockquote>
<p>&lt;%@taglib prefix=”shiro” uri=”<a href="http://shiro.apache.org/tags" target="_blank" rel="external">http://shiro.apache.org/tags</a>“ %&gt; </p>
</blockquote>
<h4 id="各类标签"><a href="#各类标签" class="headerlink" title="各类标签"></a>各类标签</h4><p><strong>guest标签</strong></p>
<blockquote>
<p><shiro:guest><br>欢迎游客访问，<br></shiro:guest></p>
</blockquote>
<p>用户没有身份验证时显示相应信息，即游客访问信息</p>
<p><strong>user标签 </strong></p>
<blockquote>
<p>   <shiro:user><br>    欢迎[<shiro:principal>]登录<br>    </shiro:principal></shiro:user>   </p>
</blockquote>
<p>用户已经身份验证/记住我登录后显示相应的信息。</p>
<p><strong>authenticated标签 </strong></p>
<blockquote>
<p> shiro:authenticated&gt;<br>     </p>
</blockquote>
<p> 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。</p>
<p><strong>notAuthenticated标签</strong></p>
<blockquote>
<p>  <shiro:notauthenticated><br>     </shiro:notauthenticated></p>
</blockquote>
<p> 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证</p>
<p><strong>principal标签</strong></p>
<blockquote>
<shiro: principal="">

</shiro:></blockquote>
<p> 显示用户身份信息，默认调用Subject.getPrincipal()获取，即Primary Principal。</p>
<p><strong>hasRole标签</strong></p>
<blockquote>
<p> <shiro:hasrole name="admin"><br>    用户[<shiro:principal>]拥有角色admin<br><br>    </shiro:principal></shiro:hasrole></p>
</blockquote>
<p> 如果当前Subject有角色将显示body体内容</p>
<p><strong>hasAnyRoles标签</strong></p>
<blockquote>
<pre><code>&lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;    
   &lt;/shiro:hasAnyRoles&gt;   
</code></pre></blockquote>
<p> 如果当前Subject有任意一个角色（或的关系）将显示body体内容</p>
<p><strong>lacksRole标签</strong></p>
<blockquote>
<p>  <shiro:lacksrole name="abc"><br>     </shiro:lacksrole></p>
</blockquote>
<p> 如果当前Subject没有角色将显示body体内容</p>
<p><strong>hasPermission标签</strong></p>
<blockquote>
<p><shiro:haspermission name="user:create"><br>    </shiro:haspermission></p>
</blockquote>
<p> 如果当前Subject有权限将显示body体内容。</p>
<p><strong>lacksPermission标签</strong></p>
<blockquote>
<p> <shiro:lackspermission name="sss:create"><br>     </shiro:lackspermission> </p>
</blockquote>
<p> 如果当前Subject没有权限将显示body体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;shiro提供了JSTL标签用于在页面进行权限控制&lt;/p&gt;
&lt;h4 id=&quot;导入标签库&quot;&gt;&lt;a href=&quot;#导入标签库&quot; class=&quot;h
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro之拦截器机制</title>
    <link href="http://www.myzwl.win/2017/07/03/shiro_3/"/>
    <id>http://www.myzwl.win/2017/07/03/shiro_3/</id>
    <published>2017-07-03T05:48:51.000Z</published>
    <updated>2017-07-15T11:44:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Shiro使用了与Servlet一样的Filter接口进行扩展，还有拦截器是基于java的反射机制，如利用动态代理实现，而平时说的过滤器是基于回调函数的实现，在实现原理上有着本质的区别<br><img src="/images/imgs4/2.gif" alt="Alt text"></p>
<h4 id="拦截器介绍"><a href="#拦截器介绍" class="headerlink" title="拦截器介绍"></a>拦截器介绍</h4><p><strong>NameableFilter</strong><br>顾名思义，就是根据相应拦截器链组装拦截器的名字找到相应的拦截器实例</p>
<p><strong>OncePerRequestFilter</strong><br>该拦截器用于控制一次请求只能走一次拦截器链，默认是开启拦截的</p>
<p><strong>ShiroFilter</strong><br>是整个shiro的入口点，用于拦截需要安全控制的请求进行处理</p>
<p><strong>AdviceFilter</strong><br>该拦截器非常类似于struct中拦截器，同时支持AOP拦截</p>
<blockquote>
<p>boolean preHandle(ServletRequest request, ServletResponse response) throws Exception<br>void postHandle(ServletRequest request, ServletResponse response) throws Exception<br>void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception;  </p>
</blockquote>
<p>preHandler：类似于AOP中的前置增强；在拦截器链执行之前执行；如果返回true则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权）</p>
<p>postHandle：类似于AOP中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）；</p>
<p>afterCompletion：类似于AOP中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源（如解除Subject与线程的绑定之类的）；</p>
<p><strong>PathMatchingFilter</strong><br>提供了基于Ant风格的请求路径匹配功能及拦截器参数解析的功能，如“roles[admin,user]”自动根据“，”分割解析到一个路径参数配置并绑定到相应的路径：</p>
<blockquote>
<p>boolean pathsMatch(String path, ServletRequest request)<br>boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception </p>
</blockquote>
<p>pathsMatch：该方法用于path与请求路径进行匹配的方法；如果匹配返回true；</p>
<p>onPreHandle：在preHandle中，当pathsMatch匹配一个路径后，会调用opPreHandler方法并将路径绑定参数配置传给mappedValue；然后可以在这个方法中进行一些验证（如角色授权），如果验证失败可以返回false中断流程；默认返回true；也就是说子类可以只实现onPreHandle即可，无须实现preHandle。如果没有path与请求路径匹配，默认是通过的（即preHandle返回true）。</p>
<p><strong>AccessControlFilter</strong><br>提供了访问控制的基础功能</p>
<blockquote>
<pre><code>abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;  
boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;  
abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception;   
</code></pre></blockquote>
<pre><code>isAccessAllowed：表示是否允许访问；mappedValue就是[urls]配置中拦截器参数部分，如果允许访问返回true，否则false；
</code></pre><p>onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；如果返回false表示该拦截器实例已经处理了，将直接返回即可。</p>
<p>同时它还有一些扩展的功能</p>
<blockquote>
<p>void setLoginUrl(String loginUrl) //身份验证时使用，默认/login.jsp<br>String getLoginUrl()<br>Subject getSubject(ServletRequest request, ServletResponse response) //获取Subject实例<br>boolean isLoginRequest(ServletRequest request, ServletResponse response)//当前请求是否是登录请求<br>void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException //将当前请求保存起来并重定向到登录页面<br>void saveRequest(ServletRequest request) //将请求保存起来，如登录成功后再重定向回该请求<br>void redirectToLogin(ServletRequest request, ServletResponse response) //重定向到登录页面 </p>
</blockquote>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h4><p>在web容器中，先执行shiro的filter链，再执行servlet容器的filter链，同时shiro的ProxiedFilterChain对Servlet容器的FilterChain进行了代理</p>
<blockquote>
<p>FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain);</p>
</blockquote>
<h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><p>通过自定义拦截器可以扩展一些功能，如动态url-角色/权限访问控制，根据Subject身份信息获取用户信息绑定到Request（即设置通用数据）、验证码验证、在线用户信息的保存等等</p>
<p><strong>扩展OncePerRequestFilter</strong><br>OncePerRequestFilter保证一次请求只调用一次doFilterInternal<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MyOncePerRequestFilter extends OncePerRequestFilter&#123;</div><div class="line">	@Override</div><div class="line">	protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)</div><div class="line">			throws ServletException, IOException &#123;	</div><div class="line">		  System.out.println("once");</div><div class="line">		  chain.doFilter(request, response);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的ini配置文件中</p>
<blockquote>
<p>[filters]<br>myFilter1=com.shiro.web.MyOncePerRequestFilter<br>[urls]<br>/**=myFilter1</p>
</blockquote>
<p>其中[filters]声明拦截器，[urls]执行拦截器</p>
<p><strong>扩展AdviceFilter</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MyAdviceFilter extends AdviceFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">		System.out.println("pre");</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void postHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">	  System.out.println("postHandle");</div><div class="line">		super.postHandle(request, response);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception)</div><div class="line">			throws Exception &#123;</div><div class="line">		System.out.println("afterCompletion");</div><div class="line">		super.afterCompletion(request, response, exception);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>preHandle：进行请求的预处理，然后根据返回值决定是否继续处理（true：继续过滤器链）；可以通过它实现权限控制；</p>
<p>postHandle：执行完拦截器链之后正常返回后执行；</p>
<p>afterCompletion：不管最后有没有异常，afterCompletion都会执行，完成如清理资源功能。</p>
<p><strong>扩展PathMatchingFilter</strong><br>提供了url模式过滤的功能<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyPathMatchingFilter extends PathMatchingFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue)</div><div class="line">			throws Exception &#123;</div><div class="line">		</div><div class="line">		   System.out.println("url matches,config is " + Arrays.toString((String[])mappedValue));  </div><div class="line">	       return true;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>preHandle：会进行url模式与请求url进行匹配，如果匹配会调用onPreHandle；如果没有配置url模式/没有url模式匹配，默认直接返回true；</p>
<p>onPreHandle：如果url模式与请求url匹配，那么会执行onPreHandle，并把该拦截器配置的参数传入。默认什么不处理直接返回true。</p>
<p><strong>扩展AccessControlFilter</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MyAccessControlFilter extends AccessControlFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)</div><div class="line">			throws Exception &#123;</div><div class="line">		System.out.println("isAccessAllowed");  </div><div class="line">        return false;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">		 System.out.println("访问拒绝也不自己处理，继续拦截器链的执行");  </div><div class="line">	        return true;  </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>isAccessAllowed：即是否允许访问，返回true表示允许；</p>
<p>onAccessDenied：表示访问拒绝时是否自己处理，如果返回true表示自己不处理且继续拦截器链执行，返回false表示自己已经处理了（比如重定向到另一个页面）</p>
<p>其中如果isAccessAllowed返回true，onAccessDenied将不执行，反之执行</p>
<h4 id="默认拦截器"><a href="#默认拦截器" class="headerlink" title="默认拦截器"></a>默认拦截器</h4><p>Shiro内置了很多默认的拦截器，比如身份验证、授权等相关的<br><img src="/images/imgs4/3.gif" alt="Alt text"><br><img src="/images/imgs4/4.gif" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Shiro使用了与Servlet一样的Filter接口进行扩展，还有拦截器是基于java的反射机制，如利用动态代理实现，而平时说的过滤器是基
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro之编码加密</title>
    <link href="http://www.myzwl.win/2017/07/02/shiro_2/"/>
    <id>http://www.myzwl.win/2017/07/02/shiro_2/</id>
    <published>2017-07-02T05:48:51.000Z</published>
    <updated>2017-07-14T12:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在涉及数据在网络上的传输时，都要将明文数据加密传输，并且通常情况下的加密都是不可逆的</p>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>shiro内部提供了base64和16进制字符串编码/解码的API支持，如下<br><strong>base64编码/解码</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     String str="123456";	</div><div class="line">String base64Encoded=Base64.encodeToString(str.getBytes());//加密</div><div class="line"> System.out.println(base64Encoded);</div><div class="line">  String str2=Base64.decodeToString(base64Encoded); //解密</div><div class="line">   System.out.println(str2);</div><div class="line">    System.out.println(str.equals(str2));</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>MTIzNDU2<br>123456<br>true</p>
</blockquote>
<p><strong>16进制字符串编码/解码</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     String str="123456";	</div><div class="line">String base64Encoded = Hex.encodeToString(str.getBytes());//加密</div><div class="line"> System.out.println(base64Encoded);</div><div class="line"> String str2 = new String(Hex.decode(base64Encoded.getBytes())); //解密</div><div class="line">   System.out.println(str2);</div><div class="line">    System.out.println(str.equals(str2));</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>313233343536<br>123456<br>true</p>
</blockquote>
<p><strong>byte与string编码/解码</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     String str="123456";</div><div class="line">     byte[] str3=CodecSupport.toBytes(str, "utf-8");  //变成byte数组</div><div class="line">System.out.println(str3);</div><div class="line">String str4=CodecSupport.toString(str3, "utf-8"); //编程String</div><div class="line">System.out.println(str4);</div></pre></td></tr></table></figure></p>
<p>输出结果</p>
<blockquote>
<p>[B@cd51c3<br>123456</p>
</blockquote>
<h4 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h4><p>该算法是一种不可逆的算法，如MD5，SHA等，一般该算法最好需要提供一个salt（盐）来增加破解难度，一般情况下的盐被设置为 密码+用户名+盐，这样只有系统知道盐值，更难被破解</p>
<p><strong>MD5散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  String str = "hello";  </div><div class="line">String salt = "world";  </div><div class="line">String md5 = new Md5Hash(str, salt,2).toString();</div><div class="line">System.out.println(md5);</div></pre></td></tr></table></figure></p>
<p>这里的2是散列次数，即迭代多少次，这里是2次</p>
<blockquote>
<p>556b1a232d4d63a2f3ab87c9535abe25</p>
</blockquote>
<p><strong>其它散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    String str = "hello";  </div><div class="line">String salt = "world";  </div><div class="line">String sha1 = new Sha256Hash(str, salt).toString(); </div><div class="line">String SHA1=new Sha1Hash(str, salt).toString();</div><div class="line">String SHA512=new Sha512Hash(str, salt).toString();</div><div class="line">System.out.println(sha1);</div><div class="line">System.out.println(SHA1);</div><div class="line">System.out.println(SHA512);</div></pre></td></tr></table></figure></p>
<p>相应的输入结果：</p>
<blockquote>
<p>5715790a892990382d98858c4aa38d0617151575<br>3e64afa1cb7d643aa36f63b8d092ad76b1f04ff557abbb3d05f5b9037abf68a6606a8885d51bec8f6f39ee7d0badd504241c3704e777a51c21a9723e285fb9b8</p>
</blockquote>
<p><strong>通用散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String simpleHash = new SimpleHash("SHA-1", str, salt).toString();</div></pre></td></tr></table></figure></p>
<p>其中第一个参数指定采用哪种算法<br>输出结果：</p>
<blockquote>
<p>5715790a892990382d98858c4aa38d0617151575</p>
</blockquote>
<p><strong>默认匹配</strong><br>Shiro提供了HashService，默认提供了DefaultHashService实现。<br>先来看下它的构造函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public DefaultHashService() &#123;</div><div class="line">        this.algorithmName = "SHA-512";//默认算法SHA-512</div><div class="line">        this.iterations = 1; //生成Hash值的迭代次数，默认1</div><div class="line">        this.generatePublicSalt = false; //是否生成公盐，默认false</div><div class="line">        this.rng = new SecureRandomNumberGenerator();//用于生成公盐</div><div class="line">    &#125;</div><div class="line">    String hex = randomNumberGenerator.nextBytes().toHex();//随机生成一个盐</div></pre></td></tr></table></figure></p>
<h4 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h4><p>Shiro还提供对称式加密/解密算法的支持，如AES、Blowfish等<br><strong>AES算法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">AesCipherService aesCipherService = new AesCipherService();</div><div class="line">      aesCipherService.setKeySize(128);//设置key长度</div><div class="line">      //生成key</div><div class="line">      Key key = aesCipherService.generateNewKey();</div><div class="line">      String text = "zwl";</div><div class="line">      //加密</div><div class="line">      String encrptText = aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();</div><div class="line">      //解密</div><div class="line">      String text2 = new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());</div><div class="line">        System.out.println(key.toString());</div><div class="line">      System.out.println(encrptText);</div><div class="line">    System.out.println(text2);</div></pre></td></tr></table></figure></p>
<p>而上面的key就相当于一把钥匙，只有了这把钥匙，就能解密<br>输出结果：</p>
<blockquote>
<p>javax.crypto.spec.SecretKeySpec@176a4<br>a316645482dff96d9c86c64adabc51dee5170232365a3c15dab941dc6b73c2ec<br>zwl</p>
</blockquote>
<p><strong>Blowfish算法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BlowfishCipherService blowfishCipherService = new BlowfishCipherService();</div><div class="line">        blowfishCipherService.setKeySize(128);</div><div class="line">        //生成key</div><div class="line">        Key key = blowfishCipherService.generateNewKey();</div><div class="line">        String text = "zwl";</div><div class="line">        //加密</div><div class="line">        String encrptText = blowfishCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();</div><div class="line">        //解密</div><div class="line">        String text2 = new String(blowfishCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes()); </div><div class="line">        System.out.println(key.toString());</div><div class="line">       System.out.println(encrptText);</div><div class="line">      System.out.println(text2);</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>javax.crypto.spec.SecretKeySpec@d97afa5c<br>8e7f6626884b7b429a1000286f4990a4<br>zwl</p>
</blockquote>
<h4 id="PasswordService-CredentialsMatcher"><a href="#PasswordService-CredentialsMatcher" class="headerlink" title="PasswordService/CredentialsMatcher"></a>PasswordService/CredentialsMatcher</h4><p>在用户输入明文密码时，shiro默认的实现方式如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public interface PasswordService &#123;  </div><div class="line">    //输入明文密码得到密文密码  </div><div class="line">    String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">    public interface CredentialsMatcher &#123;  </div><div class="line">    //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）  </div><div class="line">    boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Shiro默认提供了PasswordService实现DefaultPasswordService；CredentialsMatcher实现PasswordMatcher及HashedCredentialsMatcher</p>
<p>关于shiro的编码\加密是在是丰富多多彩，一般是学习中遇到采取查询相关的</p>
<h4 id="一个对称加密的算法"><a href="#一个对称加密的算法" class="headerlink" title="一个对称加密的算法"></a>一个对称加密的算法</h4><p>下面是在一个项目中使用到的工具类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div></pre></td><td class="code"><pre><div class="line">public class DesUtils &#123;</div><div class="line">	/** 字符串默认键值     */</div><div class="line">	  private static String strDefaultKey = "national";</div><div class="line"></div><div class="line">	  /** 加密工具     */</div><div class="line">	  private Cipher encryptCipher = null;</div><div class="line"></div><div class="line">	  /** 解密工具     */</div><div class="line">	  private Cipher decryptCipher = null;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 将byte数组转换为表示16进制值的字符串， 如：byte[]&#123;8,18&#125;转换为：0813， 和public static byte[]  </div><div class="line">	   * hexStr2ByteArr(String strIn) 互为可逆的转换过程  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需要转换的byte数组  </div><div class="line">	   * @return 转换后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   *             本方法不处理任何异常，所有异常全部抛出  </div><div class="line">	   */</div><div class="line">	  public static String byteArr2HexStr(byte[] arrB) throws Exception &#123;</div><div class="line">	    int iLen = arrB.length;</div><div class="line">	    // 每个byte用两个字符才能表示，所以字符串的长度是数组长度的两倍   </div><div class="line">	    StringBuffer sb = new StringBuffer(iLen * 2);</div><div class="line">	    for (int i = 0; i &lt; iLen; i++) &#123;</div><div class="line">	      int intTmp = arrB[i];</div><div class="line">	      // 把负数转换为正数   </div><div class="line">	      while (intTmp &lt; 0) &#123;</div><div class="line">	        intTmp = intTmp + 256;</div><div class="line">	      &#125;</div><div class="line">	      // 小于0F的数需要在前面补0   </div><div class="line">	      if (intTmp &lt; 16) &#123;</div><div class="line">	        sb.append("0");</div><div class="line">	      &#125;</div><div class="line">	      sb.append(Integer.toString(intTmp, 16));</div><div class="line">	    &#125;</div><div class="line">	    return sb.toString();</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 将表示16进制值的字符串转换为byte数组， 和public static String byteArr2HexStr(byte[] arrB)  </div><div class="line">	   * 互为可逆的转换过程  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需要转换的字符串  </div><div class="line">	   * @return 转换后的byte数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   *             本方法不处理任何异常，所有异常全部抛出  </div><div class="line">	   *  </div><div class="line">	   */</div><div class="line">	  public static byte[] hexStr2ByteArr(String strIn) throws Exception &#123;</div><div class="line">	    byte[] arrB = strIn.getBytes();</div><div class="line">	    int iLen = arrB.length;</div><div class="line"></div><div class="line">	    // 两个字符表示一个字节，所以字节数组长度是字符串长度除以2   </div><div class="line">	    byte[] arrOut = new byte[iLen / 2];</div><div class="line">	    for (int i = 0; i &lt; iLen; i = i + 2) &#123;</div><div class="line">	      String strTmp = new String(arrB, i, 2);</div><div class="line">	      arrOut[i / 2] = (byte) Integer.parseInt(strTmp, 16);</div><div class="line">	    &#125;</div><div class="line">	    return arrOut;</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 默认构造方法，使用默认密钥  </div><div class="line">	   *   </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public DesUtils() throws Exception &#123;</div><div class="line">	    this(strDefaultKey);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 指定密钥构造方法  </div><div class="line">	   *   </div><div class="line">	   * @param strKey  </div><div class="line">	   *            指定的密钥  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public DesUtils(String strKey) throws Exception &#123;</div><div class="line">	    //Security.addProvider(new com.sun.crypto.provider.SunJCE());</div><div class="line">	    Key key = getKey(strKey.getBytes());</div><div class="line"></div><div class="line">	    encryptCipher = Cipher.getInstance("DES");</div><div class="line">	    encryptCipher.init(Cipher.ENCRYPT_MODE, key);</div><div class="line"></div><div class="line">	    decryptCipher = Cipher.getInstance("DES");</div><div class="line">	    decryptCipher.init(Cipher.DECRYPT_MODE, key);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 加密字节数组  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需加密的字节数组  </div><div class="line">	   * @return 加密后的字节数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public byte[] encrypt(byte[] arrB) throws Exception &#123;</div><div class="line">	    return encryptCipher.doFinal(arrB);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 加密字符串  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需加密的字符串  </div><div class="line">	   * @return 加密后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public String encrypt(String strIn) throws Exception &#123;</div><div class="line">	    return byteArr2HexStr(encrypt(strIn.getBytes()));</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 解密字节数组  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需解密的字节数组  </div><div class="line">	   * @return 解密后的字节数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public byte[] decrypt(byte[] arrB) throws Exception &#123;</div><div class="line">	    return decryptCipher.doFinal(arrB);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 解密字符串  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需解密的字符串  </div><div class="line">	   * @return 解密后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public String decrypt(String strIn) throws Exception &#123;</div><div class="line">	    return new String(decrypt(hexStr2ByteArr(strIn)));</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 从指定字符串生成密钥，密钥所需的字节数组长度为8位 不足8位时后面补0，超出8位只取前8位  </div><div class="line">	   *   </div><div class="line">	   * @param arrBTmp  </div><div class="line">	   *            构成该字符串的字节数组  </div><div class="line">	   * @return 生成的密钥  </div><div class="line">	   * @throws java.lang.Exception  </div><div class="line">	   */</div><div class="line">	  private Key getKey(byte[] arrBTmp) throws Exception &#123;</div><div class="line">	    // 创建一个空的8位字节数组（默认值为0）   </div><div class="line">	    byte[] arrB = new byte[8];</div><div class="line"></div><div class="line">	    // 将原始字节数组转换为8位   </div><div class="line">	    for (int i = 0; i &lt; arrBTmp.length &amp;&amp; i &lt; arrB.length; i++) &#123;</div><div class="line">	      arrB[i] = arrBTmp[i];</div><div class="line">	    &#125;</div><div class="line"></div><div class="line">	    // 生成密钥   </div><div class="line">	    Key key = new javax.crypto.spec.SecretKeySpec(arrB, "DES");</div><div class="line"></div><div class="line">	    return key;</div><div class="line">	  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在涉及数据在网络上的传输时，都要将明文数据加密传输，并且通常情况下的加密都是不可逆的&lt;/p&gt;
&lt;h2 id=&quot;编码与解码&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
</feed>
