<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2017-09-02T16:13:16.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://www.myzwl.win/2017/08/27/offer_23/"/>
    <id>http://www.myzwl.win/2017/08/27/offer_23/</id>
    <published>2017-08-27T02:14:26.330Z</published>
    <updated>2017-09-02T16:13:16.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 输出字符串的全排列<br>date: 2017-05-03 19:48:51<br>tags: 剑指offer</p>
<h2 id="categories-剑指offer"><a href="#categories-剑指offer" class="headerlink" title="categories: 剑指offer"></a>categories: 剑指offer</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如：输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab,cba</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>回想字符串的模式匹配思想，我们可以将该字符串分成两部分，一部分是第一个字符串，第二部分是剩余的字符，然后保持第一个字符不变，从剩余字符遍历，同时交换遍历的位置，很显然这是一个递归的过程，最后在回溯，交换第一个字符和剩余字符的位置，依次类推</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class StringSort &#123;</div><div class="line">	</div><div class="line">	public ArrayList&lt;String&gt; permitution(String str)&#123;</div><div class="line">		ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;();</div><div class="line">		 if(str==null||str.length()&lt;0)</div><div class="line">			 return list;</div><div class="line">		 list=permitution(list,str.toCharArray(),0,str.length());</div><div class="line">		  Collections.sort(list);</div><div class="line">		  return list;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private ArrayList&lt;String&gt; permitution(ArrayList&lt;String&gt; list,char[] str,int begin,int length)</div><div class="line">	&#123;</div><div class="line">		if(begin==length-1)</div><div class="line">		&#123;</div><div class="line">			if(!list.contains(str))</div><div class="line">				list.add(String.valueOf(str));</div><div class="line">		&#125;</div><div class="line">		else&#123;</div><div class="line">			for(int i=begin;i&lt;length;i++)&#123;</div><div class="line">				if(i==begin||str[i]!=str[begin])&#123;</div><div class="line">					swap(str,begin,i);</div><div class="line">					permitution(list,str,begin+1,length);</div><div class="line">					swap(str,begin,i);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return list;</div><div class="line">	&#125;</div><div class="line">	public void swap(char[] str,int begin,int i)&#123;</div><div class="line">		char temp=str[i];</div><div class="line">		str[i]=str[begin];</div><div class="line">		str[begin]=temp;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ArrayList&lt;String&gt; list=new StringSort().permitution("abcc");</div><div class="line">         for(String s:list)&#123;</div><div class="line">        	 System.out.print(s+" ");</div><div class="line">         &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 输出字符串的全排列&lt;br&gt;date: 2017-05-03 19:48:51&lt;br&gt;tags: 剑指offer&lt;/p&gt;
&lt;h2 id=&quot;categories-剑指offer&quot;&gt;&lt;a href=&quot;#categories-剑指offer&quot; class=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.myzwl.win/2017/08/26/offer_22/"/>
    <id>http://www.myzwl.win/2017/08/26/offer_22/</id>
    <published>2017-08-26T03:06:14.890Z</published>
    <updated>2017-09-02T16:12:28.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 序列化二叉树<br>date: 2017-05-02 16:48:51<br>tags: 剑指offer</p>
<h2 id="categories-剑指offer"><a href="#categories-剑指offer" class="headerlink" title="categories: 剑指offer"></a>categories: 剑指offer</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树。其中序列化的意思返回一个带有逗号和特殊符号的字符串，而反序列化就是根据带有特殊符号和逗号的字符串返回一个二叉树</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>对应序列化二叉树来说，因为每次都是将根结点序列化，所以可用前序遍历，即如果结点有孩子，先保存结点值，在继续，当遇到孩子为空时，就用特殊符号输出代替<br>反序列化，同样用递归实现，即先利用一个索引，用于取出每次遍历的字符串中的值，同时把字符串变成一个字符数组，然后比较是否是特殊符号，如果是特殊符号，不做处理，反之，变成根结点的孩子</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">static class TreeNode&#123;</div><div class="line">		int data;</div><div class="line">		TreeNode left;</div><div class="line">		TreeNode right;</div><div class="line">		</div><div class="line">		public TreeNode(int data)&#123;</div><div class="line">			this.data=data;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String serialize(TreeNode root)&#123;</div><div class="line">	StringBuilder sb=new StringBuilder();</div><div class="line">		if(root==null)</div><div class="line">		&#123;</div><div class="line">		  sb.append("$"+",");</div><div class="line">			 return sb.toString();</div><div class="line">		&#125;</div><div class="line">		       sb.append(root.data+",");</div><div class="line">		        sb.append(serialize(root.left));</div><div class="line">		         sb.append(serialize(root.right));</div><div class="line">		        return sb.toString();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	int n=-1;</div><div class="line">	public TreeNode deSerialize(String str)&#123;</div><div class="line">		 n++;</div><div class="line">		if(n&gt;=str.length())</div><div class="line">			return null;</div><div class="line">		  TreeNode node=null;</div><div class="line">		 String[] s=str.split(",");</div><div class="line">		if(!s[n].equals("$"))&#123;</div><div class="line">			node=new TreeNode(Integer.parseInt(s[n]));</div><div class="line">			  node.left=deSerialize(str);</div><div class="line">			  node.right=deSerialize(str);</div><div class="line">		&#125;</div><div class="line">		 return node;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	void preTraver(TreeNode root)&#123;</div><div class="line">		if(root!=null)&#123;</div><div class="line">		System.out.print(root.data+" ");</div><div class="line">		 preTraver(root.left);</div><div class="line">		  preTraver(root.right);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<blockquote>
<p>TreeNode root=new TreeNode(10);<br>        TreeNode a=new TreeNode(6);<br>        TreeNode b=new TreeNode(14);<br>        TreeNode c=new TreeNode(4);<br>        TreeNode d=new TreeNode(8);<br>        TreeNode e=new TreeNode(12);<br>        TreeNode f=new TreeNode(16);<br>         root.left=a;<br>         root.right=b;<br>         a.left=c;<br>         a.right=d;<br>         b.left=e;<br>         b.right=f;<br>         String s=new ConvertTreeToDLinkList().serialize(root);<br>          System.out.println(s);<br>           TreeNode head=new ConvertTreeToDLinkList().deSerialize(s);<br>            System.out.println();<br>            new ConvertTreeToDLinkList().preTraver(head);</p>
</blockquote>
<p>测试结果</p>
<blockquote>
<p>10,6,4,$,$,8,$,$,14,12,$,$,16,$,$,<br>10 6 4 8 14 12 16 </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 序列化二叉树&lt;br&gt;date: 2017-05-02 16:48:51&lt;br&gt;tags: 剑指offer&lt;/p&gt;
&lt;h2 id=&quot;categories-剑指offer&quot;&gt;&lt;a href=&quot;#categories-剑指offer&quot; class=&quot;hea
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.myzwl.win/2017/08/25/offer_21/"/>
    <id>http://www.myzwl.win/2017/08/25/offer_21/</id>
    <published>2017-08-25T01:58:02.010Z</published>
    <updated>2017-09-02T16:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 二叉搜索树与双向链表<br>date: 2017-05-01 16:48:51<br>tags: 剑指offer</p>
<h2 id="categories-剑指offer"><a href="#categories-剑指offer" class="headerlink" title="categories: 剑指offer"></a>categories: 剑指offer</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一颗二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>由于是二叉排序树，其左子树结点值小于根结点，右子树大于根节点，可以利用中序遍历，即先左孩子递归，找到树中最小的节点，然后作为头结点，然后遍历到该左子树最后一个结点，在其后继追加根结点，同样，遍历右子树，得到右子树中的第一个结点，然后将根结点追加到其前继结点即可</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class ConvertTreeToDLinkList &#123;</div><div class="line"></div><div class="line">	static class TreeNode&#123;</div><div class="line">		int data;</div><div class="line">		TreeNode left;</div><div class="line">		TreeNode right;</div><div class="line">		</div><div class="line">		public TreeNode(int data)&#123;</div><div class="line">			this.data=data;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public TreeNode Convert(TreeNode root)&#123;</div><div class="line">		if(root==null) return null;</div><div class="line">		if(root.left==null&amp;&amp;root.right==null)</div><div class="line">			return root;</div><div class="line">		TreeNode LastOfLeftTreeNode=Convert(root.left);</div><div class="line">		  TreeNode  p=LastOfLeftTreeNode;</div><div class="line">		 //定位到左子树的最后一个结点</div><div class="line">		    while(p!=null&amp;&amp;p.right!=null)&#123;</div><div class="line">		    	p=p.right;</div><div class="line">		    &#125;</div><div class="line">		    //将根结点追加到左子树最后一个结点</div><div class="line">		    if(LastOfLeftTreeNode!=null)&#123;</div><div class="line">		    	p.right=root;</div><div class="line">		    	root.left=p;</div><div class="line">		    &#125;</div><div class="line">		    TreeNode LastOfRightTreeNode=Convert(root.right);</div><div class="line">		      if(LastOfRightTreeNode!=null)&#123;</div><div class="line">		    	  LastOfRightTreeNode.left=root;</div><div class="line">		    	   root.right=LastOfRightTreeNode;</div><div class="line">		      &#125;</div><div class="line">		      </div><div class="line">		      if(LastOfLeftTreeNode!=null)</div><div class="line">		    	  return LastOfLeftTreeNode;</div><div class="line">		return root;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		TreeNode root=new TreeNode(10);</div><div class="line">		TreeNode a=new TreeNode(6);</div><div class="line">		TreeNode b=new TreeNode(14);</div><div class="line">		TreeNode c=new TreeNode(4);</div><div class="line">		TreeNode d=new TreeNode(8);</div><div class="line">		TreeNode e=new TreeNode(12);</div><div class="line">		TreeNode f=new TreeNode(16);</div><div class="line">		</div><div class="line">		 root.left=a;</div><div class="line">		 root.right=b;</div><div class="line">		 a.left=c;</div><div class="line">		 a.right=d;</div><div class="line">		 b.left=e;</div><div class="line">		 b.right=f;</div><div class="line">		 </div><div class="line">		 TreeNode node=new ConvertTreeToDLinkList().Convert(root);</div><div class="line">		 while(node!=null)&#123;</div><div class="line">			 System.out.println(node.data);</div><div class="line">			  node=node.right;</div><div class="line">		 &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 二叉搜索树与双向链表&lt;br&gt;date: 2017-05-01 16:48:51&lt;br&gt;tags: 剑指offer&lt;/p&gt;
&lt;h2 id=&quot;categories-剑指offer&quot;&gt;&lt;a href=&quot;#categories-剑指offer&quot; class=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.myzwl.win/2017/08/24/offer_20/"/>
    <id>http://www.myzwl.win/2017/08/24/offer_20/</id>
    <published>2017-08-24T01:59:24.620Z</published>
    <updated>2017-09-02T16:11:10.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 复杂链表的复制<br>date: 2017-04-30 15:48:51<br>tags: 剑指offer</p>
<h2 id="categories-剑指offer"><a href="#categories-剑指offer" class="headerlink" title="categories: 剑指offer"></a>categories: 剑指offer</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个复杂链表（每个节点中有结点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点）</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>很自然的第一个想法就是采取分治法，首先复制原来链表的结点，把每个复制的结点都链在原结点后面，接下来，设置复制节点的特殊指针，并且如果原来节点指向特殊指针N，则原结点复制后的结点指向N的复制指针，最后，需要抽取出复制的结点，由于原结点与复制节点都是间隔的，所以可间接处理</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">public class CopyCompLicateLinkedList &#123;</div><div class="line"></div><div class="line">	static class RandomListNode&#123;</div><div class="line">		int label;</div><div class="line">		 RandomListNode next=null;</div><div class="line">		  RandomListNode random=null;</div><div class="line">		   </div><div class="line">		  RandomListNode(int label)&#123;</div><div class="line">			  this.label=label;</div><div class="line">		  &#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//复制链表结点</div><div class="line">	private void CloneNodes(RandomListNode pHead)&#123;</div><div class="line">		RandomListNode node=pHead;</div><div class="line">		 while(pHead!=null)</div><div class="line">		 &#123;</div><div class="line">			 RandomListNode cloneNode=new RandomListNode(node.label);</div><div class="line">			   cloneNode.next=node.next;</div><div class="line">			    cloneNode.random=null;</div><div class="line">			     cloneNode.random=null;</div><div class="line">			       node.next=cloneNode;</div><div class="line">			         node=cloneNode.next;</div><div class="line">		 &#125;</div><div class="line">	&#125;</div><div class="line">		//设置每个节点的随机指针</div><div class="line">		private void ConnectSibLingNodes(RandomListNode pHead)&#123;</div><div class="line">			 RandomListNode node=pHead;</div><div class="line">			  while(node!=null)</div><div class="line">			  &#123;</div><div class="line">				  RandomListNode clone=node.next;</div><div class="line">				   if(node.random!=null)</div><div class="line">				   &#123;</div><div class="line">					   clone.random=node.random.next;</div><div class="line">				   &#125;</div><div class="line">				   node=clone.next;</div><div class="line">			  &#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	 //组合复制的结点</div><div class="line">	private RandomListNode ConnectFinalListNodes(RandomListNode pHead)&#123;</div><div class="line">		RandomListNode node=null;</div><div class="line">		RandomListNode cloneHead=null;</div><div class="line">		RandomListNode cloneNode=null;</div><div class="line">		</div><div class="line">		if(node!=null)&#123;</div><div class="line">			cloneHead=node.next;</div><div class="line">			 cloneNode=node.next;</div><div class="line">			  node.next=cloneNode.next;</div><div class="line">			 node=node.next;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		while(node!=null)&#123;</div><div class="line">			cloneNode.next=node.next;</div><div class="line">			 cloneNode=cloneNode.next;</div><div class="line">			  node.next=cloneNode.next;</div><div class="line">			  node=node.next;</div><div class="line">		&#125;</div><div class="line">		return cloneHead;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public RandomListNode Clone(RandomListNode pHead)&#123;</div><div class="line">		this.CloneNodes(pHead);</div><div class="line">		 this.ConnectSibLingNodes(pHead);</div><div class="line">		  return this.ConnectFinalListNodes(pHead);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 复杂链表的复制&lt;br&gt;date: 2017-04-30 15:48:51&lt;br&gt;tags: 剑指offer&lt;/p&gt;
&lt;h2 id=&quot;categories-剑指offer&quot;&gt;&lt;a href=&quot;#categories-剑指offer&quot; class=&quot;he
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.myzwl.win/2017/08/23/offer_19/"/>
    <id>http://www.myzwl.win/2017/08/23/offer_19/</id>
    <published>2017-08-23T01:09:54.180Z</published>
    <updated>2017-09-02T16:09:12.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 二叉树中和为某一值的所有路径<br>date: 2017-04-29 17:48:51<br>tags: 剑指offer</p>
<h2 id="categories-剑指offer"><a href="#categories-剑指offer" class="headerlink" title="categories: 剑指offer"></a>categories: 剑指offer</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为整数的所有路径。路径定义为从树的根结点开始往下一直到叶子结点所经过的结点形成一条路径</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>从问题描述知道，前序遍历符合从根结点遍历，所有可用此方法遍历，同时可以设置两个集合，一个用来保存每次遍历的结点，一个用来记录每次访问过的结点路径，如果等于和的话，就将结点路径加入，如果不等于，则看是否有左右孩子，在递归遍历，最后如果，返回上层，每一次都要删掉保存的结点</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode root,int target)&#123;</div><div class="line">		  int currentSum=0;</div><div class="line">		  ArrayList&lt;Integer&gt; nodes=new ArrayList&lt;Integer&gt;();</div><div class="line">		   ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathNodes=new ArrayList&lt;&gt;();</div><div class="line">		    if(root==null)</div><div class="line">		    	return pathNodes;</div><div class="line">		      return findPath(pathNodes,nodes,root,target,currentSum);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathNodes, ArrayList&lt;Integer&gt; nodes,</div><div class="line">			TreeNode root, int target, int currentSum) &#123;</div><div class="line">	         currentSum+=root.data;</div><div class="line">	          nodes.add(currentSum);</div><div class="line">	         </div><div class="line">	        boolean isLeafNode=(root.left==null)&amp;&amp;(root.right==null);</div><div class="line">	          if(target==currentSum&amp;&amp;isLeafNode)&#123;</div><div class="line">	        	 ArrayList&lt;Integer&gt; path=new ArrayList&lt;Integer&gt;();</div><div class="line">	        	  for(Integer val:nodes)</div><div class="line">	        	  &#123;</div><div class="line">	        		  path.add(val);</div><div class="line">	        	  &#125;</div><div class="line">	        	  pathNodes.add(path);</div><div class="line">	         &#125;</div><div class="line">	         if(root.left!=null)&#123;</div><div class="line">	        	 this.findPath(pathNodes, nodes, root.left, target, currentSum);</div><div class="line">	         &#125;</div><div class="line">	         if(root.right!=null)&#123;</div><div class="line">	        	 this.findPath(pathNodes, nodes, root.right, target, currentSum);</div><div class="line">	         &#125;</div><div class="line">	         Integer value=nodes.remove(pathNodes.size()-1);</div><div class="line">	          currentSum-=value;</div><div class="line">	           return pathNodes;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"> class TreeNode&#123;</div><div class="line">	int data;</div><div class="line">	TreeNode left;</div><div class="line">	TreeNode right;</div><div class="line">	</div><div class="line">	TreeNode(int data)&#123;</div><div class="line">		this.data=data;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<blockquote>
<p>TreeNode a=new TreeNode(10);<br>       TreeNode b=new TreeNode(5);<br>       TreeNode c=new TreeNode(12);<br>       TreeNode d=new TreeNode(4);<br>       TreeNode e=new TreeNode(7);<br>       a.left=b;<br>       a.right=c;<br>       b.left=d;<br>       b.right=e;<br>       ArrayList<arraylist<integer>&gt; pathNodes=new ConstructBinaryTree().findPath(a, 19);<br>        for(ArrayList<integer> list:pathNodes)<br>            for(Integer val:list){<br>                System.out.println(val+” “);<br>            }</integer></arraylist<integer></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 二叉树中和为某一值的所有路径&lt;br&gt;date: 2017-04-29 17:48:51&lt;br&gt;tags: 剑指offer&lt;/p&gt;
&lt;h2 id=&quot;categories-剑指offer&quot;&gt;&lt;a href=&quot;#categories-剑指offer&quot; cl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.myzwl.win/2017/08/22/offer_18/"/>
    <id>http://www.myzwl.win/2017/08/22/offer_18/</id>
    <published>2017-08-22T02:25:33.870Z</published>
    <updated>2017-09-02T16:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 二叉搜索树的后续遍历序列<br>date: 2017-04-28 16:48:51<br>tags: 剑指offer</p>
<h2 id="categories-剑指offer"><a href="#categories-剑指offer" class="headerlink" title="categories: 剑指offer"></a>categories: 剑指offer</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历的结果。如果是，则输出true，否则返回false</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>如{5,7,6,9,11,10,8}，根据二叉排序树的后续遍历特点，首先知道最后一个数是根结点，然后让前面的数与它比较，当到某一个数大于他时，那门这个数的前面就是左子树，右边就是右子树，比如{5,7,6}为左子树，{9,11,10}为右子树，接着判断如果右子树中有存在某个数小于根结点8，也就是返回false，如果不是，在将左子树和右子树依次递归</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class BinaryOfOut &#123;</div><div class="line"></div><div class="line">	public boolean IsBianry(int[] ids)&#123;</div><div class="line">		if(ids.length&lt;0)</div><div class="line">			return false;</div><div class="line">		 int root=ids[ids.length-1];</div><div class="line">		    int i=0;</div><div class="line">		     for(;i&lt;ids.length-1;i++)</div><div class="line">		     &#123;</div><div class="line">		    	 if(ids[i]&gt;root)</div><div class="line">		    		 break;</div><div class="line">		     &#125;</div><div class="line">		     int[] leftTree=new int[i];</div><div class="line">               System.arraycopy(ids, 0, leftTree, 0,i);</div><div class="line">               int j=i;</div><div class="line">               for(;j&lt;ids.length-1;j++)</div><div class="line">               &#123;</div><div class="line">            	   if(root&gt;ids[j])</div><div class="line">            		   return false;</div><div class="line">               &#125;</div><div class="line">               int[] rightTree=new int[ids.length-1-i];</div><div class="line">                System.arraycopy(ids, i, rightTree, 0,ids.length-1-i);</div><div class="line">               boolean leftFlag=true;</div><div class="line">                if(i&gt;0)&#123;</div><div class="line">                	leftFlag=IsBianry(leftTree);</div><div class="line">                &#125;</div><div class="line">                boolean rightFlag=true;</div><div class="line">                if(i&lt;ids.length-1)&#123;</div><div class="line">                	rightFlag=IsBianry(rightTree);</div><div class="line">                &#125;</div><div class="line">                return leftFlag&amp;&amp;rightFlag;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		System.out.println(new BinaryOfOut().IsBianry(new int[]&#123;5,7,6,9,11,10,8&#125;));</div><div class="line">		System.out.println(new BinaryOfOut().IsBianry(new int[]&#123;7,4,6,5&#125;));</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 二叉搜索树的后续遍历序列&lt;br&gt;date: 2017-04-28 16:48:51&lt;br&gt;tags: 剑指offer&lt;/p&gt;
&lt;h2 id=&quot;categories-剑指offer&quot;&gt;&lt;a href=&quot;#categories-剑指offer&quot; clas
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.myzwl.win/2017/08/21/offer_17/"/>
    <id>http://www.myzwl.win/2017/08/21/offer_17/</id>
    <published>2017-08-21T03:03:42.020Z</published>
    <updated>2017-09-02T16:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 包含min函数的栈<br>date: 2017-04-27 16:48:51<br>tags: 剑指offer</p>
<h2 id="categories-剑指offer"><a href="#categories-剑指offer" class="headerlink" title="categories: 剑指offer"></a>categories: 剑指offer</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。调用min、push、pop的时间复杂度都是O(1)</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>可以构造一个辅助栈，该栈里只放每次的最小栈顶元素集合，比如刚开始往栈里放3,4；则辅助栈里存放的是3,3；即每次比较新加的元素和原辅助栈栈顶最小元素的大小</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class StackWithMin &#123;</div><div class="line"></div><div class="line">	Stack&lt;Integer&gt; m_data=new Stack&lt;&gt;();</div><div class="line">	   Stack&lt;Integer&gt; m_min=new Stack&lt;&gt;();</div><div class="line">	   </div><div class="line">	   public void push(Integer value)&#123;</div><div class="line">		   m_data.push(value);</div><div class="line">		   </div><div class="line">		    if(m_min.size()==0||value&lt;m_min.peek())</div><div class="line">		    	m_min.push(value);</div><div class="line">		    else&#123;</div><div class="line">		    	m_min.push(m_min.peek());</div><div class="line">		    &#125;</div><div class="line">	   &#125;</div><div class="line">	   </div><div class="line">	   public void pop()&#123;</div><div class="line">		   if(m_data.size()&gt;0&amp;&amp;m_min.size()&gt;0)</div><div class="line">		   &#123;</div><div class="line">			   m_data.pop();</div><div class="line">			   m_min.pop();</div><div class="line">		   &#125;</div><div class="line">	   &#125;</div><div class="line">	</div><div class="line">	   public Integer min()&#123;</div><div class="line">		   if(m_data.size()&gt;0&amp;&amp;m_min.size()&gt;0)</div><div class="line">			   return m_min.peek();</div><div class="line">		   return null;</div><div class="line">	   &#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		StackWithMin sta=new StackWithMin();</div><div class="line">		 sta.push(3);</div><div class="line">		  sta.push(4);</div><div class="line">		   sta.push(2);</div><div class="line">		    System.out.println(sta.min());</div><div class="line">		      sta.pop();</div><div class="line">		        System.out.println(sta.min());</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>2,3</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 包含min函数的栈&lt;br&gt;date: 2017-04-27 16:48:51&lt;br&gt;tags: 剑指offer&lt;/p&gt;
&lt;h2 id=&quot;categories-剑指offer&quot;&gt;&lt;a href=&quot;#categories-剑指offer&quot; class=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.myzwl.win/2017/08/21/offer_16/"/>
    <id>http://www.myzwl.win/2017/08/21/offer_16/</id>
    <published>2017-08-21T03:03:04.600Z</published>
    <updated>2017-09-02T16:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 从上到下打印二叉树<br>date: 2017-04-26 15:48:51<br>tags: 剑指offer</p>
<h2 id="categories-剑指offer"><a href="#categories-剑指offer" class="headerlink" title="categories: 剑指offer"></a>categories: 剑指offer</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>不分行的从上到下打印二叉树的每个节点，同一层的结点按照从左到右的顺序打印</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>其实也就是树的层次遍历，而层次遍历的通法就是构造一个队列或者其他容器集合，按照从上到下依次加进结点，每次删除一个结点，就把它的左右孩子结点加入队列，依次类推，这里使用list模拟层序遍历</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">class TreeNode&#123;</div><div class="line">	int data;</div><div class="line">	TreeNode left;</div><div class="line">	TreeNode right;</div><div class="line">	</div><div class="line">	TreeNode(int data)&#123;</div><div class="line">		this.data=data;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public List&lt;Integer&gt; printFromToptoButtom(TreeNode root)&#123;</div><div class="line">		List&lt;TreeNode&gt; node=new ArrayList&lt;TreeNode&gt;();</div><div class="line">		 List&lt;Integer&gt; treeDate=new ArrayList&lt;Integer&gt;();</div><div class="line">		  int index=1;</div><div class="line">		   if(root==null)</div><div class="line">			   return null;</div><div class="line">		      node.add(root);</div><div class="line">		     while(node.size()&gt;0)&#123;</div><div class="line">		    	 TreeNode front=node.remove(0);</div><div class="line">		    	   index--;</div><div class="line">		    	   treeDate.add(front.data);</div><div class="line">		    	   if(front.left!=null)</div><div class="line">		    	   &#123;</div><div class="line">		    		   node.add(index++,front.left);</div><div class="line">		    		  </div><div class="line">		    	   &#125;</div><div class="line">		    	   if(front.right!=null)&#123;</div><div class="line">		    		   node.add(index++,front.right);		  </div><div class="line">		    	   &#125;</div><div class="line">		     &#125;</div><div class="line">		     return treeDate;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">       TreeNode a=new TreeNode(1);</div><div class="line">       TreeNode b=new TreeNode(2);</div><div class="line">       TreeNode c=new TreeNode(3);</div><div class="line">       TreeNode d=new TreeNode(4);</div><div class="line">       TreeNode e=new TreeNode(5);</div><div class="line">       a.left=b;</div><div class="line">       a.right=c;</div><div class="line">       b.left=e;</div><div class="line">       b.right=null;</div><div class="line">       c.right=d;</div><div class="line">       c.left=null;</div><div class="line">       d.left=null;</div><div class="line">       d.right=null;</div><div class="line">       e.left=null;</div><div class="line">       e.right=null;</div><div class="line">      List&lt;Integer&gt; data= new ConstructBinaryTree().printFromToptoButtom(a);</div><div class="line">       for(Integer h:data)&#123;</div><div class="line">    	   System.out.print(h+" ");</div><div class="line">       &#125;</div><div class="line">   </div><div class="line">	&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 从上到下打印二叉树&lt;br&gt;date: 2017-04-26 15:48:51&lt;br&gt;tags: 剑指offer&lt;/p&gt;
&lt;h2 id=&quot;categories-剑指offer&quot;&gt;&lt;a href=&quot;#categories-剑指offer&quot; class=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.myzwl.win/2017/08/18/offer_15/"/>
    <id>http://www.myzwl.win/2017/08/18/offer_15/</id>
    <published>2017-08-18T06:37:36.060Z</published>
    <updated>2017-09-02T16:06:28.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 二叉树的镜像<br>date: 2017-04-25 16:48:51<br>tags: 剑指offer</p>
<h2 id="categories-剑指offer"><a href="#categories-剑指offer" class="headerlink" title="categories: 剑指offer"></a>categories: 剑指offer</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>请完成一个函数，输入一颗二叉树，该函数输出它的镜像。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>镜像也就是将每个子节点的左右子节点交换，可以先判断根结点是否有左右子树，然后依次交换，然后在利用递归的思想继续交换</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class TreeNode&#123;</div><div class="line">		int data;</div><div class="line">		TreeNode left;</div><div class="line">		TreeNode right;</div><div class="line">		</div><div class="line">		TreeNode(int data)&#123;</div><div class="line">			this.data=data;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">public void Mirror(TreeNode root)&#123;</div><div class="line">		if(root==null||(root.left==null&amp;&amp;root.right==null))</div><div class="line">			return;</div><div class="line">		TreeNode temp=root.left;</div><div class="line">		root.left=root.right;</div><div class="line">		root.right=temp;</div><div class="line">		if(root.left!=null)</div><div class="line">			Mirror(root.left);</div><div class="line">		if(root.right!=null)</div><div class="line">			Mirror(root.right);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 二叉树的镜像&lt;br&gt;date: 2017-04-25 16:48:51&lt;br&gt;tags: 剑指offer&lt;/p&gt;
&lt;h2 id=&quot;categories-剑指offer&quot;&gt;&lt;a href=&quot;#categories-剑指offer&quot; class=&quot;hea
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.myzwl.win/2017/08/18/offer_14/"/>
    <id>http://www.myzwl.win/2017/08/18/offer_14/</id>
    <published>2017-08-18T06:32:51.850Z</published>
    <updated>2017-09-02T16:06:36.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 树的子结构<br>date: 2017-04-24 15:48:51<br>tags: 剑指offer</p>
<h2 id="categories-剑指offer"><a href="#categories-剑指offer" class="headerlink" title="categories: 剑指offer"></a>categories: 剑指offer</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入两颗二叉树A，B，判断B是不是A的子结构</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>要在原二叉树中查找是否具有某棵子树，只需要判断每个节点是否都在二叉树中是否出现即可。所以需要先判断头结点，只有头结点符合要求才继续比较其子树是否符合，然后在从左右子树依次比较，如果都符合，则说明B是A的子树</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class TreeNode&#123;</div><div class="line">		int data;</div><div class="line">		TreeNode left;</div><div class="line">		TreeNode right;</div><div class="line">		</div><div class="line">		TreeNode(int data)&#123;</div><div class="line">			this.data=data;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean HasSubtree(TreeNode root1,TreeNode root2)&#123;</div><div class="line">		boolean hasSubTree=false;</div><div class="line">		if(root1!=null&amp;&amp;root2!=null)</div><div class="line">		&#123;</div><div class="line">			if(root1.data==root2.data)</div><div class="line">			&#123;</div><div class="line">				hasSubTree=nodesValEqual(root1,root2);</div><div class="line">			&#125;</div><div class="line">			if(!hasSubTree)</div><div class="line">			&#123;</div><div class="line">				hasSubTree=HasSubtree(root1.left,root2.left);</div><div class="line">			&#125;</div><div class="line">			if(!hasSubTree)</div><div class="line">			&#123;</div><div class="line">				hasSubTree=HasSubtree(root1.right,root2.right);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return hasSubTree;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private boolean nodesValEqual(TreeNode root1,TreeNode root2)&#123;</div><div class="line">		if(root2==null)</div><div class="line">			return true;</div><div class="line">		if(root1==null)</div><div class="line">			return false;</div><div class="line">		if(root1.data!=root2.data)</div><div class="line">			return false;</div><div class="line">		return nodesValEqual(root1.left,root2.left)&amp;&amp;nodesValEqual(root1.right,root2.right);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 树的子结构&lt;br&gt;date: 2017-04-24 15:48:51&lt;br&gt;tags: 剑指offer&lt;/p&gt;
&lt;h2 id=&quot;categories-剑指offer&quot;&gt;&lt;a href=&quot;#categories-剑指offer&quot; class=&quot;head
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图的深度和广度遍历</title>
    <link href="http://www.myzwl.win/2017/08/01/graph_2/"/>
    <id>http://www.myzwl.win/2017/08/01/graph_2/</id>
    <published>2017-08-01T06:48:51.000Z</published>
    <updated>2017-08-14T12:19:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图是数据结构中最复杂的，正是因为它的复杂，它也是最优魅力的。当然图的存储结构有多种方式，最常用的就是邻接矩阵和邻接表。为了方便，这里图的遍历使用邻接矩阵表示</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><img src="/images/imgs4/35.gif" alt="Alt text"><br>如图，这里只画了无向图，其中顶点由一个一维数组表示，一个二维数组存储图中的边或弧的信息，可以发现无向图是一个对称矩阵，并且约定二维数组arc[i][j]=w，若边（vi，vj）属于该图，arc[i][j]=0，若i=j，否则arc[i][j]=一个无强大值，图中是用1代替了，实际中按上述规则<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">typedef char VertexType; /* 顶点类型应由用户定义 */</div><div class="line">typedef int EdgeType; /* 边上的权值类型应由用户定义 */</div><div class="line"></div><div class="line">#define MAXSIZE 9 /* 存储空间初始分配量 */</div><div class="line">#define MAXEDGE 15</div><div class="line">#define MAXVEX 9</div><div class="line">#define INFINITY 65535</div><div class="line"></div><div class="line">typedef struct&#123;</div><div class="line">	VertexType vexs[MAXVEX];          /* 顶点表 */</div><div class="line">	EdgeType arc[MAXVEX][MAXVEX];     /* 邻接矩阵，可看作边表 */</div><div class="line">	int numVertexes,numEdges;         /* 图中当前的顶点数和边数 */ </div><div class="line">&#125;MGraph;</div><div class="line"></div><div class="line">void CreateMGraph(MGraph *G)</div><div class="line">&#123;</div><div class="line">	int i,j,k,w;</div><div class="line">	printf("输入顶点数和边数:\n");</div><div class="line">	scanf("%d,%d",&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);</div><div class="line">	for(i=0;i&lt;G-&gt;numVertexes;i++)</div><div class="line">		scanf(&amp;G-&gt;vexs[i]);</div><div class="line">	for(i=0;i&lt;G-&gt;numVertexes;i++)</div><div class="line">		for(j=0;j&lt;G-&gt;numVertexes;j++)</div><div class="line">			G-&gt;arc[i][j]=INFINITY;</div><div class="line">		for(k=0;k&lt;G-&gt;numEdges;k++)</div><div class="line">		&#123;</div><div class="line">			printf("输入边（vi，vj）上的下标i，下标j和权值w：\n");</div><div class="line">		     scanf("%d,%d,%d",&amp;i,&amp;j,&amp;w);</div><div class="line">		     G-&gt;arc[i][j]=w;</div><div class="line">		     G-&gt;arc[j][i]=G-&gt;arc[i][j];</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p><img src="/images/imgs4/18.jpg" alt="Alt text"><br>图的遍历就是指从图中某一顶点出发遍历图中其余顶点且使每一个顶点仅被访问一次，然而由于同一个图可能在空间形式上有不同画法，所以造成不能采用之前使用的双亲等方法，所以可以把访问过的顶点打上标记，即设置一个访问数组visited[n]，n是图中原点个数，初值为0，访问过后设置为1，这样就可以避免访问重复的了<br>而深度优先遍历，也叫深度优先搜索，简称DFS，就像在一个房子中搜索一样，从每一个房间开始，而是不留死角的搜索，也就是说该房间内所有地方搜索完，在去搜索其他房间，以此类推<br>从图中可以发现它是一个递归过程，也就是像二叉树的先序遍历，只不过，已经遍历的结点可以跳过</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">void CreateMGraph(MGraph *G)</div><div class="line">&#123;</div><div class="line">	int i, j;</div><div class="line"></div><div class="line">	G-&gt;numEdges=15;</div><div class="line">	G-&gt;numVertexes=9;</div><div class="line"></div><div class="line">	/* 读入顶点信息，建立顶点表 */</div><div class="line">	G-&gt;vexs[0]='A';</div><div class="line">	G-&gt;vexs[1]='B';</div><div class="line">	G-&gt;vexs[2]='C';</div><div class="line">	G-&gt;vexs[3]='D';</div><div class="line">	G-&gt;vexs[4]='E';</div><div class="line">	G-&gt;vexs[5]='F';</div><div class="line">	G-&gt;vexs[6]='G';</div><div class="line">	G-&gt;vexs[7]='H';</div><div class="line">	G-&gt;vexs[8]='I';</div><div class="line"></div><div class="line"></div><div class="line">	for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */</div><div class="line">	&#123;</div><div class="line">		for ( j = 0; j &lt; G-&gt;numVertexes; j++)</div><div class="line">		&#123;</div><div class="line">			G-&gt;arc[i][j]=0;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	G-&gt;arc[0][1]=1;</div><div class="line">	G-&gt;arc[0][5]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[1][2]=1; </div><div class="line">	G-&gt;arc[1][8]=1; </div><div class="line">	G-&gt;arc[1][6]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[2][3]=1; </div><div class="line">	G-&gt;arc[2][8]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[3][4]=1;</div><div class="line">	G-&gt;arc[3][7]=1;</div><div class="line">	G-&gt;arc[3][6]=1;</div><div class="line">	G-&gt;arc[3][8]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[4][5]=1;</div><div class="line">	G-&gt;arc[4][7]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[5][6]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[6][7]=1; </div><div class="line"></div><div class="line">	</div><div class="line">	for(i = 0; i &lt; G-&gt;numVertexes; i++)</div><div class="line">	&#123;</div><div class="line">		for(j = i; j &lt; G-&gt;numVertexes; j++)</div><div class="line">		&#123;</div><div class="line">			G-&gt;arc[j][i] =G-&gt;arc[i][j];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Boolean visited[MAXSIZE];//访问标志的数组</div><div class="line"></div><div class="line">//深度优先递归算法</div><div class="line">void DFS(MGraph G,int i)&#123;</div><div class="line">	int j;</div><div class="line">	visited[i]=TRUE;</div><div class="line">	printf("%c",G.vexs[i]);</div><div class="line">	for(j=0;j&lt;G.numVertexes;j++)</div><div class="line">		if(G.arc[i][j]==1&amp;&amp;!visited[j]) //对未访问的顶点递归调用</div><div class="line">			DFS(G,j);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//深度遍历</div><div class="line">void DFSTraverse(MGraph G)&#123;</div><div class="line">	int i;</div><div class="line">	for(i=0;i&lt;G.numVertexes;i++) //初始化</div><div class="line">		visited[i]=FALSE;</div><div class="line">	for(i=0;i&lt;G.numVertexes;i++)</div><div class="line">		if(!visited[i])</div><div class="line">			DFS(G,i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	MGraph G;</div><div class="line">	CreateMGraph(&amp;G);</div><div class="line">	printf("\n深度遍历：");</div><div class="line">	DFSTraverse(G);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了方便，就创建图的过程写死，最终深度遍历的结果为ABCDEFGHI</p>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>又称为广度优先搜索，简称BFS，它像二叉树遍历中的层序遍历，也就是一层一层的遍历，如上图，与A相连的有B、F，先遍历，又与B相连的有C,I,G，F相连的有G,E，所以下一层为C,I,G,F，依次类推一层一层遍历<br><img src="/images/imgs4/19.jpg" alt="Alt text"><br>如图它的核心思想就是构造一个队列，每一层的结点，如A出队后，与它相连的下一层结点B、F就要入队开始遍历，然后B遍历完出队，与B相连的下一层结点C、I、J入队，依次类推<br><strong>队列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/* 循环队列的顺序存储结构 */</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	int data[MAXSIZE];</div><div class="line">	int front;    	/* 头指针 */</div><div class="line">	int rear;		/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</div><div class="line">&#125;Queue;</div><div class="line"></div><div class="line">/* 初始化一个空队列Q */</div><div class="line">Status InitQueue(Queue *Q)</div><div class="line">&#123;</div><div class="line">	Q-&gt;front=0;</div><div class="line">	Q-&gt;rear=0;</div><div class="line">	return  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */</div><div class="line">Status QueueEmpty(Queue Q)</div><div class="line">&#123; </div><div class="line">	if(Q.front==Q.rear) /* 队列空的标志 */</div><div class="line">		return TRUE;</div><div class="line">	else</div><div class="line">		return FALSE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列未满，则插入元素e为Q新的队尾元素 */</div><div class="line">Status EnQueue(Queue *Q,int e)</div><div class="line">&#123;</div><div class="line">	if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)	/* 队列满的判断 */</div><div class="line">		return ERROR;</div><div class="line">	Q-&gt;data[Q-&gt;rear]=e;			/* 将元素e赋值给队尾 */</div><div class="line">	Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;/* rear指针向后移一位置， */</div><div class="line">								/* 若到最后则转到数组头部 */</div><div class="line">	return  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</div><div class="line">Status DeQueue(Queue *Q,int *e)</div><div class="line">&#123;</div><div class="line">	if (Q-&gt;front == Q-&gt;rear)			/* 队列空的判断 */</div><div class="line">		return ERROR;</div><div class="line">	*e=Q-&gt;data[Q-&gt;front];				/* 将队头元素赋值给e */</div><div class="line">	Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;	/* front指针向后移一位置， */</div><div class="line">									/* 若到最后则转到数组头部 */</div><div class="line">	return  OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>广度遍历</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/* 邻接矩阵的广度遍历算法 */</div><div class="line">void BFSTraverse(MGraph G)</div><div class="line">&#123;</div><div class="line">	int i, j;</div><div class="line">	Queue Q;</div><div class="line">	for(i = 0; i &lt; G.numVertexes; i++)</div><div class="line">       	visited[i] = FALSE;</div><div class="line">    InitQueue(&amp;Q);		/* 初始化一辅助用的队列 */</div><div class="line">    for(i = 0; i &lt; G.numVertexes; i++)  /* 对每一个顶点做循环 */</div><div class="line">    &#123;</div><div class="line">		if (!visited[i])	/* 若是未访问过就处理 */</div><div class="line">		&#123;</div><div class="line">			visited[i]=TRUE;		/* 设置当前顶点访问过 */</div><div class="line">			printf("%c ", G.vexs[i]);/* 打印顶点，也可以其它操作 */</div><div class="line">			EnQueue(&amp;Q,i);		/* 将此顶点入队列 */</div><div class="line">			while(!QueueEmpty(Q))	/* 若当前队列不为空 */</div><div class="line">			&#123;</div><div class="line">				DeQueue(&amp;Q,&amp;i);	/* 将队对元素出队列，赋值给i */</div><div class="line">				for(j=0;j&lt;G.numVertexes;j++) </div><div class="line">				&#123; </div><div class="line">					/* 判断其它顶点若与当前顶点存在边且未访问过  */</div><div class="line">					if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) </div><div class="line">					&#123; </div><div class="line"> 						visited[j]=TRUE;			/* 将找到的此顶点标记为已访问 */</div><div class="line">						printf("%c ", G.vexs[j]);	/* 打印顶点 */</div><div class="line">						EnQueue(&amp;Q,j);				/* 将找到的此顶点入队列  */</div><div class="line">					&#125; </div><div class="line">				&#125; </div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	MGraph G;</div><div class="line">	CreateMGraph(&amp;G);</div><div class="line">	printf("\n深度遍历：");</div><div class="line">	DFSTraverse(G);</div><div class="line">	printf("\n广度遍历：");</div><div class="line">	BFSTraverse(G);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终的结果是</p>
<blockquote>
<p>A B F C I G E D H</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后发现深度优先和广度优先遍历的时间复杂度是一样的，他们的适用场景不一样，深度优先更适合目标比较明确，已找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;图是数据结构中最复杂的，正是因为它的复杂，它也是最优魅力的。当然图的存储结构有多种方式，最常用的就是邻接矩阵和邻接表。为了方便，这里图的遍历
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>反射机制简单总结</title>
    <link href="http://www.myzwl.win/2017/07/31/reflaction_1/"/>
    <id>http://www.myzwl.win/2017/07/31/reflaction_1/</id>
    <published>2017-07-31T06:48:51.000Z</published>
    <updated>2017-08-13T14:55:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>反射机制是java中非常非常重要的东西，比如以前模拟jdk的代理实现和spring的aop实现都用到了反射（见以前设计模式总结），同时，正是由于反射机制，才让我们能更动态的去写程序，比如说在配置文件中配置配置，就能调用某些方法，是在太方便了，下面就开始探索反射机制，下图是类的加载模型<br><img src="/images/imgs4/33.gif" alt="Alt text"></p>
<h4 id="ClassLoad类加载过程"><a href="#ClassLoad类加载过程" class="headerlink" title="ClassLoad类加载过程"></a>ClassLoad类加载过程</h4><p>它的特点是1.并非一次性加载<br>2.需要的时候加载（运行期动态加载）<br>3.static语句块在加载后执行一次<br>4.dynamic语句块每次new新的对象都会执行（等同于构造方法中语句）<br><strong>程序验证</strong><br>在eclipse中有-verbose:class运行命令可详细的打印出jvm虚拟机第一次在内存中加载类的详细信息，如下：<br>先看模拟的程序<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		new A();		</div><div class="line">		System.out.println("**------------------------**");</div><div class="line">		new B();</div><div class="line">        new C();</div><div class="line">        new C();</div><div class="line">        new D();</div><div class="line">        new D();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class A&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C&#123;</div><div class="line">	static&#123;</div><div class="line">		System.out.println("CCCCCCCCCCCCCCCCCCCCCCCCCCC");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class D&#123;</div><div class="line">	&#123;</div><div class="line">		System.out.println("DDDDDDDDDDDDDDDDDDDDDDDDDDDD");</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中d就是动态方法<br>以下是输出结果</p>
<blockquote>
<p>[Opened E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.lang.Object from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.io.Serializable from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>。。。。。。<br>[Loaded com.zwl.tree.A from file:/E:/ecli/shiro/target/classes/]</p>
<hr>
<p>[Loaded com.zwl.tree.B from file:/E:/ecli/shiro/target/classes/]<br>[Loaded com.zwl.tree.C from file:/E:/ecli/shiro/target/classes/]<br>CCCCCCCCCCCCCCCCCCCCCCCCCCC<br>[Loaded com.zwl.tree.D from file:/E:/ecli/shiro/target/classes/]<br>DDDDDDDDDDDDDDDDDDDDDDDDDDDD<br>DDDDDDDDDDDDDDDDDDDDDDDDDDDD<br>[Loaded java.lang.Shutdown from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.lang.Shutdown$Lock from E:\myeclipse\jdk1.8\jre\lib\rt.jar]</p>
</blockquote>
<p>可以发现，jvm在初始化执行程序时需要加载很多类到内存中，并且是动态加载的，就像A和B中间输出语句打印出来，说明不是一次性加载的，这里静态函数只加载了一次，动态方法每次都会加载，其实还有一点，就是jvm会在类加载时，找到jdk中已有的类加载，加载过了一次，就不加载了如D</p>
<h4 id="classLoad类"><a href="#classLoad类" class="headerlink" title="classLoad类"></a>classLoad类</h4><p>事实上，jdk中有各种各样的ClassLoad将类加载进内存，大致分为以下几种</p>
<blockquote>
<p>一：bootstrap class loader<br>implemented by native language and load ths core classes of jdk<br>也就是说，它不是用java写的，而是用操作系统语言，如c、c++写的加载类，它是最核心的类用于加载java中核心的类，当然他没有具体名字<br>二:extesion class loader<br>loader the class from jre/lib/ext<br>三:application class loader<br>load user-define classes and ClassLoader.getSystemClassLoader()<br>也就是说它是java的核心类用于加载用户自定义的类和其他类<br>四:other class loaders<br>SecureClassLoader、URLClassLoader等等，该类是其他加载类加载其它类</p>
</blockquote>
<p><strong>程序验证</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(String.class.getClassLoader());</div><div class="line">	System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());</div><div class="line">	System.out.println(Test.class.getClassLoader().getClass().getName());</div><div class="line">	System.out.println(ClassLoader.getSystemClassLoader().getClass().getName());</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>null<br>sun.misc.Launcher$ExtClassLoader<br>sun.misc.Launcher$AppClassLoader<br>sun.misc.Launcher$AppClassLoader</p>
</blockquote>
<p>分析一下：String类bootstrap类加载的类，但是它的加载类是空，而DESKeyFactory的的加载类是扩展类，而第三和第四都是java核心类加载，总之，我们知道classload是有多种并且有顺序和层次的<br><img src="/images/imgs4/34.gif" alt="Alt text"></p>
<p>如</p>
<blockquote>
<p>ClassLoader c=Test.class.getClassLoader();<br>        while(c!=null){<br>            System.out.println(c.getClass().getName());<br>            c=c.getParent();<br>        }</p>
</blockquote>
<p>结果：</p>
<blockquote>
<p>sun.misc.Launcher$AppClassLoader<br>sun.misc.Launcher$ExtClassLoader</p>
</blockquote>
<p>注意这里的getparent（）是得到引用，不是继承。也就是说jdk底层深层次加载是，问上一层有没有加载我这个类，如果加载了就不加载了</p>
<h4 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h4><p>从classload的角度来看，内存中的一切包括方法等都是对象，也就是说我们可以动态的调用，jdk中为我们提供了类methods类如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;</div><div class="line">		</div><div class="line">		String str="com.zwl.tree.T";</div><div class="line">		Class c=Class.forName(str);</div><div class="line">		Object o=c.newInstance();</div><div class="line">		Method[] methods=c.getMethods();</div><div class="line">		for(Method m:methods)&#123;</div><div class="line">			if(m.getName().equals("mm"))&#123;</div><div class="line">			m.invoke(o);</div><div class="line">			&#125;</div><div class="line">			if(m.getName().equals("m1"))&#123;</div><div class="line">				m.invoke(o, 1,2);</div><div class="line">				System.out.println(m.getReturnType().getName());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	class T&#123;</div><div class="line">	</div><div class="line">	static&#123;</div><div class="line">		System.out.println("T loader!");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public T()&#123;</div><div class="line">		System.out.println("T constructed!");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	int i;</div><div class="line">	String s;</div><div class="line">	public void m1(int i,int j)&#123;</div><div class="line">		this.i=i+j;	</div><div class="line">		System.out.println(this.i);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void mm()&#123;</div><div class="line">		System.out.println("mm");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String getS()&#123;</div><div class="line">		return s;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<blockquote>
<p>T loader!<br>T constructed!<br>mm<br>3<br>void</p>
</blockquote>
<p>上面的程序通过class提供的forname（）方法将相应的类加载至内存，然后通过newInstance()方法取得实例，methods方法能够得到一个类的所有方法，最后通过public Object invoke(Object obj,Object… args)第二个参数是可变参数，也就是可以有多个参数来调用相应对象的相应方法，而getReturnType()是拿到方法的返回类型，也就是说我们通过class和methods可以动态的调用方法，就好比我们只要在配置文件中配置一下类或方法名，就可以动态的调用类或方法，是在是太方便了</p>
<h4 id="反射一些类常用方法"><a href="#反射一些类常用方法" class="headerlink" title="反射一些类常用方法"></a>反射一些类常用方法</h4><p><strong>ClassLoader常用方法</strong></p>
<blockquote>
<p>public abstract class ClassLoaderextends Object<br>构造方法：<br>protected ClassLoader()：使用方法 getSystemClassLoader() 返回的 ClassLoader 创建一个新的类加载器，将该加载器作为父类加载器<br>protected ClassLoader(ClassLoader parent)：使用指定的、用于委托操作的父类加载器创建新的类加载器<br>public final ClassLoader getParent()：返回委托的父类加载器<br>public URL getResource(String name)：查找具有给定名称的资源。</p>
</blockquote>
<p><strong>Class常用方法</strong></p>
<blockquote>
<p>public final class Class<t>extends Objectimplements Serializable, GenericDeclaration, Type, AnnotatedElement<br>Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的<br>public static Class&lt;?&gt; forName(String className)throws ClassNotFoundException：返回与带有给定字符串名的类或接口相关联的 Class 对象<br>public ClassLoader getClassLoader()：返回该类的类加载器<br>public Method[] getMethods()throws SecurityException：返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。<br>public String getName()：以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称<br>public String getName()：查找带有给定名称的资源。<br>public T newInstance()throws InstantiationException,IllegalAccessException： 创建此 Class 对象所表示的类的一个新实例。</t></p>
</blockquote>
<p><strong>Methods类常用方法</strong></p>
<blockquote>
<p>public final class Methodextends AccessibleObjectimplements GenericDeclaration, Member<br>public String getName():以 String 形式返回此 Method 对象表示的方法名称。<br>public Class&lt;?&gt; getReturnType():返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型。<br>public Object invoke(Object obj,<br>                     Object… args)<br>              throws IllegalAccessException,<br>                     IllegalArgumentException,<br>                     InvocationTargetException<br> 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法,此方法为可变参数   </p>
</blockquote>
<p> 反射的知识其实是很复杂的，这里只做了一次简单的总结，反射的应用也是在太广了，像strcts、spring、hibernate、mybatis、spring mvc包括shiro等等框架，你会发现他们的很多底层实现都基于反射机制。。             </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;反射机制是java中非常非常重要的东西，比如以前模拟jdk的代理实现和spring的aop实现都用到了反射（见以前设计模式总结），同时，正是
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树之压缩与解压</title>
    <link href="http://www.myzwl.win/2017/07/30/huffman_2/"/>
    <id>http://www.myzwl.win/2017/07/30/huffman_2/</id>
    <published>2017-07-30T06:48:51.000Z</published>
    <updated>2017-08-13T12:14:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>压缩与解压的另一种说法就是，压缩相当于对文件的加密过程，解压相当于对文件的解密过程，比如说，盲-z，僧-w，那么盲僧-zw，当然加密与解密各种各样，不一定非是字符型的</p>
<h4 id="压缩对比"><a href="#压缩对比" class="headerlink" title="压缩对比"></a>压缩对比</h4><p><img src="/images/imgs4/29.gif" alt="Alt text"><br>如图，最左边是未压缩的原始txt文本文件，里面有38个字节，所以占38字节，中间是利用哈夫曼编码压缩的，居然只占15个字节，最右边是好压自带的压缩，占185个字节，通过对比，发现哈夫曼压缩居然节约这么多空间！</p>
<h4 id="压缩原理"><a href="#压缩原理" class="headerlink" title="压缩原理"></a>压缩原理</h4><p>计算机只能存储二进制数，即非0即1，比如刚学c语言那会接触到的ASCII码，它是专门处理英文的，比如一个字节占8位（由8个01串组成）来表示各种英文字母以及符号，比如0在ASCII编码的十进制表示是48（00110000），a是97，所以英文共有2的8次方个，但是汉字远远不止256个，所以一个汉字用两个字节表示，所以共有2的16次方汉字，而汉字编码一般用UTF-8和GBK等<br><strong>存储过程</strong><br>比如在文件中存储aaabbc，理论上占6个字节，并且存储的二进制为01100001（a）01100001（a）01100001（a）01100010 （b）01100010 （b）01100011 （c）那么哈夫曼是怎么存储该数据的了<br>它是根据某个字出现的次数，比如a出现3次，b出现2次，c出现1次，将次数作为相应字的权值来构造哈夫曼树的<br><img src="/images/imgs4/30.gif" alt="Alt text"><br>所以得到：哈夫曼编码为a（1），b（01），c（00），所以的到压缩后的编码为aaabbc（111010100），注意这里变成2个字节了，然后将该二进制转换成10进制就行了</p>
<h4 id="压缩实现"><a href="#压缩实现" class="headerlink" title="压缩实现"></a>压缩实现</h4><p>一般有以下步骤<br>1.读取文件，统计文件中每个字节出现的次数，将该次数作为权值<br>2.根据权值构建哈夫曼树<br>3，根据哈夫曼树构建码表<br>4在读取文件，通过码表对文件中读取的字节进行加密处理<br><img src="/images/imgs4/31.gif" alt="Alt text"><br>在这里定义了一个256的整型数组（存取次数作为权值）和一个256的字符串数组（存取哈夫曼编码值）</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p><strong>哈夫曼结点</strong><br>与之前不同的是增加了索引，便于搜索<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class HuffmNode &#123;</div><div class="line">	//数据域  </div><div class="line">    private int data;  </div><div class="line">    //索引  </div><div class="line">    private int index;  </div><div class="line">    //左子节点  </div><div class="line">    private HuffmNode left;  </div><div class="line">    //右子节点  </div><div class="line">    private HuffmNode right;  </div><div class="line">      </div><div class="line">    //哈夫曼节点的构造函数  </div><div class="line">    public HuffmNode(int data,int index)&#123;  </div><div class="line">        this.data=data;  </div><div class="line">        this.index=index;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //私有属性的封装  </div><div class="line">    public int getData() &#123;  </div><div class="line">        return data;  </div><div class="line">    &#125;  </div><div class="line">    public void setData(int data) &#123;  </div><div class="line">        this.data = data;  </div><div class="line">    &#125;  </div><div class="line">    public int getIndex() &#123;  </div><div class="line">        return index;  </div><div class="line">    &#125;  </div><div class="line">    public void setIndex(int index) &#123;  </div><div class="line">        this.index = index;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getLeft() &#123;  </div><div class="line">        return left;  </div><div class="line">    &#125;  </div><div class="line">    public void setLeft(HuffmNode left) &#123;  </div><div class="line">        this.left = left;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getRight() &#123;  </div><div class="line">        return right;  </div><div class="line">    &#125;  </div><div class="line">    public void setRight(HuffmNode right) &#123;  </div><div class="line">        this.right = right;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>压缩实现类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">public class Compress &#123;</div><div class="line"></div><div class="line">	 public int[] times=new int[256];</div><div class="line">	 public String[] HuffmCodes=new String[256];</div><div class="line">	 public LinkedList&lt;HuffmNode&gt; list = new LinkedList&lt;HuffmNode&gt;();  </div><div class="line"></div><div class="line">	//初始化 </div><div class="line">     public Compress()&#123;</div><div class="line">    	 for(int i=0;i&lt;HuffmCodes.length;i++)</div><div class="line">    	 &#123;</div><div class="line">    		 HuffmCodes[i]="";</div><div class="line">    	 &#125;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     public void countTimes(String path)throws Exception&#123;</div><div class="line">    	//构造文件输入流</div><div class="line">    	 FileInputStream fis=new FileInputStream(path);</div><div class="line">    	//读取文件  </div><div class="line">    	 int value=fis.read();</div><div class="line">    	 while(value!=-1)&#123;</div><div class="line">    		 times[value]++;</div><div class="line">    		 value=fis.read();</div><div class="line">    	 &#125;</div><div class="line">    	 fis.close(); </div><div class="line">     &#125;</div><div class="line">     </div><div class="line">   //构造哈夫曼树 </div><div class="line">     public HuffmNode createTree()&#123;  </div><div class="line">         //将次数作为权值构造森林  </div><div class="line">         for (int i = 0; i &lt; times.length; i++) &#123;  </div><div class="line">             if(times[i]!=0)&#123;  </div><div class="line">                 HuffmNode node = new HuffmNode(times[i],i);  </div><div class="line">                 //将构造好的节点加入到容器中的正确位置  </div><div class="line">                 list.add(getIndex(node), node);  </div><div class="line">             &#125;  </div><div class="line">         &#125;  </div><div class="line">           </div><div class="line">         //将森林（容器中的各个节点）构造成哈夫曼树  </div><div class="line">         while(list.size()&gt;1) &#123;  </div><div class="line">             //获取容器中第一个元素（权值最小的节点）  </div><div class="line">             HuffmNode firstNode =list.removeFirst();  </div><div class="line">             //获取中新的第一个元素，原来的第一个元素已经被移除了（权值次小的节点）  </div><div class="line">             HuffmNode secondNode =list.removeFirst();  </div><div class="line">             //将权值最小的两个节点构造成父节点  </div><div class="line">             HuffmNode fatherNode =  </div><div class="line">                     new HuffmNode(firstNode.getData()+secondNode.getData(),-1);  </div><div class="line">             fatherNode.setLeft(firstNode);  </div><div class="line">             fatherNode.setRight(secondNode);  </div><div class="line">             //父节点加入到容器中的正确位置  </div><div class="line">             list.add(getIndex(fatherNode),fatherNode);  </div><div class="line">         &#125;  </div><div class="line">         //返回整颗树的根节点  </div><div class="line">         return list.getFirst();  </div><div class="line">     &#125;  </div><div class="line">     </div><div class="line">   //利用前序遍历获取编码表  </div><div class="line">     public void getHuffmCode(HuffmNode root,String code)&#123;  </div><div class="line">         //往左走，哈夫曼编码加0  </div><div class="line">         if(root.getLeft()!=null)&#123;  </div><div class="line">             getHuffmCode(root.getLeft(),code+"0");  </div><div class="line">         &#125;  </div><div class="line">         //往右走，哈夫曼编码加1  </div><div class="line">         if(root.getRight()!=null)&#123;  </div><div class="line">             getHuffmCode(root.getRight(),code+"1");  </div><div class="line">         &#125;  </div><div class="line">         //如果是叶子节点，返回该叶子节点的哈夫曼编码  </div><div class="line">         if(root.getLeft()==null &amp;&amp; root.getRight()==null)&#123;  </div><div class="line">//           System.out.println(root.getIndex()+"的编码为："+code);  </div><div class="line">             HuffmCodes[root.getIndex()]=code;  </div><div class="line">         &#125;  </div><div class="line">     &#125;  </div><div class="line">     </div><div class="line">   //压缩文件 </div><div class="line">     public void compress(String path,String destpath)throws Exception&#123;</div><div class="line">    	//构建文件输出流  </div><div class="line">    	 FileOutputStream fos=new FileOutputStream(destpath);</div><div class="line">    	 FileInputStream fis=new FileInputStream(path);</div><div class="line">    	        </div><div class="line">         //读文件，并将对应的哈夫曼编码串接成字符串  </div><div class="line">    	 int value=fis.read();</div><div class="line">    	 String str="";</div><div class="line">    	 while(value!=-1)&#123;</div><div class="line">    		 str+=HuffmCodes[value];</div><div class="line">    		 value=fis.read();</div><div class="line">    	 &#125;</div><div class="line">    	 System.out.println(str);</div><div class="line">    	 fis.close();</div><div class="line">    	 </div><div class="line">    	 String s="";</div><div class="line">    	 while(str.length()&gt;=8)&#123;</div><div class="line">    		 s=str.substring(0, 8);</div><div class="line">    		 int b=changeStringToInt(s);</div><div class="line">    		 fos.write(b);</div><div class="line">    		 fos.flush();</div><div class="line">    		 str=str.substring(8);</div><div class="line">    	 &#125;</div><div class="line">    	 </div><div class="line">    	 int last1=8-str.length();</div><div class="line">    	 for(int i=0;i&lt;last1;i++)&#123;</div><div class="line">    		 str+="0";</div><div class="line">    	 &#125;</div><div class="line">    	 s=str.substring(0, 8);  </div><div class="line">         int d=changeStringToInt(s);  </div><div class="line">         fos.write(d);</div><div class="line">         fos.close();</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">   //插入元素位置的索引  </div><div class="line">     public int getIndex(HuffmNode node) &#123;  </div><div class="line">         for (int i = 0; i &lt; list.size(); i++) &#123;  </div><div class="line">             if(node.getData()&lt;=list.get(i).getData())&#123;  </div><div class="line">                 return i;  </div><div class="line">             &#125;  </div><div class="line">         &#125;  </div><div class="line">        return list.size();  </div><div class="line">     &#125;  </div><div class="line">	 </div><div class="line">   //将字符串转换成整数  </div><div class="line">     public int changeStringToInt(String s)&#123; </div><div class="line">    	 int v1=(s.charAt(0)-48)*128;  </div><div class="line">         int v2=(s.charAt(1)-48)*64;  </div><div class="line">         int v3=(s.charAt(2)-48)*32;  </div><div class="line">         int v4=(s.charAt(3)-48)*16;  </div><div class="line">         int v5=(s.charAt(4)-48)*8;  </div><div class="line">         int v6=(s.charAt(5)-48)*4;  </div><div class="line">         int v7=(s.charAt(6)-48)*2;  </div><div class="line">         int v8=(s.charAt(7)-48)*1;  </div><div class="line">         return v1+v2+v3+v4+v5+v6+v7+v8;</div><div class="line">     &#125; </div><div class="line">	 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有几处需要注意下，首先changeStringToInt(String s）方法是根据二进制的定义做转换的，void countTimes(String path)throws Exception中那个value是根据其相应的字节的ASCII码值得，比如a是97，就是times[97]++，初始值都是0；<br>然后void compress(String path,String destpath)throws Exception中读文件刚开始是取8位然后转成int在写进文件，然后取第8未到末尾，在循环直至最后不足8位，在后面补0，在写进去。</p>
<p><strong>测试类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//创建压缩对象  </div><div class="line">      Compress compress = new Compress();  </div><div class="line">      //统计文件中0-255出现的次数  </div><div class="line">      compress.countTimes("C:\\Users\\Administrator\\Desktop\\test.txt");  </div><div class="line">      //构造哈夫曼树，并得到根节点  </div><div class="line">      HuffmNode root=compress.createTree();  </div><div class="line">      //得到哈夫曼编码  </div><div class="line">      compress.getHuffmCode(root, "");  </div><div class="line">      //压缩文件  </div><div class="line">      compress.compress("C:\\Users\\Administrator\\Desktop\\test.txt",  </div><div class="line">              "C:\\Users\\Administrator\\Desktop\\tes.zip");</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>1011010101110010110101011011011011100111011110011000010000100111010100010000010011111101101111110111111011000010000100</p>
</blockquote>
<p>同时会生成一个压缩文件，如前面的图所示</p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p><strong>解压原理</strong><br>之前说过哈夫曼编码不会出现像0和01这样前者是后者子串的情况，所以解压采取的办法就是在压缩时写进去每个编码的长度和对应的编码，就像密码本一样，记录着每个密码的详细信息（这里理解每个密码长度和密码数据域唯一确定一个解码）<br>打个比方，假设ab压缩后为0和10，当然压缩后是变成010，那怎么解码了？，首先在压缩时，在之前压缩代码上加上一个记录编码长度和对应的编码，像a不是97吗，那在写入时记录code[97]=1，对应的编码str[97]=0，code[98]=1；str[98]=0，一次类推，写入时是先写入编码长度的，不过要将字符串转换成十进制，然后通过字符串分割成不同编码，这样每个字节也就拿到手了<br>模拟一下，不妨把abbcc先压缩，然后读出它的二进制如下</p>
<blockquote>
<p>000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015214308</p>
</blockquote>
<p>再来分析分析：<br>前面在152之前都是存取密码长度的信息，212是对应ASSII码的相应字节的编码长度，如a（10）、b（0），c（11）所以长度分别对应212，接下来就是152也就是abc的二进制值了，10011，不足8位后面补0，即10011000，对应十进制就是152，后面143就是文本的需要解密的编码，后面08没有弄懂，在压缩文件中并没有输入这个东西，也做了大量实验发现都有后面这些数字，暂且认为就是压缩文件自带的标识吧（逻辑上还没有证明，所以勉强这么认为）<br>所以，解码思路就是先根据长度读取相应位置，然后分割每个位置得到相应二进制编码，最后再转回来，看看编码的打印结果</p>
<blockquote>
<p>0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000212000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000codeLength:1<br>int152<br>哈夫曼编码：10011000<br>huff10<br>huff0<br>huff11<br>需要解密的字符串：10001111<br>截取的字符串：10<br>截取后剩余编码长度：6<br>截取的字符串：0<br>截取后剩余编码长度：5<br>截取的字符串：0<br>截取后剩余编码长度：4<br>截取的字符串：11<br>截取后剩余编码长度：2<br>截取的字符串：11<br>截取后剩余编码长度：0</p>
</blockquote>
<p>不是很规范，但是大概跟踪了过程，长度为5（10011），不足8位不以为，所以codeLength为1,152就是哈夫曼密码手册值了，变成二进制为10011000，然后分割成10,0,11分别对应ASSII码为a、b、c三个字符，需要解密的是10001111，也就是143，解密分别对应abbcc，所以至此完成解密了<br>说了这么多，再来看看代码吧</p>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><p><strong>压缩编码</strong><br>由于解压需要的压缩编码在之前主要修改一点，所以这里就把增加的代码贴出来，分析分析<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//将整个哈夫曼编码以及每个编码的长度写入文件  </div><div class="line">     String code ="";  </div><div class="line">     for (int i = 0; i &lt; 256; i++) &#123;  </div><div class="line">         fos.write(HuffmCodes[i].length());  </div><div class="line">         code+=HuffmCodes[i];  </div><div class="line">         fos.flush();  </div><div class="line">     &#125;  </div><div class="line">     //把哈夫曼编码写入文件  </div><div class="line">       </div><div class="line">  System.out.println("code="+code);  </div><div class="line">     String str1="";  </div><div class="line">     while(code.length()&gt;=8)&#123;  </div><div class="line">         str1=code.substring(0, 8);  </div><div class="line">         int c=changeStringToInt(str1);  </div><div class="line">      System.out.println(c);  </div><div class="line">         fos.write(c);  </div><div class="line">         fos.flush();  </div><div class="line">         code=code.substring(8);  </div><div class="line">     &#125;  </div><div class="line">     //处理最后一个不为8的数  </div><div class="line">     int last=8-code.length();  </div><div class="line">     for (int i = 0; i &lt;last; i++) &#123;  </div><div class="line">         code+="0";  </div><div class="line">     &#125;  </div><div class="line">     str1=code.substring(0, 8);  </div><div class="line">     int c=changeStringToInt(str1); </div><div class="line">     System.out.println("c:"+c);</div><div class="line">     fos.write(c);  </div><div class="line">     fos.flush();</div></pre></td></tr></table></figure></p>
<p>上面代码是说首先我们已经统计了文本中字符出现的次数，压缩那里已经写过了，然后将长度表写入进压缩文件，也就是那一大串000中间含有长度的字符串，存在code里，注意长度为空就是空字符，所以code就是那5位的二进制，然后不足8位的补成8位，再变成十进制也就是152了，这是这段代码与之前增加的部分，我们也称为码表构造</p>
<p><strong>解压实现类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line">//每个编码的长度  </div><div class="line">    public int [] codelengths = new int [256];  </div><div class="line">    //对应的哈夫曼编码值  </div><div class="line">    public String [] codeMap=new String[256];  </div><div class="line">    </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		 Decompress d = new Decompress();  </div><div class="line">	        d.decompress("C:\\Users\\Administrator\\Desktop\\tes.zip",  </div><div class="line">	                "C:\\Users\\Administrator\\Desktop\\mytes.txt"); </div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/* </div><div class="line">     * 解压思路： </div><div class="line">     * 1、读取文件里面的码表 </div><div class="line">     * 2、得到码表 </div><div class="line">     * 3、读取数据 </div><div class="line">     * 4、还原数据 </div><div class="line">     */  </div><div class="line">      </div><div class="line">    public void decompress(String srcpath,String destpath) &#123;  </div><div class="line">    	   </div><div class="line">        try &#123;  </div><div class="line">            FileInputStream fis = new FileInputStream(srcpath);  </div><div class="line">            FileOutputStream fos = new FileOutputStream(destpath);  </div><div class="line">            int zwl;</div><div class="line">            int value;  </div><div class="line">            int codeLength=0;  </div><div class="line">            String code="";  </div><div class="line">            //还原码表  </div><div class="line">            for (int i = 0; i &lt; codelengths.length; i++) &#123;  </div><div class="line">                value=fis.read();  </div><div class="line">                codelengths[i]=value;  </div><div class="line">             System.out.print(codelengths[i]);  </div><div class="line">                codeLength+=codelengths[i];  </div><div class="line">            &#125;  </div><div class="line">           // System.out.println("总长度:"+codeLength);</div><div class="line">            //得到总长度  </div><div class="line">            //将总长度除以8的到字节个数  </div><div class="line">            int len=codeLength/8;  </div><div class="line">            //如果不是8的倍数，则字节个数加1（对应压缩补0的情况）  </div><div class="line">            if((codeLength)%8!=0)&#123;  </div><div class="line">                len++;  </div><div class="line">            &#125;  </div><div class="line">            //读取哈夫曼编码  </div><div class="line">          System.out.println("codeLength:"+len);  </div><div class="line">            for (int i = 0; i &lt; len; i++) &#123;  </div><div class="line">                //把读到的整数转换成二进制  </div><div class="line">            	int s=fis.read();</div><div class="line">            	System.out.println("int"+s);</div><div class="line">                code+=changeIntToString(s);  </div><div class="line">                  </div><div class="line">            &#125;  </div><div class="line">          System.out.println("哈夫曼编码："+code);  </div><div class="line">              </div><div class="line">            for (int i = 0; i &lt; codeMap.length; i++) &#123;  </div><div class="line">                //如果第i个位置不为0 ，则说明第i个位置存储有哈夫曼编码  </div><div class="line">                if(codelengths[i]!=0)&#123;  </div><div class="line">                    //将得到的一串哈夫曼编码按照长度分割分割  </div><div class="line">                    String ss=code.substring(0, codelengths[i]);  </div><div class="line">                    codeMap[i]=ss;  </div><div class="line">                    System.out.println("huff"+codeMap[i]);</div><div class="line">                    code=code.substring(codelengths[i]);  </div><div class="line">                &#125;else&#123;  </div><div class="line">                    //为0则没有对应的哈夫曼编码  </div><div class="line">                    codeMap[i]="";  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">              </div><div class="line">            //读取压缩的文件内容  </div><div class="line">            String codeContent="";  </div><div class="line">            while(fis.available()&gt;1)&#123;  </div><div class="line">                codeContent+=changeIntToString(fis.read());  </div><div class="line">            &#125;  </div><div class="line">            //读取最后一个  </div><div class="line">            value=fis.read();  </div><div class="line">            //把最后补的0给去掉  </div><div class="line">            codeContent=codeContent.substring(0, codeContent.length()-value);  </div><div class="line">                  </div><div class="line">            for (int i = 0; i &lt; codeContent.length(); i++) &#123;  </div><div class="line">                  </div><div class="line">                String codecontent=codeContent.substring(0, i+1);  </div><div class="line">                  </div><div class="line">                for (int j = 0; j &lt; codeMap.length; j++) &#123;  </div><div class="line">                    if(codeMap[j].equals(codecontent))&#123;  </div><div class="line">                     System.out.println("截取的字符串："+codecontent);  </div><div class="line">                        fos.write(j);  </div><div class="line">                        fos.flush();   </div><div class="line">                        codeContent=codeContent.substring(i+1);  </div><div class="line">                    System.out.println("截取后剩余编码长度："+codeContent.length());  </div><div class="line"> </div><div class="line">                        i=-1;  </div><div class="line">                        break;  </div><div class="line">                    &#125;  </div><div class="line">            &#125;  </div><div class="line">            &#125;  </div><div class="line"></div><div class="line">              </div><div class="line">            fos.close();  </div><div class="line">            fis.close();  </div><div class="line">              </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //十进制转二进制字符串  </div><div class="line">    public String changeIntToString(int value) &#123;  </div><div class="line">        String s="";  </div><div class="line">        for (int i = 0; i &lt; 8; i++) &#123;  </div><div class="line">            s=value%2+s;  </div><div class="line">            value=value/2;  </div><div class="line">        &#125;  </div><div class="line">        return s;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的codelengths[]和codeMap[]就是分别存放码表和码表值的数组，流程就是先读取文本内容，拿到长度表中有长度的编码，如212，然后判断其是多少个字节，然后读哈夫曼编码，根据字节数，转成二进制后，找到对应的码表，然后就是分割编码了，最后就得到我们想要的解码了。最后<br><img src="/images/imgs4/32.gif" alt="Alt text"><br>分别为压缩前，压缩后的，会发现压缩居然比压缩前占得空间还大，那是因为我们压缩的文件太小了，而之前也比较过了，压缩一般都是针对大文件的</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后不得不说哈夫曼树的精妙让人惊叹和着迷，同时也认识到了计算机底层知识的重要性，当你回过头来再去看以前的知识，会有另一种不同的感受，当然当再去看压缩与解压，原来是这么回事。当然探索的过程是很累的，会遇到各种难题和挫折，而在当下这个追求功利主义，很多时候都是表象的去用一些东西，当然有时候你把时间花在一些与收益不是很正相关的上面，可能会让你的性价比不是很高，但是正是由于这种自娱自乐的快乐，才更让人充实，而不是每天都去追求“外功”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;压缩与解压的另一种说法就是，压缩相当于对文件的加密过程，解压相当于对文件的解密过程，比如说，盲-z，僧-w，那么盲僧-zw，当然加密与解密各
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树之构建</title>
    <link href="http://www.myzwl.win/2017/07/30/huffman_1/"/>
    <id>http://www.myzwl.win/2017/07/30/huffman_1/</id>
    <published>2017-07-30T05:48:51.000Z</published>
    <updated>2017-08-13T12:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到哈夫曼树，就不得不说它在压缩与解压方面的应用太完美了，就是把一个大的文件，通过算法压缩成一个较小的文件，从而大大节约了空间</p>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>通俗的说就是给定n个权值作为n个叶子结点，构造一颗二叉树，若带权路径长度达到最小，称这样的树为哈夫曼树，也称为最优二叉树，同时，由定义可知，哈夫曼树是带权路径长度最短的树，所以权值较大的结点离根较近<br><img src="/images/imgs4/17.jpg" alt="Alt text"></p>
<h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><p><strong>路径长度</strong><br>结点路径长度：从树中一个结点到另一个结点之间的分支，构成两个结点之间路径，路径上的分支数目称为结点长度，如结点100到结点29的结点路径长度就是2</p>
<p>树的路径长度：从树根到每一个结点的路径长度之和</p>
<p><strong>权值</strong><br>所有叶子结点的date域，也就是当前叶子结点存放的数据域<br><strong>带权路径长度</strong><br>结点带权路径长度：从该节点到树根之间的路径长度与结点上权值的乘积<br>树的带权路径长度：树中所有结点的带权路径长度之和，并且几位WPL，如果WPL最小，则称该二叉树为哈夫曼树</p>
<p><strong>哈夫曼树构建过程</strong><br>它的构建思想其实很简单的，大概如下<br>1.根据给定的n个权值{w1,w2,..wn}构成n棵二叉树的集合F={T1,T2,..Tn};其中每棵二叉树Ti中只有一个带权为wi的根结点，器左右子树为空<br>2：在F中选取两颗根结点权值最小的树作为左右子树构造一颗新二叉树，并且新二叉树的根结点权值为左右子根结点的权值之和<br>3:在F中删除这两颗树，同时将新二叉树加入F中<br>4:重复2和3步骤，知道F中只含一棵树为止</p>
<h4 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h4><p>哈夫曼结点<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class HuffmNode &#123;</div><div class="line">	//构造HuffmNode类  </div><div class="line">    private int data;  </div><div class="line">    private HuffmNode left;  </div><div class="line">    private HuffmNode right;  </div><div class="line">    //HuffmNode类构造函数  </div><div class="line">    public  HuffmNode(int data) &#123;  </div><div class="line">        this.data=data;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //封装属性  </div><div class="line">    public int getData() &#123;  </div><div class="line">        return data;  </div><div class="line">    &#125;  </div><div class="line">    public void setData(int data) &#123;  </div><div class="line">        this.data = data;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getLeft() &#123;  </div><div class="line">        return left;  </div><div class="line">    &#125;  </div><div class="line">    public void setLeft(HuffmNode left) &#123;  </div><div class="line">        this.left = left;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getRight() &#123;  </div><div class="line">        return right;  </div><div class="line">    &#125;  </div><div class="line">    public void setRight(HuffmNode right) &#123;  </div><div class="line">        this.right = right;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造哈夫曼树<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class HuffmTree &#123;  </div><div class="line">      </div><div class="line">    public int [] datas =&#123;42,8,19,100,58,15,29&#125;;  </div><div class="line">    public LinkedList&lt;HuffmNode&gt; list = new LinkedList&lt;HuffmNode&gt;();  </div><div class="line">      </div><div class="line">    public HuffmNode createTree() &#123;  </div><div class="line">        //按照从小到大的将数据封装成节点  </div><div class="line">        for (int i = 0; i &lt; datas.length; i++) &#123;  </div><div class="line">            HuffmNode node = new HuffmNode(datas[i]);  </div><div class="line">            //得到需要插入的位置索引  </div><div class="line">            int index=getIndex(node);  </div><div class="line">            //将数据添加到容器中  </div><div class="line">            list.add(index, node);  </div><div class="line">        &#125;  </div><div class="line">        //构造哈夫曼树  </div><div class="line">        while(list.size()&gt;1)&#123;  </div><div class="line">            //移除容器中的第一个节点  </div><div class="line">            HuffmNode firstNode =list.removeFirst();  </div><div class="line">            //容器中原来的第二个节点变成新的第一个节点  </div><div class="line">            HuffmNode secondNode =list.removeFirst();  </div><div class="line">            //构造父节点数据域  </div><div class="line">            HuffmNode fatherNode = new HuffmNode(firstNode.getData()+secondNode.getData());  </div><div class="line">            //构造父节点左子叶  </div><div class="line">            fatherNode.setLeft(firstNode);  </div><div class="line">            //构造父节点右子叶  </div><div class="line">            fatherNode.setRight(secondNode);  </div><div class="line">            //得到构造好的父节点的索引  </div><div class="line">            int index=getIndex(fatherNode);  </div><div class="line">            //将父节点加入森林  </div><div class="line">            list.add(index, fatherNode);  </div><div class="line">        &#125;  </div><div class="line">        //返回根节点  </div><div class="line">        return list.getFirst();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //得到索引  </div><div class="line">    public int getIndex(HuffmNode node) &#123;  </div><div class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;  </div><div class="line">            if(node.getData()&gt;list.get(i).getData())&#123;  </div><div class="line">                continue;  </div><div class="line">            &#125;else &#123;  </div><div class="line">                return i;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        //如果比容器中的任何一个数大，则插入最后面  </div><div class="line">        return list.size();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //得到哈夫曼编码  </div><div class="line">    public void getHuffmCode(HuffmNode root,String code) &#123;  </div><div class="line">        if(root.getLeft()!=null)&#123;  </div><div class="line">            getHuffmCode(root.getLeft(),code+"0");  </div><div class="line">        &#125;  </div><div class="line">        if(root.getRight()!=null)&#123;  </div><div class="line">            getHuffmCode(root.getRight(),code+"1");  </div><div class="line">        &#125;  </div><div class="line">        if(root.getLeft()==null &amp;&amp; root.getRight()==null)&#123;  </div><div class="line">            System.out.println(root.getData()+":"+code);  </div><div class="line">        &#125;  </div><div class="line">    &#125;   </div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实这段代码就是上述四个步骤的实现，代码也很好理解，带权值为datas，将结点放到链表中，然后注意利用非正规的选择排序将链表集合里权值从小到大排好序，然后开始选择权值最小的两个构造一个新的权值结点，同时删除那两个，加入这个新的。。重复直到只剩一个根结点为止，很明显此时就是哈夫曼树了，最后通过后序遍历得到哈夫曼编码值，这里我们约定左子树一个路径为0，右子树一个路径为1，所以一定不存在像01与010这样前面是后面子串的编码值<br><strong>测试类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		 HuffmTree tree = new HuffmTree();  </div><div class="line">	        HuffmNode root = tree.createTree();</div><div class="line">	        tree.getHuffmCode(root, ""); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>8:000<br>11:001<br>23:01<br>14:100<br>7:1010<br>3:10110<br>5:10111<br>29:11</p>
</blockquote>
<p>注意这里的结果和图示有一个地方不一样，就是那个几点8，这里的结点8是合成的，可以根据结果画出哈夫曼树，比较就会看出不同</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;说到哈夫曼树，就不得不说它在压缩与解压方面的应用太完美了，就是把一个大的文件，通过算法压缩成一个较小的文件，从而大大节约了空间&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>网络编程简单总结</title>
    <link href="http://www.myzwl.win/2017/07/29/socket_1/"/>
    <id>http://www.myzwl.win/2017/07/29/socket_1/</id>
    <published>2017-07-29T05:48:51.000Z</published>
    <updated>2017-08-12T08:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/images/imgs4/16.jpg" alt="Alt text"><br>在java网络编程中最主要的是tcp/ip协议，这个协议也是Internet最基本的协议，而其就是由网络层的ip协议和传输层的tcp协议组成，同时由于分层的思想，也就是每一层只能与它下面的层打交道，也就是说，应用层只跟传输层打交道，传输层只跟网络层打交道</p>
<h4 id="ip协议"><a href="#ip协议" class="headerlink" title="ip协议"></a>ip协议</h4><p><img src="/images/imgs4/27.gif" alt="Alt text"><br>关于底层协议的具体过程是在太复杂了，当初学习计算机网络的时候也是被各种细节弄得云里雾里的，总之ip层就是唯一确定了一台机器，就像我们住的房间地址一样，唯一确定了我们的住处<br>这里需要注意的是，ip地址由四位字节组成，每个字节由8位二进制组成，同时有a，b，c三类地址，如图由网络号和主机号组成，当然这是公网，如果是局域网的话，就需要配网关和子网掩码了，如192.168.1.1和255.255.0.0那么255.255就是确定了ip地址哪几位字节是网络号，如192.168就是网络号，当然其配置各种内网ip是很复杂的，具体参考计算机网络</p>
<h4 id="TCP与UDP协议"><a href="#TCP与UDP协议" class="headerlink" title="TCP与UDP协议"></a>TCP与UDP协议</h4><p><strong>tcp协议</strong></p>
<blockquote>
<p>它是专门设计用于在不可靠的因特网上提供端到端的字节流通信的协议，它是一种面向连接的协议，它连接的是字节流。<br>这里面有几个注意的地方：<br>可靠性：就是建立三次握手过程，就是说，我把信息传给你，等待，收到回复后，在确认。。最后在发送消息，它保证了数据一定发送给了对方，所以是一种可靠传输，但是遇到阻塞效率会很低<br>端口：ip地址唯一确定了这台机器，相当于一个房子，但是你消息总不能发给整个电脑吧，比如qq，而端口就相当于一间房间，具体发给那个，比如送到qq这间房间</p>
</blockquote>
<p><strong>端口分类</strong></p>
<blockquote>
<p>有65536个端口    0号是保留端口<br>1-1024是固定端口<br>又叫有名端口，即被某些程序固定使用，一般程序员不使用。<br>22：SSH远程登录协议    23：telnet使用    21：ftp使用<br>25：smtp服务使用    80：iis使用    7：echo服务<br>1025-65535是动态端口<br>这些端口，程序员可以使用<br>端口(port)–注意事项<br>1、在计算机(尤其是做服务器)要尽可能的少开端口；<br>2、一个端口只能被一个程序监听；<br>3、如果使用netstat -an可以查看本机有哪些端口在监听</p>
</blockquote>
<p><strong>UDP协议</strong><br>UDP向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接。<br>简单来说，就是只发一次数据，不管对方有没有接收到都不会再发了，但是有时候效率会很高，像网络拥堵时</p>
<p><strong>url</strong><br>统一资源定义符也被称为网页地址。Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL地址，这种地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是Internet上的站点，简单地说，URL就是Web地址，俗称“网址”，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法，如：<br><a href="http://www.sina.com:8080/index.html" target="_blank" rel="external">http://www.sina.com:8080/index.html</a><br>1、协议；2、ip地址(32位)；3、端口号(16位)0-65535；4、资源名称。</p>
<p><strong>单工、半双工和全双工</strong><br> 如果甲可以向乙发送数据，但是乙不能向甲发送数据，这样的通信就是单工通信(Simplex Communication)。<br>    单工数据传输只支持数据在一个方向上传输，就和传呼机一样。<br>    半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信，就和对讲机(步话机)一样；<br>全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力，就和电话一样</p>
<h4 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h4><p><img src="/images/imgs4/28.gif" alt="Alt text"><br>如模拟的客户端与服务端<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class MyServer &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new MyServer();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyServer()&#123;</div><div class="line">		try &#123;</div><div class="line">			//在9999号端口上监听</div><div class="line">			ServerSocket ss=new ServerSocket(9999);</div><div class="line">			System.out.println("9999端口监听...");</div><div class="line">			//等待某个客户端来连接，该函数会返回一个Socket连接</div><div class="line">			Socket s=ss.accept();</div><div class="line">			//要读取s中传递的数据</div><div class="line">			InputStreamReader isr=new InputStreamReader(s.getInputStream());</div><div class="line">			BufferedReader br=new BufferedReader(isr);</div><div class="line">			</div><div class="line">			String info=br.readLine();</div><div class="line">			System.out.println("服务器接收到:\t"+info);</div><div class="line">			</div><div class="line">			PrintWriter pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			pw.println("我是服务器，已收到你发送的信息!");</div><div class="line"></div><div class="line"></div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class MyClient &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new MyClient();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyClient()&#123;</div><div class="line">		try &#123;</div><div class="line">			//Socket()就是去连接某个服务器端 127.0.0.1表示服务器的ip</div><div class="line">			//9999是服务器的端口号</div><div class="line">			Socket s=new Socket("127.0.0.1",9999);</div><div class="line">			//如果s连接成功，就可以发送数据到服务器端</div><div class="line">			//我们通过pw向s写数据,true表示即时刷新</div><div class="line">			PrintWriter pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			pw.println("你好吗？我是客户端");</div><div class="line">			//要读取s中传递的数据</div><div class="line">			InputStreamReader isr=new InputStreamReader(s.getInputStream());</div><div class="line">			BufferedReader br=new BufferedReader(isr);</div><div class="line">			String info=br.readLine();</div><div class="line">			System.out.println("接收到服务器：\t"+info);</div><div class="line"></div><div class="line"></div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要注意的几个地方，必须是服务端先开启，然后accept（）等待客户端，没有客户端连接，它将处于阻塞状态，一旦有了客户端它将回应，其次这是理由tcp实现的，UDP实现用java提供的另外类，最后这里有一个问题，就是只能接受一次，需要改进，也就是不断循环接收客户端连接</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">			//在9999号端口上监听</div><div class="line">			ServerSocket ss=new ServerSocket(9999);</div><div class="line">			//等待客户端连接，该函数会返回一个Socket连接</div><div class="line">			Socket s=ss.accept();</div><div class="line">			//要读取s中传递的数据</div><div class="line">			isr=new InputStreamReader(s.getInputStream());</div><div class="line">			br=new BufferedReader(isr);</div><div class="line">			</div><div class="line">			pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			</div><div class="line">			//接收从控制台输入的信息</div><div class="line">			isr2=new InputStreamReader(System.in);</div><div class="line">			br2=new BufferedReader(isr2);</div><div class="line">			while(true)&#123;</div><div class="line">				//接收客户端信息</div><div class="line">				String infoFromClient=br.readLine();</div><div class="line">				System.out.println("服务器接收到:\t"+infoFromClient);</div><div class="line">				//接收从控制台输入的信息</div><div class="line">				System.out.println("请输入要发送到客户端的信息：");</div><div class="line">				String response=br2.readLine();</div><div class="line">				//服务器从控制台上接收bye服务器端退出</div><div class="line">				if(response.equals("bye"))&#123;</div><div class="line">					System.out.println("退出对话");</div><div class="line">					s.close();</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">				//把从控制台输入的信息，回送给客户端</div><div class="line">				pw.println(response);</div><div class="line">			&#125;</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;finally&#123;</div><div class="line">			try &#123;</div><div class="line">				if(br2!=null) br2.close();</div><div class="line">				if(isr2!=null) isr2.close();</div><div class="line">				if(pw!=null) pw.close();</div><div class="line">				if(br!=null) br.close();</div><div class="line">				if(isr!=null) isr.close();</div><div class="line">			&#125; catch (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>最后当然网络编程中也就是流的数据传送的应用，也不得不说网络底层协议其实很复杂的，只有当我们有精力了，再去细细研究它，才会有更多的收获</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/imgs4/16.jpg&quot; alt=&quot;Alt text&quot;&gt;&lt;br&gt;在java网络编程中最主要的是tcp/
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="http://www.myzwl.win/2017/07/28/balace_1/"/>
    <id>http://www.myzwl.win/2017/07/28/balace_1/</id>
    <published>2017-07-28T05:48:51.000Z</published>
    <updated>2017-08-12T07:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AVL树，也叫平衡二叉树，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。同时，将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，还将距离插入结点最近的且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树<br><img src="/images/imgs4/25.gif" alt="Alt text"><br>如图：一为一个不平衡二叉排序树，显然时间复杂度较大，二为改进后的平衡二叉树，而在改进的过程中，最重要的就是通过平衡因子来判断是进行左旋还是右旋，如右旋，新增一个节点N后，平衡被打破，需要平衡因子2大于0，需要右旋，就是将其左子树作为根结点，左子树的右子树作为原根结点的左子树，这样做的原因就是根据二叉排序树的左右子树特点来的，很容易想明白</p>
<h4 id="模拟平衡二叉树"><a href="#模拟平衡二叉树" class="headerlink" title="模拟平衡二叉树"></a>模拟平衡二叉树</h4><p>不妨构造一个a[10]={3,2,1,4,5,6,7,10,9,8};<br><img src="/images/imgs4/26.gif" alt="Alt text"><br>大概过程如图所示，其中最重要的就是平衡因子的判断，如果是同号，且绝对值大于1的话，就要做相应的旋转操作，如果是不同号的话，就要通过旋转先转换成同号，在做操作</p>
<h4 id="左右旋操作"><a href="#左右旋操作" class="headerlink" title="左右旋操作"></a>左右旋操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">typedef struct BiTNode</div><div class="line">&#123;</div><div class="line">	int data;</div><div class="line">	int bf;</div><div class="line">	struct BiTNode *lchild,*rchild;</div><div class="line">&#125;BiTNode,*BiTree;</div><div class="line"></div><div class="line">//左旋处理</div><div class="line">void R_Rotate(BiTree *p)&#123;</div><div class="line">	BiTree L;</div><div class="line">	L=(*p)-&gt;lchild;   //L指向p的左子树根结点</div><div class="line">	(*p)-&gt;lchild=L-&gt;rchild; //L的右子树挂接为p的左子树</div><div class="line">	L-&gt;rchild=(*p);  </div><div class="line">	*p=L;           //p指向新的根结点</div><div class="line">&#125;</div><div class="line"></div><div class="line">//右旋处理</div><div class="line">void L_Ronate(BiTree *p)</div><div class="line">&#123;</div><div class="line">	BiTree R;</div><div class="line">	R=(*p)-&gt;rchild; //R指向p的右子树根结点</div><div class="line">	(*p)-&gt;rchild=R-&gt;lchild;  //R的左子树挂接为P的右子树</div><div class="line">	R-&gt;lchild=(*p);</div><div class="line">	*p=R;            //p指向新的根结点</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过之前的图来对比看，其实质也就是交互根结点位置和挂接新左右子树</p>
<h4 id="左右平衡旋转"><a href="#左右平衡旋转" class="headerlink" title="左右平衡旋转"></a>左右平衡旋转</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#define LH +1 /*  左高 */ </div><div class="line">#define EH 0  /*  等高 */ </div><div class="line">#define RH -1 /*  右高 */ </div><div class="line"></div><div class="line">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */</div><div class="line">/*  本算法结束时，指针T指向新的根结点 */</div><div class="line">void LeftBalance(BiTree *T)</div><div class="line">&#123; </div><div class="line">	BiTree L,Lr;</div><div class="line">	L=(*T)-&gt;lchild; /*  L指向T的左子树根结点 */ </div><div class="line">	switch(L-&gt;bf)</div><div class="line">	&#123; /*  检查T的左子树的平衡度，并作相应平衡处理 */ </div><div class="line">		 case LH: /*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */ </div><div class="line">			(*T)-&gt;bf=L-&gt;bf=EH;</div><div class="line">			R_Rotate(T);</div><div class="line">			break;</div><div class="line">		 case RH: /*  新结点插入在T的左孩子的右子树上，要作双旋处理 */ </div><div class="line">			Lr=L-&gt;rchild; /*  Lr指向T的左孩子的右子树根 */ </div><div class="line">			switch(Lr-&gt;bf)</div><div class="line">			&#123; /*  修改T及其左孩子的平衡因子 */ </div><div class="line">				case LH: (*T)-&gt;bf=RH;</div><div class="line">						 L-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case EH: (*T)-&gt;bf=L-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case RH: (*T)-&gt;bf=EH;</div><div class="line">						 L-&gt;bf=LH;</div><div class="line">						 break;</div><div class="line">			&#125;</div><div class="line">			Lr-&gt;bf=EH;</div><div class="line">			L_Rotate(&amp;(*T)-&gt;lchild); /*  对T的左子树作左旋平衡处理 */ </div><div class="line">			R_Rotate(T); /*  对T作右旋平衡处理 */ </div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */ </div><div class="line">/*  本算法结束时，指针T指向新的根结点 */ </div><div class="line">void RightBalance(BiTree *T)</div><div class="line">&#123; </div><div class="line">	BiTree R,Rl;</div><div class="line">	R=(*T)-&gt;rchild; /*  R指向T的右子树根结点 */ </div><div class="line">	switch(R-&gt;bf)</div><div class="line">	&#123; /*  检查T的右子树的平衡度，并作相应平衡处理 */ </div><div class="line">	 case RH: /*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */ </div><div class="line">			  (*T)-&gt;bf=R-&gt;bf=EH;</div><div class="line">			  L_Rotate(T);</div><div class="line">			  break;</div><div class="line">	 case LH: /*  新结点插入在T的右孩子的左子树上，要作双旋处理 */ </div><div class="line">			  Rl=R-&gt;lchild; /*  Rl指向T的右孩子的左子树根 */ </div><div class="line">			  switch(Rl-&gt;bf)</div><div class="line">			  &#123; /*  修改T及其右孩子的平衡因子 */ </div><div class="line">				case RH: (*T)-&gt;bf=LH;</div><div class="line">						 R-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case EH: (*T)-&gt;bf=R-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case LH: (*T)-&gt;bf=EH;</div><div class="line">						 R-&gt;bf=RH;</div><div class="line">						 break;</div><div class="line">			  &#125;</div><div class="line">			  Rl-&gt;bf=EH;</div><div class="line">			  R_Rotate(&amp;(*T)-&gt;rchild); /*  对T的右子树作右旋平衡处理 */ </div><div class="line">			  L_Rotate(T); /*  对T作左旋平衡处理 */ </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="插入与主函数"><a href="#插入与主函数" class="headerlink" title="插入与主函数"></a>插入与主函数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */ </div><div class="line">/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */ </div><div class="line">/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */</div><div class="line">Status InsertAVL(BiTree *T,int e,Status *taller)</div><div class="line">&#123;  </div><div class="line">	if(!*T)</div><div class="line">	&#123; /*  插入新结点，树“长高”，置taller为TRUE */ </div><div class="line">		 *T=(BiTree)malloc(sizeof(BiTNode));</div><div class="line">		 (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=NULL; (*T)-&gt;bf=EH;</div><div class="line">		 *taller=TRUE;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if (e==(*T)-&gt;data)</div><div class="line">		&#123; /*  树中已存在和e有相同关键字的结点则不再插入 */ </div><div class="line">			*taller=FALSE; return FALSE;</div><div class="line">		&#125;</div><div class="line">		if (e&lt;(*T)-&gt;data)</div><div class="line">		&#123; /*  应继续在T的左子树中进行搜索 */ </div><div class="line">			if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) /*  未插入 */ </div><div class="line">				return FALSE;</div><div class="line">			if(taller) /*   已插入到T的左子树中且左子树“长高” */ </div><div class="line">				switch((*T)-&gt;bf) /*  检查T的平衡度 */ </div><div class="line">				&#123;</div><div class="line">					case LH: /*  原本左子树比右子树高，需要作左平衡处理 */ </div><div class="line">							LeftBalance(T);	*taller=FALSE; break;</div><div class="line">					case EH: /*  原本左、右子树等高，现因左子树增高而使树增高 */ </div><div class="line">							(*T)-&gt;bf=LH; *taller=TRUE; break;</div><div class="line">					case RH: /*  原本右子树比左子树高，现左、右子树等高 */  </div><div class="line">							(*T)-&gt;bf=EH; *taller=FALSE; break;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123; /*  应继续在T的右子树中进行搜索 */ </div><div class="line">			if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) /*  未插入 */ </div><div class="line">				return FALSE;</div><div class="line">			if(*taller) /*  已插入到T的右子树且右子树“长高” */ </div><div class="line">				switch((*T)-&gt;bf) /*  检查T的平衡度 */ </div><div class="line">				&#123;</div><div class="line">					case LH: /*  原本左子树比右子树高，现左、右子树等高 */ </div><div class="line">							(*T)-&gt;bf=EH; *taller=FALSE;	break;</div><div class="line">					case EH: /*  原本左、右子树等高，现因右子树增高而使树增高  */</div><div class="line">							(*T)-&gt;bf=RH; *taller=TRUE; break;</div><div class="line">					case RH: /*  原本右子树比左子树高，需要作右平衡处理 */ </div><div class="line">							RightBalance(T); *taller=FALSE; break;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	int i;</div><div class="line">	int a[10]=&#123;3,2,1,4,5,6,7,10,9,8&#125;;</div><div class="line">	BiTree T=NULL;</div><div class="line">	Status taller;</div><div class="line">	for(i=0;i&lt;10;i++)</div><div class="line">	&#123;</div><div class="line">		InsertAVL(&amp;T,a[i],&amp;taller);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后不得不说，AVL树是在是太复杂了，但是其思想是在是太精妙了，它克服了二叉排序树在查找效率上的不足，通过在插入数据时，就将其变成一个平衡二叉树，从而使其时间复杂度为O(logn)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;AVL树，也叫平衡二叉树，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。同时，将二叉树上结点的左子树深度减去右子树深度
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="http://www.myzwl.win/2017/07/27/BSTSort_1/"/>
    <id>http://www.myzwl.win/2017/07/27/BSTSort_1/</id>
    <published>2017-07-27T05:48:51.000Z</published>
    <updated>2017-08-12T05:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>二叉排序树，又称为二分查找树，它或者是一颗空树，或者具有如下性质<br>1.若它的左子树不为空，则左子树上所有结点的值均小于根结点值<br>2.若它的右子树不为空，则右子树上所有结点的值均小于根结点值<br>3.它的左右子树也分别为二叉排序树<br><img src="/images/imgs4/23.gif" alt="Alt text"></p>
<h4 id="二叉排序树查找操作"><a href="#二叉排序树查找操作" class="headerlink" title="二叉排序树查找操作"></a>二叉排序树查找操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">typedef struct BiTNode</div><div class="line">&#123;</div><div class="line">	int data;</div><div class="line">	struct BiTNode *lchild,*rchild;</div><div class="line">&#125;BiTNode,*BiTree;</div><div class="line"></div><div class="line"></div><div class="line">//递归查找二叉排序树中是否存在key</div><div class="line">//f指向T的双亲，初始值为NULL</div><div class="line">//若查找成功，则p指向该节点，并返回true</div><div class="line">//若查找失败，则p指向查找路径上访问的最后一个结点，并返回FALSE</div><div class="line">Status SearchBST(BiTree T,int key,BiTree f,BiTree *p)</div><div class="line">&#123;</div><div class="line">	if(!T)     //查找不成功</div><div class="line">	&#123;</div><div class="line">		*p=f;</div><div class="line">		return FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	else if(key==T-&gt;data) //查找成功</div><div class="line">	&#123;</div><div class="line">		*p=T;</div><div class="line">		return TRUE;</div><div class="line">	&#125;</div><div class="line">	else if(key&gt;T-&gt;data)&#123;         //在右子树中递归查找</div><div class="line">		return SearchBST(T-&gt;rchild,key,T,p);</div><div class="line">	&#125;</div><div class="line">	else if(key&lt;T-&gt;data)          //在左子树中递归查找</div><div class="line">		return SearchBST(T-&gt;lchild,key,T,p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看看它的过程是如何运行的，比如现在要查找93，显然初始化为SearchBST(T,93,NULL,p),因为93&gt;62，所以递归执行SearchBST(T-rchild,93,T,p),即SearchBST(88,93,62,P)这里用结点data值表示结点，又93&gt;88,继续SearchBST(99,93,88,P)，又93&lt;99，SearchBST(93,93,99,P)，所以93==93，得到最终p=T=93，f=99，查找成功。<br>可以发现二叉排序树的查找算法如此精妙而又优雅</p>
<h4 id="二叉排序树的插入操作"><a href="#二叉排序树的插入操作" class="headerlink" title="二叉排序树的插入操作"></a>二叉排序树的插入操作</h4><p>插入操作是基于查找操作的，也就是如果该二叉树为空，则新插入点为根结点，如果不为空，在先查找是否存在此元素，存在返回FALSE，否则在查找路径上的最后一个结点，通过比较插入到左孩子还是右孩子，最终返回TRUE<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Status InsertBST(BiTree *T,int key)</div><div class="line">&#123;</div><div class="line">	BiTree p,s;</div><div class="line">	if(!SearchBST(T,key,NULL,&amp;p)) //查找不成功</div><div class="line">	&#123;</div><div class="line">		s=(BiTree)malloc(sizeof(BiTNode));</div><div class="line">		 s-&gt;data=key;</div><div class="line">		 s-&gt;lchild=s-&gt;rchild=NULL;</div><div class="line">		 if(!p)                    //插入s为新的根结点</div><div class="line">		 	*T=s;</div><div class="line">		 else if(key&lt;s-data)      //插入s为左孩子</div><div class="line">		 	p-&gt;lchild=s;</div><div class="line">		 else                     //插入s为右孩子</div><div class="line">		 	p-&gt;rchild=s;</div><div class="line">		 return TRUE;</div><div class="line">	&#125;</div><div class="line">	else                       //树中已存在此关键字，则不插入</div><div class="line">		return FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="二叉排序树的删除操作"><a href="#二叉排序树的删除操作" class="headerlink" title="二叉排序树的删除操作"></a>二叉排序树的删除操作</h4><p>删除操作需要考虑三种情况，因为删除之后要保证还是一颗二叉排序树。如图<br><img src="/images/imgs4/24.gif" alt="Alt text"><br>一：删除叶子结点，这对这个二叉树来说并无影响，所以不移动其它元素<br>二：删除只含有左子树或者右子树的二叉排序树，因为根据二叉排序树的特点，很明显只要将它的左子树或右子树全部移动到它双亲的左子树或右子树就行了<br>三：删除既有左子树又有右子树的结点，我们可以通过它的中序遍历，也就是让它的直接前驱或者直接后继来替换它的位置，然后直接后继在分三种情况，直至只有一个孩子或者无孩子来替换<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">Status DeleteBST(BiTree *T,int key) //找到待删结点</div><div class="line">&#123;</div><div class="line">	if(!*T)</div><div class="line">		return FALSE;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if(key==(*T)-&gt;data)</div><div class="line">			return Delete(T);</div><div class="line">		else if(key&lt;(*T)-&gt;data)</div><div class="line">			return DeleteBST(&amp;(*T)-&gt;lchild,key);</div><div class="line">		else</div><div class="line">			return DeleteBST(&amp;(*T)-&gt;rchild,key);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//从二叉树中删除结点p，并重接它的左或右子树</div><div class="line">Status Delete(BiTree *p)</div><div class="line">&#123;</div><div class="line">	BiTree q,s;</div><div class="line">	if((*p)-&gt;rchild==NULL)  //右子树空则重接它的左子树</div><div class="line">	&#123;</div><div class="line">		q=*p;</div><div class="line">		*p=(*p)-&gt;lchild;</div><div class="line">		free(q);</div><div class="line">	&#125;</div><div class="line">	else if((*p)-&gt;lchild==NULL) //左子树空则重接它的右子树</div><div class="line">	&#123;</div><div class="line">		q=*p;</div><div class="line">		*p=(*p)-&gt;rchild;</div><div class="line">		free(q);</div><div class="line">	&#125;</div><div class="line">	else&#123;         //左右子树均不为空</div><div class="line">		q=*p;</div><div class="line">		s=(*p)-&gt;lchild;</div><div class="line">		while(s-&gt;lchild) //找到待删结点的前驱</div><div class="line">		&#123;</div><div class="line">			q=s;</div><div class="line">			s=s-&gt;rchild;</div><div class="line">		&#125;</div><div class="line">		(*p)-&gt;data=s-&gt;data;</div><div class="line">		if(q!=*p)        //重接q的右子树</div><div class="line">			q-&gt;rchild=s-&gt;lchild;</div><div class="line">		else             //重接q的左子树</div><div class="line">			q-&gt;lchild=s-&gt;lchild;</div><div class="line">		free(s);</div><div class="line">	&#125;</div><div class="line">	return TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>二叉排序树是以链式结构进行存储，所以在插入和删除元素上高效，，但是查找上走的是从根路径到结点的路径，其比较次数与数的层数有关如果该数是一颗斜数，那么查找就会比较很多次，如果该树是一颗完全二叉树，那么比较次数就最优，此时时间复杂度为O(logn),但是平均来说时间复杂度为O(n)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;二叉排序树，又称为二分查找树，它或者是一颗空树，或者具有如下性质&lt;br&gt;1.若它的左子树不为空，则左子树上所有结点的值均小于根结点值&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>死锁和生产者消费者问题</title>
    <link href="http://www.myzwl.win/2017/07/26/procos_1/"/>
    <id>http://www.myzwl.win/2017/07/26/procos_1/</id>
    <published>2017-07-26T05:48:51.000Z</published>
    <updated>2017-08-10T08:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>线程同步操作的是同一个线程对象，所以可能造成线程不安全，出现非数据的原子操作，所以，需要加锁，同时线程是程序的执行顺序，也就是cpu根据不同时间片选择某个时间执行某个线程，关于线程并发，在以前的总结中做过了几个简单的总结。<br>而死锁最经典的例子就是哲学家进餐问题，每个哲学家都左手拿着一只筷子，并且总共有五个哲学家，5个筷子，只有当哲学家左右手都有筷子时才能进餐，所以每个哲学家都在等右边哲学家方上筷子，处于僵持等待状态，称为死锁。<br>这里模仿两个线程死锁的情况<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class LockTest implements Runnable&#123;</div><div class="line"></div><div class="line">	public int flag=1;</div><div class="line">	 static Object o1=new Object(),o2=new Object();</div><div class="line">	   </div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println("flag="+flag);</div><div class="line">		 if(flag==1)&#123;</div><div class="line">		 synchronized (o1) &#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(5000);</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			synchronized (o2) &#123;</div><div class="line">				System.out.println("1");</div><div class="line">			&#125;</div><div class="line">		 &#125;	 </div><div class="line">		&#125;</div><div class="line">		if(flag==0)&#123;</div><div class="line">			 synchronized (o2) &#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(5000);</div><div class="line">					&#125; catch (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					synchronized (o1) &#123;</div><div class="line">						System.out.println("0");</div><div class="line">					&#125;</div><div class="line">				 &#125;	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LockTest lt1=new LockTest();</div><div class="line">		LockTest lt2=new LockTest();</div><div class="line">		 lt1.flag=1;</div><div class="line">		 lt2.flag=0;</div><div class="line">		  Thread t1=new Thread(lt1);</div><div class="line">		  Thread t2=new Thread(lt2);</div><div class="line">		  t1.start();</div><div class="line">		  t2.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>flag=1<br>flag=0</p>
</blockquote>
<p>大概分析一下，该类本身是一个线程类，flag用来控制执行哪个锁，O1和O2是两个被锁住对象，flag为1时先锁住o1，在锁住o2，flag为0则相反，而死锁发生就在此处两个线程启动了，o1被锁住了，另一个o2被锁住了，都在等待对方释放锁，显然处于僵持，产生死锁，<br>解决死锁的一个简单办法就是增大锁的粒度，扩大锁对象，比如讲前面的O1与O2改成this<br>结果：</p>
<blockquote>
<p>flag=1<br>flag=0<br>1<br>0</p>
</blockquote>
<h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><p>概述，模拟一个生产者利用生产食物放到篮子里，而一个消费者从篮子里消费食物<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">public class Food &#123; //食物类</div><div class="line"> int id;</div><div class="line"> public Food(int id)&#123;</div><div class="line">	 this.id=id;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class UtilStack &#123;//工具，用来放食物</div><div class="line"></div><div class="line">	int index=0; //食物计数变量</div><div class="line">	Food[] arrFD=new Food[4]; //最多工具能放食物容量</div><div class="line">	</div><div class="line">	public synchronized void push(Food fd)&#123; //生产食物，必须加锁，保证生产过程不被打断</div><div class="line">		while(index==arrFD.length)</div><div class="line">		&#123;</div><div class="line">			try &#123;</div><div class="line">				System.out.println("full");</div><div class="line">				this.wait();  //生产满了，就去休息区休息，等待被唤醒</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		this.notify();//唤醒当前在休息区的线程</div><div class="line">		arrFD[index]=fd;</div><div class="line">		index++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public synchronized Food pop()&#123; //消费</div><div class="line">		while(index==0) //消费完了，进休息区</div><div class="line">			try &#123;</div><div class="line">				System.out.println("empty");</div><div class="line">				this.wait();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		this.notify();</div><div class="line">		index--;</div><div class="line">		return arrFD[index];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Producer implements Runnable&#123;//生产者</div><div class="line"></div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Producer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=new Food(i);</div><div class="line">			ss.push(fd);</div><div class="line">			System.out.println("生产了"+fd.id);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(1000);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Consumer implements Runnable&#123;//消费者</div><div class="line"></div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Consumer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=ss.pop();</div><div class="line">			System.out.println("消费了"+fd.id);</div><div class="line">		 try &#123;</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>消费利用一对生产者和消费者模拟</p>
<blockquote>
<pre><code>UtilStack ss=new UtilStack();
    Producer p=new Producer(ss);
    Consumer c=new Consumer(ss);
    new Thread(p).start();
    new Thread(c).start();
</code></pre></blockquote>
<p>结果如下：</p>
<blockquote>
<p>生产了0<br>消费了0<br>生产了1<br>生产了2<br>消费了2<br>生产了3<br>生产了4<br>消费了4<br>生产了5<br>生产了6<br>消费了6<br>生产了7<br>full<br>消费了7<br>生产了8<br>full<br>消费了8<br>生产了9<br>full<br>消费了9<br>生产了10<br>full<br>消费了10<br>生产了11<br>full<br>消费了11<br>生产了12<br>full<br>消费了12<br>生产了13<br>full<br>消费了13<br>生产了14<br>full<br>消费了14<br>生产了15<br>full</p>
</blockquote>
<p>这里优于设置了消费者消费时间长，所以导致index不一样。可以发现当生产者满了，生产者不生产了，进入休息区，等待被唤醒，关于wait（）、notify（）、notifyAll（），在之前的多线程总结中已总结了</p>
<p><strong>结果分析</strong><br>从中我们可以看到生产者有满了的情况，但是消费者消费完了，index就不满了，然后就去叫醒了生产者继续生产，同样如果我们把消费者时间设置短一点看看，预测应该是empty的，在被生产者叫醒</p>
<blockquote>
<p>生产了0<br>消费了0<br>empty<br>消费了1<br>生产了1<br>empty<br>消费了2<br>生产了2<br>empty<br>消费了3<br>生产了3<br>empty<br>生产了4<br>消费了4<br>empty</p>
</blockquote>
<p>最后不得不说生产者与消费者问题可以解决平时在项目开发配置中不求甚解的一些问题，像缓冲区、连接池、消息队列、死锁、同步等等，</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h4&gt;&lt;p&gt;线程同步操作的是同一个线程对象，所以可能造成线程不安全，出现非数据的原子操作，所以，需要加锁，同时线程是程序的执行顺序，也就是cpu根据不同
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://www.myzwl.win/2017/07/25/quick_1/"/>
    <id>http://www.myzwl.win/2017/07/25/quick_1/</id>
    <published>2017-07-25T05:48:51.000Z</published>
    <updated>2017-08-10T04:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速排序被列为20世纪十大算法之一，正如其名一样，排序的速度非常快。<br>而它的基本思想就是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续排序，最终达到有序的目的<br><img src="/images/imgs4/22.gif" alt="Alt text"></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>采取同样的策略，从计算机的角度看看程序是怎么执行的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void QuickSort(SqList *L)&#123;</div><div class="line">  QSort(L,1,L-&gt;length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void QSort(SqList *L,int low,int high)&#123;</div><div class="line">  int pivot;</div><div class="line">   if(low&lt;high)&#123;</div><div class="line">    pivot=Partition(L,low,high);//将L-&gt;r[low..high]一分为二</div><div class="line">     QSort(L,low,pivor-1); //对低子表递归排序</div><div class="line">      QSort(L,pivot+1,high); //对高子表递归排序</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>里面有个函数Partition(L,low,high),和归并排序一样，暂时先不管它，初始化数组为{50,10,90,30,70,40,80,60,20}，初始low=1，high=9；<br>pivot为选择其中一个关键字，比pivot小的排到左边，比pivot大的排到右边，显然此时pivot=5，然后执行 QSort(L，1,4）直至排好序，同样右边也是递归调用QSort（L，6,9），这里的核心算法也就是Partition(L,low,high)如何排序的了<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int Partition(SqList *L,int low,int high)&#123;</div><div class="line">  int pivotkey;</div><div class="line">   pivotkey=L-&gt;[low]; //用子表的第一个记录做关键字</div><div class="line">    while(low&lt;high)</div><div class="line">    &#123;</div><div class="line">      while(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</div><div class="line">        high--;</div><div class="line">      swap(L,low,high);//交换low和high的记录</div><div class="line">      while(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</div><div class="line">         low++;</div><div class="line">       swap(L,low,high);</div><div class="line">    &#125;</div><div class="line">    return low;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样一行一行的看，这里默认选取子表的第一个记录作为关键字pivotkey=L-&gt;[low];接下来，由于low=1<high=9，执行内部程序，然后比较l->r[high]=L-&gt;r[9]=20与pivotkey=50大小，显然前者小于后者，不满足，将high与low交换，也就是说小的在左边，此时为{20,10,90.。。50},；然后明显20<50，所以low++；得low=2；并且10<50，在循环，得low=3，此时90>50,退出循环，在此交换位置，得{20,10,50.。。。90}；<br>最后low=3<9在循环，90>50,满足，high–，high=8，有L-&gt;high[8]=60&gt;50;high–;有80&gt;50;high–,有40&lt;50,退出循环，此时high=6，交换，依次类推，最终low=high=5，退出整个循环<br>最后在分别递归低和高的子表，最后我们发现他的规律如此只简单，遇到比关键字小的，依次递增比较，直到有比它大的，在换另一边比较，不得不说快速排序实在是太精妙了</9在循环，90></50，所以low++；得low=2；并且10<50，在循环，得low=3，此时90></high=9，执行内部程序，然后比较l-></p>
<p>最后再来看一下快速排序的时间复杂度，在最优的情况下为O（nlogn);</p>
<h4 id="排序算法间的比较"><a href="#排序算法间的比较" class="headerlink" title="排序算法间的比较"></a>排序算法间的比较</h4><p><img src="/images/imgs4/2.png" alt="Alt text"><br>分类<br><img src="/images/imgs4/15.jpg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;快速排序被列为20世纪十大算法之一，正如其名一样，排序的速度非常快。&lt;br&gt;而它的基本思想就是通过一趟排序将待排序的记录分割成独立的两部分，
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://www.myzwl.win/2017/07/24/guibin_1/"/>
    <id>http://www.myzwl.win/2017/07/24/guibin_1/</id>
    <published>2017-07-24T05:48:51.000Z</published>
    <updated>2017-08-10T08:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>归并的意思就是将两个或者两个以上的有序数组合成一个有序表。而归并排序就是将含有n个记录的子序列，每个子序列长度为1，然后两两归并，得到[n/2]个长度为2或者1的有序子序列，在两两归并，。。。。，如此重复，直到得到一个长度为n的有序序列为止<br><img src="/images/imgs4/14.jpg" alt="Alt text"></p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>不妨先看代码，在从计算机角度去看看是如何执行代码过程的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void MergeSort(SqList *L)&#123;</div><div class="line">  MSort(L-&gt;r,L-&gt;r,1,L-&gt;length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//将SR[s..t]归并到TR1[s..t]</div><div class="line">void MSort(int SR[],int TR1[],int s,int t)&#123;</div><div class="line">  int m;</div><div class="line">  int TR2[MAXSIZE+1];</div><div class="line">  if(s==t)</div><div class="line">    TR1[s]=SR[s];</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    m=(s+t)/2;</div><div class="line">    MSort(SR,TR2,s,m);</div><div class="line">    MSort(SR,TR2,m+1,t);</div><div class="line">    Merge(TR2,TR1,s,m,t);//将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>里面有个递归 Merge(TR2,TR1,s,m,t);暂时先不管它，假设模拟的数组为{50,10,90,30,70,40,80,60,20}，所以知道初始化时SR和TR1都是该数组，s=1，t-9；由于s！=t，所以执行else中的语句。此时m=5，也就是正中间下标，所以开始先执行递归MSort(SR,TR2,1,5)，递归过程如下所示<br><img src="/images/imgs4/21.gif" alt="Alt text"><br>其核心部分就是最后都变成叶子结点，递归结束，然后执行if里语句，不过此时TR1[s]=SR[s]，注意这里s是元素下标，所以第一次TR2={50,10}，然后就要执行Merge(TR2,TR1,s,m,t);前面是50与10已结归并了，暂时我们知道它就是把无需归并为有序就行了，即TR2={10,50}后面在详细分析它，<br>接下来同理，依次向上归并，最后得到{10,30,50,70,90}，同理，根结点右子树也一样，最终完成了归并</p>
<p>再来看看Merge(TR2,TR1,s,m,t)函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void Merge(int SR[],int TR[],int i,int m,int n)</div><div class="line">&#123;</div><div class="line">  int j,k,l;</div><div class="line">   for(j=m+1,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++)</div><div class="line">   &#123;</div><div class="line">    if(SR[i]&lt;SR[j])</div><div class="line">      TR[k]=SR[i++];</div><div class="line">    else</div><div class="line">      TR[k]=SR[j++];</div><div class="line">   &#125;</div><div class="line">   if(i&lt;=m)&#123;  //将剩余元素归并</div><div class="line">    for(l=0;l&lt;=m-1;l++)</div><div class="line">      TR[k+1]=SR[i+1];</div><div class="line">  &#125;</div><div class="line"> if(j&lt;=n)</div><div class="line"> &#123;</div><div class="line">  for(l=0;l&lt;n-j;l++)</div><div class="line">    TR[k+1]=SR[j+1];</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就拿{10,30,50,70,90}和{20,40,60,80}归并为有序序列来说，此时i=1，m=5,n=9；进入for循环，此时j从6到9，i由1到5，k由1开始每次加1，并且k就是TR数组的下标，然后开始归并，左右子树的SR[i]=SR[1]=10与SR[j]=SR[6]=20开始比较，将较小数放入到一个初始化时空的TR[]中，比如是10，然后i++；否则j++，这样就可以得到有序序列了，但是最终当j=10时退出循环，而后面还有一些元素未归并，将执行后面if语句，将最后的90复制到最后，最终完成了归并</p>
<p>最后再来看看归并排序的时间复杂度，由于其与完全二叉树有关，最终得到其为O（nlogn)，而它也是比较占用内存但是很稳定的一种算法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;归并的意思就是将两个或者两个以上的有序数组合成一个有序表。而归并排序就是将含有n个记录的子序列，每个子序列长度为1，然后两两归并，得到[n/
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
