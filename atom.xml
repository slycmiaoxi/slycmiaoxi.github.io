<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2017-03-19T04:58:30.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例设计模式</title>
    <link href="http://www.myzwl.win/2017/03/17/danli/"/>
    <id>http://www.myzwl.win/2017/03/17/danli/</id>
    <published>2017-03-17T12:48:51.000Z</published>
    <updated>2017-03-19T04:58:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>在介绍单例设计模式之前，先简单介绍一下java的内存分析，可以帮助我们更好的了解相关内容。在此之前，先简单介绍几个相关概念</strong></p>
<h3 id="Stack（栈）"><a href="#Stack（栈）" class="headerlink" title="Stack（栈）"></a>Stack（栈）</h3><p>存放基本数据类型的数据和对象的引用及存放变量，如果存放的是基本数据类型（非static），直接将变量名和值存入stack中，如果是引用，只将变量名存入栈，然后指向它new的对象（存放在堆中）</p>
<h3 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a>Heap（堆）</h3><p>存放new产生的数据</p>
<h3 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h3><p>存放在对象中用static定义的静态成员（基本类型）</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>存放所有数据</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><strong>下面将模拟几个实例先说明在证明。（此外注意String不是基本数据类型）</strong><br><img src="/images/imgs2/1.gif" alt="Alt text"><br>上面给出了一个实例，意在了解内存分配，接下来将以String为例说明</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String str="abc";</div><div class="line">String str1="abc";</div><div class="line">String str2=str;</div><div class="line">String str3=new String("abc");</div><div class="line">String str4=new String("abc");</div><div class="line">String str5=str3;</div><div class="line">static String str6="abc";</div><div class="line">static String str7=new String("abc");</div></pre></td></tr></table></figure>
<p>对应的测试内存地址是否相等</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   System.out.println(str==str1);</div><div class="line">System.out.println(str==str2);</div><div class="line">System.out.println(str1==str2);</div></pre></td></tr></table></figure>
<p>测试结果 true true true<br>说明String 是引用类型，而且上面方法产生的变量都只在栈中并且都是同一个地址</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   System.out.println(str==str3);</div><div class="line">System.out.println(str3==str4);</div></pre></td></tr></table></figure>
<p>测试结果：false false<br>说明：new 之后的对象地址存放在堆中，同时堆中每个new之后的对象地址都是不一样的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   System.out.println(str==str6);</div><div class="line">System.out.println(str3==str6);</div><div class="line">System.out.println(str6==str7);</div><div class="line">System.out.println(str3==str7);</div></pre></td></tr></table></figure>
<p>测试结果：true false false false<br>说明：String类型的静态变量存放在栈中，而new之后的静态变量存放在堆中</p>
<p>关于内存分配，比较复杂，这里只简单验证其中一些，其他可以自己设计案例模拟</p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>顾名思义就是指唯一的对象实例<br>具体点说就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例只存在一个，<br>通常其结构如下所示。<br><img src="/images/imgs2/2.gif" alt="Alt text"><br>入门案例：首先是单例类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pojo;</div><div class="line"></div><div class="line">public class Singleton &#123;</div><div class="line"> private static Singleton singleton=new Singleton();</div><div class="line"> </div><div class="line"> private Singleton()&#123;&#125;</div><div class="line"></div><div class="line"> public static Singleton getInstance()</div><div class="line"> &#123;</div><div class="line">	 return singleton;</div><div class="line"> &#125;&#125;</div></pre></td></tr></table></figure>
<p>测试用junit4进行测试</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test1()&#123;</div><div class="line">	System.out.println("start test..");</div><div class="line">	Singleton obj1=Singleton.getInstance();</div><div class="line">	Singleton obj2=Singleton.getInstance();</div><div class="line">	System.out.println(obj1==obj2);</div><div class="line">	System.out.println("end test..");</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果：start test.. true end test..<br>说明，obj1与obj2是同一个实例，间接说明了单例的特性</p>
<p>至此我们对单例有了一个初步的形式上的认识了，那么它的特点是什么了？主要为三点<br>一：单例类确保自己只有一个实例（构造函数私有：不被外部实例化，也不被继承）<br>二：单例类必须自己创建自己的实例<br>三：单例类必须为其他对象提供唯一的实例</p>
<p>说到单例就必然涉及到多线程，不多说，先模拟一个多线程来说明单例中存在的并发问题。<br>友情提醒一下，上面用的是饿汉式创建单例，就一开始就创建了一个实例，显然浪费内存，接下来将用懒汉式创建单例<br>主体类代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static Singleton singleton;</div><div class="line">	</div><div class="line">	 private Singleton()&#123; &#125;</div><div class="line">	 </div><div class="line">	 public static Singleton getInstance()</div><div class="line">	 &#123;</div><div class="line">		 if(singleton==null)&#123;</div><div class="line">			 singleton=new Singleton();</div><div class="line">		 &#125;</div><div class="line">		 return singleton;</div><div class="line">	 &#125;</div></pre></td></tr></table></figure>
<p>下面将用三个线程模拟，两个线程调用单例类，第三个线程启动前两个线程，测试用junit</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class thread1 implements Runnable&#123;</div><div class="line">	Singleton singleton;</div><div class="line">	public Singleton getSingleton() &#123;</div><div class="line">		return singleton;</div><div class="line">	&#125;</div><div class="line">	public void setSingleton(Singleton singleton) &#123;</div><div class="line">		this.singleton = singleton;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		singleton=Singleton.getInstance();	&#125;&#125;</div><div class="line">		</div><div class="line">public class Thread2 implements Runnable&#123;</div><div class="line">	Singleton singleton;</div><div class="line">	public Singleton getSingleton() &#123;</div><div class="line">		return singleton;	&#125;</div><div class="line">		</div><div class="line">	public void setSingleton(Singleton singleton) &#123;</div><div class="line">		this.singleton = singleton;	&#125;</div><div class="line">		</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		 singleton=Singleton.getInstance();</div><div class="line">			&#125;&#125;</div></pre></td></tr></table></figure>
<p>简单说明一下，这两个线程目的是调用单例类（注意如果是单例，决不允许出现不同实例）<br>先贴出测试类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   thread3 t=new thread3();</div><div class="line">Thread tt=new Thread(t);</div><div class="line">tt.start();</div></pre></td></tr></table></figure>
<p>这里我们通过控制第三个线程来构造并发，(这里采用数学中的极限思想)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class thread3 implements Runnable&#123;</div><div class="line">	thread1 t1=new thread1();</div><div class="line">	Thread2 t2=new Thread2();</div><div class="line">	Thread t=new Thread(t1);</div><div class="line">	Thread t3=new Thread(t2);</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">	long start=System.currentTimeMillis();</div><div class="line">		t.start();</div><div class="line">		t3.start();</div><div class="line">		long end=System.currentTimeMillis();</div><div class="line">		System.out.println(end-start);   //并发的时间间隔</div><div class="line">		System.out.println(t1.getSingleton());</div><div class="line">		System.out.println(t2.getSingleton());</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试结果：0 null null<br>多次运行，又出现另一种结果：6<br>com.zwl.pojo.Singleton@8fdcd1<br>null和其他不同步结果<br>说明在很短的时间间隔类，一个居然已经有了实例，而另一个居然是空，显然不是单例，想想倘若在此时去操作该单例，可能就会是静态类发生变化，也就是并发问题了。</p>
<p>很自然。那么怎么去解决了，一种很通用的方法就是加锁实现同步</p>
<h3 id="双锁机制"><a href="#双锁机制" class="headerlink" title="双锁机制"></a>双锁机制</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static Singleton getInstance()</div><div class="line"> &#123;</div><div class="line">	 if(singleton==null)</div><div class="line">	 &#123;</div><div class="line">		 synchronized(Singleton.class)</div><div class="line">		 &#123;</div><div class="line">	 if(singleton==null)&#123;</div><div class="line">		 singleton=new Singleton();</div><div class="line">	 &#125;</div><div class="line">		 &#125;</div><div class="line">	 &#125;</div><div class="line">	 return singleton;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Synchronized关键字，声明使该线程在某处同步，也就是一个线程先占用，另一个线程被阻塞，显然如果不为空，就直接返回对象，对应第二个线程也就不执行if语句了，达到单例效果，可以想象如果为计数变量，同样可以通过二次加锁实现同步<br>  但是实际还是出现不同步，原因是jvm的一个bug，它允许无序写入线程，导致不同步，当然我们可以通过申明volatile关键字。<br> 为什么就可以解决双重解锁的bug了？<br>原因是volatile保证原子性，顺序性，即在双重加锁前保证多线程实现顺序性，举个例子吧，现在有两个线程t1和t2，分别执行b，c操作，如果乱序写入，可能出现t1正在操作b还没完成，t2操作c，致使单例失败，所以需要保证顺序性。<br>经过不断的测试，发现完全同步，只不过时间间隔为0，和null，null，至少是同步了~</p>
<p><strong>接下来简单比较一下饿汉式和懒汉式的区别</strong><br>从速度和反应时间上，饿汉式加载好，从资源利用率上懒汉式好，<br>饿汉式很明显不会出现多线程并发问题，所以是线程安全的，而懒汉式则是非线程安全的</p>
<p>关于单例模式的应用，笔者在当初学习过程中，遇到很多，学习总是一个不断压缩与重新认识的过程，像sql工具类，hibernate的懒加载，mybatis及 spring中的一些配置等等，往往把握不好，就会出现错误，这里只列举一些工具类，因为它是笔者接触的第一个单例应用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Private static Connection connection;</div><div class="line">Private sqlhelper()&#123;&#125;；</div><div class="line">	public static Connection mysqlconn() throws Exception &#123;</div><div class="line">		try &#123;</div><div class="line">			// 加载驱动</div><div class="line">			Class.forName("com.mysql.jdbc.Driver");</div><div class="line">			// 连接数据库</div><div class="line">			 connection = DriverManager.getConnection(</div><div class="line">					"jdbc:mysql://localhost:3306/software", "root", "");</div><div class="line">			System.out.println("获得数据库");</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; </div><div class="line">		return connection;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在介绍单例设计模式之前，先简单介绍一下java的内存分析，可以帮助我们更好的了解相关内容。在此之前，先简单介绍几个相关概念&lt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://www.myzwl.win/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用nat123搭建本地服务器</title>
    <link href="http://www.myzwl.win/2017/03/17/nat123/"/>
    <id>http://www.myzwl.win/2017/03/17/nat123/</id>
    <published>2017-03-17T11:48:51.000Z</published>
    <updated>2017-03-19T05:11:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>这是笔者去年第一次将web项目通过外网访问，当然结果很美好，过程很艰难，当时也是第一次用文档记录了探索过程，当然也是在google老师的帮助下，诚然学习最大的乐趣就是通过自己忘我的想尽一切办法最后solve的那种快感</strong><br><em>进入正题</em></p>
<p> 1 因为要把服务器架在自己的机子上，所以可以选择花生壳和nat123，于是当时百度了一堆关于该技术，充其量只是了解了概念，然后修改tomcat配置文件，先将默认的8080端口改为100（按理讲应该改为80，之后注意中讲为什么），然后将root文件夹全部删掉，当然还有一部（但是我配置了只要一输入域名就是空白页，所以我舍弃了这一步）配置域名与tomcat项目的映射</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Context path=<span class="string">""</span> debug=<span class="string">"0"</span> docBase=<span class="string">"你项目的决定路径"</span> reloadable=<span class="string">"true"</span>&gt;&lt;/Context&gt;</div></pre></td></tr></table></figure>
<p> 2 tomcat部分算是完成了，之后我选择了用nat123，建议去官网下载最新版本，注册，登录然后按照百度步骤，懒得写了就截个图吧<br> <img src="/images/imgs1/15.gif" alt="Alt text"></p>
<pre><code>注意应用类型我们选80（http）网站，毕竟这是相对来说最佳选择，内网端口（默认可以写80）我选择了100（之后一定要打开和开放端口，后面再说），内网地址，命令行中输入ipconfig查看ip4就是内网，当然也可以用localhost等等（因为他们在tomcat配置，或者在c盘的一个文件中为他们设置了常量，百度就能找到c盘那个源码，tomcat不多说就在配置里面，很好找），其他配置不动，然后保存
</code></pre><p>  <img src="/images/imgs1/16.gif" alt="Alt text"><br>    这样就有了域名<br>  <img src="/images/imgs1/17.gif" alt="Alt text"></p>
<pre><code>在打开nav123客户端，出现笑脸，如图等表示映射正常，
</code></pre><hr>
<p><strong>然后下面才是最恐怖的地方了（出现各种问题）</strong></p>
<p><strong>1 如果你内网和tomcat选择的是80端口，注意80端口默认不打开的，先开启控制面板-系统与安全-windows防火墙-高级设置-入站规则-新建规则-端口-80-下一步。。-完成，</strong><br>   然后在用netstat –a看看有没有80端口，假设有了，然后以为顺利 了，结果点击客户端的设置，发现最上面出现无公网连接，也就是说内网的80端口不能映射外网，这下麻烦了，好吧，据需钻研解决方案。试着其中一个靠谱的，说路由器配置中没有开放外网，好吧<br><img src="/images/imgs1/18.gif" alt="Alt text"><br>   先在计算机中输入192.168.1.1（这是电信的），打开路由器（然后简单去了解了一下路由器）先开启dmz主机，指派一个特定内网ip（那个机子对外开放），然后</p>
<p><img src="/images/imgs1/19.gif" alt="Alt text"></p>
<p><strong>在虚拟服务中打开相应端口80（暂且不是100），然后自以为一切顺利，在点开客户端那个设置或打开命名行输入ipconfig，都显示自己的公网了，相当于一道闸门打开了，当然也找不出问题了，结果又出现将域名输入出现错误。</strong></p>
<p><strong>结果觉得可能是80端口被封（可是已经在客户端能做的范围内把80打开了，最好的解释是要去电信局备案，才能在服务器端解封80端口），也就是说，80端口我们用不了了）</strong></p>
<p><strong>居然一时用不了，就用其他端口吧，就100吧，把之前所有的80开放改为100，然后在打开网页（注意：tomcat没有配置项目初始化，自己指定），然后在用手机或者其他机子试一次，即域名+项目名，结果成功了，但是网速不行啊（又头疼了~~）</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这是笔者去年第一次将web项目通过外网访问，当然结果很美好，过程很艰难，当时也是第一次用文档记录了探索过程，当然也是在goo
    
    </summary>
    
    
      <category term="踩坑 , window" scheme="http://www.myzwl.win/source/tags/%E8%B8%A9%E5%9D%91-window/"/>
    
  </entry>
  
  <entry>
    <title>window分区导致双系统无引导界面</title>
    <link href="http://www.myzwl.win/2017/03/17/fenqu/"/>
    <id>http://www.myzwl.win/2017/03/17/fenqu/</id>
    <published>2017-03-17T06:09:42.000Z</published>
    <updated>2017-03-18T13:20:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>先简单介绍一下情境，笔者电脑上装的是双系统，而且bios上设置了system password（当然，已经忘记了是多少了），然后心血来潮在阿里云买了一个学生优惠的服务器，安装了mysql+tomcat7+jdk，在电脑上d盘已经装了linux，在c盘上分了一个分区，那么问题来了，当再次打开电脑时，无引导界面，取而代之的是</strong></p>
<p><img src="/images/z4.gif" alt="Alt text"><br>然后google了许多解决方案，当然是在彩果许多坑之后找到了适合自己的解决方案，毕竟一个问题的解决总不是一帆风顺的。<br>  <em>进入正题</em><br>  <strong>如果我们要重装系统，肯定得用到bios设置，那么问题来了，如果你设置了密码，并且密码忘记了，那怎么办?</strong><br>  一种办法是通过硬件，通过把电池正负极按照网上说的折腾一下，就可以恢复bios出厂设置，显然这种方法有极大风险，可能会损坏硬件（具体参考google）或者用相关修复工具，但是笔者的电脑都无引导界面，尴尬了~<br>  还有一种办法就是在你输入3次错误的密码时会出现如下错误代码</p>
<p> <img src="/images/z1.gif" alt="Alt text"><br> 然后就是<a href="https://bios.pw.org" target="_blank" rel="external">在这里面设置</a>，如下图，输入上述的错误代码，就出现了bios密码，</p>
<p> <img src="/images/z2.gif" alt="Alt text"></p>
<p> <strong>当然，笔者电脑里有许多宝贵的数据，不可能也不愿意重装系统，经过google一番，发现是分区导致引导盘不能引导，只需要找到该分区，在llinux上重新修复就行了</strong></p>
<blockquote>
<p>首先在页面中输入如下ls<br>grub rescue&gt; ls<br>出现如下（基本都差不多）<br>hd0，（hd0，nsdoc9），（hd0，nsdoc8），（hd0，nsdoc7），（hd0<br>，nsdoc6），（hd0，nsdoc5），（hd0，nsdoc2），（hd0，nsdoc1）</p>
</blockquote>
<p>然后通过ls 如上的分区循环一遍，如ls （hd0，nsdoc9）/<br>上述有一个会出现详细信息，他就是安装linux那个分区，其余都是unknown filesystem，当然如果出现bad filesystem那是你没加/<br>如下图：</p>
<p><img src="/images/z3.gif" alt="Alt text"></p>
<p><strong>接下来设置root引导盘</strong></p>
<blockquote>
<p>set root=(hd0，nsdoc6）<br>这里设置的是上述找到分区的那个盘<br>set prefix=(hd0，nsdoc6）/boot/grub/</p>
</blockquote>
<p>然后可以用set验证一下</p>
<blockquote>
<p>set<br>会出现上述设置的信息</p>
</blockquote>
<p>最后执行下述命令</p>
<blockquote>
<p>insmod normal<br>在输入normal，就会自动跳转到引导界面，我们选择ubuntu进入，在里面进行修复即可</p>
</blockquote>
<p>进入linux系统打开终端，先更新grub，即输入</p>
<blockquote>
<p>sudo update-grub</p>
</blockquote>
<p>ok后在输入</p>
<blockquote>
<p>sudo grub-install /dev/sda<br>结束后，我们就可以重启电脑，一切都ok了。<br>进入电脑后笔者做的第一件事就是备份数据，毕竟要给自己留条后路，如果遇到更复杂的情况就后悔莫及了。。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;先简单介绍一下情境，笔者电脑上装的是双系统，而且bios上设置了system password（当然，已经忘记了是多少了），然后心血来潮在阿里云买了一个学生优惠的服务器，安装了mysql+tomcat7+jdk，在电脑上d盘已经装了linux，在c盘上分了一
    
    </summary>
    
    
      <category term="踩坑 , window" scheme="http://www.myzwl.win/source/tags/%E8%B8%A9%E5%9D%91-window/"/>
    
  </entry>
  
  <entry>
    <title>阿里云服务器上搭建javaweb站点</title>
    <link href="http://www.myzwl.win/2017/03/16/dajianserver/"/>
    <id>http://www.myzwl.win/2017/03/16/dajianserver/</id>
    <published>2017-03-16T09:48:51.000Z</published>
    <updated>2017-03-18T13:20:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>事实上笔者在去年8月份的时候就已经在自己电脑上通过nat123搭建了一台服务器，即p2p，自己的电脑作为服务器，但是这很不安全，而且每次别人通过外网访问，电脑必须打开而且开着服务器，由于是免费的，导致别人访问网速跟不上等等，最近阿里云有学生9.9元购买服务器，所以笔者买了一个，也很有兴趣将笔者之前写的两个网站部署上，结果很美好，但过程很坑，所以就需要总结来提高自己</strong><br><em>进入正题</em><br>笔者也是google了许多例子和前人的经验找到适合自己的方法</p>
<p><strong>首先需要租一台云服务器，我选择了阿里云</strong><br><img src="/images/imgs1/1.gif" alt="Alt text"></p>
<p>注意这里操作系统有四个选项，笔者发现只有第四个符合自己（貌似是自定义），然后按照步骤，其中有些需要注意<br><img src="/images/imgs1/1.gif" alt="Alt text"></p>
<p>安全组，这里暂时可以选择默认的第一个，因为后面如果在搭建web时需要一些端口（如mysql默认3306端口改掉，tomcat8080端口换成80等等），到时可以在后台操作）</p>
<p><img src="/images/imgs1/3.gif" alt="Alt text"><br>关于镜像选择，因为笔者是window7，而且还是32位的，相对64位只能有不大于4g的内存，</p>
<p><img src="/images/imgs1/4.gif" alt="Alt text"><br>这里的密码就是之后在本地机子上远程登录这个服务器所要的密码</p>
<p>ok至此，成功租了一台服务器，这时你会收到一条短信，里面有你这台服务器的公网地址</p>
<p><strong>然后笔者就开始着手在本机上登录该服务器，当然是为了搭建javaweb准备的</strong></p>
<ol>
<li><p>在本机上准备javaweb需要的环境<br><img src="/images/imgs1/5.gif" alt="Alt text"></p>
</li>
<li><p>在本机上新建一个分区用来放上述软件供服务器远程使用（其实也可以不用分区，直接复制也行，毕竟笔者被分区坑了，导致后来的双系统引导界面消失）</p>
</li>
<li><p>本机上登录远程连接可以用运行-mstsc-直接进入到如下界面<br><img src="/images/imgs1/6.gif" alt="Alt text"><br>其中计算机就是你的公网地址，如果你是新建了一个分区，那么就点选项在本地资源的详细信息中就新建的那个分区勾上，笔者这里是x盘（如果没有的话就直接连接）<br><img src="/images/imgs1/7.gif" alt="Alt text"></p>
</li>
<li><p>后面什么证书，安全啊先不管了，应该是进入远程服务器了<br><img src="/images/imgs1/8.gif" alt="Alt text"></p>
</li>
<li><p>接下来就是将mysql，jdk等复制到c盘中，因为只有一个盘，后续就是安装配置了</p>
</li>
<li>安装jdk，笔者的是jdk1.6（注意jdk版本不同，后续运行高版本会出像版本错误，笔者已吃过亏），配置环境变量</li>
<li>安装tomcat，配置tomcat环境变量，注意上述不需要自定义文件夹，因为只有一个c盘，tomcat默认端口是8080</li>
<li>安装mysql，这里面需要注意的是里面有端口设置，可以选择默认的3306或者自定义，然后就是用户与密码设置</li>
<li>可以使用可视化数据库工具，这里笔者使用了navicat<br><strong>至此算是搭建了一个简单web环境，可以先测试一下</strong><br>拷贝一个已经被编译过的web项目，启动tomcat与mysql，然后利用localhost:8080/项目名访问，如果出现界面就表示以上配置成功</li>
</ol>
<p><strong>接下来需要买一个域名</strong><br><img src="/images/imgs1/9.gif" alt="Alt text"></p>
<ol>
<li>成功后点击解析，在里面找到新手设置，点进去<br><img src="/images/imgs1/10.gif" alt="Alt text"><br>点击设置网站解析，然后输入公网，即可。</li>
<li>在远程服务器中，找到tomcat下conf下的server.xml文件，如果我们不想要8080端口并且输入域名时不想要端口的话，就先把8080端口改成80</li>
</ol>
<blockquote>
<p> Connector port=”80” protocol=”HTTP/1.1”<br>               connectionTimeout=”20000”<br>               redirectPort=”8443” /&gt;</p>
</blockquote>
<p> 3.然后找到host</p>
<blockquote>
<p>  Host name=”你刚刚解析的域名”  appBase=”webapp”<br>            unpackWARs=”true” autoDeploy=”true”&gt;</p>
<p>&lt;Context path=”” docBase=”/项目名” debug=”0” reloadable=”true” </p>
</blockquote>
<p>注意这里appBase是放项目的站点，context内的docBase是你的项目名，目前我们只是一个tomcat运行一个域名执行一个项目<br>然后打开C:\Windows\System32\drivers\etc下的host文件<br>增加如下设置</p>
<blockquote>
<p>127.0.0.1       localhost<br>  ::1             localhost<br>192.168.1.11    刚刚的域名</p>
</blockquote>
<p>保存，然后重启服务器，可能会发现会遇到一些问题，如80端口被占用，80端口未开放等等，假设未被占有（如果占用，google上有解决方法），<br>如果未开放，这里我们就需要在云服务器上进行端口开放设置</p>
<p><strong>进入我们购买的云服务器，点击安全组，选中一个实例，点击配置，选择公网入方向，按照步骤开放想要的端口</strong><br> <img src="/images/imgs1/10.gif" alt="Alt text"></p>
<p> 至此只要输入域名就可以访问了。</p>
<p> 当然，如果我们想要一个tomcat上配置多个域名，每个域名运行各自不同的项目，那如何做了，经过踩坑后，大概如下步骤</p>
<ol>
<li>可以选择在tomcat下新建一个站点，类似于原来的webapp，然后在server.xml中进行配置一个新host</li>
</ol>
<blockquote>
<p>  Host name=”第二个域名”  appBase=”新创建的站点”<br>            unpackWARs=”true” autoDeploy=”true”&gt;</p>
<p>&lt;Context path=”” docBase=”/第二个项目名” debug=”0” reloadable=”true”</p>
</blockquote>
<p>2.然后在hosts文件汇总加入第二个域名</p>
<blockquote>
<p>127.0.0.1       localhost<br>  ::1             localhost<br>192.168.1.11    刚刚的域名<br>192.168.1.11    第二个域名</p>
</blockquote>
<p>最后重启服务器。<br>笔者在这里遇到了一个很奇怪的坑，同一服务器下的项目出现奇怪的jar包冲突，只要删掉xerces包就行了（当然是在远程服务器上才产生冲突的）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;事实上笔者在去年8月份的时候就已经在自己电脑上通过nat123搭建了一台服务器，即p2p，自己的电脑作为服务器，但是这很不安全，而且每次别人通过外网访问，电脑必须打开而且开着服务器，由于是免费的，导致别人访问网速跟不上等等，最近阿里云有学生9.9元购买服务器
    
    </summary>
    
    
      <category term="踩坑 , window" scheme="http://www.myzwl.win/source/tags/%E8%B8%A9%E5%9D%91-window/"/>
    
  </entry>
  
  <entry>
    <title>初步搭建hexo博客</title>
    <link href="http://www.myzwl.win/2017/03/12/hexo1/"/>
    <id>http://www.myzwl.win/2017/03/12/hexo1/</id>
    <published>2017-03-12T09:48:51.000Z</published>
    <updated>2017-03-18T13:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客是一种能够更好提高自己的途径，关于利用hexo搭建博客，笔者是一路google一路踩坑，才完成的，当然关于这方面的搭建，实在太多了，笔者也只是稍微总结一下</p>
<ol>
<li>首先在github上注册一个账号</li>
<li>创建代码库（repository），一般以yourname/youname.github.io</li>
<li>setting中选择主题</li>
<li>购买一个域名（这里以笔者在阿里云买的为例）</li>
<li>点击域名里的解析<br><img src="/images/imgs1/12.gif" alt="Alt text"><br>注意CNAME为你的仓库名，其他套用<br>6.回到setting中在Custom domain下填写你刚才的域名，然后在code中会出现一个CNAME文件<br>7.yourname.gthub.io访问你的博客，目前应该只是一个默认主页</li>
</ol>
<p><strong>接下来就是本地安装hexo与github page联系起来</strong><br> 1.官网安装node.js（注意是32位还是64位）<br> 2安装git（在过程中会有一项自带环境变量设置，选中，不然后面无法识别git）<br> 3安装hexo（以笔者的在e:/blog下为例）<br> 在git bush中</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-cli -g</div></pre></td></tr></table></figure>
<p>然后在输入</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo --save</div></pre></td></tr></table></figure>
<p>然后利用</p>
<blockquote>
<p>hexo -v</p>
</blockquote>
<p>验证安装是否成功</p>
<p> 4.然后在要创建的目录下初始化hexo</p>
<blockquote>
<p>hexo init</p>
</blockquote>
<p>5安装所需的组件和依赖组件<br>  npm install</p>
<p>笔者当时一下子全部安装了很多扩展组件如:</p>
<blockquote>
<p>npm install hexo-deployer-git –save</p>
</blockquote>
<p>在看看目录下应该产生如下目录<br><img src="/images/imgs1/13.gif" alt="Alt text"></p>
<p>6 生成静态文件</p>
<blockquote>
<p>hexo g</p>
</blockquote>
<p>7 启动服务器，进行本地预览访问</p>
<blockquote>
<p>hexo s</p>
</blockquote>
<p>然后在浏览器中打开<a href="http://localhost:4000/，会出现一个默认的hexo主页" target="_blank" rel="external">http://localhost:4000/，会出现一个默认的hexo主页</a></p>
<p>8 Hexo与github page 联系<br>首先是配置Git个人信息</p>
<blockquote>
<p>git config –global user.name “用户名”<br>git config –global user.email “邮箱地址”</p>
</blockquote>
<p>9 生成密钥</p>
<blockquote>
<p>sh-keygen -t rsa -C “邮箱地址”</p>
</blockquote>
<p>这里笔者遇到一个坑，默认是在administrator目录下生成一个.ssh文件夹里面包含<br><img src="/images/imgs1/14.gif" alt="Alt text"><br>结果没有，所以自己在该目录下创建一个.ssh文件夹</p>
<p>10 配置Deployment（以笔者的为例）</p>
<blockquote>
<p>deploy:<br>  type: git<br>repository: <a href="http://github.com/slycmiaoxi/slycmiaoxi.github.io.git" target="_blank" rel="external">http://github.com/slycmiaoxi/slycmiaoxi.github.io.git</a><br>branch: master</p>
</blockquote>
<p>这里的repository是git上对应的use ssh进行clone的</p>
<p>11 登录到git的use ssh将.ssh文件下的id_rsa.pub里的内容复制到改里面</p>
<p>12 写文章上传</p>
<blockquote>
<p>hexo new post “article title” 新建一个文章，默认放再_post下<br>  hexo clean 清空public里的文件，该文件夹是上传到git上<br>  hexo g 生成到public文件夹中<br>  hexo d 部署，此过程要输入用户名和密码，</p>
</blockquote>
<p>  笔者在hexo d过程中曾出现一致无权限，后来在google老师的指引下需要设置用户名和密码，在.ssh文件下生成known_hosts文件，如果没有遇到，那是比较幸运了<br>  目前还是默认的主题，显然不好看，其次编写文章需要markdown语言，笔者使用的是小书匠，因为其组件丰富，操作简单</p>
<p> 13 更换主题<br> 首先需要cd到你的hexo根目录，然后</p>
<blockquote>
<p>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> themes/next</p>
</blockquote>
<p> 我选择的是next主题，因为其功能，配置方面相对较强大，当然在主题配置方面一路是坑，这里推荐去next官网看配置，大部分都涉及到<br> 如果我们启用next主题，只要在_config.yml（站配置文件中）找到theme，将默认的改成next即可，<br> 另一方面，在theme文件夹下的next文件夹下的_config.yml(主题配置文件）进行主题的配置，当然里面其他文件也是可以配置的，当然google是最好的帮手<br> 最后主题也配置好了，只需要输入yourname.github.io就可以访问你的博客了<br> 当然笔者是一路踩坑过来，很多google也不一定适合自己，只有自己探索过的才是最适合自己的。<br> 最后需要说一下，多说老是注册异常，后来干脆选择友言代替，总之theme里面有很多需要探索的，google是最好的老师</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客是一种能够更好提高自己的途径，关于利用hexo搭建博客，笔者是一路google一路踩坑，才完成的，当然关于这方面的搭建，实在太多了，笔者也只是稍微总结一下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先在github上注册一个账号&lt;/li&gt;
&lt;li&gt;创建代码库（repository），
    
    </summary>
    
    
      <category term="踩坑 , hexo" scheme="http://www.myzwl.win/source/tags/%E8%B8%A9%E5%9D%91-hexo/"/>
    
  </entry>
  
  <entry>
    <title>第一篇仅为测试</title>
    <link href="http://www.myzwl.win/2017/03/10/hi/"/>
    <id>http://www.myzwl.win/2017/03/10/hi/</id>
    <published>2017-03-10T09:48:51.000Z</published>
    <updated>2017-03-18T13:11:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>花了好几天业余时间终于搞好了，正是一路踩坑，一路请教google老师，一路折腾，一路不断学习，搭建了一个比较丑的博客</strong></p>
<blockquote>
<p>cout&lt;&lt;“so hard”<br>cout&lt;&lt;“这仅仅是一个测试”</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是一个测试代码!</div></pre></td></tr></table></figure>
<p><img src="/images/avatar.gif" alt="Alt text"></p>
<table>
<thead>
<tr>
<th>java</th>
<th>c</th>
<th>c++</th>
<th>hello world</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>c++</td>
<td>java</td>
<td>hello</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;花了好几天业余时间终于搞好了，正是一路踩坑，一路请教google老师，一路折腾，一路不断学习，搭建了一个比较丑的博客&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cout&amp;lt;&amp;lt;“so hard”&lt;br&gt;cout&amp;lt;&amp;lt;“这仅仅
    
    </summary>
    
    
      <category term="测试" scheme="http://www.myzwl.win/source/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
