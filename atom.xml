<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2017-08-12T08:38:18.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络编程简单总结</title>
    <link href="http://www.myzwl.win/2017/07/29/socket_1/"/>
    <id>http://www.myzwl.win/2017/07/29/socket_1/</id>
    <published>2017-07-29T05:48:51.000Z</published>
    <updated>2017-08-12T08:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/images/imgs4/16.jpg" alt="Alt text"><br>在java网络编程中最主要的是tcp/ip协议，这个协议也是Internet最基本的协议，而其就是由网络层的ip协议和传输层的tcp协议组成，同时由于分层的思想，也就是每一层只能与它下面的层打交道，也就是说，应用层只跟传输层打交道，传输层只跟网络层打交道</p>
<h4 id="ip协议"><a href="#ip协议" class="headerlink" title="ip协议"></a>ip协议</h4><p><img src="/images/imgs4/27.gif" alt="Alt text"><br>关于底层协议的具体过程是在太复杂了，当初学习计算机网络的时候也是被各种细节弄得云里雾里的，总之ip层就是唯一确定了一台机器，就像我们住的房间地址一样，唯一确定了我们的住处<br>这里需要注意的是，ip地址由四位字节组成，每个字节由8位二进制组成，同时有a，b，c三类地址，如图由网络号和主机号组成，当然这是公网，如果是局域网的话，就需要配网关和子网掩码了，如192.168.1.1和255.255.0.0那么255.255就是确定了ip地址哪几位字节是网络号，如192.168就是网络号，当然其配置各种内网ip是很复杂的，具体参考计算机网络</p>
<h4 id="TCP与UDP协议"><a href="#TCP与UDP协议" class="headerlink" title="TCP与UDP协议"></a>TCP与UDP协议</h4><p><strong>tcp协议</strong></p>
<blockquote>
<p>它是专门设计用于在不可靠的因特网上提供端到端的字节流通信的协议，它是一种面向连接的协议，它连接的是字节流。<br>这里面有几个注意的地方：<br>可靠性：就是建立三次握手过程，就是说，我把信息传给你，等待，收到回复后，在确认。。最后在发送消息，它保证了数据一定发送给了对方，所以是一种可靠传输，但是遇到阻塞效率会很低<br>端口：ip地址唯一确定了这台机器，相当于一个房子，但是你消息总不能发给整个电脑吧，比如qq，而端口就相当于一间房间，具体发给那个，比如送到qq这间房间</p>
</blockquote>
<p><strong>端口分类</strong></p>
<blockquote>
<p>有65536个端口    0号是保留端口<br>1-1024是固定端口<br>又叫有名端口，即被某些程序固定使用，一般程序员不使用。<br>22：SSH远程登录协议    23：telnet使用    21：ftp使用<br>25：smtp服务使用    80：iis使用    7：echo服务<br>1025-65535是动态端口<br>这些端口，程序员可以使用<br>端口(port)–注意事项<br>1、在计算机(尤其是做服务器)要尽可能的少开端口；<br>2、一个端口只能被一个程序监听；<br>3、如果使用netstat -an可以查看本机有哪些端口在监听</p>
</blockquote>
<p><strong>UDP协议</strong><br>UDP向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接。<br>简单来说，就是只发一次数据，不管对方有没有接收到都不会再发了，但是有时候效率会很高，像网络拥堵时</p>
<p><strong>url</strong><br>统一资源定义符也被称为网页地址。Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL地址，这种地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是Internet上的站点，简单地说，URL就是Web地址，俗称“网址”，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法，如：<br><a href="http://www.sina.com:8080/index.html" target="_blank" rel="external">http://www.sina.com:8080/index.html</a><br>1、协议；2、ip地址(32位)；3、端口号(16位)0-65535；4、资源名称。</p>
<p><strong>单工、半双工和全双工</strong><br> 如果甲可以向乙发送数据，但是乙不能向甲发送数据，这样的通信就是单工通信(Simplex Communication)。<br>    单工数据传输只支持数据在一个方向上传输，就和传呼机一样。<br>    半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信，就和对讲机(步话机)一样；<br>全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力，就和电话一样</p>
<h4 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h4><p><img src="/images/imgs4/28.gif" alt="Alt text"><br>如模拟的客户端与服务端<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class MyServer &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new MyServer();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyServer()&#123;</div><div class="line">		try &#123;</div><div class="line">			//在9999号端口上监听</div><div class="line">			ServerSocket ss=new ServerSocket(9999);</div><div class="line">			System.out.println("9999端口监听...");</div><div class="line">			//等待某个客户端来连接，该函数会返回一个Socket连接</div><div class="line">			Socket s=ss.accept();</div><div class="line">			//要读取s中传递的数据</div><div class="line">			InputStreamReader isr=new InputStreamReader(s.getInputStream());</div><div class="line">			BufferedReader br=new BufferedReader(isr);</div><div class="line">			</div><div class="line">			String info=br.readLine();</div><div class="line">			System.out.println("服务器接收到:\t"+info);</div><div class="line">			</div><div class="line">			PrintWriter pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			pw.println("我是服务器，已收到你发送的信息!");</div><div class="line"></div><div class="line"></div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class MyClient &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new MyClient();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyClient()&#123;</div><div class="line">		try &#123;</div><div class="line">			//Socket()就是去连接某个服务器端 127.0.0.1表示服务器的ip</div><div class="line">			//9999是服务器的端口号</div><div class="line">			Socket s=new Socket("127.0.0.1",9999);</div><div class="line">			//如果s连接成功，就可以发送数据到服务器端</div><div class="line">			//我们通过pw向s写数据,true表示即时刷新</div><div class="line">			PrintWriter pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			pw.println("你好吗？我是客户端");</div><div class="line">			//要读取s中传递的数据</div><div class="line">			InputStreamReader isr=new InputStreamReader(s.getInputStream());</div><div class="line">			BufferedReader br=new BufferedReader(isr);</div><div class="line">			String info=br.readLine();</div><div class="line">			System.out.println("接收到服务器：\t"+info);</div><div class="line"></div><div class="line"></div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要注意的几个地方，必须是服务端先开启，然后accept（）等待客户端，没有客户端连接，它将处于阻塞状态，一旦有了客户端它将回应，其次这是理由tcp实现的，UDP实现用java提供的另外类，最后这里有一个问题，就是只能接受一次，需要改进，也就是不断循环接收客户端连接</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">			//在9999号端口上监听</div><div class="line">			ServerSocket ss=new ServerSocket(9999);</div><div class="line">			//等待客户端连接，该函数会返回一个Socket连接</div><div class="line">			Socket s=ss.accept();</div><div class="line">			//要读取s中传递的数据</div><div class="line">			isr=new InputStreamReader(s.getInputStream());</div><div class="line">			br=new BufferedReader(isr);</div><div class="line">			</div><div class="line">			pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			</div><div class="line">			//接收从控制台输入的信息</div><div class="line">			isr2=new InputStreamReader(System.in);</div><div class="line">			br2=new BufferedReader(isr2);</div><div class="line">			while(true)&#123;</div><div class="line">				//接收客户端信息</div><div class="line">				String infoFromClient=br.readLine();</div><div class="line">				System.out.println("服务器接收到:\t"+infoFromClient);</div><div class="line">				//接收从控制台输入的信息</div><div class="line">				System.out.println("请输入要发送到客户端的信息：");</div><div class="line">				String response=br2.readLine();</div><div class="line">				//服务器从控制台上接收bye服务器端退出</div><div class="line">				if(response.equals("bye"))&#123;</div><div class="line">					System.out.println("退出对话");</div><div class="line">					s.close();</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">				//把从控制台输入的信息，回送给客户端</div><div class="line">				pw.println(response);</div><div class="line">			&#125;</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;finally&#123;</div><div class="line">			try &#123;</div><div class="line">				if(br2!=null) br2.close();</div><div class="line">				if(isr2!=null) isr2.close();</div><div class="line">				if(pw!=null) pw.close();</div><div class="line">				if(br!=null) br.close();</div><div class="line">				if(isr!=null) isr.close();</div><div class="line">			&#125; catch (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>最后当然网络编程中也就是流的数据传送的应用，也不得不说网络底层协议其实很复杂的，只有当我们有精力了，再去细细研究它，才会有更多的收获</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/imgs4/16.jpg&quot; alt=&quot;Alt text&quot;&gt;&lt;br&gt;在java网络编程中最主要的是tcp/
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="http://www.myzwl.win/2017/07/28/balace_1/"/>
    <id>http://www.myzwl.win/2017/07/28/balace_1/</id>
    <published>2017-07-28T05:48:51.000Z</published>
    <updated>2017-08-12T07:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AVL树，也叫平衡二叉树，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。同时，将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，还将距离插入结点最近的且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树<br><img src="/images/imgs4/25.gif" alt="Alt text"><br>如图：一为一个不平衡二叉排序树，显然时间复杂度较大，二为改进后的平衡二叉树，而在改进的过程中，最重要的就是通过平衡因子来判断是进行左旋还是右旋，如右旋，新增一个节点N后，平衡被打破，需要平衡因子2大于0，需要右旋，就是将其左子树作为根结点，左子树的右子树作为原根结点的左子树，这样做的原因就是根据二叉排序树的左右子树特点来的，很容易想明白</p>
<h4 id="模拟平衡二叉树"><a href="#模拟平衡二叉树" class="headerlink" title="模拟平衡二叉树"></a>模拟平衡二叉树</h4><p>不妨构造一个a[10]={3,2,1,4,5,6,7,10,9,8};<br><img src="/images/imgs4/26.gif" alt="Alt text"><br>大概过程如图所示，其中最重要的就是平衡因子的判断，如果是同号，且绝对值大于1的话，就要做相应的旋转操作，如果是不同号的话，就要通过旋转先转换成同号，在做操作</p>
<h4 id="左右旋操作"><a href="#左右旋操作" class="headerlink" title="左右旋操作"></a>左右旋操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">typedef struct BiTNode</div><div class="line">&#123;</div><div class="line">	int data;</div><div class="line">	int bf;</div><div class="line">	struct BiTNode *lchild,*rchild;</div><div class="line">&#125;BiTNode,*BiTree;</div><div class="line"></div><div class="line">//左旋处理</div><div class="line">void R_Rotate(BiTree *p)&#123;</div><div class="line">	BiTree L;</div><div class="line">	L=(*p)-&gt;lchild;   //L指向p的左子树根结点</div><div class="line">	(*p)-&gt;lchild=L-&gt;rchild; //L的右子树挂接为p的左子树</div><div class="line">	L-&gt;rchild=(*p);  </div><div class="line">	*p=L;           //p指向新的根结点</div><div class="line">&#125;</div><div class="line"></div><div class="line">//右旋处理</div><div class="line">void L_Ronate(BiTree *p)</div><div class="line">&#123;</div><div class="line">	BiTree R;</div><div class="line">	R=(*p)-&gt;rchild; //R指向p的右子树根结点</div><div class="line">	(*p)-&gt;rchild=R-&gt;lchild;  //R的左子树挂接为P的右子树</div><div class="line">	R-&gt;lchild=(*p);</div><div class="line">	*p=R;            //p指向新的根结点</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过之前的图来对比看，其实质也就是交互根结点位置和挂接新左右子树</p>
<h4 id="左右平衡旋转"><a href="#左右平衡旋转" class="headerlink" title="左右平衡旋转"></a>左右平衡旋转</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#define LH +1 /*  左高 */ </div><div class="line">#define EH 0  /*  等高 */ </div><div class="line">#define RH -1 /*  右高 */ </div><div class="line"></div><div class="line">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */</div><div class="line">/*  本算法结束时，指针T指向新的根结点 */</div><div class="line">void LeftBalance(BiTree *T)</div><div class="line">&#123; </div><div class="line">	BiTree L,Lr;</div><div class="line">	L=(*T)-&gt;lchild; /*  L指向T的左子树根结点 */ </div><div class="line">	switch(L-&gt;bf)</div><div class="line">	&#123; /*  检查T的左子树的平衡度，并作相应平衡处理 */ </div><div class="line">		 case LH: /*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */ </div><div class="line">			(*T)-&gt;bf=L-&gt;bf=EH;</div><div class="line">			R_Rotate(T);</div><div class="line">			break;</div><div class="line">		 case RH: /*  新结点插入在T的左孩子的右子树上，要作双旋处理 */ </div><div class="line">			Lr=L-&gt;rchild; /*  Lr指向T的左孩子的右子树根 */ </div><div class="line">			switch(Lr-&gt;bf)</div><div class="line">			&#123; /*  修改T及其左孩子的平衡因子 */ </div><div class="line">				case LH: (*T)-&gt;bf=RH;</div><div class="line">						 L-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case EH: (*T)-&gt;bf=L-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case RH: (*T)-&gt;bf=EH;</div><div class="line">						 L-&gt;bf=LH;</div><div class="line">						 break;</div><div class="line">			&#125;</div><div class="line">			Lr-&gt;bf=EH;</div><div class="line">			L_Rotate(&amp;(*T)-&gt;lchild); /*  对T的左子树作左旋平衡处理 */ </div><div class="line">			R_Rotate(T); /*  对T作右旋平衡处理 */ </div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */ </div><div class="line">/*  本算法结束时，指针T指向新的根结点 */ </div><div class="line">void RightBalance(BiTree *T)</div><div class="line">&#123; </div><div class="line">	BiTree R,Rl;</div><div class="line">	R=(*T)-&gt;rchild; /*  R指向T的右子树根结点 */ </div><div class="line">	switch(R-&gt;bf)</div><div class="line">	&#123; /*  检查T的右子树的平衡度，并作相应平衡处理 */ </div><div class="line">	 case RH: /*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */ </div><div class="line">			  (*T)-&gt;bf=R-&gt;bf=EH;</div><div class="line">			  L_Rotate(T);</div><div class="line">			  break;</div><div class="line">	 case LH: /*  新结点插入在T的右孩子的左子树上，要作双旋处理 */ </div><div class="line">			  Rl=R-&gt;lchild; /*  Rl指向T的右孩子的左子树根 */ </div><div class="line">			  switch(Rl-&gt;bf)</div><div class="line">			  &#123; /*  修改T及其右孩子的平衡因子 */ </div><div class="line">				case RH: (*T)-&gt;bf=LH;</div><div class="line">						 R-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case EH: (*T)-&gt;bf=R-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case LH: (*T)-&gt;bf=EH;</div><div class="line">						 R-&gt;bf=RH;</div><div class="line">						 break;</div><div class="line">			  &#125;</div><div class="line">			  Rl-&gt;bf=EH;</div><div class="line">			  R_Rotate(&amp;(*T)-&gt;rchild); /*  对T的右子树作右旋平衡处理 */ </div><div class="line">			  L_Rotate(T); /*  对T作左旋平衡处理 */ </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="插入与主函数"><a href="#插入与主函数" class="headerlink" title="插入与主函数"></a>插入与主函数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */ </div><div class="line">/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */ </div><div class="line">/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */</div><div class="line">Status InsertAVL(BiTree *T,int e,Status *taller)</div><div class="line">&#123;  </div><div class="line">	if(!*T)</div><div class="line">	&#123; /*  插入新结点，树“长高”，置taller为TRUE */ </div><div class="line">		 *T=(BiTree)malloc(sizeof(BiTNode));</div><div class="line">		 (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=NULL; (*T)-&gt;bf=EH;</div><div class="line">		 *taller=TRUE;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if (e==(*T)-&gt;data)</div><div class="line">		&#123; /*  树中已存在和e有相同关键字的结点则不再插入 */ </div><div class="line">			*taller=FALSE; return FALSE;</div><div class="line">		&#125;</div><div class="line">		if (e&lt;(*T)-&gt;data)</div><div class="line">		&#123; /*  应继续在T的左子树中进行搜索 */ </div><div class="line">			if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) /*  未插入 */ </div><div class="line">				return FALSE;</div><div class="line">			if(taller) /*   已插入到T的左子树中且左子树“长高” */ </div><div class="line">				switch((*T)-&gt;bf) /*  检查T的平衡度 */ </div><div class="line">				&#123;</div><div class="line">					case LH: /*  原本左子树比右子树高，需要作左平衡处理 */ </div><div class="line">							LeftBalance(T);	*taller=FALSE; break;</div><div class="line">					case EH: /*  原本左、右子树等高，现因左子树增高而使树增高 */ </div><div class="line">							(*T)-&gt;bf=LH; *taller=TRUE; break;</div><div class="line">					case RH: /*  原本右子树比左子树高，现左、右子树等高 */  </div><div class="line">							(*T)-&gt;bf=EH; *taller=FALSE; break;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123; /*  应继续在T的右子树中进行搜索 */ </div><div class="line">			if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) /*  未插入 */ </div><div class="line">				return FALSE;</div><div class="line">			if(*taller) /*  已插入到T的右子树且右子树“长高” */ </div><div class="line">				switch((*T)-&gt;bf) /*  检查T的平衡度 */ </div><div class="line">				&#123;</div><div class="line">					case LH: /*  原本左子树比右子树高，现左、右子树等高 */ </div><div class="line">							(*T)-&gt;bf=EH; *taller=FALSE;	break;</div><div class="line">					case EH: /*  原本左、右子树等高，现因右子树增高而使树增高  */</div><div class="line">							(*T)-&gt;bf=RH; *taller=TRUE; break;</div><div class="line">					case RH: /*  原本右子树比左子树高，需要作右平衡处理 */ </div><div class="line">							RightBalance(T); *taller=FALSE; break;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	int i;</div><div class="line">	int a[10]=&#123;3,2,1,4,5,6,7,10,9,8&#125;;</div><div class="line">	BiTree T=NULL;</div><div class="line">	Status taller;</div><div class="line">	for(i=0;i&lt;10;i++)</div><div class="line">	&#123;</div><div class="line">		InsertAVL(&amp;T,a[i],&amp;taller);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后不得不说，AVL树是在是太复杂了，但是其思想是在是太精妙了，它克服了二叉排序树在查找效率上的不足，通过在插入数据时，就将其变成一个平衡二叉树，从而使其时间复杂度为O(logn)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;AVL树，也叫平衡二叉树，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。同时，将二叉树上结点的左子树深度减去右子树深度
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="http://www.myzwl.win/2017/07/27/BSTSort_1/"/>
    <id>http://www.myzwl.win/2017/07/27/BSTSort_1/</id>
    <published>2017-07-27T05:48:51.000Z</published>
    <updated>2017-08-12T05:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>二叉排序树，又称为二分查找树，它或者是一颗空树，或者具有如下性质<br>1.若它的左子树不为空，则左子树上所有结点的值均小于根结点值<br>2.若它的右子树不为空，则右子树上所有结点的值均小于根结点值<br>3.它的左右子树也分别为二叉排序树<br><img src="/images/imgs4/23.gif" alt="Alt text"></p>
<h4 id="二叉排序树查找操作"><a href="#二叉排序树查找操作" class="headerlink" title="二叉排序树查找操作"></a>二叉排序树查找操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">typedef struct BiTNode</div><div class="line">&#123;</div><div class="line">	int data;</div><div class="line">	struct BiTNode *lchild,*rchild;</div><div class="line">&#125;BiTNode,*BiTree;</div><div class="line"></div><div class="line"></div><div class="line">//递归查找二叉排序树中是否存在key</div><div class="line">//f指向T的双亲，初始值为NULL</div><div class="line">//若查找成功，则p指向该节点，并返回true</div><div class="line">//若查找失败，则p指向查找路径上访问的最后一个结点，并返回FALSE</div><div class="line">Status SearchBST(BiTree T,int key,BiTree f,BiTree *p)</div><div class="line">&#123;</div><div class="line">	if(!T)     //查找不成功</div><div class="line">	&#123;</div><div class="line">		*p=f;</div><div class="line">		return FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	else if(key==T-&gt;data) //查找成功</div><div class="line">	&#123;</div><div class="line">		*p=T;</div><div class="line">		return TRUE;</div><div class="line">	&#125;</div><div class="line">	else if(key&gt;T-&gt;data)&#123;         //在右子树中递归查找</div><div class="line">		return SearchBST(T-&gt;rchild,key,T,p);</div><div class="line">	&#125;</div><div class="line">	else if(key&lt;T-&gt;data)          //在左子树中递归查找</div><div class="line">		return SearchBST(T-&gt;lchild,key,T,p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看看它的过程是如何运行的，比如现在要查找93，显然初始化为SearchBST(T,93,NULL,p),因为93&gt;62，所以递归执行SearchBST(T-rchild,93,T,p),即SearchBST(88,93,62,P)这里用结点data值表示结点，又93&gt;88,继续SearchBST(99,93,88,P)，又93&lt;99，SearchBST(93,93,99,P)，所以93==93，得到最终p=T=93，f=99，查找成功。<br>可以发现二叉排序树的查找算法如此精妙而又优雅</p>
<h4 id="二叉排序树的插入操作"><a href="#二叉排序树的插入操作" class="headerlink" title="二叉排序树的插入操作"></a>二叉排序树的插入操作</h4><p>插入操作是基于查找操作的，也就是如果该二叉树为空，则新插入点为根结点，如果不为空，在先查找是否存在此元素，存在返回FALSE，否则在查找路径上的最后一个结点，通过比较插入到左孩子还是右孩子，最终返回TRUE<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Status InsertBST(BiTree *T,int key)</div><div class="line">&#123;</div><div class="line">	BiTree p,s;</div><div class="line">	if(!SearchBST(T,key,NULL,&amp;p)) //查找不成功</div><div class="line">	&#123;</div><div class="line">		s=(BiTree)malloc(sizeof(BiTNode));</div><div class="line">		 s-&gt;data=key;</div><div class="line">		 s-&gt;lchild=s-&gt;rchild=NULL;</div><div class="line">		 if(!p)                    //插入s为新的根结点</div><div class="line">		 	*T=s;</div><div class="line">		 else if(key&lt;s-data)      //插入s为左孩子</div><div class="line">		 	p-&gt;lchild=s;</div><div class="line">		 else                     //插入s为右孩子</div><div class="line">		 	p-&gt;rchild=s;</div><div class="line">		 return TRUE;</div><div class="line">	&#125;</div><div class="line">	else                       //树中已存在此关键字，则不插入</div><div class="line">		return FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="二叉排序树的删除操作"><a href="#二叉排序树的删除操作" class="headerlink" title="二叉排序树的删除操作"></a>二叉排序树的删除操作</h4><p>删除操作需要考虑三种情况，因为删除之后要保证还是一颗二叉排序树。如图<br><img src="/images/imgs4/24.gif" alt="Alt text"><br>一：删除叶子结点，这对这个二叉树来说并无影响，所以不移动其它元素<br>二：删除只含有左子树或者右子树的二叉排序树，因为根据二叉排序树的特点，很明显只要将它的左子树或右子树全部移动到它双亲的左子树或右子树就行了<br>三：删除既有左子树又有右子树的结点，我们可以通过它的中序遍历，也就是让它的直接前驱或者直接后继来替换它的位置，然后直接后继在分三种情况，直至只有一个孩子或者无孩子来替换<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">Status DeleteBST(BiTree *T,int key) //找到待删结点</div><div class="line">&#123;</div><div class="line">	if(!*T)</div><div class="line">		return FALSE;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if(key==(*T)-&gt;data)</div><div class="line">			return Delete(T);</div><div class="line">		else if(key&lt;(*T)-&gt;data)</div><div class="line">			return DeleteBST(&amp;(*T)-&gt;lchild,key);</div><div class="line">		else</div><div class="line">			return DeleteBST(&amp;(*T)-&gt;rchild,key);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//从二叉树中删除结点p，并重接它的左或右子树</div><div class="line">Status Delete(BiTree *p)</div><div class="line">&#123;</div><div class="line">	BiTree q,s;</div><div class="line">	if((*p)-&gt;rchild==NULL)  //右子树空则重接它的左子树</div><div class="line">	&#123;</div><div class="line">		q=*p;</div><div class="line">		*p=(*p)-&gt;lchild;</div><div class="line">		free(q);</div><div class="line">	&#125;</div><div class="line">	else if((*p)-&gt;lchild==NULL) //左子树空则重接它的右子树</div><div class="line">	&#123;</div><div class="line">		q=*p;</div><div class="line">		*p=(*p)-&gt;rchild;</div><div class="line">		free(q);</div><div class="line">	&#125;</div><div class="line">	else&#123;         //左右子树均不为空</div><div class="line">		q=*p;</div><div class="line">		s=(*p)-&gt;lchild;</div><div class="line">		while(s-&gt;lchild) //找到待删结点的前驱</div><div class="line">		&#123;</div><div class="line">			q=s;</div><div class="line">			s=s-&gt;rchild;</div><div class="line">		&#125;</div><div class="line">		(*p)-&gt;data=s-&gt;data;</div><div class="line">		if(q!=*p)        //重接q的右子树</div><div class="line">			q-&gt;rchild=s-&gt;lchild;</div><div class="line">		else             //重接q的左子树</div><div class="line">			q-&gt;lchild=s-&gt;lchild;</div><div class="line">		free(s);</div><div class="line">	&#125;</div><div class="line">	return TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>二叉排序树是以链式结构进行存储，所以在插入和删除元素上高效，，但是查找上走的是从根路径到结点的路径，其比较次数与数的层数有关如果该数是一颗斜数，那么查找就会比较很多次，如果该树是一颗完全二叉树，那么比较次数就最优，此时时间复杂度为O(logn),但是平均来说时间复杂度为O(n)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;二叉排序树，又称为二分查找树，它或者是一颗空树，或者具有如下性质&lt;br&gt;1.若它的左子树不为空，则左子树上所有结点的值均小于根结点值&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>死锁和生产者消费者问题</title>
    <link href="http://www.myzwl.win/2017/07/26/procos_1/"/>
    <id>http://www.myzwl.win/2017/07/26/procos_1/</id>
    <published>2017-07-26T05:48:51.000Z</published>
    <updated>2017-08-10T08:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>线程同步操作的是同一个线程对象，所以可能造成线程不安全，出现非数据的原子操作，所以，需要加锁，同时线程是程序的执行顺序，也就是cpu根据不同时间片选择某个时间执行某个线程，关于线程并发，在以前的总结中做过了几个简单的总结。<br>而死锁最经典的例子就是哲学家进餐问题，每个哲学家都左手拿着一只筷子，并且总共有五个哲学家，5个筷子，只有当哲学家左右手都有筷子时才能进餐，所以每个哲学家都在等右边哲学家方上筷子，处于僵持等待状态，称为死锁。<br>这里模仿两个线程死锁的情况<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class LockTest implements Runnable&#123;</div><div class="line"></div><div class="line">	public int flag=1;</div><div class="line">	 static Object o1=new Object(),o2=new Object();</div><div class="line">	   </div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println("flag="+flag);</div><div class="line">		 if(flag==1)&#123;</div><div class="line">		 synchronized (o1) &#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(5000);</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			synchronized (o2) &#123;</div><div class="line">				System.out.println("1");</div><div class="line">			&#125;</div><div class="line">		 &#125;	 </div><div class="line">		&#125;</div><div class="line">		if(flag==0)&#123;</div><div class="line">			 synchronized (o2) &#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(5000);</div><div class="line">					&#125; catch (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					synchronized (o1) &#123;</div><div class="line">						System.out.println("0");</div><div class="line">					&#125;</div><div class="line">				 &#125;	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LockTest lt1=new LockTest();</div><div class="line">		LockTest lt2=new LockTest();</div><div class="line">		 lt1.flag=1;</div><div class="line">		 lt2.flag=0;</div><div class="line">		  Thread t1=new Thread(lt1);</div><div class="line">		  Thread t2=new Thread(lt2);</div><div class="line">		  t1.start();</div><div class="line">		  t2.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>flag=1<br>flag=0</p>
</blockquote>
<p>大概分析一下，该类本身是一个线程类，flag用来控制执行哪个锁，O1和O2是两个被锁住对象，flag为1时先锁住o1，在锁住o2，flag为0则相反，而死锁发生就在此处两个线程启动了，o1被锁住了，另一个o2被锁住了，都在等待对方释放锁，显然处于僵持，产生死锁，<br>解决死锁的一个简单办法就是增大锁的粒度，扩大锁对象，比如讲前面的O1与O2改成this<br>结果：</p>
<blockquote>
<p>flag=1<br>flag=0<br>1<br>0</p>
</blockquote>
<h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><p>概述，模拟一个生产者利用生产食物放到篮子里，而一个消费者从篮子里消费食物<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">public class Food &#123; //食物类</div><div class="line"> int id;</div><div class="line"> public Food(int id)&#123;</div><div class="line">	 this.id=id;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class UtilStack &#123;//工具，用来放食物</div><div class="line"></div><div class="line">	int index=0; //食物计数变量</div><div class="line">	Food[] arrFD=new Food[4]; //最多工具能放食物容量</div><div class="line">	</div><div class="line">	public synchronized void push(Food fd)&#123; //生产食物，必须加锁，保证生产过程不被打断</div><div class="line">		while(index==arrFD.length)</div><div class="line">		&#123;</div><div class="line">			try &#123;</div><div class="line">				System.out.println("full");</div><div class="line">				this.wait();  //生产满了，就去休息区休息，等待被唤醒</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		this.notify();//唤醒当前在休息区的线程</div><div class="line">		arrFD[index]=fd;</div><div class="line">		index++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public synchronized Food pop()&#123; //消费</div><div class="line">		while(index==0) //消费完了，进休息区</div><div class="line">			try &#123;</div><div class="line">				System.out.println("empty");</div><div class="line">				this.wait();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		this.notify();</div><div class="line">		index--;</div><div class="line">		return arrFD[index];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Producer implements Runnable&#123;//生产者</div><div class="line"></div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Producer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=new Food(i);</div><div class="line">			ss.push(fd);</div><div class="line">			System.out.println("生产了"+fd.id);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(1000);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Consumer implements Runnable&#123;//消费者</div><div class="line"></div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Consumer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=ss.pop();</div><div class="line">			System.out.println("消费了"+fd.id);</div><div class="line">		 try &#123;</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>消费利用一对生产者和消费者模拟</p>
<blockquote>
<pre><code>UtilStack ss=new UtilStack();
    Producer p=new Producer(ss);
    Consumer c=new Consumer(ss);
    new Thread(p).start();
    new Thread(c).start();
</code></pre></blockquote>
<p>结果如下：</p>
<blockquote>
<p>生产了0<br>消费了0<br>生产了1<br>生产了2<br>消费了2<br>生产了3<br>生产了4<br>消费了4<br>生产了5<br>生产了6<br>消费了6<br>生产了7<br>full<br>消费了7<br>生产了8<br>full<br>消费了8<br>生产了9<br>full<br>消费了9<br>生产了10<br>full<br>消费了10<br>生产了11<br>full<br>消费了11<br>生产了12<br>full<br>消费了12<br>生产了13<br>full<br>消费了13<br>生产了14<br>full<br>消费了14<br>生产了15<br>full</p>
</blockquote>
<p>这里优于设置了消费者消费时间长，所以导致index不一样。可以发现当生产者满了，生产者不生产了，进入休息区，等待被唤醒，关于wait（）、notify（）、notifyAll（），在之前的多线程总结中已总结了</p>
<p><strong>结果分析</strong><br>从中我们可以看到生产者有满了的情况，但是消费者消费完了，index就不满了，然后就去叫醒了生产者继续生产，同样如果我们把消费者时间设置短一点看看，预测应该是empty的，在被生产者叫醒</p>
<blockquote>
<p>生产了0<br>消费了0<br>empty<br>消费了1<br>生产了1<br>empty<br>消费了2<br>生产了2<br>empty<br>消费了3<br>生产了3<br>empty<br>生产了4<br>消费了4<br>empty</p>
</blockquote>
<p>最后不得不说生产者与消费者问题可以解决平时在项目开发配置中不求甚解的一些问题，像缓冲区、连接池、消息队列、死锁、同步等等，</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h4&gt;&lt;p&gt;线程同步操作的是同一个线程对象，所以可能造成线程不安全，出现非数据的原子操作，所以，需要加锁，同时线程是程序的执行顺序，也就是cpu根据不同
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://www.myzwl.win/2017/07/25/quick_1/"/>
    <id>http://www.myzwl.win/2017/07/25/quick_1/</id>
    <published>2017-07-25T05:48:51.000Z</published>
    <updated>2017-08-10T04:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速排序被列为20世纪十大算法之一，正如其名一样，排序的速度非常快。<br>而它的基本思想就是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续排序，最终达到有序的目的<br><img src="/images/imgs4/22.gif" alt="Alt text"></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>采取同样的策略，从计算机的角度看看程序是怎么执行的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void QuickSort(SqList *L)&#123;</div><div class="line">  QSort(L,1,L-&gt;length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void QSort(SqList *L,int low,int high)&#123;</div><div class="line">  int pivot;</div><div class="line">   if(low&lt;high)&#123;</div><div class="line">    pivot=Partition(L,low,high);//将L-&gt;r[low..high]一分为二</div><div class="line">     QSort(L,low,pivor-1); //对低子表递归排序</div><div class="line">      QSort(L,pivot+1,high); //对高子表递归排序</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>里面有个函数Partition(L,low,high),和归并排序一样，暂时先不管它，初始化数组为{50,10,90,30,70,40,80,60,20}，初始low=1，high=9；<br>pivot为选择其中一个关键字，比pivot小的排到左边，比pivot大的排到右边，显然此时pivot=5，然后执行 QSort(L，1,4）直至排好序，同样右边也是递归调用QSort（L，6,9），这里的核心算法也就是Partition(L,low,high)如何排序的了<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int Partition(SqList *L,int low,int high)&#123;</div><div class="line">  int pivotkey;</div><div class="line">   pivotkey=L-&gt;[low]; //用子表的第一个记录做关键字</div><div class="line">    while(low&lt;high)</div><div class="line">    &#123;</div><div class="line">      while(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</div><div class="line">        high--;</div><div class="line">      swap(L,low,high);//交换low和high的记录</div><div class="line">      while(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</div><div class="line">         low++;</div><div class="line">       swap(L,low,high);</div><div class="line">    &#125;</div><div class="line">    return low;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样一行一行的看，这里默认选取子表的第一个记录作为关键字pivotkey=L-&gt;[low];接下来，由于low=1<high=9，执行内部程序，然后比较l->r[high]=L-&gt;r[9]=20与pivotkey=50大小，显然前者小于后者，不满足，将high与low交换，也就是说小的在左边，此时为{20,10,90.。。50},；然后明显20<50，所以low++；得low=2；并且10<50，在循环，得low=3，此时90>50,退出循环，在此交换位置，得{20,10,50.。。。90}；<br>最后low=3<9在循环，90>50,满足，high–，high=8，有L-&gt;high[8]=60&gt;50;high–;有80&gt;50;high–,有40&lt;50,退出循环，此时high=6，交换，依次类推，最终low=high=5，退出整个循环<br>最后在分别递归低和高的子表，最后我们发现他的规律如此只简单，遇到比关键字小的，依次递增比较，直到有比它大的，在换另一边比较，不得不说快速排序实在是太精妙了</9在循环，90></50，所以low++；得low=2；并且10<50，在循环，得low=3，此时90></high=9，执行内部程序，然后比较l-></p>
<p>最后再来看一下快速排序的时间复杂度，在最优的情况下为O（nlogn);</p>
<h4 id="排序算法间的比较"><a href="#排序算法间的比较" class="headerlink" title="排序算法间的比较"></a>排序算法间的比较</h4><p><img src="/images/imgs4/2.png" alt="Alt text"><br>分类<br><img src="/images/imgs4/15.jpg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;快速排序被列为20世纪十大算法之一，正如其名一样，排序的速度非常快。&lt;br&gt;而它的基本思想就是通过一趟排序将待排序的记录分割成独立的两部分，
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://www.myzwl.win/2017/07/24/guibin_1/"/>
    <id>http://www.myzwl.win/2017/07/24/guibin_1/</id>
    <published>2017-07-24T05:48:51.000Z</published>
    <updated>2017-08-10T08:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>归并的意思就是将两个或者两个以上的有序数组合成一个有序表。而归并排序就是将含有n个记录的子序列，每个子序列长度为1，然后两两归并，得到[n/2]个长度为2或者1的有序子序列，在两两归并，。。。。，如此重复，直到得到一个长度为n的有序序列为止<br><img src="/images/imgs4/14.jpg" alt="Alt text"></p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>不妨先看代码，在从计算机角度去看看是如何执行代码过程的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void MergeSort(SqList *L)&#123;</div><div class="line">  MSort(L-&gt;r,L-&gt;r,1,L-&gt;length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//将SR[s..t]归并到TR1[s..t]</div><div class="line">void MSort(int SR[],int TR1[],int s,int t)&#123;</div><div class="line">  int m;</div><div class="line">  int TR2[MAXSIZE+1];</div><div class="line">  if(s==t)</div><div class="line">    TR1[s]=SR[s];</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    m=(s+t)/2;</div><div class="line">    MSort(SR,TR2,s,m);</div><div class="line">    MSort(SR,TR2,m+1,t);</div><div class="line">    Merge(TR2,TR1,s,m,t);//将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>里面有个递归 Merge(TR2,TR1,s,m,t);暂时先不管它，假设模拟的数组为{50,10,90,30,70,40,80,60,20}，所以知道初始化时SR和TR1都是该数组，s=1，t-9；由于s！=t，所以执行else中的语句。此时m=5，也就是正中间下标，所以开始先执行递归MSort(SR,TR2,1,5)，递归过程如下所示<br><img src="/images/imgs4/21.gif" alt="Alt text"><br>其核心部分就是最后都变成叶子结点，递归结束，然后执行if里语句，不过此时TR1[s]=SR[s]，注意这里s是元素下标，所以第一次TR2={50,10}，然后就要执行Merge(TR2,TR1,s,m,t);前面是50与10已结归并了，暂时我们知道它就是把无需归并为有序就行了，即TR2={10,50}后面在详细分析它，<br>接下来同理，依次向上归并，最后得到{10,30,50,70,90}，同理，根结点右子树也一样，最终完成了归并</p>
<p>再来看看Merge(TR2,TR1,s,m,t)函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void Merge(int SR[],int TR[],int i,int m,int n)</div><div class="line">&#123;</div><div class="line">  int j,k,l;</div><div class="line">   for(j=m+1,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++)</div><div class="line">   &#123;</div><div class="line">    if(SR[i]&lt;SR[j])</div><div class="line">      TR[k]=SR[i++];</div><div class="line">    else</div><div class="line">      TR[k]=SR[j++];</div><div class="line">   &#125;</div><div class="line">   if(i&lt;=m)&#123;  //将剩余元素归并</div><div class="line">    for(l=0;l&lt;=m-1;l++)</div><div class="line">      TR[k+1]=SR[i+1];</div><div class="line">  &#125;</div><div class="line"> if(j&lt;=n)</div><div class="line"> &#123;</div><div class="line">  for(l=0;l&lt;n-j;l++)</div><div class="line">    TR[k+1]=SR[j+1];</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就拿{10,30,50,70,90}和{20,40,60,80}归并为有序序列来说，此时i=1，m=5,n=9；进入for循环，此时j从6到9，i由1到5，k由1开始每次加1，并且k就是TR数组的下标，然后开始归并，左右子树的SR[i]=SR[1]=10与SR[j]=SR[6]=20开始比较，将较小数放入到一个初始化时空的TR[]中，比如是10，然后i++；否则j++，这样就可以得到有序序列了，但是最终当j=10时退出循环，而后面还有一些元素未归并，将执行后面if语句，将最后的90复制到最后，最终完成了归并</p>
<p>最后再来看看归并排序的时间复杂度，由于其与完全二叉树有关，最终得到其为O（nlogn)，而它也是比较占用内存但是很稳定的一种算法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;归并的意思就是将两个或者两个以上的有序数组合成一个有序表。而归并排序就是将含有n个记录的子序列，每个子序列长度为1，然后两两归并，得到[n/
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java IO简单总结</title>
    <link href="http://www.myzwl.win/2017/07/23/IO_1/"/>
    <id>http://www.myzwl.win/2017/07/23/IO_1/</id>
    <published>2017-07-23T05:48:51.000Z</published>
    <updated>2017-08-09T07:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在涉及IO流之前需要知道文件的概念。文件是数据源（保存数据的的地方）的一种，比如word文件、txt文件。他既可以保存一张图片，也可以保存视频、声音。。。等等<br><strong>文件流</strong><br><img src="/images/imgs4/19.gif" alt="Alt text"><br>文件在程序中是以流的形式来操作的<br>流：数据在数据源（文件）和程序（内存）之间经历的路径<br>输入流：数据从数据源到内存的路径<br>输出流：数据从内存到数据源的路径</p>
<h4 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h4><p>1.根据处理数据类型的不同分为：字符流和字节流<br>字节流：可以用于读写二进制文件及任何类型的byte，也就是一个字节一个的读<br>字符流：可以用于读写文本文件，不能操作二进制文件，也就是两个字节两个字节的读<br>2.根据数据流向不同分为：输入流和输出流<br>3。节点流和处理流<br>节点流：直接与数据源相连，读入或读出，可以发现使用该流过于频繁操作硬件，从而使读写很不方便<br>常用的结点流：</p>
<blockquote>
<p>父类：InputStream、OutputStream、Reader、Writer<br>文件 ：FileInputStream 、 FileOutputStrean 、FileReader、FileWriter 文件进行处理的节点流<br>数　组 ：ByteArrayInputStream、 ByteArrayOutputStream、 CharArrayReader 、CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）<br>字符串 ：StringReader、 StringWriter 对字符串进行处理的节点流<br>管　道 ：PipedInputStream 、PipedOutputStream 、PipedReader 、PipedWriter 对管道进行处理的节点流</p>
</blockquote>
<p>处理流：处理流和节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。<br><img src="/images/imgs4/20.gif" alt="Alt text"><br>常用的处理流：</p>
<blockquote>
<p>缓冲流：BufferedInputStrean 、BufferedOutputStream、 BufferedReader、 BufferedWriter 增加缓冲功能，避免频繁读写硬盘<br>转换流：InputStreamReader 、OutputStreamReader实现字节流和字符流之间的转换<br>数据流： DataInputStream 、DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来</p>
</blockquote>
<p><img src="/images/imgs4/13.jpg" alt="Alt text"></p>
<h4 id="文件File类"><a href="#文件File类" class="headerlink" title="文件File类"></a>文件File类</h4><p><strong>File常用方法</strong></p>
<blockquote>
<p>创建：<br>createNewFile()在指定位置创建一个空文件，成功就返回true，如果已存在就不创建，然后返回false。<br>mkdir()  在指定位置创建一个单级文件夹。<br>mkdirs()  在指定位置创建一个多级文件夹。<br>renameTo(File dest)如果目标文件与源文件是在同一个路径下，那么renameTo的作用是重命名， 如果目标文件与源文件不是在同一个路径下，那么renameTo的作用就是剪切，而且还不能操作文件夹。<br>删除：<br>delete()  删除文件或者一个空文件夹，不能删除非空文件夹，马上删除文件，返回一个布尔值。<br>deleteOnExit()jvm退出时删除文件或者文件夹，用于删除临时文件，无返回值。<br> 判断：<br>exists()  文件或文件夹是否存在。<br>isFile()  是否是一个文件，如果不存在，则始终为false。<br>isDirectory()  是否是一个目录，如果不存在，则始终为false。<br>isHidden()  是否是一个隐藏的文件或是否是隐藏的目录。<br>isAbsolute()  测试此抽象路径名是否为绝对路径名。<br> 获取：<br>getName()  获取文件或文件夹的名称，不包含上级路径。<br>getAbsolutePath()获取文件的绝对路径，与文件是否存在没关系<br>length()  获取文件的大小（字节数），如果文件不存在则返回0L，如果是文件夹也返回0L。<br>getParent()  返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回null。<br>lastModified()获取最后一次被修改的时间。<br>文件夹相关：<br>static File[] listRoots()列出所有的根目录（Window中就是所有系统的盘符）<br>list()  返回目录下的文件或者目录名，包含隐藏文件。对于文件这样操作会返回null。<br>listFiles()  返回目录下的文件或者目录对象（File类实例），包含隐藏文件。对于文件这样操作会返回null。<br>list(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。<br>listFiles(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> //创建一个文件对象</div><div class="line">  File f1=new File("e:\\aa.txt");</div><div class="line">  //得到文件的路径</div><div class="line">  System.out.println("文件路径"+f1.getAbsolutePath());</div><div class="line">//得到文件的大小,字节数</div><div class="line">  System.out.println("文件的大小"+f1.length());</div><div class="line">//创建文件夹</div><div class="line">		File f3=new File("e:\\ff");</div><div class="line">		//判断文件夹是否存在</div><div class="line">		if(f3.isDirectory())&#123;</div><div class="line">			System.out.println("文件夹存在，不能创建!");</div><div class="line">		&#125;else&#123;</div><div class="line">			//创建文件夹</div><div class="line">			f3.mkdir();</div><div class="line">		&#125;</div><div class="line">		//创建文件和创建文件夹</div><div class="line">		File f2=new File("e:\\ff\\zwl.txt");</div><div class="line">		//判断文件是否存在</div><div class="line">		if(!f2.exists())//可以创建</div><div class="line">			try &#123;</div><div class="line">				f2.createNewFile();//创建一个新文件</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		else&#123;</div><div class="line">			System.out.println("文件存在，不能创建!");</div><div class="line">		&#125;</div><div class="line">		//列出一个文件夹下面的所有文件</div><div class="line">		File f4=new File("e:\\ff");</div><div class="line">		//判断文件夹是事存在</div><div class="line">		if(f4.isDirectory())&#123;</div><div class="line">			//将文件夹的文件，传给lists数组</div><div class="line">			//将文件夹的文件，传给lists数组</div><div class="line">			File lists[]=f4.listFiles();</div><div class="line">			//遍历数组</div><div class="line">			for(int i=0;i&lt;lists.length;i++)&#123;</div><div class="line">				//输出文件夹下所有文件文件名</div><div class="line">				System.out.println("显示出文件名是"+lists[i].getName());</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>对应的结果：</p>
<blockquote>
<p>文件路径e:\aa.txt<br>文件的大小0<br>显示出文件名是zwl.txt</p>
</blockquote>
<h4 id="文件字节与字符流"><a href="#文件字节与字符流" class="headerlink" title="文件字节与字符流"></a>文件字节与字符流</h4><p><strong>InputStream常用方法</strong></p>
<blockquote>
<p>public abstract int read() throws IOException:从输入流中读取数据的下一个字节,到达末尾，返回-1；<br> public int read(byte[] b)throws IOException：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中<br> public int read(byte[] b,int off,int len)throws IOException：将输入流中最多 len 个数据字节读入 byte 数组<br> public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源</p>
</blockquote>
<p><strong>OutputStream常用方法</strong></p>
<blockquote>
<p>public void flush()throws IOException:刷新此输出流并强制写出所有缓冲的输出字节<br> public abstract void write(int b)throws IOException:将 b.length 个字节从指定的 byte 数组写入此输出流。<br> public void write(byte[] b, int off, int len)throws IOException:将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流<br> public void write(byte[] b)throws IOException:将指定的字节写入此输出流。</p>
</blockquote>
<p> Reader与Writer和上述方法基本类似，只不过它操作的是字符。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">int b=0;</div><div class="line">  //FileInputStream in=null;</div><div class="line">  FileReader in=null;</div><div class="line">   FileOutputStream out=null;</div><div class="line">    try &#123;</div><div class="line">		in=new FileReader("E:\\php练习\\readmeFirst.txt");</div><div class="line">		out=new FileOutputStream("E:\\php练习\\ttl.txt");</div><div class="line">	&#125; catch (Exception e) &#123;</div><div class="line">		System.out.println("not file");</div><div class="line">		 System.exit(-1);</div><div class="line">	&#125;</div><div class="line">    try &#123;</div><div class="line">		long num=0;</div><div class="line">		while((b=in.read())!=-1)&#123;</div><div class="line">			System.out.print((char)b);</div><div class="line">			//out.write(b);;</div><div class="line">			num++;</div><div class="line">		&#125;</div><div class="line">		in.close();</div><div class="line">		out.close();</div><div class="line">		System.out.println();</div><div class="line">		System.out.println("共读取了"+num+"个字符");</div><div class="line">	&#125; catch (Exception e) &#123;</div><div class="line">		System.out.println("error!");</div><div class="line">		 System.exit(-1);</div><div class="line">	&#125;</div><div class="line">    System.out.println("copy ok");</div></pre></td></tr></table></figure></p>
<p>上面程序是将已存在的一个文件复制到另一个文件中</p>
<p><strong>缓冲字节与字符流</strong><br>它是在原来节点流基础上增加了一根管道，用于缓存数据，用法基本类似，但是它的构造函数必须是结点流，同时在字符缓冲流中有一个可以读取或存取字符串的方法如：</p>
<blockquote>
<p>public String readLine()throws IOException:读取一个文本行</p>
</blockquote>
<p><strong>Object流</strong><br>Object流的意思将是像一根节点流插入一根Object流管道，专门操作Object，而它必须实现Serializable接口，该接口的意思是可序列化，就是说将一个对象流序列化成子节流写进网络或者文件，比如说游戏存盘，有各个游戏的记录，如果以面向对象来写进管道，它的各个成员变量，会在内存中被序列化成二进制写进去，而Serializable接口无方法，它只是个标记接口，编译器看到实现该接口的类就知道它应该被序列化，同样有一个transient关键字，是使可序列化的某个属性变成透明，也就是它不能变成字节写进去，那个属性只能为默认属性写进去<br>ok，接下来就来看看Object流相关常用方法</p>
<blockquote>
<p>ObjectOutput:有一个void writeObject(Object obj) throws IOException：将对象写入底层存储或流。<br>ObjectInput：Object readObject()throws ClassNotFoundException,IOException：读取并返回对象</p>
</blockquote>
<p>最后不得不说IO流是在太复杂，就是一根管道不断套接着另一根管道，但是IO流是非常有用的，不仅能帮助我们了解计算机底层，而且涉及到数据传输都离不开它。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在涉及IO流之前需要知道文件的概念。文件是数据源（保存数据的的地方）的一种，比如word文件、txt文件。他既可以保存一张图片，也可以保存视
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>直接插入和希尔排序</title>
    <link href="http://www.myzwl.win/2017/07/22/inserSort_1/"/>
    <id>http://www.myzwl.win/2017/07/22/inserSort_1/</id>
    <published>2017-07-22T05:48:51.000Z</published>
    <updated>2017-08-09T04:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>直接插入在本质上改良了之前的冒泡和选择排序，而希尔排序更是超越O（n^2)的传统排序的改良算法</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>算法描述：直接插入排序就是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表<br>首先先定义数据结构</p>
<blockquote>
<p>#define MAXSIZE 10<br>typedef struct{<br>    int r[Maxsize+1]//用于存储要排序的数组，r[0]用作哨兵或者临时变量<br>    int length; //记录顺序表的长度<br>}SqList;</p>
</blockquote>
<p>接下来不妨以5个数模拟该算法执行过程</p>
<blockquote>
<p>初始化为{0,5,3,4,6,2}<br>从第二个数开始往前比较，如3比5小，那么，3赋值给哨兵，5后移到3位置，哨兵赋值给5位置，此时变成<br>{3,3,5,4,6,2}；<br>继续循环，哨兵初始化为0,4比5小，4给哨兵，5后移至4，在比较哨兵与3大小，如果比3小，3后移，在插入到该位置，否则直接插到5位置，ok这就是该算法的核心，在合适的位置直接插入</p>
</blockquote>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>下面在来看算法，一般理解算法的过程，就把自己当做计算机，自我调试，然后就会发现其中无穷的乐趣<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;    </div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;ctype.h&gt;      </div><div class="line">#include &lt;stdlib.h&gt;   </div><div class="line">#include &lt;io.h&gt;  </div><div class="line">#include &lt;math.h&gt;  </div><div class="line">#include &lt;time.h&gt;</div><div class="line"></div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define TRUE 1</div><div class="line">#define FALSE 0</div><div class="line"></div><div class="line"></div><div class="line">typedef int Status; </div><div class="line"></div><div class="line"></div><div class="line">#define MAXSIZE 10000  /* 用于要排序数组个数最大值，可根据需要修改 */</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	int r[MAXSIZE+1];	/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</div><div class="line">	int length;			/* 用于记录顺序表的长度 */</div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line">void InsertSort(SqList *L)</div><div class="line">&#123;</div><div class="line">	int i,j; //i用来控制外层循环，也就是r[i]中每个数，j用来控制r[i]与前面的数大小，并插到合适的位置</div><div class="line">for(i=2;i&lt;=L-&gt;length;i++)&#123;</div><div class="line">   if(L-&gt;r[i]&lt;L-&gt;r[i-1]) //要插的数比前一个数大</div><div class="line">   &#123;</div><div class="line">   	L-&gt;r[0]=L-&gt;r[i];    //要插入的数先放到哨兵</div><div class="line">   	 for(j=i-1;L-&gt;r[j]&gt;L-&gt;r[0];j--) //依次比较插入的数前面的数，放到合适的位置</div><div class="line">   	 	L-&gt;r[j+1]=L-&gt;r[j]; //记录后移</div><div class="line">   	 L-&gt;r[j+1]=L-&gt;r[0];  //插入合适的位置</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void print(SqList L) //打印元素</div><div class="line">&#123;</div><div class="line">	int i;</div><div class="line">	for(i=1;i&lt;L.length;i++)</div><div class="line">		printf("%d,",L.r[i]);</div><div class="line">	printf("%d",L.r[i]);</div><div class="line">	printf("\n");</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	int i;</div><div class="line">      int d[5]=&#123;5,3,4,6,2&#125;;</div><div class="line">        SqList L;</div><div class="line">          for(i=0;i&lt;5;i++)</div><div class="line">          	L.r[i+1]=d[i];</div><div class="line">             L.r[0]=0;</div><div class="line">             L.length=5;</div><div class="line">            printf("直接插入排序:\n");</div><div class="line">             InsertSort(&amp;L);</div><div class="line">              print(L);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面在看看它的时间复杂度，最好的情况就是{2,3,4,5,6}，也就是说其本身已经是一个有序的，很显然只需要L-&gt;r[i]与L-&gt;r[r-1]大小，所以此时时间复杂度为O(n);最坏的情况就是{6,5,4,3,2}，即2+3+。。+n为（n+2)(n-1)/2<br>所以最后根据平局原则，知道直接插入排序的时间复杂度为O(n^2);</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>基本有序</strong><br>首先需要了解一下基本有序的概念，就是指小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，如{2,1,3,6,4,7,5,8,9}，但如{1,5,9,3,7,8,2,4,6}这种9在第三位，2在倒数第三位就不叫基本有序</p>
<p>希尔排序的关键就是将相隔某个”增量”的记录组成一个子序列，实现跳跃式的移动</p>
<blockquote>
<p>初始一个数组{0,9,1,5,8,3,7,4,6,2}，其中0为哨兵<br>并且初始化增量为数组长度（哨兵不算），所以为9，并约定一个循环，当且仅当增量小于等于1退出循环，并且每次增量都执行增量=增量/3+1（也可以是其他增量原则），第一次就是4了<br>然后一个循环变量i从增量+1开始直到小于等于数组长度，然后比较该i值与i-增量值，也就是第一个值大小，后面就是直接插入算法思想了，有一点不一样，就是循环变量j控制不太一样</p>
</blockquote>
<p>然后看看上述数组怎么比较的</p>
<blockquote>
<p>第一次：i=增量+1=5开始，也就是3与9比较，明显满足3&lt;9,然后交换（直接插入思想），依次7与1，不交换，4与5交换，6与8交换，2与9交换这里那个j条件也满足并且2&lt;3在交换，ok得到一个交换后的数组<br>{2,1,4,6,3,7,5,8,9}可以发现经过第一轮后，该数组基本有序了<br>紧接着开始进行第二轮，即增量=增量/3+1=2，即从第三个2与4不交换，1与6不交换，4与3交换，6与7不交换，4与5不交换，7与8不交换，5与9不交换，即得到{2,1,3,6,4,7,5,,8,9};<br>最后一轮：增量为1,2与1交换，2与4不交换，然后依次比较，由于目前已经基本有序，所以交换的比较少，<br>最后得到{1,2,3,4,5,6,7,8,9}</p>
</blockquote>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>通过上面的例子，大概就是希尔排序的模拟过程，可以发现增量值是一个很巧妙的地方<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">void ShellSort(SqList *L)</div><div class="line">&#123;</div><div class="line">  int i,j;</div><div class="line">  int increment=L-&gt;length; //初始化增量为数组长度</div><div class="line">  do&#123;</div><div class="line">    increment=increment/3+1; //增量序列</div><div class="line">    for(i=increment+1;i&lt;=L-&gt;length;i++) //从增量序列后一位开始</div><div class="line">    &#123;</div><div class="line">      if(L-&gt;r[i]&lt;L-&gt;r[i-increment]) //该位置与第一位比较，是否交换</div><div class="line">      &#123;</div><div class="line">        L-&gt;r[0]=L-&gt;r[i]; //若交换，先放到哨兵位置</div><div class="line">         for(j=i-increment;j&gt;0&amp;&amp;L-&gt;r[0]&lt;L-&gt;r[j];j-=increment)</div><div class="line">           L-&gt;r[j+increment]=L-&gt;r[j]; //记录后移</div><div class="line">            L-&gt;r[j+increment]=L-&gt;r[0];//插入到正确位置</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;while(increment&gt;1);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	int i;</div><div class="line">      int d[5]=&#123;5,3,4,6,2&#125;;</div><div class="line">        SqList L;</div><div class="line">          for(i=0;i&lt;5;i++)</div><div class="line">          	L.r[i+1]=d[i];</div><div class="line">             L.r[0]=0;</div><div class="line">             L.length=5;</div><div class="line">            printf("希尔排序:\n");</div><div class="line">           ShellSort(&amp;L);</div><div class="line">               print(L);</div><div class="line">              print(L);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现希尔排序的关键就是增量的选择，而它的时间复杂度是O(n^(3/2)),显然比传统的算法O(n^2)时间复杂度要小很多</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;直接插入在本质上改良了之前的冒泡和选择排序，而希尔排序更是超越O（n^2)的传统排序的改良算法&lt;/p&gt;
&lt;h4 id=&quot;直接插入排序&quot;&gt;&lt;a
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常用集合类简单总结</title>
    <link href="http://www.myzwl.win/2017/07/21/jihes_1/"/>
    <id>http://www.myzwl.win/2017/07/21/jihes_1/</id>
    <published>2017-07-21T05:48:51.000Z</published>
    <updated>2017-08-08T12:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在没有集合之前我们都是直接用数组存放对象，但是这样操作会很不方便，于是利用数据结构封装了一些列集合，而集合中不存放输几局的基本类型，只存放对象的引用，如图（部分集合源码分析在之前的总结中已经简单研究过）<br><img src="/images/imgs4/1.png" alt="Alt text"><br>java集合主要分为以下三种类型：<br>Set(集)：集合中的对象不按特定方式排序，且没有重复对象。它的有些实现类能对集合中的对象按照特地方式排序。<br>List(列表)：集合中的对象按照索引位置排序，可以有重复对象，允许使用索引检索对象。<br>Map(映射)：集合中的每一个元素都包含一对键对象和值对象（key-value），集合中的键对象是不能重复的,它的一些实现类能对集合中的键对象进行排序。</p>
<p>注意这里的不能重复与比较hashcode和equals有关</p>
<h4 id="集合底层概述"><a href="#集合底层概述" class="headerlink" title="集合底层概述"></a>集合底层概述</h4><p><strong>Collection接口</strong><br>Collection接口是Set、List、Queue接口的父接口，提供了多数集合常用的方法声明，包括 add()、remove()、contains() 、size() 、iterator() 等</p>
<p><strong>List接口</strong><br>它的特点是有序可重复，使用此接口能够精确的控制每个元素插入的位置用户能够使用索引来访问List中的元素并且允许有可重复的元素</p>
<p><strong>ArrayList</strong><br>底层实现是一个动态的数组，查询快，增删慢，线程不安全，效率高</p>
<p><strong>LinkedList</strong><br>底层实现是一个双向循环链表，查询慢，增删快，线程不安全，效率较高</p>
<p><strong>Vector</strong><br>是ArrlyList的线程安全版，底层同它基本一致，但是效率低，现在基本很少用</p>
<p><strong>Set接口</strong><br>它的特点就是唯一性并且不允许出现重复元素和是无序的</p>
<p><strong>hashSet</strong><br>底层是基于哈希表实现的，而其核心就是先比较hashCode（）值是否相同（相当于索引），然后在用equals比较是否相同，从而确定元素是否重复，所以当不希望集合中有重复值，并且不关心元素之间的顺序时可以使用此类</p>
<p><strong>LinkedHashSet</strong><br>底层实现是使用链表和哈希表，它由链表保证元素有序，哈希表保证元素唯一，因此当不希望集合中有重复值，并且希望按照元素的插入顺序进行迭代遍历时可采用此类</p>
<p><strong>TreeSet</strong><br>底层实现是红黑树，也就是一种平衡AVL树，通过比较返回值是否是0来保证元素唯一性，并且通过自然排序来保证元素的排序（自然排序也就是让元素所属的类实现Comparable接口，比如abc排在abd前面，总之就是和插入顺序无关，只和元素本身的内容和特质有关）</p>
<p><strong>Queue接口</strong><br>它的特点就是队列，即用于保存将要执行的任务列表</p>
<p><strong>LinkedList</strong><br>实现了该接口，可以实现先进先出的队列</p>
<p><strong>PriorityQueue</strong><br>底层采用某种排序的单链表存储队列元素，用来创建自然排序的优先级队列</p>
<p><strong>Map接口</strong><br>Map关心的是唯一的标识符，也就是将唯一的键映射到某个元素，以键值对形式存储，键唯一，值可重复</p>
<p><strong>HashMap</strong><br>底层实现是基于哈希表依赖于hashCode（）和equals（）方法，线程不安全，允许key和value为NULL，效率高</p>
<p><strong>Hashtable</strong><br>HashMap的线程安全版，效率低，不允许key和value为NULL</p>
<p><strong>LinkedHashMap</strong><br>底层是由链表和哈希表组成，链表保证元素有序，哈希表保证元素唯一，所以当需要键值对，并且关心插入顺序时可采用它</p>
<p><strong>TreeMap</strong><br>底层是由红黑树实现，当需要键值对，并关心元素的自然排序时可采用它</p>
<p><strong>Collections</strong><br>内置了一些常见的集合算法，像排序，查找算法等</p>
<h4 id="如何选择哪种集合"><a href="#如何选择哪种集合" class="headerlink" title="如何选择哪种集合"></a>如何选择哪种集合</h4><p>1 首先看是否是键值对形式<br>  是的话就选择Map<br>   然后再看是否需要排序：<br>     是的话就是TreeMap<br>     不是的话就是HashMap<br>     一般情况下都使用HashMap<br>   不是键值对的话就选择Collection<br>     再看元素是否唯一：<br>       是的话就选set<br>         元素是否需要排序<br>           是的话就选TreeSet<br>           反之选择HashSet<br>          一般情况选择HashSet<br>        不是元素唯一就选List<br>          再看是否是否需要线程安全：<br>           是的话就选Vector<br>            不是的话就选择ArrayList或者LinkedList<br>             增删选择：LinkedList<br>              查询选择ArrayList<br>              一般情况下都选择ArrayList</p>
<h4 id="集合常见方法"><a href="#集合常见方法" class="headerlink" title="集合常见方法"></a>集合常见方法</h4><p><strong>Collection的常见方法</strong></p>
<blockquote>
<p>1，添加。<br>    boolean add(Object obj):<br>    boolean addAll(Collection coll):<br>2，删除。<br>    boolean remove(object obj):<br>    boolean removeAll(Collection coll);<br>    void clear();<br>3，判断：<br>    boolean contains(object obj):<br>    boolean containsAll(Colllection coll);<br>    boolean isEmpty():判断集合中是否有元素。<br>4，获取：<br>    int size():<br>    Iterator iterator():取出元素的方式：迭代器。<br> 5，其他：<br>    boolean retainAll(Collection coll);取交集。<br>    Object[] toArray():将集合转成数组。 </p>
</blockquote>
<p><strong>Map的常见方法</strong></p>
<blockquote>
<p> 1，添加。<br>          value put(key,value):返回前一个和key关联的值，如果没有返回null.<br> 2，删除。<br>            void  clear():清空map集合。<br>            value remove(key):根据指定的key翻出这个键值对。<br> 3，判断。<br>                boolean containsKey(key):<br>                boolean containsValue(value):<br>                boolean isEmpty();<br> 4，获取。<br>                value get(key):通过键获取值，如果没有该键返回null。                        当然可以通过返回null，来判断是否包含指定键。<br>                int size(): 获取键值对的个数。<br>5.特殊方法： Collection<v> values() 包含的值的 Collection 视图。<br>             Set<map.entry<k,v>&gt; entrySet()方法：返回一个set集合，里面装的是Map.Entry接口类型的键值对象</map.entry<k,v></v></p>
</blockquote>
<p><strong>Map遍历方法</strong></p>
<blockquote>
<p>  第一种遍历的方法<br>  Set<k> keySet()：返回键的set集合<br> 取出map中的所有元素。<br> 原理，通过keySet方法获取map中所有的键所在的Set集合，在通过Set的迭代器获取到每一个键，<br>  在对每一个键通过map集合的get方法获取其对应的值即可。<br>    Set<integer> keySet = map.keySet();<br>        System.out.println(keySet);//键的set集合<br>        Iterator<integer> it = keySet.iterator();//迭代keySet<br>        while(it.hasNext()){<br>            Integer key = it.next();<br>            String value = map.get(key);<br>            System.out.println(key+”:”+value);<br>        }</integer></integer></k></p>
<p>第二种遍历map的方式：通过看API:Set<map.entry<k,v>&gt; entrySet()：Map.Entry<k,v>接口类型，<br>  里面有K getKey() 返回与此项对应的键。 V getValue()  返回与此项对应的值。<br>  Set<map.entry<integer, string="">&gt;entrySet = map.entrySet();<br>        System.out.println(entrySet);//键值对对象<br>        Iterator<map.entry<integer, string="">&gt;it = entrySet.iterator();<br>        while(it.hasNext()){<br>            Map.Entry<integer, string=""> entryMap = it.next();<br>            Integer key = entryMap.getKey();//获取键<br>            String value = entryMap.getValue();//获取值<br>            System.out.println(key+”:”+value);<br>  }</integer,></map.entry<integer,></map.entry<integer,></k,v></map.entry<k,v></p>
</blockquote>
<h4 id="collections常用方法"><a href="#collections常用方法" class="headerlink" title="collections常用方法"></a>collections常用方法</h4><p>由于该集合工具类方法太多，只总结出部分<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">sort</span><span class="params">(Collection)</span></span>：对集合进行自然排序</div><div class="line"><span class="function"><span class="title">reverse</span><span class="params">()</span></span>：反转集合中元素的顺序</div><div class="line"><span class="function"><span class="title">shuffle</span><span class="params">(Collection)</span></span>：对集合进行随机排序</div><div class="line"><span class="function"><span class="title">fill</span><span class="params">(List list,Object o)</span></span>：用对象o替换集合list中的所有元素</div><div class="line"><span class="function"><span class="title">copy</span><span class="params">(List m,List n)</span></span>：将集合n中的元素全部复制到m中,并且覆盖相应索引的元素</div><div class="line"><span class="function"><span class="title">min</span><span class="params">(Collection)</span></span>,min(Collection,Comparator)：前者采用Collection内含自然比较法，后者采用Comparator进行比较</div><div class="line"><span class="function"><span class="title">max</span><span class="params">(Collection)</span></span>,max(Collection,Comparator)：同上</div><div class="line"><span class="function"><span class="title">indexOfSubList</span><span class="params">(List list,List subList)</span></span>：查找subList在list中首次出现位置的索引</div><div class="line"><span class="function"><span class="title">swap</span><span class="params">(List list,int i,int j)</span></span>：交换集合中指定元素索引的位置</div><div class="line">.binarySearch(Collection,Object)：查找指定集合中的元素，返回所查找元素的索引</div><div class="line"><span class="function"><span class="title">replaceAll</span><span class="params">(List list,Object old,Object new)</span></span>：替换批定元素为某元素,若要替换的值存在刚返回true,反之返回false</div></pre></td></tr></table></figure></p>
<p>最后不得不说集合容器是在太复杂了，它包装了许许多多的数据结构和算法，也正是因为如此，才大大简化了难度，但同时也说明了数据结构与算法的重要性，只有我们真正理解了算法和数据结构，才能更好的驾驭集合类</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在没有集合之前我们都是直接用数组存放对象，但是这样操作会很不方便，于是利用数据结构封装了一些列集合，而集合中不存放输几局的基本类型，只存放对
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String与StringBuffer常用方法总结</title>
    <link href="http://www.myzwl.win/2017/07/20/StringBuf_1/"/>
    <id>http://www.myzwl.win/2017/07/20/StringBuf_1/</id>
    <published>2017-07-20T05:48:51.000Z</published>
    <updated>2017-08-07T06:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>String与StringBuffer的区别，简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。</p>
<h4 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h4><p>在之前的数据结构与算法中已经模拟了部分String常用的方法</p>
<blockquote>
<p>public final class Stringextends Objectimplements Serializable, Comparable<string>, CharSequence</string></p>
</blockquote>
<p><strong>构造方法</strong></p>
<blockquote>
<p>public String()：初始化一个新创建的 String 对象，使其表示一个空字符序列。注意，由于 String 是不可变的，所以无需使用此构造方法。<br> public String(String original）：创建一个String对象为original的拷贝<br> public String(char[] value)：用一个字符数组创建一个String对象<br> public String(char[] value, int offset,int count)：用一个字符数组从offset项开始的count个字符序列创建一个String对象</p>
</blockquote>
<p><strong>普通方法</strong></p>
<blockquote>
<p>public char charAt(int index):返回字符串中第index个字符<br> public int length():返回字符串的长度<br> public int indexOf(String str):返回字符串中出现str的第一个位置<br> public int indexOf(String str,int fromIndex):返回字符串中从fromIndex开始起出现str的第一个位置<br> public boolean equalsIgnoreCase(String another):比较字符串与another是否一样（忽略大小写）<br> public String replace(char oldChar,char newChar):在字符串中用newChar替换oldChar<br> public boolean startWith(String prefix):判断字符串是否以prefix字符串开头<br> public boolean endsWith(String suffix):判断字符串是否以suffix为结尾<br> public String toLowerCase():返回一个字符串为该字符串的小写形式<br> public String substring(int beginIndex):返回该字符串从beginIndex开始到结尾的字符串<br> public String substring(int beginIndex,int endIndex):返回该字符串从beginIndex开始到endIndex结尾的字符串<br> public String trim():返回将该字符串去掉开头和结尾空格后的字符串</p>
</blockquote>
<p><strong>静态重载方法</strong></p>
<blockquote>
<p>public static String valueOf(..):将基本类型数据转化为字符串，如<br> public static String valueOf(double d)</p>
</blockquote>
<p><strong>其它常用方法</strong></p>
<blockquote>
<p>public String[] split(String regix):可以将一个字符串按照指定的分隔符分隔，返回分隔后的字符串数组<br>public String concat(String str)//将参数中的字符串str连接到当前字符串的后面，效果等价于”+”；<br>contains(String str)//判断参数s是否被包含在字符串中，并返回一个布尔类型的值。<br>字符串转换为基本类型<br>java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：<br>1)public static byte parseByte(String s)<br>2)public static short parseShort(String s)<br>3)public static short parseInt(String s)<br>4)public static long parseLong(String s)<br>5)public static float parseFloat(String s)<br>6)public static double parseDouble(String s)</p>
</blockquote>
<p><strong>字符串比较</strong></p>
<blockquote>
<p>1)public int compareTo(String anotherString)//该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。<br>2)public int compareToIgnore(String anotherString)//与compareTo方法相似，但忽略大小写。<br>3)public boolean equals(Object anotherObject)//比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。<br>4)public boolean equalsIgnoreCase(String anotherString)//与equals方法相似，但忽略大小写。</p>
</blockquote>
<h4 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h4><p><strong>构造方法</strong></p>
<blockquote>
<p>StringBuffer() ：构造一个没有任何字符的StringBuffer类。<br>StringBuffer(int length) ：：构造一个没有任何字符的StringBuffer类，并且，其长度为length。<br>StringBuffer(String str) ：以str为初始值构造一个StringBuffer类。</p>
</blockquote>
<p><strong>append方法</strong><br>为该对象添加字符序列，返回添加后的该对象引用，同时是调用了toString方法转化为字符串</p>
<blockquote>
<ol>
<li>StringBuffer append(boolean b)</li>
<li>StringBuffer append(char c)</li>
<li>StringBuffer append(char[] str)</li>
<li>StringBuffer append(char[] str, int offset, int len)</li>
<li>StringBuffer append(double d)</li>
<li>StringBuffer append(float f)</li>
<li>StringBuffer append(int i)</li>
<li>StringBuffer append(long l)</li>
<li>StringBuffer append(Object obj)</li>
<li>StringBuffer append(String str)</li>
<li>StringBuffer append(StringBuffer sb)</li>
</ol>
</blockquote>
<p><strong>其他方法</strong></p>
<blockquote>
<p>12.int capacity() ：返回当前StringBuffer对象（字符串缓冲区）的总空间，而非字符号串的长度。</p>
<ol>
<li>char charAt(int index) ：在当前StringBuffer对象中取索引号为index的字符。第一个字符的索引为“0”</li>
<li>StringBuffer delete(int start, int end) ：删除当前StringBuffer对象中以索引号start开始，到end结束的子串。</li>
<li>StringBuffer deleteCharAt(int index) ：删除当前StringBuffer对象中索引号为index的字符。</li>
<li>void ensureCapacity(int minimumCapacity) ：重新设置字符号串缓冲区的总空间。如果minimumCapacity大于当前的总空间，则新的空间被设置：一种结果是minimumCapacity；另一种结果是{“老空间”乘2加2}<br>17.void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) ：从当前StringBuffer对象的索引号srcBegin开始，到srcEnd结束的子串，赋值到字符数组dst中，并且从dst的索引号dstBegin开始</li>
<li>int indexOf(String str) ：返回当前StringBuffer对象中，第一个满足str子串的位置。</li>
<li>int indexOf(String str, int fromIndex) ：从当前StringBuffer对象的fromIndex开始查找，返回第一个满足str子串的位置。</li>
<li>StringBuffer insert(int offset, boolean b)</li>
<li>StringBuffer insert(int offset, char c)</li>
<li>StringBuffer insert(int offset, char[] str)</li>
<li>StringBuffer insert(int index, char[] str, int offset, int len)</li>
<li>StringBuffer insert(int offset, double d)</li>
<li>StringBuffer insert(int offset, float f)</li>
<li>StringBuffer insert(int offset, int i)</li>
<li>StringBuffer insert(int offset, long l)</li>
<li>StringBuffer insert(int offset, Object obj)</li>
<li>StringBuffer insert(int offset, String str)</li>
<li>int lastIndexOf(String str) ：返回当前StringBuffer对象中，最后一个满足str子串的位置。</li>
<li>int lastIndexOf(String str, int fromIndex) ：从当前StringBuffer对象的fromIndex开始查找，返回最后一个满足str子串的位置。</li>
<li>int length() ：返回当前StringBuffer对象（字符缓冲区）中，字符串的长度。注意：此方法与capacity() 不同。</li>
<li>StringBuffer replace(int start, int end, String str) ：替换当前StringBuffer对象的字符串。从start开始，到end结束的位置替换成str。</li>
<li>StringBuffer reverse() ：将字符串翻转。</li>
<li>void setCharAt(int index, char ch) ：设置索引号index的字符为ch。</li>
<li>void setLength(int newLength) ：重新设置字符串缓冲区中字符串的长度，如果newLength小于当前的字符串长度，将截去多余的字符。</li>
<li>String substring(int start) ：取当前StringBuffer对象中，从start开始到结尾的子串。</li>
<li>String substring(int start, int end) ：取当前StringBuffer对象中，从start开始到end的子串。</li>
<li>String toString() ：将当前StringBuffer对象转换成String对象。</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;String与StringBuffer的区别，简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Brute-Force与KMP算法</title>
    <link href="http://www.myzwl.win/2017/07/19/suanfa_2/"/>
    <id>http://www.myzwl.win/2017/07/19/suanfa_2/</id>
    <published>2017-07-19T05:48:51.000Z</published>
    <updated>2017-08-07T05:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设有两个串：目标串target和模式串pattern，在目标串中查找与模式串pattern相等得一个子串并确定孩子串位置的操作称为串的模式匹配。而匹配的结果有两种，如果target中存在等于pattern的子串，则匹配成功，给出孩子串在target中的位置，否则匹配失败</p>
<h4 id="Brute-Force算法"><a href="#Brute-Force算法" class="headerlink" title="Brute-Force算法"></a>Brute-Force算法</h4><p><img src="/images/imgs4/16.gif" alt="Alt text"><br>算法描述：如图，该算法的核心就是在target中从begin位置，这里begin=0开始，比较ti与pi是否相等，如果有一个不相等，则begin开始从之前的下一个字符开始匹配，同时pattern中退回到第一个字符，在依次比较，知道存在相等字符，返回相应位置，可以发现该算法是一个回溯算法。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//模式匹配，pattern为待匹配子串，begin为起始匹配位置</div><div class="line">public int indexOf(MyString pattern,int begin)&#123;</div><div class="line">	//待匹配子串不为空并且长度大于0和目标串大于等于带匹配子串</div><div class="line">	if(pattern!=null&amp;&amp;pattern.length()&gt;0&amp;&amp;this.length()&gt;=pattern.length())</div><div class="line">	&#123;</div><div class="line">		int i=begin,j=0; //记录i为开始位置，j为待匹配子串计数器</div><div class="line">		while(i&gt;this.length())&#123; //目标串全部匹配完，退出</div><div class="line">			if(this.charAt(i)==pattern.charAt(j))//如果，有字符相等</div><div class="line">			&#123;</div><div class="line">				i++; //计数器都加1，并且开始比较后一个字符</div><div class="line">				j++;</div><div class="line">			&#125;</div><div class="line">			else&#123;</div><div class="line">				i=i+j+1; //i回溯，变成上一个目标串匹配字符的下一个字符</div><div class="line">				j=0;    //待匹配字符，回溯为0</div><div class="line">			&#125;</div><div class="line">			if(j==pattern.length())</div><div class="line">				return i-j; //返回匹配到的位置</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	           return -1; //匹配失败</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回当前目标串的首次位置，从第一个位置开始</div><div class="line">public int indexOf(MyString pattern)&#123;</div><div class="line">	return this.indexOf(pattern, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="模式匹配应用"><a href="#模式匹配应用" class="headerlink" title="模式匹配应用"></a>模式匹配应用</h4><p>一般我们要替换或者删除相关子串时，首先就是查找是否存在此串，然后在进行相关操作<br>首先是替换操作<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//返回当前串替换之后的串</div><div class="line">public MyString replaceFirst(MyString pattern,MyString replacement)&#123;</div><div class="line">	int i=this.indexOf(pattern, 0);//找到要替换串的下标</div><div class="line">	 if(i==-1)</div><div class="line">		 return this; //不存在要替换的部分，返回当前串</div><div class="line">	 //连接三个串</div><div class="line">	 return this.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length()));		 </div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyString replaceAll(MyString pattern,MyString replacement)&#123;</div><div class="line">	MyString temp=new MyString(this);</div><div class="line">	 int i=this.indexOf(pattern, 0);</div><div class="line">	  while(1!=-1)</div><div class="line">	  &#123;</div><div class="line">		  temp=temp.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length()));</div><div class="line">		  i=temp.indexOf(pattern, i+replacement.length());//从下一个字符开始继续寻找匹配</div><div class="line">	  &#125;</div><div class="line">	  return temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，String是不变类型，也就是一个新的字符串是在堆栈上又开辟了一个新空间，不是原来的对象<br>下面是删除操作<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public MyString deleteFirst(MyString target,MyString pattern)&#123;</div><div class="line">	int i=target.indexOf(pattern);</div><div class="line">	 if(i==-1)</div><div class="line">		 return target;</div><div class="line">	  return target.substring(0, i)+target.substring(i+pattern.length());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyString deleteAll(MyString target,MyString pattern)&#123;</div><div class="line">	int i=target.indexOf(pattern);</div><div class="line">	 while(i!=-1)</div><div class="line">	 &#123;</div><div class="line">		 target=target.substring(0, i)+target.substring(i+pattern.length());</div><div class="line">		  i=target.indexOf(pattern, i);</div><div class="line">	 &#125;</div><div class="line">	 return target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心思想就是先模式匹配，然后在构造一个新的串</p>
<p>最后分析一下该模式匹配算法，假设模式串长度为m，可以发现他的时间复杂度为O(m);并且匹配中存在很多重复，所以算法效率是很低的</p>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>由之前的算法我们知道，它存在重复匹配，如之前的pattern=abc，此时p的各个字符都不相等，而在匹配时target=ababdabcd中，第一次从a匹配，到第三位不等，开始从第二位匹配，但由于第一次已经知道pi各位不等，所以第二位就不用匹配了，他肯定与第一位不等，所以可省略，而这恰恰是KMP算法的核心</p>
<p><strong>next数组</strong><br>next数组的作用就是研究pattern串，依次确定如果不匹配下一次target串从哪一位开始匹配。并且这样定义next数组</p>
<blockquote>
<p>next[J]=-1，当j=0；<br>next[j]=k 当0&lt;=k&lt;f时且使p_0..p_k-1=p_j-k..p_j-1的最大整数</p>
</blockquote>
<p><img src="/images/imgs4/17.gif" alt="Alt text"><br>如图：pattern=”abcabc”，当j=0时，next[0]=-1；当j=1,2,3时，”a”,”ab”,”abc”都没有相同前缀子串和后缀子串next[j]=k=0；当j=4时，”abca”钟相同的前缀子串和后缀子串是”a”，所以k=1；当j=5时，为”ab”，所以k=2，依次类推<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private int[] getNext(String pattern)&#123;  //求next</div><div class="line">		int j=0,k=-1;                   //初始化j，k，next</div><div class="line">		int[] next=new int[pattern.length()];</div><div class="line">		next[0]=-1;</div><div class="line">		while(j&lt;pattern.length()-1)    //当j遍历完pattern字符串，结束</div><div class="line">		&#123;</div><div class="line">			if(k==-1||pattern.charAt(j)==pattern.charAt(k)) //k为初始值或者pattern的后缀字符与前缀相同</div><div class="line">			&#123; </div><div class="line">				j++;           //j后移，k加一，同时第j个字符的next值为k</div><div class="line">				k++;</div><div class="line">				next[j]=k;</div><div class="line">			&#125; </div><div class="line">			else              //否则，k重新回到前缀值，继续比较</div><div class="line">				k=next[k];</div><div class="line">			return next;</div><div class="line">		&#125;</div><div class="line">		return next;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下面是KMP的算法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int indexOf(String target,String pattern,int begin)&#123;</div><div class="line">		if(pattern!=null&amp;&amp;pattern.length()&gt;0&amp;&amp;this.length()&gt;=pattern.length())</div><div class="line">		&#123;</div><div class="line">		int i=begin,j=0;</div><div class="line">		int[] next=getNext(pattern); //求得next数组，这样就可以避免一些重复比较了</div><div class="line">		while(i&lt;target.length())&#123;</div><div class="line">			if(j==-1||target.charAt(i)==pattern.charAt(j))</div><div class="line">			&#123;</div><div class="line">				i++;</div><div class="line">				j++;</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">				j=next[j]; //退回到next[J]个字符开始比较</div><div class="line">			if(j==pattern.length())</div><div class="line">				return i-j;</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		return -1;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h4 id="改进的KMP算法"><a href="#改进的KMP算法" class="headerlink" title="改进的KMP算法"></a>改进的KMP算法</h4><p>当target=”aaaabcde”时，pattern=”aaaax”时，发现，a重复了，按照之前的算法，当i=5时，有重复比较四个a，所以可改进<br><img src="/images/imgs4/18.gif" alt="Alt text"><br>如图：改进的nextval是在next数组基础上，这里约定的next初始值为-1，所以如j=3，与next[j]+1比较，如果相等，则其值等于next[j]+1的next值，否则，保持原next值不变<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private int[] getNext(String pattern)&#123;</div><div class="line">		int j=0,k=-1;</div><div class="line">		int[] next=new int[pattern.length()];</div><div class="line">		next[0]=-1;</div><div class="line">		while(j&lt;pattern.length()-1)</div><div class="line">		&#123;</div><div class="line">			if(k==-1||pattern.charAt(j)==pattern.charAt(k))</div><div class="line">			&#123;</div><div class="line">				j++;</div><div class="line">				k++;</div><div class="line">				if(pattern.charAt(j)!=pattern.charAt(k))//改进之处</div><div class="line">				next[j]=k;</div><div class="line">				else</div><div class="line">					next[j]=next[k];</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">				k=next[k];</div><div class="line">			return next;</div><div class="line">		&#125;</div><div class="line">		return next;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>由此发现KMP算法的时间复杂度为O(n);</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;设有两个串：目标串target和模式串pattern，在目标串中查找与模式串pattern相等得一个子串并确定孩子串位置的操作称为串的模式匹
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>冒泡与选择排序</title>
    <link href="http://www.myzwl.win/2017/07/18/suanfa_1/"/>
    <id>http://www.myzwl.win/2017/07/18/suanfa_1/</id>
    <published>2017-07-18T05:48:51.000Z</published>
    <updated>2017-08-06T12:56:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>算法描述：冒泡排序是一种交换排序，它的基本思想就是两两比较相邻的关键字，如果反序则交换，直到没有反序的记录为止<br><img src="/images/imgs4/14.gif" alt="Alt text"><br>就像冒泡一样，第一次先把最大的选出来冒到最后，依次类推，从下个继续冒最大的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int a[])&#123;</div><div class="line">		int temp;  //临时变量，用于交换</div><div class="line">		for(int i=a.length-1;i&gt;0;i--) //外层循环，用于控制需要冒泡的个数</div><div class="line">			for(int j=0;j&lt;=i-1;j++) //内存循环</div><div class="line">				if(a[j]&gt;a[j+1]) //如果需要交换，则交换</div><div class="line">				&#123;</div><div class="line">					temp=a[j+1];</div><div class="line">					a[j+1]=a[j];</div><div class="line">					a[j]=temp;</div><div class="line">				&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出这个冒泡的实现是很简单的，但是效率上存在严重问题，比如有序数列2,1,3,4,5这个除了第一个，其余都已经是有序了，但是根据算法还是不断循环，比较增加了冗余，所以需要改进<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int a[])&#123;</div><div class="line">	int temp;</div><div class="line">	boolean flag=true; //用来作为标记</div><div class="line">	for(int i=a.length-1;i&gt;0&amp;&amp;flag;i--)&#123; //如果flag为false，也就是已经有序了，退出</div><div class="line">		flag=false;  //初始化为false</div><div class="line">		for(int j=0;j&lt;=i-1;j++)</div><div class="line">			if(a[j]&gt;a[j+1])</div><div class="line">			&#123;</div><div class="line">				temp=a[j+1];</div><div class="line">				a[j+1]=a[j];</div><div class="line">				a[j]=temp;</div><div class="line">				flag=true;  //如果有数据交换，则设为true</div><div class="line">			&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>显然从效率上提高了许多，由内外循环次数可以得出其时间复杂度为o(n^2)</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>算法描述：选择排序就是通过n-i此关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换<br><img src="/images/imgs4/15.gif" alt="Alt text"><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void ChooseSort(int[] a)&#123;</div><div class="line">	int min,temp;  //分别为每一次循环的当前最小变量和临时变量</div><div class="line">	for(int i=0;i&lt;a.length;i++)&#123;</div><div class="line">		 min=i; //初始化最小变量，为当前循环的第一个变量</div><div class="line">	 for(int j=i+1;j&lt;a.length;j++)</div><div class="line">	 &#123;</div><div class="line">		 if(a[j]&lt;a[i])  //找到比当前循环的最小变量小的记录，并记录下标</div><div class="line">			 min=j;</div><div class="line">	 &#125;</div><div class="line">	 if(min!=i) //如果有比当前最小变量小，则交换记录</div><div class="line">	 &#123;</div><div class="line">		 temp=a[min];</div><div class="line">		 a[min]=a[i];</div><div class="line">		 a[i]=temp;			 </div><div class="line">	 &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出它的时间复杂度仍然是O(n^2)</p>
<h4 id="约瑟夫环的另一种解法"><a href="#约瑟夫环的另一种解法" class="headerlink" title="约瑟夫环的另一种解法"></a>约瑟夫环的另一种解法</h4><p>至于问题描述就不描述了，在之前的数据结构总结中已经有了这个问题的描述<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public static void Count3Quit()&#123;</div><div class="line">		boolean[] arr=new boolean[500]; //初始化500个人围成圈</div><div class="line">		 for(int i=0;i&lt;arr.length;i++) //假设每个人值都为true</div><div class="line">	      arr[i]=true;</div><div class="line">		    int len=arr.length; //记录总人数</div><div class="line">		    int index=0;  //记录每个人的索引</div><div class="line">		    int count=0;  //记录数数变量，这里是数三退一</div><div class="line">		     while(len&gt;1)//直到只剩最后一个人为止</div><div class="line">		     &#123;</div><div class="line">		    	 if(arr[index]==true) //人还在圈内</div><div class="line">		    	 &#123;</div><div class="line">		    		 count++; //数数加一</div><div class="line">		    		 if(count==3) //数到三时，退一个人</div><div class="line">		    		 &#123;</div><div class="line">		    			 count=0; //计数重置为0</div><div class="line">		    			  arr[index]=false; //该人退出</div><div class="line">		    			   len--; //总人数减一</div><div class="line">		    		 &#125;</div><div class="line">		    	 &#125;</div><div class="line">		    	 index++; //索引加一</div><div class="line">		    	 if(index==arr.length)//索引超出人数长度，循环从0开始</div><div class="line">		    		 index=0;</div><div class="line">		     &#125;</div><div class="line">		     for(int i=0;i&lt;arr.length;i++)//输出最后一个人</div><div class="line">		    	 if(arr[i]==true)</div><div class="line">		    		 System.out.println(i);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h4&gt;&lt;p&gt;算法描述：冒泡排序是一种交换排序，它的基本思想就是两两比较相邻的关键字，如果反序则交换，直到没有反序的记录为止&lt;br&gt;&lt;im
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java异常处理二</title>
    <link href="http://www.myzwl.win/2017/07/17/yc_2/"/>
    <id>http://www.myzwl.win/2017/07/17/yc_2/</id>
    <published>2017-07-17T05:48:51.000Z</published>
    <updated>2017-08-05T10:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过一已经初步了解了异常的一些原理和相关性质，当然在平时写程序时被各种各样的异常类型弄得叫苦不堪<br><img src="/images/imgs4/12.gif" alt="Alt text"></p>
<h4 id="java常见异常"><a href="#java常见异常" class="headerlink" title="java常见异常"></a>java常见异常</h4><p>从api文档中可以看出，java已经为我们内置了很多异常<br><img src="/images/imgs4/13.gif" alt="Alt text"><br>先来看看RuntimeException中常见异常</p>
<blockquote>
<p>  1java.lang.ArrayIndexOutOfBoundsException<br>    数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。<br>    2、java.lang.ArithmeticException<br>    算术条件异常。譬如：整数除零等。<br>    3、java.lang.NullPointerException<br>    空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等<br>    4、java.lang.ClassNotFoundException<br>    找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。<br>   5、java.lang.NegativeArraySizeException  数组长度为负异常<br>   6、java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常<br>   7、java.lang.SecurityException 安全性异常<br>   8、java.lang.IllegalArgumentException 非法参数异常</p>
</blockquote>
<p><strong>IOException</strong></p>
<blockquote>
<p>IOException：操作输入流和输出流时可能出现的异常。<br>  EOFException   文件已结束异常<br>  FileNotFoundException   文件未找到异常</p>
</blockquote>
<p><strong>其他异常</strong></p>
<blockquote>
<p> ClassCastException    类型转换异常类<br>   ArrayStoreException  数组中包含不兼容的值抛出的异常<br>    SQLException   操作数据库异常类<br>    NoSuchFieldException   字段未找到异常<br>    NoSuchMethodException   方法未找到抛出的异常<br>    NumberFormatException    字符串转换为数字抛出的异常<br>    StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常<br>    IllegalAccessException  不允许访问某类异常<br>    InstantiationException  当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</p>
</blockquote>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>在Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。<br> 所有异常都必须是 Throwable 的子类。<br> 如果希望写一个检查性异常类，则需要继承 Exception 类。<br> 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。<br> 如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class MyException extends Exception&#123;</div><div class="line"></div><div class="line">	private int id;</div><div class="line">	</div><div class="line">	public MyException()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyException(String msg,int id)&#123;</div><div class="line">		super(msg);</div><div class="line">		this.id=id;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int getId()&#123;</div><div class="line">		return this.id;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Ttest &#123;</div><div class="line">  public void regist(int num) throws MyException&#123;</div><div class="line">	  if(num&lt;0)&#123;</div><div class="line">		  throw new MyException("不能为负数",404);</div><div class="line">	  &#125;</div><div class="line">	  System.out.println("it is"+num);		  </div><div class="line">  &#125;</div><div class="line">  public void manager()&#123;</div><div class="line">	  try &#123;</div><div class="line">		regist(-10);</div><div class="line">	&#125; catch (MyException e) &#123;</div><div class="line">		System.out.println("Error Code"+e.getId());</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">	  System.out.println("over");</div><div class="line">  &#125;</div><div class="line">  public static void main(String args[])&#123;</div><div class="line">	  Ttest t=new Ttest();</div><div class="line">	  t.manager();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果有异常时运行结果如下：</p>
<blockquote>
<p>com.test.QQ.MyException: 不能为负数<br>    at com.test.QQ.Ttest.regist(Ttest.java:6)<br>    at com.test.QQ.Ttest.manager(Ttest.java:12)<br>    at com.test.QQ.Ttest.main(Ttest.java:21)<br>Error Code404<br>over</p>
</blockquote>
<p>将regist（-10）改为regist（10），如下</p>
<blockquote>
<p>it is10<br>over</p>
</blockquote>
<h4 id="spring异常处理"><a href="#spring异常处理" class="headerlink" title="spring异常处理"></a>spring异常处理</h4><p>前面我们都是用try..catch来捕获异常，造成业务逻辑较多，而spring通过注解式使捕获异常更方便。核心如下：</p>
<blockquote>
<p>  @ExceptionHandler：统一处理某一类异常，从而能够减少代码重复率和复杂度<br>    @ControllerAdvice：异常集中处理，更好的使业务逻辑与异常处理剥离开<br>    @ResponseStatus：可以将某种异常映射为HTTP状态码</p>
</blockquote>
<p>@ExceptionHandler源码如下：</p>
<blockquote>
<p>@Target({ElementType.METHOD})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface ExceptionHandler {<br>    Class&lt;? extends Throwable&gt;[] value() default {};<br> }</p>
</blockquote>
<p> 首先是注解的说明：<br> @Retention: 定义注解的保留策略<br>@Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在class字节码文件中不包含<br>@Retention(RetentionPolicy.CLASS)     // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，<br>@Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到</p>
<p>@Target：定义注解的作用目标<br>@Target(ElementType.TYPE)   //接口、类、枚举、注解<br>@Target(ElementType.FIELD) //字段、枚举的常量<br>@Target(ElementType.METHOD) //方法<br>@Target(ElementType.PARAMETER) //方法参数<br>@Target(ElementType.CONSTRUCTOR)  //构造函数<br>@Target(ElementType.LOCAL_VARIABLE)//局部变量<br>@Target(ElementType.ANNOTATION_TYPE)//注解<br>@Target(ElementType.PACKAGE) ///包    </p>
<p>@Document：说明该注解将被包含在javadoc中<br>@Inherited：说明子类可以继承父类中的该注解</p>
<p>该注解作用对象为方法，并且在运行时有效，value()可以指定异常类<br>方法返回值可以为：<br>    ModelAndView对象<br>    Model对象<br>    Map对象<br>    View对象<br>    String对象<br>    还有@ResponseBody、HttpEntity&lt;?&gt;或ResponseEntity&lt;?&gt;，以及void</p>
<p>如</p>
<blockquote>
<p>@ControllerAdvice //在所有的controller中执行该异常<br>public class DefaultExceptionHandler {<br>    /**</p>
<pre><code> * 没有权限 异常
 * &lt;p/&gt;
 * 后续根据不同的需求定制即可
 */
@ExceptionHandler({UnauthorizedException.class}) //不同的异常处理
@ResponseStatus(HttpStatus.UNAUTHORIZED)
public String processUnauthenticatedException(NativeWebRequest request, UnauthorizedException e) {
    System.out.println(&quot;un&quot;);
    return null;
</code></pre><p>}</p>
</blockquote>
<pre><code>@ExceptionHandler(RuntimeException.class)
@ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)  
public String handleUnexpectedServerError(RuntimeException ex) { 
    System.out.println(&quot;500&quot;);
    return null;
}

@ExceptionHandler(ServletException.class)
@ResponseStatus(value = HttpStatus.NOT_FOUND)  
public String handleNotFoundError() {     
       System.out.println(&quot;404&quot;);
      return null;       
}
</code></pre><p>}</p>
<p>如上的500和404错误，先给出错误的异常，在给出错误的状态码并且异常与状态码必须是对应的，该类的源码在org.springframework.http下，如</p>
<blockquote>
<p>public enum HttpStatus {<br>成功<br>   OK(200, “OK”),<br>   创建<br>   CREATED(201, “Created”),<br>   /接受<br>   ACCEPTED(202, “Accepted”),<br>   BAD_REQUEST(400, “Bad Request”),<br>   没有认证权限<br>   UNAUTHORIZED(401, “Unauthorized”),</p>
</blockquote>
<p>   PAYMENT_REQUIRED(402, “Payment Required”),<br>   禁止<br>   FORBIDDEN(403, “Forbidden”),</p>
<p>   NOT_FOUND(404, “Not Found”),</p>
<p>   有了上述全局处理的异常，就不许要在每个类里面重复写了，同时如果我们是在页面中需要捕获异常，如页面的404和500，只需在web.xml中配置一下（在spring配置文件中注入无效，也不知道怎么回事），如下：</p>
<blockquote>
<p><error-page><br>        <error-code>404</error-code><br>        <location>/404.jsp</location><br>    </error-page><br>    <error-page><br>    <error-code>500</error-code><br>     <location>/500.jsp</location><br> </error-page></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过一已经初步了解了异常的一些原理和相关性质，当然在平时写程序时被各种各样的异常类型弄得叫苦不堪&lt;br&gt;&lt;img src=&quot;/images/
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java异常处理一</title>
    <link href="http://www.myzwl.win/2017/07/16/yc_1/"/>
    <id>http://www.myzwl.win/2017/07/16/yc_1/</id>
    <published>2017-07-16T05:48:51.000Z</published>
    <updated>2017-08-05T05:27:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不得不说，我们平时在写程序时遇到最多的情形或者最头疼的事情就是遇到异常，然后各种调试，各种方法用尽最后才解决它，那么异常主要分为几类，每个类又有什么特征了（如图）<br><img src="/images/imgs4/11.gif" alt="Alt text"><br>从大的角度说主要分成两类：Error类代表了编译和系统的错误，不允许捕获，也就是我们自己无法主动去处理它；Exception类代表了我们可捕获并且可自己可处理异常，而Exception有包括两类，一个是你必须要处理的异常，如某个类有throws异常了，在未进入运行期就必须处理，另一类就是Runtime Exception（运行期异常），就是只有在运行时（也就是编译成class文件）时才知道，这个异常可处理或不处理</p>
<h4 id="处理异常机制"><a href="#处理异常机制" class="headerlink" title="处理异常机制"></a>处理异常机制</h4><p>在java应用程序中，异常处理机制主要为两种:抛出异常和捕获异常<br><strong>抛出异常</strong><br>简单的说，就是不处理异常，将异常不断抛给上一级，直至某一级有有处理异常措施，一般用throws、throw如</p>
<blockquote>
<p>public readFile() throws IOException{<br>    throw new xxx();<br>}</p>
</blockquote>
<p><strong>捕获异常</strong><br>定义是这样说的，在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。<br>一般有try..catch语句块，其语法格式如下：</p>
<blockquote>
<p>   try {<br>        // 可能会发生异常的程序代码<br>    } catch (Type1 id1){<br>        // 捕获并处置try抛出的异常类型Type1<br>    }<br>    catch (Type2 id2){<br>         //捕获并处置try抛出的异常类型Type2<br>    }  </p>
</blockquote>
<pre><code>如果，不管异常有没有捕获，都要执行某段代码，如数据库查询后都要关闭等等，就可以用finally，上面修改
</code></pre><blockquote>
<p>   try {<br>        // 可能会发生异常的程序代码<br>    } catch (Type1 id1){<br>        // 捕获并处置try抛出的异常类型Type1<br>    }<br>    catch (Type2 id2){<br>         //捕获并处置try抛出的异常类型Type2<br>    }  finally{<br>        //必须执行的代码<br>    }</p>
</blockquote>
<h4 id="try-catch-finally-规则"><a href="#try-catch-finally-规则" class="headerlink" title="try-catch-finally 规则"></a>try-catch-finally 规则</h4><pre><code>try块：用于捕获异常。其后可接0个或多个catch块，如果没有catch块，则必须跟一个finally块
catch块：用于处理try捕获到的异常。
finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行：
</code></pre><p>1）在finally语句块中发生了异常。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）关闭CPU。</p>
<p>try..catch..拥有执行顺序，即第一个catch之后，后面不在执行catch，所以一般将较详细的catch放在最前面，如先捕获IOException在捕获Exception</p>
<h4 id="throws规则"><a href="#throws规则" class="headerlink" title="throws规则"></a>throws规则</h4><p>1) 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</p>
<p>2）必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</p>
<p>3)仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出</p>
<p>4）调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。<br>如下</p>
<blockquote>
<pre><code>void method1() throws IOException{}  //合法    
</code></pre></blockquote>
<pre><code>//编译错误，必须捕获或声明抛出IOException    
void method2(){    
  method1();    
}    

//合法，声明抛出IOException    
void method3()throws IOException {    
  method1();    
}    

//合法，声明抛出Exception，IOException是Exception的子类    
void method4()throws Exception {    
  method1();    
}    

//合法，捕获IOException    
void method5(){    
 try{    
    method1();    
 }catch(IOException e){…}    
}    

//编译错误，必须捕获或声明抛出Exception    
void method6(){    
  try{    
    method1();    
  }catch(IOException e){throw new Exception();}    
}    

//合法，声明抛出Exception    
void method7()throws Exception{    
 try{    
  method1();    
 }catch(IOException e){throw new Exception();}    
}   

这里需要注意的是throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象
</code></pre><p><strong>Throwable类源码分析</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div></pre></td><td class="code"><pre><div class="line">/**  </div><div class="line">    *   </div><div class="line">    * Throwable是所有Error和Exceptiong的父类  </div><div class="line">    * 注意它有四个构造函数:  </div><div class="line">    * Throwable()  </div><div class="line">    * Throwable(String message)  </div><div class="line">    * Throwable(Throwable cause)  </div><div class="line">    * Throwable(String message, Throwable cause)  </div><div class="line">    *   </div><div class="line">    */    </div><div class="line">    public class Throwable implements Serializable &#123;    </div><div class="line">          private static final long serialVersionUID = -3042686055658047285L;    </div><div class="line">        </div><div class="line">          /**  </div><div class="line">           * Native code saves some indication of the stack backtrace in this slot.  </div><div class="line">           */    </div><div class="line">          private transient Object backtrace;     </div><div class="line">          /** </div><div class="line">       * 描述此异常的信息 </div><div class="line">       */  </div><div class="line">      private String detailMessage;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 表示当前异常由那个Throwable引起 </div><div class="line">        * 如果为null表示此异常不是由其他Throwable引起的 </div><div class="line">        * 如果此对象与自己相同,表明此异常的起因对象还没有被初始化 </div><div class="line">       */  </div><div class="line">      private Throwable cause = this;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 描述异常轨迹的数组 </div><div class="line">       */  </div><div class="line">      private StackTraceElement[] stackTrace;  </div><div class="line">      /** </div><div class="line">       * 构造函数,起因对象没有被初始化可以在以后使用initCause进行初始化 </div><div class="line">        * fillInStackTrace可以用来初始化它的异常轨迹的数组 </div><div class="line">       */  </div><div class="line">      public Throwable() &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数 </div><div class="line">       */  </div><div class="line">      public Throwable(String message) &#123;  </div><div class="line">         //填充异常轨迹数组  </div><div class="line">          fillInStackTrace();  </div><div class="line">         //初始化异常描述信息  </div><div class="line">          detailMessage = message;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数,cause表示起因对象 </div><div class="line">       */  </div><div class="line">      public Throwable(String message, Throwable cause) &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">          detailMessage = message;  </div><div class="line">          this.cause = cause;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数 </div><div class="line">       */  </div><div class="line">      public Throwable(Throwable cause) &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">          detailMessage = (cause==null ? null : cause.toString());  </div><div class="line">          this.cause = cause;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 获取详细信息 </div><div class="line">       */  </div><div class="line">      public String getMessage() &#123;  </div><div class="line">          return detailMessage;  </div><div class="line">      &#125;  </div><div class="line"></div><div class="line">      /** </div><div class="line">       * 获取详细信息 </div><div class="line">       */  </div><div class="line">      public String getLocalizedMessage() &#123;  </div><div class="line">          return getMessage();  </div><div class="line">      &#125;  </div><div class="line">       /** </div><div class="line">       * 获取起因对象 </div><div class="line">       */  </div><div class="line">      public Throwable getCause() &#123;  </div><div class="line">          return (cause==this ? null : cause);  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 初始化起因对象,这个方法只能在未被初始化的情况下调用一次 </div><div class="line">       */  </div><div class="line">      public synchronized Throwable initCause(Throwable cause) &#123;  </div><div class="line">         //如果不是未初始化状态则抛出异常  </div><div class="line">          if (this.cause != this)  </div><div class="line">              throw new IllegalStateException("Can't overwrite cause");  </div><div class="line">          </div><div class="line">         //要设置的起因对象与自身相等则抛出异常  </div><div class="line">          if (cause == this)  </div><div class="line">              throw new IllegalArgumentException("Self-causation not permitted");  </div><div class="line">          </div><div class="line">         //设置起因对象  </div><div class="line">          this.cause = cause;  </div><div class="line">         //返回设置的起因的对象  </div><div class="line">          return this;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 字符串表示形式 </div><div class="line">       */  </div><div class="line">      public String toString() &#123;       </div><div class="line">          String s = getClass().getName();          </div><div class="line">          String message = getLocalizedMessage();        </div><div class="line">          return (message != null) ? (s + ": " + message) : s;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace() &#123;   </div><div class="line">          printStackTrace(System.err);  </div><div class="line">      &#125;  </div><div class="line"></div><div class="line">       /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace(PrintStream s) &#123;  </div><div class="line">          synchronized (s) &#123;  </div><div class="line">            //调用当前对象的toString方法  </div><div class="line">              s.println(this);  </div><div class="line">            //获取异常轨迹数组  </div><div class="line">              StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">              </div><div class="line">            //打印出每个元素的字符串表示  </div><div class="line">              for (int i=0; i &lt; trace.length; i++)  </div><div class="line">                s.println("\tat " + trace[i]);  </div><div class="line">  </div><div class="line">            //获取起因对象  </div><div class="line">              Throwable ourCause = getCause();  </div><div class="line">              </div><div class="line">            //递归的打印出起因对象的信息  </div><div class="line">              if (ourCause != null)  </div><div class="line">                ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">       /** </div><div class="line">       * 打印起因对象的信息 </div><div class="line">       * @param s 打印的流 </div><div class="line">        * @param causedTrace 有此对象引起的异常的异常轨迹  </div><div class="line">       */  </div><div class="line">      private void printStackTraceAsCause(PrintStream s,  </div><div class="line">                                          StackTraceElement[] causedTrace)  </div><div class="line">      &#123;  </div><div class="line">         //获得当前的异常轨迹  </div><div class="line">          StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">         //m为当前异常轨迹数组的最后一个元素位置,   </div><div class="line">         //n为当前对象引起的异常的异常轨迹数组的最后一个元素  </div><div class="line">          int m = trace.length-1, n = causedTrace.length-1;  </div><div class="line">         //分别从两个数组的后面做循环,如果相等则一直循环,直到不等或数组到头  </div><div class="line">          while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(causedTrace[n])) &#123;  </div><div class="line">              m--; n--;  </div><div class="line">         &#125;  </div><div class="line">          </div><div class="line">         //相同的个数  </div><div class="line">          int framesInCommon = trace.length - 1 - m;  </div><div class="line">          </div><div class="line">         //打印出不同的错误轨迹  </div><div class="line">          s.println("Caused by: " + this);  </div><div class="line">          for (int i=0; i &lt;= m; i++)  </div><div class="line">              s.println("\tat " + trace[i]);  </div><div class="line">          //如果有相同的则打印出相同的个数  </div><div class="line">          if (framesInCommon != 0)  </div><div class="line">              s.println("\t... " + framesInCommon + " more");  </div><div class="line">  </div><div class="line">         //获得此对象的起因对象,并递归打印出信息  </div><div class="line">          Throwable ourCause = getCause();  </div><div class="line">          if (ourCause != null)  </div><div class="line">              ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace(PrintWriter s) &#123;   </div><div class="line">          synchronized (s) &#123;  </div><div class="line">              s.println(this);  </div><div class="line">              StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">              for (int i=0; i &lt; trace.length; i++)  </div><div class="line">                  s.println("\tat " + trace[i]);  </div><div class="line">  </div><div class="line">              Throwable ourCause = getCause();  </div><div class="line">              if (ourCause != null)  </div><div class="line">                  ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 打印起因对象的信息 </div><div class="line">        */  </div><div class="line">      private void printStackTraceAsCause(PrintWriter s,  </div><div class="line">                                          StackTraceElement[] causedTrace)  </div><div class="line">      &#123;  </div><div class="line">          // assert Thread.holdsLock(s);  </div><div class="line">  </div><div class="line">          // Compute number of frames in common between this and caused  </div><div class="line">          StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">          int m = trace.length-1, n = causedTrace.length-1;  </div><div class="line">          while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(causedTrace[n])) &#123;  </div><div class="line">              m--; n--;  </div><div class="line">          &#125;  </div><div class="line">          int framesInCommon = trace.length - 1 - m;  </div><div class="line">  </div><div class="line">          s.println("Caused by: " + this);  </div><div class="line">          for (int i=0; i &lt;= m; i++)  </div><div class="line">              s.println("\tat " + trace[i]);  </div><div class="line">          if (framesInCommon != 0)  </div><div class="line">              s.println("\t... " + framesInCommon + " more");  </div><div class="line">  </div><div class="line">          // Recurse if we have a cause  </div><div class="line">          Throwable ourCause = getCause();  </div><div class="line">          if (ourCause != null)  </div><div class="line">              ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 填充异常轨迹 </div><div class="line">       */  </div><div class="line">      public synchronized native Throwable fillInStackTrace();  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 返回当前的异常轨迹的拷贝 </div><div class="line">       */  </div><div class="line">      public StackTraceElement[] getStackTrace() &#123;  </div><div class="line">          return (StackTraceElement[]) getOurStackTrace().clone();  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      </div><div class="line">      /** </div><div class="line">       * 获取当前的异常轨迹 </div><div class="line">        */  </div><div class="line">      private synchronized StackTraceElement[] getOurStackTrace() &#123;  </div><div class="line">         //如果第一次调用此方法则初始化异常轨迹数组  </div><div class="line">          if (stackTrace == null) &#123;  </div><div class="line">            //获得异常轨迹深度  </div><div class="line">              int depth = getStackTraceDepth();  </div><div class="line">            //创建新的异常轨迹数组,并填充它  </div><div class="line">              stackTrace = new StackTraceElement[depth];  </div><div class="line">              </div><div class="line">            for (int i=0; i &lt; depth; i++)  </div><div class="line">                stackTrace[i] = getStackTraceElement(i);//获取指定位标的异常轨迹  </div><div class="line">          &#125;  </div><div class="line">          </div><div class="line">          return stackTrace;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 设置异常轨迹 </div><div class="line">       */  </div><div class="line">      public void setStackTrace(StackTraceElement[] stackTrace) &#123;  </div><div class="line">         //拷贝设置参数  </div><div class="line">          StackTraceElement[] defensiveCopy =  </div><div class="line">              (StackTraceElement[]) stackTrace.clone();  </div><div class="line">          </div><div class="line">         //如果设置参数有空元素则抛出异常  </div><div class="line">          for (int i = 0; i &lt; defensiveCopy.length; i++)  </div><div class="line">              if (defensiveCopy[i] == null)  </div><div class="line">                  throw new NullPointerException("stackTrace[" + i + "]");  </div><div class="line">  </div><div class="line">         //设置当前对象的异常轨迹  </div><div class="line">          this.stackTrace = defensiveCopy;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 异常轨迹的深度,0表示无法获得 </div><div class="line">       */  </div><div class="line">      private native int getStackTraceDepth();  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 获取指定位标的异常轨迹 </div><div class="line">       */  </div><div class="line">      private native StackTraceElement getStackTraceElement(int index);  </div><div class="line">  </div><div class="line">      </div><div class="line">      private synchronized void writeObject(java.io.ObjectOutputStream s)  </div><div class="line">          throws IOException  </div><div class="line">      &#123;  </div><div class="line">          getOurStackTrace();  </div><div class="line">          s.defaultWriteObject();  </div><div class="line">      &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上源码分析来自于互联网，同时由于目前是jdk1.8和这个源码有一小部分不一样，但不影响整体分析。当然，我们真正关心的是他的下面几个方法</p>
<blockquote>
<p>e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息:<br>   getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。<br>　 getMeage()：返回异常的消息信息。<br>　 printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。<br>而当我们出现异常时，就形成一条异常链，一个一个堆栈的打印出相关信息和异常</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;不得不说，我们平时在写程序时遇到最多的情形或者最头疼的事情就是遇到异常，然后各种调试，各种方法用尽最后才解决它，那么异常主要分为几类，每个类
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://www.myzwl.win/2017/07/15/sjjg_10/"/>
    <id>http://www.myzwl.win/2017/07/15/sjjg_10/</id>
    <published>2017-07-15T05:48:51.000Z</published>
    <updated>2017-07-27T14:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>查找操作，通俗的讲，就是给定一个值key，在一个数据结构中找出关键字为key的元素。而基于线性表的查找算法有顺序查找（O（n）），二分查找和分块查找</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>主要用于已排序的顺序表<br>算法描述：假定顺序表已按照升序排列，从表的中间位置开始比较，如果当前元素的关键字等于给定值，则查找成功，否则，若给定的值小于当前元素关键字，则在表的前半段继续查找，反之，在后半段查找，以此重复，直到获得查找结果<br><img src="/images/imgs4/10.gif" alt="Alt text"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class BSArray &#123;</div><div class="line"></div><div class="line">	//在升序排列的数组中，若找到关键字，则返回相应下标，否则返回-1</div><div class="line">	public static&lt;T&gt; int binarySearch(Comparable&lt;T&gt;[] value,T key)&#123;</div><div class="line">		return binarySearch(value,0,value.length-1,key);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static&lt;T&gt; int binarySearch(Comparable&lt;T&gt;[] value,int begin,int end,T key)&#123;</div><div class="line">		if(key!=null)</div><div class="line">			while(begin&lt;=end)&#123;    //边界有效</div><div class="line">				int mid=(begin+end)/2;  //中间位置，当前比较元素位置</div><div class="line">		System.out.println(value[mid]+"?");</div><div class="line">		if(value[mid].compareTo(key)==0) //对象比较大小</div><div class="line">			return mid;                  //查找成功</div><div class="line">		if(value[mid].compareTo(key)&gt;0)  </div><div class="line">			end=mid-1;                    //缩小到前半段</div><div class="line">		else</div><div class="line">			begin=mid+1;                 //缩小到后半段</div><div class="line">	&#125; </div><div class="line">	return -1;                           //查找不成功</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;查找操作，通俗的讲，就是给定一个值key，在一个数据结构中找出关键字为key的元素。而基于线性表的查找算法有顺序查找（O（n）），二分查找和
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>hash散列表</title>
    <link href="http://www.myzwl.win/2017/07/14/sjjg_9/"/>
    <id>http://www.myzwl.win/2017/07/14/sjjg_9/</id>
    <published>2017-07-14T05:48:51.000Z</published>
    <updated>2017-07-27T11:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>散列（hash）表是一种支持高效的查找、插入和删除操作的数据结构，它是针对查找效率接近O（1）而专门设计的。它根据元素的关键字确定元素的存储位置，而其中主要解决两个问题，设计散列函数和处理冲突</p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>在数据元素的关键字和该元素的存储位置之间建立一种对应关系，称为散列函数，而由散列函数决定元素存储位置的存储结构称为散列表，散列函数声明为</p>
<blockquote>
<p>public int hash(int key) //散列函数，确定关键字为key元素的散列地址</p>
</blockquote>
<p>散列函数实质上是关键字集合到地址集合的映射，如果这种映射是一一对应的，则查找效率是O（1），但是由于散列表是一个压缩映射，即存储容量有限，即映射关系是多对一的映射，所以会产生冲突<br><img src="/images/imgs4/9.gif" alt="Alt text"></p>
<h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>设两个关键字k1和k2（k1！=k2），如果有hash（k1）=hash（k2），即它们的散列值相同，表示不同关键字的多个元素映射到同一个存储位置，称为冲突，如图，所设的关键字序列是（1,4,3,11,12,6,14,74,16,96），元素个数是10，关键字范围是0~99，如果散列值的容量是100，很明显是一对一不会产生冲突，但是空间利用率此时只有10%，如果容量是10或者20，冲突差生的频率会减少</p>
<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>该散列函数定义为hash（k）=k%p，函数结果范围为0~p-1，图示就是采用这种方法，而p取值为小于散列表长度的最大素数，如散列表长度分别为8,16,128，则对应的p（最大素数）分别为7,13,127</p>
<h4 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h4><p><strong>开放定址法</strong><br>当产生冲突时，开放定址法在散列表内寻找另一个位置存储冲突的元素，如利用线性探查发实现，即设一个元素关键字为k，其散列地址为i=hash（k），若散列表中i位置已存储元素，则产生冲突，探测下一个位置i+1是否为空，。。直到找到一个空位置，但是它的缺陷就是在散列表内处理冲突，使得一个存储地址i可被任意一个元素抢占，这样就破坏了散列函数i=hash（k）的规则</p>
<p><strong>链地址法</strong><br><img src="/images/imgs4/12.jpg" alt="Alt text"><br>该方法是将多个冲突的元素存储在一条单链表中（称为同义词单链表），如图示<br>而对链地址法表进行插入、删除、查找等操作主要分两步完成<br>1.计算元素的散列函数值<br>2.根据元素的散列函数值，对某一条同义词单链表进行插入、删除和查找操作<br>规定查找成功的平均查找长度为（根据图示）ASL=(9<em>1+3</em>2)/12<br>并且有如下结论：<br>1.查找操作的时间复杂度为O（m），其中m为一条痛一次单链表的长度，插入操作为O(1),删除操作为O(m)</p>
<h4 id="模拟HashSet类"><a href="#模拟HashSet类" class="headerlink" title="模拟HashSet类"></a>模拟HashSet类</h4><p>这里同义词单链表采用单链表<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class HashSet&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	private SinglyLinkenList&lt;T&gt;[] table;    //散列表，同义词单链表对象数组</div><div class="line">	public HashSet(int size)&#123;               //构造指定容量的散列表</div><div class="line">		this.table=new SinglyLinkenList[Math.abs(size)];</div><div class="line">		for(int i=0;i&lt;table.length;i++)</div><div class="line">			table[i]=new SinglyLinkenList&lt;T&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public HashSet()&#123; //构造最大质数为97的容量</div><div class="line">		this(97);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private int hash(T x)&#123;  //散列函数，确定关键字为key元素的散列地址</div><div class="line">		int key=Math.abs(x.hashCode()); //每个对象的hashcode（）方法返回散列码，并且每个对象不同</div><div class="line">		return key%table.length; //出留余数法，除数是散列表长度</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void insert(T x)&#123;//插入x元素</div><div class="line">		table[hash(x)].insert(0, x);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void remove(T x)&#123; //删除x元素</div><div class="line">		table[hash(x)].remove((Integer) x);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public T search(T key)&#123; //返回查找到的关键字为key元素，查找不成功返回null</div><div class="line">		return table[hash(key)].search(key);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean contain(T key)&#123; //判断散列表是否包含关键字为key元素</div><div class="line">		return this.search(key)!=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String toString()&#123;</div><div class="line">		String str="";</div><div class="line">		for(int i=0;i&lt;table.length;i++)  //遍历各同义词单链表</div><div class="line">			if(!table[i].isEmpty())</div><div class="line">				str+=table[i].toString()+"\n";</div><div class="line">		return str;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;散列（hash）表是一种支持高效的查找、插入和删除操作的数据结构，它是针对查找效率接近O（1）而专门设计的。它根据元素的关键字确定元素的存储
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树和二叉树</title>
    <link href="http://www.myzwl.win/2017/07/13/sjjg_8/"/>
    <id>http://www.myzwl.win/2017/07/13/sjjg_8/</id>
    <published>2017-07-13T05:48:51.000Z</published>
    <updated>2017-07-27T07:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>树是数据元素（结点）之间具有层次关系的非线性结构。在树结构中，除根以外的结点只有一个前驱结点，可以有零至多个后继结点，根结点没有前驱结点</p>
<h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><p><img src="/images/imgs4/7.jpg" alt="Alt text"><br>1.父母、孩子、兄弟结点<br>2.度（结点所拥有的子树数目），如A的度为3<br>3.结点的层次（结点处于树中的位置，约定根结点层次为1），树的高度（树中结点的最大层次数）如图中树高度为3<br>4.边（设X结点是y结点的父母结点，有序对（X，y）称为这两个结点的边，路径如A到E结点，表示为（A，B，E），路径长度（路径上的边数）为2<br>5.无序数与有序树（区别子树之间有没有次序）<br>6.森林（删除根结点）</p>
<h4 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h4><p><img src="/images/imgs4/8.jpg" alt="Alt text"><br>二叉树最多有两颗子树，分别为左右子树<br>性质1：若根结点的层次为1，则二叉树第i层最多有2^(i-1)(i&gt;1)个结点<br>性质2：在高度为h的二叉树中，最多有2^h-1个结点（h&gt;=0)<br>性质3：设一棵二叉树的叶子结点数为n0,2度结点数为n2，则n0=n2+1<br>性质4：一颗具有n个结点的完全二叉树，其高度为h=[log以2为底数n为参数]+1；其中[]是高斯取整函数<br>性质5：一颗具有n个结点的完全二叉树，对序号为i（0&lt;=i<n)的结点，有 1.若i="0，则i为根结点，无父母结点：若i">0，则i的父母结点序号为[(i+1)/2]<br>2.若2<em>i+1&lt;n，则i的左孩子结点序号为2</em>i+1；否则无左孩子<br>3.若2<em>i+2&lt;n，则i的右孩子结点序号为2</em>i+2，否则i无右孩子</n)的结点，有></p>
<h4 id="二叉树的遍历规则"><a href="#二叉树的遍历规则" class="headerlink" title="二叉树的遍历规则"></a>二叉树的遍历规则</h4><p><strong>孩子优先遍历</strong><br>二叉树的遍历是按照一定规则和次序访问二叉树中的所有结点，并且每个结点仅被访问一次，同时遍历二叉树访问结点的次序是线性的。<br>1.先根次序：访问根结点，遍历左子树，遍历右子树（124536）<br>2.中根次序：遍历左子树，访问根结点，遍历右子树（425136）<br>3.后根次序：遍历左子树，遍历右子树，访问根结点（452631）</p>
<p><strong>兄弟优先遍历</strong><br>该遍历是按照层次进行的，遍历历程是从根结点开始，逐层深入，从左至右依次访问完当前层的所有结点，在访问下一层</p>
<h4 id="二叉树抽象数据类型和存储结构"><a href="#二叉树抽象数据类型和存储结构" class="headerlink" title="二叉树抽象数据类型和存储结构"></a>二叉树抽象数据类型和存储结构</h4><p><strong>顺序存储结构</strong><br><img src="/images/imgs4/9.jpg" alt="Alt text"><br>二叉树的顺序存储结构仅适用于完全二叉树和满二叉树，如图所示。根据之前的性质，可以实现对应关系一一对应个。<br>而对于非完全二叉树，如果采取顺序存储，可以将其补成一个完全二叉树，对于空结点利用特殊符号代替，但是会造成空间浪费，并且线性映射关系不明确</p>
<p><strong>链式存储结构</strong><br><img src="/images/imgs4/11.jpg" alt="Alt text"><br>二叉链表采用两条链分别连接左右孩子结点，每个结点有三个域：data存储数据元素，left、right分别指向左右孩子结点<br>三叉链表在二叉链表基础上增加一条链parent连接父母结点<br><img src="/images/imgs4/10.jpg" alt="Alt text"></p>
<p><strong>二叉链表结点</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class BinaryNode&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	public T data;                 //数据域，存储数据元素</div><div class="line">	public BinaryNode&lt;T&gt; left,right;   //链域，分别指向左、右孩子结点</div><div class="line">	</div><div class="line">	public BinaryNode(T data,BinaryNode&lt;T&gt; left,BinaryNode&lt;T&gt; right)&#123;</div><div class="line">		this.data=data;</div><div class="line">		this.left=left;</div><div class="line">		this.right=right;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode(T data)&#123;</div><div class="line">		this(data,null,null);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode()&#123;</div><div class="line">		this(null,null,null);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>抽象数据类型</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface BinaryTTree&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	boolean isEmpty();           //判断二叉树是否为空</div><div class="line">	int count();                 //返回二叉树的结点个数</div><div class="line">	int height();                //返回二叉树的高度</div><div class="line">	void preOrder();             //先根次序遍历二叉树</div><div class="line">	void inOrder();              //中根次序遍历二叉树</div><div class="line">	void postOrder();            //后根次序遍历二叉树</div><div class="line">	void levelOrder();           //按层次遍历二叉树</div><div class="line">	BinaryNode&lt;T&gt; search(T key);   //查找并返回首次出现关键字为key元素结点</div><div class="line">	BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; node);      //返回node的父母结点</div><div class="line">	void insertRoot(T x);            //插入元素x作为根结点</div><div class="line">	BinaryNode&lt;T&gt; insertChild(BinaryNode&lt;T&gt; p,T x,boolean leftChild); //插入孩子节点</div><div class="line">	void removeChild(BinaryNode&lt;T&gt; p,boolean leftChild); //删除p结点的左或右子树</div><div class="line">	void removeAll();  //删除二叉树</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是其实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line">public class BinaryTree&lt;T&gt; implements BinaryTTree&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	public BinaryNode&lt;T&gt; root;   //根结点，结点结构为二叉链表</div><div class="line">	public BinaryTree()&#123;         //构造空二叉树</div><div class="line">		this.root=null;</div><div class="line">	&#125;</div><div class="line">	public boolean isEmpty() &#123;  //判断二叉树是否为空</div><div class="line">		return this.root==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int count() &#123;</div><div class="line">		return count(root);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int count(BinaryNode&lt;T&gt; p)&#123; //返回以p结点为根的子树的结点个数</div><div class="line">		if(p==null)</div><div class="line">			return 0;</div><div class="line">		return 1+count(p.left)+count(p.right);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int height() &#123;</div><div class="line">		return height(root);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int height(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p==null)</div><div class="line">			return 0;</div><div class="line">		int lh=height(p.left); //返回左子树高度</div><div class="line">		int rh=height(p.right); //返回右子树高度</div><div class="line">		return (lh&gt;=rh)?lh+1:rh+1; //当前子树高度为较高子树高度加1</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void preOrder() &#123;</div><div class="line">		System.out.println("先根次序遍历二叉树:  ");</div><div class="line">		preOrder(root);</div><div class="line">		System.out.println();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void preOrder(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p!=null)</div><div class="line">		&#123;</div><div class="line">			System.out.println(p.data.toString()+" ");//访问当前结点</div><div class="line">			preOrder(p.left); //按先根次序遍历当前结点左子树，递归调用</div><div class="line">			preOrder(p.right); //按先根次序遍历当前结点右子树，递归调用</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void inOrder() &#123;</div><div class="line">		System.out.println("中根次序遍历二叉树 :   ");</div><div class="line">		inOrder(root);</div><div class="line">		System.out.println();	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void inOrder(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p!=null)</div><div class="line">		&#123;</div><div class="line">			inOrder(p.left);</div><div class="line">			System.out.println(p.data.toString()+" ");</div><div class="line">			inOrder(p.right);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void postOrder() &#123;</div><div class="line">	</div><div class="line">		System.out.println("后根次序遍历二叉树 :   ");</div><div class="line">		inOrder(root);</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void postOrder(BinaryNode&lt;T&gt; p)&#123;</div><div class="line">		if(p!=null)&#123;</div><div class="line">			postOrder(p.left);</div><div class="line">			postOrder(p.right);</div><div class="line">			System.out.println(p.data.toString()+" ");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void levelOrder() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public BinaryNode&lt;T&gt; search(T key) &#123;</div><div class="line">		return search(root,key);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode&lt;T&gt; search(BinaryNode&lt;T&gt; p,T key) &#123;</div><div class="line">		if(p==null||key==null)</div><div class="line">			return null;</div><div class="line">		if(p.data.equals(key))  //查找成功，返回找到结点</div><div class="line">			return p;</div><div class="line">		BinaryNode&lt;T&gt; find=search(p.left,key);//在左子树中查找，递归调用</div><div class="line">		if(find==null)</div><div class="line">			find=search(p.right,key);//左子树中未找到，在右子树中继续递归查找</div><div class="line">		return find;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; node) &#123;</div><div class="line">	if(root==null||node==null||node==root)</div><div class="line">		return null;</div><div class="line">	 return getParent(root,node);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public BinaryNode&lt;T&gt; getParent(BinaryNode&lt;T&gt; p,BinaryNode&lt;T&gt; node) &#123;</div><div class="line">	if(p==null)</div><div class="line">		return null;</div><div class="line">	if(p.left==node||p.right==node)</div><div class="line">		return p;</div><div class="line">	BinaryNode&lt;T&gt; find=getParent(p.left,node);</div><div class="line">	if(find==null)</div><div class="line">		find=getParent(p.right,node);</div><div class="line">		return find;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void insertRoot(T x) &#123;</div><div class="line">		root=new BinaryNode&lt;T&gt;(x, root, null);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	//插入元素x作为p结点的孩子，若leftChild为true,插入结点作为左孩子，否则作为右孩子</div><div class="line">	public BinaryNode&lt;T&gt; insertChild(BinaryNode&lt;T&gt; p,T x,boolean leftChild)&#123;</div><div class="line">		if(p==null||x==null)</div><div class="line">			return null;</div><div class="line">		if(leftChild)</div><div class="line">		&#123;</div><div class="line">			p.left=new BinaryNode&lt;T&gt;(x, p.left, null);//插入x作为p的左孩子，p原左孩子变为x左孩子</div><div class="line">			return p.left;</div><div class="line">		&#125;</div><div class="line">		p.right=new BinaryNode&lt;T&gt;(x,null,p.right); //插入x结点作为p的右孩子</div><div class="line">		return p.right;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line">	public void removeChild(BinaryNode&lt;T&gt; p, boolean leftChild) &#123;</div><div class="line">	if(p!=null)</div><div class="line">		if(leftChild)</div><div class="line">			p.left=null;</div><div class="line">		else</div><div class="line">			p.right=null;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">		this.root=null;</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;树是数据元素（结点）之间具有层次关系的非线性结构。在树结构中，除根以外的结点只有一个前驱结点，可以有零至多个后继结点，根结点没有前驱结点&lt;/
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>优先队列与递归</title>
    <link href="http://www.myzwl.win/2017/07/12/sjjg_7/"/>
    <id>http://www.myzwl.win/2017/07/12/sjjg_7/</id>
    <published>2017-07-12T05:48:51.000Z</published>
    <updated>2017-07-26T14:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果按照队列的特点，即先来先服务原则，在很多情况下不能实现相关设计，比如操作系统中的进程调度管理，就是按照优先级大小来进行调度</p>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>若一个队列中的每个元素都有一个优先级，每次出队的是具有优先级最高的元素，则称该队列为优先队列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class PriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; implements QQueue&#123;</div><div class="line"></div><div class="line">	private SortedSinglyLinkedList&lt;T&gt; list; //使用排序单链表存储队列元素</div><div class="line">	</div><div class="line">	public PriorityQueue()&#123;   //构造空队列</div><div class="line">		this.list=new SortedSinglyLinkedList&lt;T&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123; //判断队列是否为空</div><div class="line">		return list.isEmpty();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(Object x) &#123; //元素x入队，根据元素大小插入在单链表适当位置</div><div class="line">		list.insert(x);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object dequeue() &#123;//出队，返回对头元素</div><div class="line"></div><div class="line">		return list.remove(0);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String toString()&#123;</div><div class="line">		return list.toString();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进程按优先级调度管理<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Process implements Comparable&lt;Process&gt;&#123;</div><div class="line"></div><div class="line">	private String name;   //进程名</div><div class="line">	private int priority;  //优先级</div><div class="line"></div><div class="line"></div><div class="line">	public Process(String name, int priority) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.priority = priority;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	public int compareTo(Process o) &#123;//比较两个进程的大小，约定进程排队次序的规则</div><div class="line"></div><div class="line">		return this.priority-o.priority;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>从形式上，递归的定义可如下所示<br><img src="/images/imgs4/6.jpg" alt="Alt text"><br>同时递归定义必须满足以下两个条件<br>1.边界条件：至少有一条初始定义是非递归的。<br>2.递归通式： 由已知函数值逐步递推计算出未知函数值</p>
<p>递归算法是指直接或者间接调用自身的算法<br>如用递归算法求fibonacci数列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Factorial &#123;</div><div class="line"></div><div class="line">	public static int factorial(int n)</div><div class="line">	&#123;</div><div class="line">		if(n&lt;0)</div><div class="line">			throw new IllegalArgumentException("n="+n);</div><div class="line">		if(n==0||n==1)</div><div class="line">			return n;</div><div class="line">		return factorial(n-1)+factorial(n-2);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String args[])&#123;</div><div class="line">		for(int i=0;i&lt;=24;i++)</div><div class="line">			System.out.print(factorial(i)+" ");</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<blockquote>
<p>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 </p>
</blockquote>
<p>再如将之前的SinglyLinkenList类增加一个复制方法，采用递归法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private Node&lt;T&gt; copy(Node&lt;T&gt; p)&#123;</div><div class="line">	Node&lt;T&gt; q=null; //新结点</div><div class="line">	if(p!=null)  //要复制的结点非空</div><div class="line">	&#123;</div><div class="line">		q=new Node&lt;T&gt;(p.data,null); //相当于q.data=p.data，q.next=null</div><div class="line">		q.next=copy(p.next);//递归，q1.data=p.next.data，q1.next=null，先返回q1，q.next=q1</div><div class="line">		//可以看成一棵二叉树</div><div class="line">	&#125;</div><div class="line">	return q;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果按照队列的特点，即先来先服务原则，在很多情况下不能实现相关设计，比如操作系统中的进程调度管理，就是按照优先级大小来进行调度&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>顺序与链式队列</title>
    <link href="http://www.myzwl.win/2017/07/11/sjjg_6/"/>
    <id>http://www.myzwl.win/2017/07/11/sjjg_6/</id>
    <published>2017-07-11T05:48:51.000Z</published>
    <updated>2017-07-26T07:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行。特点是先进先出。</p>
<h4 id="队列抽象数据类型"><a href="#队列抽象数据类型" class="headerlink" title="队列抽象数据类型"></a>队列抽象数据类型</h4><p><img src="/images/imgs4/5.jpg" alt="Alt text"><br>其中，像队列中插入元素的过程称为入队（enqueue），删除元素的过程称为出队（dequeue），允许入队的一端称为队尾（rear），允许出队的一头称为对头（front），没有元素的队列称为空队列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface QQueue&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	boolean isEmpty();          //判断队列是否为空</div><div class="line">	void enqueue(T x);          //元素x入队</div><div class="line">	T dequeue();                //出队，返回对头元素</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>顺序队列使用数组存储数据元素<br>1.当队列空时，设置队头、队尾下标front=rear=-1，<br>2.当第一个元素入队时，front=rear=0，同时改变两个下标<br>3.进行入队、出队操作，front、rear随之变化<br>4.当入队的元素个数（包括已出队元素）超出数组容量时，rear下标越界，数据溢出，但是，由于之前已有若干元素出队，数组前部以空出许多存储单元，所以这种溢出并不是因为存储空间不够而产生的，称为假溢出</p>
<p>所以顺序队列有两个缺点：假溢出和存储单元没有重复使用机制</p>
<h4 id="顺序循环队列"><a href="#顺序循环队列" class="headerlink" title="顺序循环队列"></a>顺序循环队列</h4><p>相比较顺序队列，有如下不同<br>1.队头、队尾元素按照如下循环规律变化，其中length表示数组长度<br>front=（front+1)%length;<br>rear=(rear+1)%length;<br>所以可以看出front和rear的取值范围为0~length-1；</p>
<p>2.约定rear是下一个入队元素位置，队列空条件是front==rear，即入队只改变rear，出队只改变front<br>3.约定队列满条件是队列中仍然有一个空位置，即front==（rear+1）%length，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class SeqQueue&lt;T&gt; implements QQueue&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Object element[];  //存储队列数据元素的数组</div><div class="line">	private int front,rear;    //分别为对头和队尾元素</div><div class="line">	</div><div class="line">	public SeqQueue(int length)&#123;        //构造容量为length的空队列</div><div class="line">		if(length&lt;64)</div><div class="line">			length=64;</div><div class="line">		this.element=new Object[Math.abs(length)];</div><div class="line">		this.front=this.rear=0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public SeqQueue()&#123;       //构造默认容量空队列</div><div class="line">		this(64);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;     //判断队列是否为空</div><div class="line">		return this.front==this.rear;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(T x) &#123;   //元素x入队，空对象不能入队</div><div class="line">	if(x==null)</div><div class="line">		return;</div><div class="line">	if(this.front==(this.rear+1)%this.element.length) //当队满时，扩充容量</div><div class="line">	&#123;</div><div class="line">		Object[] temp=this.element;</div><div class="line">		this.element=new Object[temp.length*2];</div><div class="line">		int i=this.front,j=0;</div><div class="line">		while(i!=this.rear)&#123;        //按照队列元素次序复制数组元素</div><div class="line">			this.element[j]=temp[i];</div><div class="line">			i=(i+1)%temp.length;</div><div class="line">			j++;</div><div class="line">		&#125;</div><div class="line">		this.front=0;</div><div class="line">		this.rear=j;</div><div class="line">	&#125;</div><div class="line">		this.element[this.rear]=x;</div><div class="line">		this.rear=(this.rear+1)%this.element.length;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T dequeue() &#123;         //出队，返回队头元素，若队列空则返回null</div><div class="line">   if(isEmpty())</div><div class="line">		return null;</div><div class="line">    T temp=(T)this.element[this.front];</div><div class="line">      this.front=(this.front+1)%this.element.length;  //取得队头元素</div><div class="line">     return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p>以不带头结点的单链表实现链式队列，设指针front和rear分别指向队头和队尾结点，初始空队列的状态设置为front=rear=null；队列空条件是front==null&amp;&amp;rear==null</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class LinkedQueue&lt;T&gt; implements QQueue&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Node&lt;T&gt; front,rear;        //分别指向队头和队尾</div><div class="line">	</div><div class="line">	public LinkedQueue()&#123;             //构造空队列</div><div class="line">		this.front=this.rear=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;        //判断队列是否为空</div><div class="line">		return this.front==null&amp;&amp;this.rear==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(T x) &#123;       //元素x入队，空对象入队</div><div class="line">		if(x==null)  </div><div class="line">			return;</div><div class="line">		Node&lt;T&gt; q=new Node&lt;T&gt;(x,null);  </div><div class="line">		 if(this.front==null)</div><div class="line">			 this.front=q;   //空队入队</div><div class="line">		 else</div><div class="line">			 this.rear.next=q; //插入在队尾之后</div><div class="line">		 this.rear=q;		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T dequeue() &#123;  //出队，返回对头元素，若队列元素为空，返回null</div><div class="line">		if(isEmpty())</div><div class="line">			return null;</div><div class="line">		T temp=this.front.data;    //取得队头元素</div><div class="line">		this.front=this.front.next;    //删除队头结点</div><div class="line">		if(this.front==null)</div><div class="line">			this.rear=null;</div><div class="line">		return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行。特点是先进先出。&lt;/p&gt;
&lt;h4 id=&quot;队列抽象数据类型&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://www.myzwl.win/2017/07/10/sjjg_5/"/>
    <id>http://www.myzwl.win/2017/07/10/sjjg_5/</id>
    <published>2017-07-10T05:48:51.000Z</published>
    <updated>2017-07-26T05:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈是一种特殊的线性表，其特殊之处在于插入和删除操作的位置受到限制，而且插入和删除只允许在线性表的一端进行，特点是后进先出</p>
<h4 id="栈抽象数据类型"><a href="#栈抽象数据类型" class="headerlink" title="栈抽象数据类型"></a>栈抽象数据类型</h4><p><img src="/images/imgs4/8.gif" alt="Alt text"><br>其中允许操作的一端为栈顶（top），不允许操作的一端为栈底（bottom），栈中插入元素的操作称为入栈（push），删除元素的操作为出栈（pop），没有元素的栈称为空栈</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface SStack&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	boolean isEmpty();  //判断是否为空栈</div><div class="line">	void push(T x);     //元素x入栈</div><div class="line">	T pop();            //出栈，返回当前栈顶元素</div><div class="line">	T get();            //取栈顶元素，未出栈</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>采用顺序存储结构的栈称为顺序栈<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class SeqStack&lt;T&gt; implements SStack&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Object element[];    //存取栈数据元素的数组</div><div class="line">	private int top;             //栈顶元素下标</div><div class="line">	</div><div class="line">	public SeqStack(int size)&#123;    //构造容量为size的空栈</div><div class="line">		this.element=new Object[Math.abs(size)];</div><div class="line">		this.top=-1;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public SeqStack()&#123;         //构造默认容量的空栈</div><div class="line">		this(64);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123; //判断栈是否为空</div><div class="line">		</div><div class="line">		return this.top==-1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void push(T x) &#123;    //元素x入栈，空对象不能入栈</div><div class="line">		if(x==null)</div><div class="line">			return;</div><div class="line">		if(this.top==element.length-1)   //栈满，扩充栈容量</div><div class="line">		&#123;</div><div class="line">			Object[] temp=this.element;</div><div class="line">			this.element=new Object[temp.length*2];</div><div class="line">			for(int i=0;i&lt;temp.length;i++)</div><div class="line">				this.element[i]=temp[i];</div><div class="line">		&#125;</div><div class="line">		this.top++;</div><div class="line">		this.element[this.top]=x;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T pop() &#123;  //出栈</div><div class="line">		</div><div class="line">		return this.top==-1?null:(T)this.element[this.top--];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get() &#123;		//取栈顶元素</div><div class="line">		return this.top==-1?null:(T)this.element[this.top];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上，push（），pop（），get（）方法的时间复杂度为O（1），而需要扩充容量时，复杂度为O（n）；</p>
<h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>采用链式存储结构的栈称为链式栈，这里采用单链表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class LinkedStack&lt;T&gt; implements SStack&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Node&lt;T&gt; top;         //栈顶结点</div><div class="line">	</div><div class="line">	public LinkedStack()&#123;        //构造空栈</div><div class="line">		this.top=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;     //判断栈是否为空</div><div class="line">		return this.top==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void push(T x) &#123;</div><div class="line">		if(x!=null)</div><div class="line">			this.top=new Node(x, this.top);  //头插入，x结点作为新的栈顶结点</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T pop() &#123;         //出栈，返回栈顶元素</div><div class="line">		if(this.top==null)</div><div class="line">			return null;</div><div class="line">		T temp=this.top.data;</div><div class="line">		this.top=this.top.next;</div><div class="line">		return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get() &#123;</div><div class="line">		return this.top==null?null:this.top.data;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;栈是一种特殊的线性表，其特殊之处在于插入和删除操作的位置受到限制，而且插入和删除只允许在线性表的一端进行，特点是后进先出&lt;/p&gt;
&lt;h4 i
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
