<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2017-09-12T14:16:54.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见面试题八之javaweb基础</title>
    <link href="http://www.myzwl.win/2017/09/04/face_8/"/>
    <id>http://www.myzwl.win/2017/09/04/face_8/</id>
    <published>2017-09-04T09:48:51.000Z</published>
    <updated>2017-09-12T14:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="使用spring框架的好处是什么"><a href="#使用spring框架的好处是什么" class="headerlink" title="使用spring框架的好处是什么"></a>使用spring框架的好处是什么</h4><p>轻量级、控制反转、面向切面编程（AOP）、容器（包含并管理应用中对象的生命周期和配置）、mvc框架、事务管理、异常处理</p>
<h4 id="applicationContext通常的实现是什么"><a href="#applicationContext通常的实现是什么" class="headerlink" title="applicationContext通常的实现是什么"></a>applicationContext通常的实现是什么</h4><p>FileSystemXmlApplicationContext（从一个xml文件中加载beans的定义）<br>classPathXmlApplicationContext：（也是从一个xml文件中加载beans文件，但是在classpath里找bean配置）<br>WebXmlApplicationContext：定义一个web应用的所有bean</p>
<h4 id="什么是spring的依赖注入？有哪些方法进行依赖注入？"><a href="#什么是spring的依赖注入？有哪些方法进行依赖注入？" class="headerlink" title="什么是spring的依赖注入？有哪些方法进行依赖注入？"></a>什么是spring的依赖注入？有哪些方法进行依赖注入？</h4><p>你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件和服务，之后一个容器负责把他们组装起来<br>构造器依赖注入、setter方法注入</p>
<h4 id="解释spring支持的几种bean的作用域"><a href="#解释spring支持的几种bean的作用域" class="headerlink" title="解释spring支持的几种bean的作用域"></a>解释spring支持的几种bean的作用域</h4><blockquote>
<p>singleton：bean在每个spring ioc容器中只有一个实例<br>prototype： 一个bean的定义可以有多个实例<br>request： 每次http请求都会创建一个bean，改作用域仅在web的spring applicationContext情形下有效<br>session、global-session</p>
</blockquote>
<h4 id="解释spring框架中bean的生命周期"><a href="#解释spring框架中bean的生命周期" class="headerlink" title="解释spring框架中bean的生命周期"></a>解释spring框架中bean的生命周期</h4><blockquote>
<p>1.spring容器从XML文件中读取bean的定义，并实例化bean<br>2.spring根据bean的定义填充所有的属性<br>3.如果bean实现了beanNameAware接口，spring传递bean的ID到setBeanName方法<br>4.如果Bean实现了BeanFactoryAware接口，spring传递beanfactory给setBeanFactory<br>5.如果有任何与bean相关联的beanpostprocessors，spring会在postprocesserBeforeInitalzation（）方法内部调用他们<br>6.如果bean实现了intialzingBean了，调用它的afterPropertySet方法，如果bean声明初始化方法，调用此初始化方法<br>7.如果bean实现了disposableBean，它将调用destroy（）方法</p>
</blockquote>
<h4 id="spring中如何注入一个java集合"><a href="#spring中如何注入一个java集合" class="headerlink" title="spring中如何注入一个java集合"></a>spring中如何注入一个java集合</h4><p><list>、<set>,<map>,<props></props></map></set></list></p>
<h4 id="有哪些不同方式的自动装配"><a href="#有哪些不同方式的自动装配" class="headerlink" title="有哪些不同方式的自动装配"></a>有哪些不同方式的自动装配</h4><p>有五种自动装配的方式</p>
<blockquote>
<p>no:默认方式，通过显示设置ref属性来进行装配<br>byName：通过参数名自动装配<br>byType：通过参数类型自动装配<br>constructor ： 类似于bytype，但是要提供构造器参数<br>autodetect：首次尝试construc，其次是bytype</p>
</blockquote>
<h4 id="hibernate中sessionFactory是线程安全吗？session是线程安全的吗"><a href="#hibernate中sessionFactory是线程安全吗？session是线程安全的吗" class="headerlink" title="hibernate中sessionFactory是线程安全吗？session是线程安全的吗"></a>hibernate中sessionFactory是线程安全吗？session是线程安全的吗</h4><p>sessionfactory对应一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。一般在启动的时候通过单例模式进行封装便于访问<br>session是一个轻量级的非线程安全的对象，线程间不能共享session，session默认会延迟获取数据库连接</p>
<h4 id="mybatis中的动态SQL是什么意思"><a href="#mybatis中的动态SQL是什么意思" class="headerlink" title="mybatis中的动态SQL是什么意思"></a>mybatis中的动态SQL是什么意思</h4><p>动态sql主要包括if、choose、when、otherwise、trim、where、set、foreach</p>
<h4 id="简单说一下mybatis的一级缓存和二级缓存"><a href="#简单说一下mybatis的一级缓存和二级缓存" class="headerlink" title="简单说一下mybatis的一级缓存和二级缓存"></a>简单说一下mybatis的一级缓存和二级缓存</h4><p>mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从从缓存取出返回结果集。mybatis内部缓存使用一个hashmap，key为hashcode+sqlid+sql语句。value从查询出来映射生成java对象<br>mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个namespace中查询sql可以从缓存中存取数据，二级缓存是可以跨sqlsession的</p>
<h4 id="什么是泛型是如何工作？什么是类型擦除？如何工作？"><a href="#什么是泛型是如何工作？什么是类型擦除？如何工作？" class="headerlink" title="什么是泛型是如何工作？什么是类型擦除？如何工作？"></a>什么是泛型是如何工作？什么是类型擦除？如何工作？</h4><blockquote>
<p>1类型检查：在生成字节码之前提供类型检查<br>2.类型擦除：所有的类型参数都用他们的限定类型替换，包括类、变量和方法<br>3：如果调用类型擦除和多态性发生冲突时，则在调用该方法时插入强制类型转换<br>类型擦除：<br>所有类型参数都用他们的限定类型替换：比如T,Object</p>
</blockquote>
<p>如何工作</p>
<blockquote>
<p>泛型通过类型擦除来实现的，编译器在编译时期擦除了所有类型相关的信息，所有在运行时不存在任何类型相关的信息</p>
</blockquote>
<h4 id="Ajax的实现流程是主怎样的"><a href="#Ajax的实现流程是主怎样的" class="headerlink" title="Ajax的实现流程是主怎样的"></a>Ajax的实现流程是主怎样的</h4><blockquote>
<p>1创建XMLHttpRequest对象，也就是创建一个异步调用对象<br>2.创建一个新的HTTp请求，并指定该HTTP请求的方法，url及验证信息<br>3设置http请求状态变化的函数<br>4.发送HTTp请求<br>5获取异步调用返回的数据<br>6.使用javascript和DOM实现局部刷新</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己
    
    </summary>
    
      <category term="面试题" scheme="http://www.myzwl.win/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="学习效果检验" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%95%88%E6%9E%9C%E6%A3%80%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>常见面试题七之javaweb基础</title>
    <link href="http://www.myzwl.win/2017/09/04/face_7/"/>
    <id>http://www.myzwl.win/2017/09/04/face_7/</id>
    <published>2017-09-04T08:48:51.000Z</published>
    <updated>2017-09-12T07:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="说一说servlet的生命周期"><a href="#说一说servlet的生命周期" class="headerlink" title="说一说servlet的生命周期"></a>说一说servlet的生命周期</h4><p>包括加载和实例化、初始化、处理请求及服务结束，有javax.servlet.Servlet接口的相关方法实现<br>web容器加载servlet，生命周期开始。通过调用servlet的init（）方法进入初始化，通过service（）方法实现，根据不同的请求调用do<em>*</em>（）方法，服务结束，web容器调用servlet的destroy（）方法</p>
<h4 id="servlet-API中forward（）与redirect（）区别？"><a href="#servlet-API中forward（）与redirect（）区别？" class="headerlink" title="servlet API中forward（）与redirect（）区别？"></a>servlet API中forward（）与redirect（）区别？</h4><blockquote>
<p>从地址栏显示来说：<br>forward是服务器请求的地址资源，通过内部转发方式最后只返回一次内容，而redirect是重新转发，也就是需要经过两次请求与响应<br>从数据共享来说<br>forward可以共享request里的数据，而redirect不行，forward是服务器内部的一种操作，而redirect是服务器通知客户端，然后客户端重新发起请求<br>从运用地方<br>forward一般用于用户登录的时候，根据角色转发到相应的模块<br>redirect一般用于用户注销登录时返回主页和跳转到其它的网站<br>从效率上<br>forward高，redirect低</p>
</blockquote>
<h4 id="request-getAttribute-和request-getParameter-有什么区别"><a href="#request-getAttribute-和request-getParameter-有什么区别" class="headerlink" title="request.getAttribute()和request.getParameter()有什么区别"></a>request.getAttribute()和request.getParameter()有什么区别</h4><blockquote>
<p>后者取得通过容器的实现来取得通过类似post，get等方式传入的数据<br>前者返回对象，后者返回字符串</p>
</blockquote>
<h4 id="jsp有哪些内置对象？作用分别是什么"><a href="#jsp有哪些内置对象？作用分别是什么" class="headerlink" title="jsp有哪些内置对象？作用分别是什么"></a>jsp有哪些内置对象？作用分别是什么</h4><p>总共有九大内置对象</p>
<blockquote>
<p>request、reponse、pageContext、session、application、out、config、page、exception</p>
</blockquote>
<h4 id="Http中，get和post方法区别"><a href="#Http中，get和post方法区别" class="headerlink" title="Http中，get和post方法区别"></a>Http中，get和post方法区别</h4><blockquote>
<p>1.get请求的数据会被浏览器缓存起来，并以明文方式出现在url中，不太安全而post则更安全<br>2get传输数据有大小限制get请求的参数会跟在url后进行传递</p>
</blockquote>
<h4 id="jdbc访问数据库的基本步骤是什么？"><a href="#jdbc访问数据库的基本步骤是什么？" class="headerlink" title="jdbc访问数据库的基本步骤是什么？"></a>jdbc访问数据库的基本步骤是什么？</h4><blockquote>
<p>1.加载驱动<br>2.通过driverManager对象获取连接对象Connection<br>3.通过连接对象获取会话<br>4.通过会话进行数据的增删改查，封装对象<br>5。关闭数据库</p>
</blockquote>
<h4 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h4><p>幻读是指一个事务多次执行一条查询语句返回的确是不同的值。假设一个事务正根据某个条件进行数据库查询，然后另一个事务插入了一行满足这个查询条件的数据，之后这个事务再次执行了这条查询，返回的结果集中包含在刚插入的那条数据</p>
<h4 id="谈谈你对struts的理解"><a href="#谈谈你对struts的理解" class="headerlink" title="谈谈你对struts的理解"></a>谈谈你对struts的理解</h4><blockquote>
<p>1.structs本质就是一个servlet，而这个servlet就是ActionServlet或是其子类，即将所有请求都交给servlet去处理，而该servlet参考配置文件将请求分发给不同action处理<br>2.在把请求交给action之前，会将参数封装成一个frombean对象，而该对象只有通过validate方法，才能将对象传递给execute方法，否则将返回一个错误页面，并且这个页面由input属性指定<br>3.action执行完之后要返回显示的结果视图，这个结果一个actionForward来表示，而其是通过在struts配置文件中配置获得返回页面</p>
</blockquote>
<h4 id="谈谈你对hibernate的理解"><a href="#谈谈你对hibernate的理解" class="headerlink" title="谈谈你对hibernate的理解"></a>谈谈你对hibernate的理解</h4><blockquote>
<p>1.使用hibernate的基本流程：配置Configuration对象、产生sessionfactory、创建session对象、启动事务，完成CRUD操作，提交事务，关闭session<br>2.使用hibernate时，先要配置hibernate.cfg.xml文件，其中配置数据库连接信息和方言，还要为每个实体配置相应的hbm.xml文件<br>3.在应用hibernate时，重点要了解session的缓存原理，级联，延迟加载和hql语句</p>
</blockquote>
<h4 id="谈谈你对spring的理解"><a href="#谈谈你对spring的理解" class="headerlink" title="谈谈你对spring的理解"></a>谈谈你对spring的理解</h4><blockquote>
<p>1.spring是实现了工厂模式的工厂类，这个类为beanFactory，通常为其子类applicationContext，spring相当于一个大的工厂类，在其配置文件中通过<bean>元素配置用于创建实例对象名和实例对象的属性<br>2.spring提供了对IOC的良好支持，利用IOC可以很好的实现模块间的解耦<br>3.spring提供了对AOP技术的良好封装，即把系统中很多不相干的类的方法，在这些众多的方法中加入某种系统功能的代码，例如，加入日志，权限判断，异常处理等等，称为AOP<br>4实现AOP采用代理类，在jdk中采用proxy类产生动态代理的方式为某个接口生成实现类，</bean></p>
</blockquote>
<h4 id="谈谈struts的优缺点"><a href="#谈谈struts的优缺点" class="headerlink" title="谈谈struts的优缺点"></a>谈谈struts的优缺点</h4><p>优点：</p>
<blockquote>
<p>1.实现mvc模式，结构清晰，使开发者只关注业务逻辑的实现<br>2有丰富的tag可以使用，大大提高开发效率<br>3.页面导航使系统的脉络更加清晰<br>4.提供Exception处理机制</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>1.structs的action是一种thread-safe方式，它仅仅允许一个实例处理所有的请求。容易引起线程安全问题<br>2 测试不方便。struts的每个action都同web层耦合在一起，这样它的测试依赖于web容器，单元测试很难实现<br>3.对servlet的依赖性过强，struts处理action时必须依赖servletRequest和servletRespouse，所以它摆脱不了servlet容器</p>
</blockquote>
<h4 id="mybatis和hibernate有什么不同"><a href="#mybatis和hibernate有什么不同" class="headerlink" title="mybatis和hibernate有什么不同"></a>mybatis和hibernate有什么不同</h4><p>相同点：</p>
<blockquote>
<p>都屏蔽了jdbc api底层访问细节，编程流程固定，还将sql语句与java代码混杂在一起</p>
</blockquote>
<p>不同点</p>
<blockquote>
<p>半自动，将sql语句与代码进行分离，提供了将结果集自动封装成为实体对象和对象集合的功能<br>全自动，hibernate，提供hql语句</p>
</blockquote>
<h4 id="介绍一下hibernate的二级缓存"><a href="#介绍一下hibernate的二级缓存" class="headerlink" title="介绍一下hibernate的二级缓存"></a>介绍一下hibernate的二级缓存</h4><p>回答思路：1.首先说清楚什么是缓存<br>2.再说有了hibernate的session就是一级缓存，即有了一级缓存，为什么还要有二级缓存<br>3.最后说如何配置hibernate的二级缓存</p>
<blockquote>
<p>1.缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中，这个数据结构通常类似于hashmap，当以后要使用某个对象时，先查询缓存中是否有这个对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在缓存中，以便下次使用<br>2.hibernate的session就是一级缓存，当想要使用session从数据库中查询出的一个对象时，session也是先从自己内部查看是否存在这个对象，存在则直接返回，不存在则查询数据库<br>由于session代表依次会话，一个session与一个数据库连接的相关性，通常仅用一个事务，用完就关闭，由于一级缓存是线程不安全的，要被多个线程共享，而二级缓存是全局缓存，可以被多个线程和事务共享<br>3二级缓存是独立于hibernate的软件部件，如ehcache</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己
    
    </summary>
    
      <category term="面试题" scheme="http://www.myzwl.win/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="学习效果检验" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%95%88%E6%9E%9C%E6%A3%80%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>常见面试题六之java基础</title>
    <link href="http://www.myzwl.win/2017/09/03/face_6/"/>
    <id>http://www.myzwl.win/2017/09/03/face_6/</id>
    <published>2017-09-03T08:48:51.000Z</published>
    <updated>2017-09-07T13:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="说出math的取整函数及其意义"><a href="#说出math的取整函数及其意义" class="headerlink" title="说出math的取整函数及其意义"></a>说出math的取整函数及其意义</h4><p>提供了三种，分别为ceil（向上取整），如math.ceil（11.3）为12；<br>floor（向下取整），如math.floor（11.3），结果为11<br>round（四舍五入），如math.round（11.5）为12</p>
<h4 id="Overload与Override的区别？Overload的方法是否可以改变返回值的类型？"><a href="#Overload与Override的区别？Overload的方法是否可以改变返回值的类型？" class="headerlink" title="Overload与Override的区别？Overload的方法是否可以改变返回值的类型？"></a>Overload与Override的区别？Overload的方法是否可以改变返回值的类型？</h4><p>Overload是重载，Overrride是覆盖，也就是重写</p>
<blockquote>
<p>重载表示方法名相同，但是参数个数或类型不同）<br>重写表示子类中的方法可以与父亲中某个方法的名称和参数完全相同，通过子类创建实例调用父类这个方法，也就是相当于覆盖了父类的这个方法，但是当父类是private时相当于子类增加了一个全新的方法，就不存在覆盖了。并且子类应该比父类抛出更少的异常或者拥有更大的权限<br>如果参数名不同会改变返回类型，但是如果都一样肯定不会改变返回类型</p>
</blockquote>
<h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4><p>接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？抽象类是否可以有静态的main方法？</p>
<blockquote>
<p>接口可以继承接口，抽象类可以实现接口，抽象类可以继承具体类，抽象类可以有静态的main方法<br>抽象类和普通类唯一的区别就是不能创建实例对象和允许有abstract方法</p>
</blockquote>
<h4 id="java中实现多态的机制是什么？"><a href="#java中实现多态的机制是什么？" class="headerlink" title="java中实现多态的机制是什么？"></a>java中实现多态的机制是什么？</h4><p>靠的是父类或接口定义的引用变量可以指向子类或者具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量类型中定义的方法</p>
<h4 id="abstractclass和interface语法上有什么区别"><a href="#abstractclass和interface语法上有什么区别" class="headerlink" title="abstractclass和interface语法上有什么区别"></a>abstractclass和interface语法上有什么区别</h4><blockquote>
<p>1.抽象类可以有构造方法，接口不能有构造方法<br>2.抽象类中可以有普通成员方法，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。<br>4.抽象类中的抽象方法访问类型可以是public、protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型<br>5.抽象类中可以包含静态方法，接口中不能包含静态方法<br>6.抽象类和接口类中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以是任意，但是接口中定义的变量只能是public static final类型<br>7一个类可以实现多个接口，但只能继承一个抽象类</p>
</blockquote>
<h4 id="abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？"><a href="#abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？" class="headerlink" title="abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？"></a>abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？</h4><blockquote>
<p>abstract的method不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系<br>native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在被子类实现的问题，所以，它也不能为抽象的，<br>synchronized应该是作用在一个具体的方法上才有意义，而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法无法确定this是什么</p>
</blockquote>
<h4 id="下面这条语句一共创建了多少个对象？"><a href="#下面这条语句一共创建了多少个对象？" class="headerlink" title="下面这条语句一共创建了多少个对象？"></a>下面这条语句一共创建了多少个对象？</h4><p>String s=”a”+”b”+”c”+”d”;<br>对于如下代码</p>
<blockquote>
<p>String s1=”a”;<br>String s2=s1+”b”;<br>String s3=”a”+”b”;<br>System.out.println(s2=”ab”);<br>System.out.println(s3=”ab”);<br>第一句打印为false，第二句为true，说明编译器对字符串常量直接进行了优化，所以产生了一个对象</p>
</blockquote>
<h4 id="java中堆和栈有什么区别？"><a href="#java中堆和栈有什么区别？" class="headerlink" title="java中堆和栈有什么区别？"></a>java中堆和栈有什么区别？</h4><p>jvm中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个jvm的所有线程共享</p>
<h4 id="什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？"><a href="#什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？" class="headerlink" title="什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？"></a>什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？</h4><p>将一个对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如将一个java对象存储到硬盘或者送给网络上的其他计算机，可以用代码把一个java对象变成某个格式的字节流在传输<br>如果要让java自动帮我们做，就需要实现serializable接口，编译的类才被writeObject方法操作，例如，在web中，如果对象被保存在了session中，tomcat在重启时要把session对象序列化到硬盘</p>
<h4 id="描述一下JVM加载class文件的原理机制？"><a href="#描述一下JVM加载class文件的原理机制？" class="headerlink" title="描述一下JVM加载class文件的原理机制？"></a>描述一下JVM加载class文件的原理机制？</h4><p>JVM中类的装载是由classLoader和它的子类来实现的，java classLoader是一个重要的运行时系统组件。他负责在运行时查找和装入文件的类</p>
<h4 id="heap和stack有什么区别？"><a href="#heap和stack有什么区别？" class="headerlink" title="heap和stack有什么区别？"></a>heap和stack有什么区别？</h4><p>java的内存分为两类，栈内存和堆内存</p>
<blockquote>
<p>栈内存是指程序进入一个方法时，会为这个方法单独分配一块私有存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈的变量也将随之释放<br>堆是用于存放不在当前方法栈中的那些数据，例如使用new创建的对象放在堆里，所以，它不会随方法结束而消失，局部变量使用final修饰后，放在堆中</p>
</blockquote>
<h4 id="GC是是什么？为什么要有GC？"><a href="#GC是是什么？为什么要有GC？" class="headerlink" title="GC是是什么？为什么要有GC？"></a>GC是是什么？为什么要有GC？</h4><p>GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定性甚至崩溃，java提供GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，java语言没有提供释放已分配内存的显示操作方法</p>
<h4 id="垃圾回收的优点和原理，并考虑2种回收机制"><a href="#垃圾回收的优点和原理，并考虑2种回收机制" class="headerlink" title="垃圾回收的优点和原理，并考虑2种回收机制"></a>垃圾回收的优点和原理，并考虑2种回收机制</h4><p>垃圾回收可以有效的防止内存泄漏，有效的使用可以使用的内存。垃圾回收期是作为一个单独低级别的线程运行，不可预知的情况下对内存中已经死亡或者长时间没有使用的对象进行清除和回收，程序员不能实时调用垃圾回收器对某个对象或所有对象进行垃圾回收<br>回收机制有标记垃圾回收和增量垃圾回收</p>
<h4 id="垃圾回收器基本原理，可以马上回收内存及有什么办法主动通知JVM进行垃圾回收"><a href="#垃圾回收器基本原理，可以马上回收内存及有什么办法主动通知JVM进行垃圾回收" class="headerlink" title="垃圾回收器基本原理，可以马上回收内存及有什么办法主动通知JVM进行垃圾回收"></a>垃圾回收器基本原理，可以马上回收内存及有什么办法主动通知JVM进行垃圾回收</h4><blockquote>
<p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小、及使用情况。通常，GC采用有向图的方式记录和管理堆里中的所有对象，通过这种方式确定哪些对象是可达的，哪些对象是不可达的。当GC确定一些对象不可达的，GC有责任回收这些内存空间<br>程序员可以手动执行System.gc（），通知gc运行，但是java语言规范并不保证GC一定会执行</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己
    
    </summary>
    
      <category term="面试题" scheme="http://www.myzwl.win/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="学习效果检验" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%95%88%E6%9E%9C%E6%A3%80%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>常见面试题之五</title>
    <link href="http://www.myzwl.win/2017/09/03/face_5/"/>
    <id>http://www.myzwl.win/2017/09/03/face_5/</id>
    <published>2017-09-03T07:48:51.000Z</published>
    <updated>2017-09-07T02:37:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="http协议的请求包含哪些内容"><a href="#http协议的请求包含哪些内容" class="headerlink" title="http协议的请求包含哪些内容"></a>http协议的请求包含哪些内容</h4><p>HTTP请求是指从客户端到服务器端的请求消息。包括：消息首行中，对资源的请求方法、资源的标识符及使用的协议。从客户端到服务器端的请求消息包括，消息首行中，对资源的请求方法、资源的标识符及使用的协议。<br>HTTP请求信息由3部分组成：<br>请求方法URI协议/版本<br>请求头(Request Header)<br>请求正文<br>如下</p>
<blockquote>
<p>1.GET /index.jsp HTTP/1.1<br> 2.Accept-Language: zh-cn<br>3.Connection: Keep-Alive<br>4.Host: 192.168.0.106<br>5.Content-Length: 37<br>6.userName=new_andy&amp;password=new_andy</p>
</blockquote>
<p>HTTP响应也由3个部分构成，分别是：<br>状态行<br>响应头(Response Header)<br>响应正文<br>如下：</p>
<blockquote>
<p>1.HTTP/1.1 200 OK<br>2.Server: Microsoft-IIS/4.0<br>3.Date: Mon, 3 Jan 2005 13:13:33 GMT<br>4.Content-Type: text/html<br>5.Last-Modified: Mon, 11 Jan 2004 13:23:42 GMT<br>6.Content-Length: 90<br>7.<html><br>8.<head><br>9.<title>解读HTTP包示例</title></head><body><br>10.Hello WORLD!<br>11.</body><br>12.</html></p>
</blockquote>
<h4 id="session和cookie的比较"><a href="#session和cookie的比较" class="headerlink" title="session和cookie的比较"></a>session和cookie的比较</h4><p>区别:</p>
<blockquote>
<p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>   考虑到安全应当使用session。<br>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>   考虑到减轻服务器性能方面，应当使用COOKIE。<br>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
</blockquote>
<p>联系</p>
<blockquote>
<p>session和cookie之间是通过$_COOKIE[‘PHPSESSID’]来联系的，通过$_COOKIE[‘PHPSESSID’]可以知道session的id，从而获取到其他的信息。</p>
</blockquote>
<h4 id="hibernate对象的三种状态"><a href="#hibernate对象的三种状态" class="headerlink" title="hibernate对象的三种状态"></a>hibernate对象的三种状态</h4><p>transient(瞬时状态)，persistent(持久化状态)以及detached(离线状态)</p>
<blockquote>
<p>瞬时状态就是刚new出来一个对象，还没有被保存到数据库中，持久化状态就是已经被保存到数据库中，离线状态就是数据库中有，但是session中不存在该对象<br>①.对于刚创建的一个对象，如果session中和数据库中都不存在该对象，那么该对象就是瞬时对象(Transient)<br>②.瞬时对象调用save方法，或者离线对象调用update方法可以使该对象变成持久化对象，如果对象是持久化对象时，那么对该对象的任何修改，都会在提交事务时才会与之进行比较，如果不同，则发送一条update语句，否则就不会发送语句<br>③.离线对象就是，数据库存在该对象，但是该对象又没有被session所托管</p>
</blockquote>
<h4 id="对restful的了解"><a href="#对restful的了解" class="headerlink" title="对restful的了解"></a>对restful的了解</h4><p>资源与URI:<br>任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值),要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI,URI既可以看成是资源的地址，也可以看成是资源的名称<br>统一资源接口:<br>不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。<br>资源的表述:<br>在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。 资源的表述包括数据和描述数据的元数据，例如，HTTP头“Content-Type” 就是这样一个元数据属性。<br>资源的链接:<br>状态的转移<br>应用状态与资源状态:<br>客户端负责维护应用状态，而服务端维护资源状态,浏览器随各次请求发出去的Cookie是被用于构建会话状态的。 当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。</p>
<h4 id="json是什么"><a href="#json是什么" class="headerlink" title="json是什么?"></a>json是什么?</h4><p>JavaScript对象表示法，它是一种基于文本，独立于语言的轻量级数据交换格式.XML虽然可以作为跨平台的数据交换格式，但是在JS(JavaScript的简写)中处理XML非常不方便，同时XML标记比数据多，增加了交换产生的流量，而JSON没有附加的任何标记，在JS中可作为对象处理<br>JSON的两种结构<br>对象</p>
<blockquote>
<p>{<br>    key1:value1,<br>    key2:value2,<br>    …<br>}</p>
</blockquote>
<p>数组</p>
<blockquote>
<p>[<br>    {<br>        key1:value1,<br>        key2:value2<br>    },<br>    {<br>         key3:value3,<br>         key4:value4<br>    }<br>]</p>
</blockquote>
<p>认识JSON字符串</p>
<blockquote>
<p>字符串：指使用“”双引号或’’单引号包括的字符。例如：var comStr = ‘this is string’;<br>json字符串：指的是符合json格式要求的js字符串。例如：var jsonStr = “{StudentID:’100’,Name:’tmac’,Hometown:’usa’}”;<br>json对象：指符合json格式要求的js对象。例如：var jsonObj = { StudentID: “100”, Name: “tmac”, Hometown: “usa” };</p>
</blockquote>
<p>遍历JSON对象<br>可以使用for…in…循环来遍历JSON对象中的数据，比如我们要遍历输出obj对象的值</p>
<blockquote>
<p>function Traversal() {<br>            for (var c in obj) {<br>                console.log(c + “:”, obj[c]);<br>            }<br>        }</p>
</blockquote>
<p>在客户端，读写json对象可以使用”.”操作符或”[“key”]”，json字符串转换为json对象使用eval()函数</p>
<h4 id="对多线程的认识以及线程池的原理及作用"><a href="#对多线程的认识以及线程池的原理及作用" class="headerlink" title="对多线程的认识以及线程池的原理及作用"></a>对多线程的认识以及线程池的原理及作用</h4><p>回答思路：多线程是什么，它是干什么的&gt;开启线程的方式&gt;线程的生命周期&gt;线程安全问题&gt;实现同步的方式</p>
<blockquote>
<p>多线程就是多个工作让CPU交互处理。java用Runnalbe接口实现或者继承Thread类就可以, 线程的生命周期是 创建》就绪（runnable）==》运行（running）==》死亡（dead） 在运行时也会有堵塞（blocked）的情况<br>线程是交互执行的，所以如果发现了一个线程一直在一个资源里执行，那么其他线程不能使用这个资源，就会一直停在那里，也就是死锁，解决线程安全的办法一般是让同一时刻，只能让一个线程访问该资源。也就是同步。 java实现同步的方法是用synchronized和Lock关键字。<br>线程池就相当于操作系统的缓冲区，把程序启动的若干线程存放在线程池中，等到程序收到请求了就唤醒某一个线程。 作用就是为了性能，让程序更能节省效率。</p>
</blockquote>
<h4 id="选择算法要考虑哪些因素，说说你熟悉的算法思想"><a href="#选择算法要考虑哪些因素，说说你熟悉的算法思想" class="headerlink" title="选择算法要考虑哪些因素，说说你熟悉的算法思想"></a>选择算法要考虑哪些因素，说说你熟悉的算法思想</h4><p>因素：时间、空间复杂度、稳定性、要操作数据的特点······<br>思想：递归、迭代、分治······</p>
<h4 id="一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</h4><p>可以有多个类，但是只能有一个public的类，并且public的类名必须与文件名相一致</p>
<h4 id="说说-amp-与-amp-amp-的区别"><a href="#说说-amp-与-amp-amp-的区别" class="headerlink" title="说说&amp;与&amp;&amp;的区别"></a>说说&amp;与&amp;&amp;的区别</h4><blockquote>
<p>&amp;与&amp;&amp;都可以用作逻辑与（and）的运算符<br>&amp;&amp;具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。而&amp;则会同时计算<br>&amp;可以作为位运算符，当&amp;两边表达式不是boolean时，&amp;表示按位与操作，通常使用Ox0f来与一个整数&amp;运算，来取该整数的最低4个bit位</p>
</blockquote>
<h4 id="switch语句能否作用在byte上，能否作用在long上，能否作用在String上？"><a href="#switch语句能否作用在byte上，能否作用在long上，能否作用在String上？" class="headerlink" title="switch语句能否作用在byte上，能否作用在long上，能否作用在String上？"></a>switch语句能否作用在byte上，能否作用在long上，能否作用在String上？</h4><blockquote>
<p>在switch（e）中，e只能是一个整数表达式或者枚举常量，整数表达式可以是int基本类型或者Integer包装类型，而byte、short、char都可以隐含转换成int，所以可以，但long和String不符合</p>
</blockquote>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>short s=1;s=s+1;有什么错？<br>等号左边s是short类型，而等号右边是int类型，需要强制转换否则报错，<br>而short s=1;s+=1；不会报错<br>因为+=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确处理</p>
<h4 id="用最有效的方法算出2乘以8等于几？"><a href="#用最有效的方法算出2乘以8等于几？" class="headerlink" title="用最有效的方法算出2乘以8等于几？"></a>用最有效的方法算出2乘以8等于几？</h4><blockquote>
<p>2&lt;&lt;3（左移三位），将一个数左移n位相当于乘以2的n次方，而位运算cpu是直接支持的，效率最高</p>
</blockquote>
<h4 id="使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h4><p>当使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的，例如<br>s xx=new s(“yy”),xx=new s(“”)(编译器会报错)，但是xx.add(“zz”)可以通过编译</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己
    
    </summary>
    
      <category term="面试题" scheme="http://www.myzwl.win/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="学习效果检验" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%95%88%E6%9E%9C%E6%A3%80%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>常见面试题之四</title>
    <link href="http://www.myzwl.win/2017/09/02/face_4/"/>
    <id>http://www.myzwl.win/2017/09/02/face_4/</id>
    <published>2017-09-02T07:48:51.000Z</published>
    <updated>2017-09-06T13:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="如何去除多表查询产生重复的数据-连接查询"><a href="#如何去除多表查询产生重复的数据-连接查询" class="headerlink" title="如何去除多表查询产生重复的数据(连接查询)"></a>如何去除多表查询产生重复的数据(连接查询)</h4><p>如果一个查询需要对多个表进行操作就称为连接查询,连接查询的结果集或结果称为表之间的连接.<br>连接查询实际上是通过各个表之间共同列的关联性来查询数据的,它是关系数据库查询最主要的特征.<br>连接查询分类：<br>1.自连接查询，对同一个表进行连接操作<br>2.内连接查询，&lt;又分为：自然连接、等值连接、不等值连接三种&gt;<br>3.外连接查询，&lt;又分为：左外连接、右外连接、全外连接三种&gt;<br>4.交叉连接查询，也作无条件查询。<br>5.联合查询</p>
<h4 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h4><p>一个表自己与自己建立连接称为自连接或自身连接，如：</p>
<blockquote>
<p>select x.* from sclass x,sclass y<br>where x.cno=’’101’’ and x.degree&gt;y.degree and y.sno=’’9505201’’ and y.cno=’’101’’<br>order by x.degree desc</p>
</blockquote>
<h4 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接(INNER JOIN)"></a>内连接(INNER JOIN)</h4><p>它只返回两个数据集合之间匹配关系的那些行.<br>将位于两个互相交叉的数据集合中重叠部分以内的那些数据行连接起来.<br>语法：<br>select 字段名列表 from 表名 [inner] join 表名 on 连接条件 [where 条件表达式]<br>select x.sno,x.sname,y.cno,y.degree from student x<br>INNER join sclass y on x.sno=y.sno where x.sclass=’’xx’’</p>
<blockquote>
<p>等值连接：<br>所谓等值连接，是指表之间通过“等于”关系连接起来，产生一个临时表，<br>然后对该临时表进行处理后生成最终结果。其查询结果中列出被连接表中的所有列，<br>包括其中的重复列。<br>如：SELECT x.sno,y.cname,x.degree<br>FROM score x,course y<br>WHERE x.cno=y.cno<br>不等值连接：<br>是指表之间的连接关系不是“等于”，而是其它关系。<br>这些运算符包括&gt;、&gt;=、&lt;=、&lt;、!&gt;、!&lt;和&lt;&gt;<br>select x.sno,x.sname,y.cno,y.degree<br>from student x,score y<br>where x.sno!=y.sno<br>自然连接：<br>在等值连接中消除重复列就是自然连接。<br>关键词 DISTINCT 用于返回唯一不同的值。<br>SELECT DISTINCT 列名称 FROM 表名称</p>
</blockquote>
<h4 id="jre和jdk的区别"><a href="#jre和jdk的区别" class="headerlink" title="jre和jdk的区别"></a>jre和jdk的区别</h4><blockquote>
<p>JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。<br>JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java</p>
</blockquote>
<h4 id="java基本数据类型"><a href="#java基本数据类型" class="headerlink" title="java基本数据类型"></a>java基本数据类型</h4><blockquote>
<p>byte、short、int、long、float、double、char、boolean</p>
</blockquote>
<h4 id="能否重写构造方法"><a href="#能否重写构造方法" class="headerlink" title="能否重写构造方法"></a>能否重写构造方法</h4><p>重载构造方法是可以的。<br>但是重写则不可以，因为被重写的前提是被继承，而构造方法根本就不能被继承，所以谈不上被重写。只能调用父类的构造方法</p>
<h4 id="依赖注入的底层实现方式"><a href="#依赖注入的底层实现方式" class="headerlink" title="依赖注入的底层实现方式"></a>依赖注入的底层实现方式</h4><p>依赖注入（Dependency Injection）是用于实现控制反转（Inversion of Control）的最常见的方式之一<br>为什么需要依赖注入？<br>比如下面这段模拟代码</p>
<blockquote>
<p>public class MovieLister {<br>    private MovieFinder finder;<br>    public MovieLister() {<br>        finder = new MovieFinderImpl();<br>    }<br>    public Movie[] moviesDirectedBy(String arg) {<br>    }<br>    …<br>}<br>public interface MovieFinder {<br>    List findAll();<br>}</p>
</blockquote>
<p>我们创建了一个名为MovieLister的类来提供需要的电影列表，它moviesDirectedBy方法提供根据导演名来搜索电影的方式。真正负责搜索电影的是实现了MovieFinder接口的MovieFinderImpl，我们的MovieLister类在构造函数中创建了一个MovieFinderImpl的对象<br>当我们希望修改finder，将finder替换为一种新的实现时（比如为MovieFinder增加一个参数表明Movie数据的来源是哪个数据库），我们不仅需要修改MovieFinderImpl类，还需要修改我们MovieLister中创建MovieFinderImpl的代码。<br>这就是依赖注入要处理的耦合。这种在MovieLister中创建MovieFinderImpl的方式，使得MovieLister不仅仅依赖于MovieFinder这个接口，它还依赖于MovieListImpl这个实现<br>依赖注入的实现方式</p>
<blockquote>
<p>构造函数注入<br>setter注入<br>接口注入(接口注入使用接口来提供setter方法)</p>
</blockquote>
<h4 id="父类能否调用子类方法"><a href="#父类能否调用子类方法" class="headerlink" title="父类能否调用子类方法"></a>父类能否调用子类方法</h4><p>能.把子类传递到父类的有参构造中，然后调用。<br>使用反射的方式调用<br>如下模拟</p>
<blockquote>
<p>package com.zwl.test;<br>public class exam {<br>    private examson son;<br>    public exam(examson son){<br>        this.son=son;<br>    }<br>    public exam(){<br>    }<br>    public void Reflaction() throws InstantiationException, IllegalAccessException{<br>        try {<br>            Class ref=Class.forName(“com.zwl.test.examson”);<br>            examson s=(examson) ref.newInstance();<br>            s.method();<br>            s.staMethod();<br>        } catch (ClassNotFoundException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>    public void showByDI(){<br>        son.staMethod();<br>        son.method();<br>    }<br>    public static void main(String[] args)  {<br>         try {<br>             exam e=new exam(new examson());<br>              e.showByDI();<br>              e.Reflaction();<br>        } catch (InstantiationException e1) {<br>            e1.printStackTrace();<br>        } catch (IllegalAccessException e1) {<br>            e1.printStackTrace();<br>        }<br>    }<br>}<br>class examson extends exam{<br>        public static void staMethod(){<br>        System.out.println(“it is a static method”);<br>    }</p>
</blockquote>
<pre><code>public void method(){
    System.out.println(&quot;ok&quot;);
}
</code></pre><p>}</p>
<h4 id="构造代码块和构造方法的执行顺序"><a href="#构造代码块和构造方法的执行顺序" class="headerlink" title="构造代码块和构造方法的执行顺序"></a>构造代码块和构造方法的执行顺序</h4><p>父类静态块-自身静态块-父类块-父类构造器-自身块-自身构造器</p>
<h4 id="接口属性为什么定义为final"><a href="#接口属性为什么定义为final" class="headerlink" title="接口属性为什么定义为final"></a>接口属性为什么定义为final</h4><p>interface中的变量是当作常量来设计的，它不但是final，而且还是public static的，也即interface中的变量一定是public static final的</p>
<ol>
<li>接口中的数据对所有实现类只有一份,所以是static<br>2.要使实现类为了向上转型成功,所以必须是final的，这样不用关心你到底是通过社么方式实现实现类的，进而统一了</li>
</ol>
<h4 id="类变量有没有默认值，局部变量呢？"><a href="#类变量有没有默认值，局部变量呢？" class="headerlink" title="类变量有没有默认值，局部变量呢？"></a>类变量有没有默认值，局部变量呢？</h4><p>静态成员变量和非静态成员变量jvm都会赋初值，而局部变量不会，如果局部变量没有被初始化，并且在方法中一直没有被使用，则编译和运行都会通过，但是用了，会在编译器报错</p>
<h4 id="内部类能否调用外部类方法"><a href="#内部类能否调用外部类方法" class="headerlink" title="内部类能否调用外部类方法"></a>内部类能否调用外部类方法</h4><p>内部类可以看成一个外部类的方法或成员属性，直接 方法();<br>或者 外部类名称.this.方法()</p>
<h4 id="静态方法能否调用非静态方法"><a href="#静态方法能否调用非静态方法" class="headerlink" title="静态方法能否调用非静态方法"></a>静态方法能否调用非静态方法</h4><p>不能直接调用，但可以通过将一个对象的引用传入static方法中，再去调用该对象的non-static方法<br>类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。</p>
<h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><blockquote>
<p>这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。<br>sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。<br>锁: 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。<br>sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。<br>使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。<br>synchronized(x){<br>      x.notify()<br>     //或者wait()<br>   }</p>
</blockquote>
<h4 id="内存溢出和内存泄露的区别"><a href="#内存溢出和内存泄露的区别" class="headerlink" title="内存溢出和内存泄露的区别"></a>内存溢出和内存泄露的区别</h4><p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。<br>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>memory leak会最终会导致out of memory！<br>内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己
    
    </summary>
    
      <category term="面试题" scheme="http://www.myzwl.win/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="学习效果检验" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%95%88%E6%9E%9C%E6%A3%80%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>常见面试题之三</title>
    <link href="http://www.myzwl.win/2017/09/02/face_3/"/>
    <id>http://www.myzwl.win/2017/09/02/face_3/</id>
    <published>2017-09-02T05:48:51.000Z</published>
    <updated>2017-09-05T14:36:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="题型一"><a href="#题型一" class="headerlink" title="题型一"></a>题型一</h4><p>说说String s1 = “123”；<br>String s2 = new String（“123”）；第二句产生了几个对象，为什么？</p>
<blockquote>
<p>一个，此处有一个陷阱，如果单独来看第二句，首先堆里有一个引用对象，然后指向数据域中常量池中的值123，但是第一句已经产生了此常量值，所以只有一个。此外s2是放在堆里的，而s1是放在常量池中的</p>
</blockquote>
<h4 id="SpringMVC的工作流程"><a href="#SpringMVC的工作流程" class="headerlink" title="SpringMVC的工作流程"></a>SpringMVC的工作流程</h4><p>答题思路：url&gt;DispatcherServlet&gt;HandlerMapping映射器&gt;Controller&gt;ModelAndView&gt;DispatcherServlet&gt;viewResoler</p>
<blockquote>
<p>spring mvc和大部分mvc框架一样，底层也是依赖servlet api的，所以spring mvc的请求处理也是从一个servlet开始，这个servlet就是DispatcherServlet<br>然后就是DispatcherServlet.对一个请求的处理过程<br>1.Handle Mapping映射控制器，负责将url映射成对应的controller<br>2.controller  spring的控制器，相当于servlet或者structs的action，负责主要的业务处理，并返回一个modelandview给DispatcherServlet.<br>3:ModelAndView 包含着一个页面文件(jsp和html等)的逻辑视图名,<br>4:ViewResoler 视图解析器,根据ModelAndView提供的视图对象,查找对应的视图文件,并把他响应给客户.<br>在获得请求以后,DispatcherServlet首先会查询Handler Mapping对象(一个或多个)<br>Handler Mapping的主要工作是将请求的url映射成对应的Controller对象.<br>接着,DispatcherServlet根据Handler Mapping对象找到的结果,把请求分发给对应的Controller对象来处理,Controller负责处理具体的业务逻辑,并返回一个带有下一个页面信息的ModelView对象,最后ViewResoler 对象根据ModelAndView的信息查找对应的视图页面,并响应给用户</p>
</blockquote>
<h4 id="myBatis中-和-的区别"><a href="#myBatis中-和-的区别" class="headerlink" title="myBatis中$和#的区别"></a>myBatis中$和#的区别</h4><blockquote>
<ol>
<li>#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by “111”, 如果传入的值是id，则解析成的sql为order by “id”.</li>
<li>$将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id,  如果传入的值是id，则解析成的sql为order by id.</li>
<li>#方式能够很大程度防止sql注入<br>4.$方式无法防止Sql注入<br>5.$方式一般用于传入数据库对象，例如传入表名.<br>6.一般能用#的就别用$.<br>默认情况下，使用#{}格式的语法会导致MyBatis创建预处理语句属性并以它为背景设置安全的值（比如?）。这样做很安全,接受从用户输出的内容并提供给语句中不变的字符串，这样做是不安全的。这会导致潜在的SQL注入攻击，因此你不应该允许用户输入这些字段，或者通常自行转义并检查。</li>
</ol>
</blockquote>
<h4 id="悲观锁和乐观锁的比较"><a href="#悲观锁和乐观锁的比较" class="headerlink" title="悲观锁和乐观锁的比较"></a>悲观锁和乐观锁的比较</h4><p> 面试思路：什么是锁，用来干什么&gt;悲观锁乐观锁各自特点&gt;优缺点比较和各自应用场景</p>
<blockquote>
<p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。<br>悲观锁:<br>简单来说悲观锁认什么操作都可以改变数据，所以在改数据就锁住（在sql语句中加上for update就可以了）<br>MySQL InnoDB中使用悲观锁<br>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。 set autocommit=0;<br>//0.开始事务<br>begin;/begin work;/start transaction; (三者选一就可以)<br>//1.查询出商品信息<br>select status from t_goods where id=1 for update;<br>//2.根据商品信息生成订单<br>insert into t_orders (id,goods_id) values (null,1);<br>//3.修改商品status为2<br>update t_goods set status=2;<br>//4.提交事务<br>commit;/commit work;<br>上面的查询语句中，我们使用了 select…for update 的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。<br>优点与不足：<br>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数<br>乐观锁：<br>简单来说乐观锁很乐观 所以修改数据库后锁住 （一般在数据库中加上一个字段区别历史版本和当前版本）<br>1.查询出商品信息<br>select (status,status,version) from t_goods where id=#{id}<br>2.根据商品信息生成订单<br>3.修改商品status为2<br>update t_goods<br>set status=2,version=version+1<br>where id=#{id} and version=#{version};<br>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。<br>优点与不足<br>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
</blockquote>
<h4 id="mysql实现分页的sql语句"><a href="#mysql实现分页的sql语句" class="headerlink" title="mysql实现分页的sql语句"></a>mysql实现分页的sql语句</h4><p>面试思路：数据库分页的简单实现&gt;数据量变大时的优化方案</p>
<blockquote>
<p>sql语句是LIMIT m,n其中m是当前页，n是从当前页数n个记录，如果参数为一个就是数n个记录<br>一般我们都会这样写:当数据达到百万级的时候会慢死<br>SELECT <em> FROM table ORDER BY id LIMIT 1000000, 10;<br>优化一：<br>SELECT </em> FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10;<br>速度可以提升到0.x秒了<br>优化二：<br>SELECT <em> FROM table WHERE id BETWEEN 1000000 AND 1000010;<br>比上面提升5到10倍<br>另外，如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询<br>SELECT </em> FROM table WHERE id IN(10000, 100000, 1000000…); </p>
</blockquote>
<h4 id="内部类的种类，接口中可否有内部类"><a href="#内部类的种类，接口中可否有内部类" class="headerlink" title="内部类的种类，接口中可否有内部类"></a>内部类的种类，接口中可否有内部类</h4><p>四种内部类,接口中可以定义内部类</p>
<blockquote>
<p>静态内部类：<br>必须以static关键字标注<br>只能访问外部类中的静态的成员变量或者是静态的方法<br>访问一个内部类使应该这样outerClass.innerClass inter = new outerClass.innerClass();不能直接实例化内部类<br>成员内部类：<br>定义在一个类的内部，但是没有static关键字修饰<br>生成示例的方法outerClass.innerClass inter = (new outerClass()).new innerClass()<br>对外部类变量的引用outClass.this.variale<br>可以访问外部类的静态与非静态方法<br>局部内部类<br>匿名内部类</p>
</blockquote>
<h4 id="谈谈对gc的认识"><a href="#谈谈对gc的认识" class="headerlink" title="谈谈对gc的认识"></a>谈谈对gc的认识</h4><blockquote>
<p>gc是jvm的垃圾回收机制 程序里有一个System.gc(); 但这个不能说是调用jvm的回收系统，而是请求jvm回收。 jvm的回收机制不受代码控制，只能设置jvm的堆的常量 Xmx3550m Xms3550m Xmn2g Xss128k</p>
</blockquote>
<h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>回答思路：事务是干什么的&gt;事务的ACID特性&gt;事务的隔离级别</p>
<blockquote>
<p>事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取。事务的正确执行使得数据库从一种状态转换成另一种状态<br>原子性。即不可分割性，事务要么全部被执行，要么就全部不被执行。如果事务的所有子事务全部提交成功，则所有的数据库操作被提交，数据库状态发生转换；如果有子事务失败，则其他子事务的数据库操作被回滚，即数据库回到事务执行前的状态，不会发生状态转换<br>一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态<br>隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，即在事务正确提交之前，它可能的结果不应显示给任何其他事务<br>持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存<br>对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题，这些并发问题可归纳为以下几类<br>第一类丢失更新：撤销一个事务时，把其他事务已提交的更新数据覆盖。　<br>脏读：一个事务读到另一个事务为提交的更新数据。<br>虚读：一个事务读到另一个事务已提交的新插入的数据。<br>不可重复读：一个事务读到另一个事务已提交的更新数据。<br>第二类丢失更新：这是不可重复读中的特例，一个事务覆盖另一个事务已提交的更新数据。</p>
</blockquote>
<p>隔离级别</p>
<blockquote>
<p>Serializable(串行化)：一个事务在执行过程中完全看不到其他事务对数据库所做的更新。<br>    Repeatable Read(可重复读)：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务对已有记录的更新。<br>    Read Commited（读已提交数据）：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的对已有记录的更新<br>    Read Uncomitted（读未提交数据）：一个事务在执行过程中可以拷打其他事务没有提交的新插入的记录，而且能看到其他事务没有提交的对已有记录的更新。<br>    悲观锁<br>    .乐观锁</p>
</blockquote>
<h4 id="数据库设计三范式是什么"><a href="#数据库设计三范式是什么" class="headerlink" title="数据库设计三范式是什么"></a>数据库设计三范式是什么</h4><p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<blockquote>
<p>第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；<br>通俗的理解是，字段还可以再分吗？如过不能，则是符合1NF的设计。<br>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>也就是说主键列与非主键列遵循完全函数依赖关系<br>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。<br>也就是说非主键列之间没有传递函数依赖关系<br>打个比方，比如评论表，如果你将用户ID，用户头像都放在这留言表中，就是不合适的了。用户头像是依赖于用户ID，而不依赖该评论。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己
    
    </summary>
    
      <category term="面试题" scheme="http://www.myzwl.win/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="学习效果检验" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%95%88%E6%9E%9C%E6%A3%80%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>常见面试题之java集合二</title>
    <link href="http://www.myzwl.win/2017/09/01/face_2/"/>
    <id>http://www.myzwl.win/2017/09/01/face_2/</id>
    <published>2017-09-01T11:48:51.000Z</published>
    <updated>2017-09-04T15:30:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="说说java集合框架"><a href="#说说java集合框架" class="headerlink" title="说说java集合框架"></a>说说java集合框架</h4><p>ArrayList和Vector有何异同点？</p>
<blockquote>
<p>ArrayList和Vector在很多时候都很类似。<br>（1）两者都是基于索引的，内部由一个数组支持。<br>（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。<br>（3）ArrayList和Vector的迭代器实现都是fail-fast的。<br>（4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。<br>ArrayList和Vector的不同点。<br>（1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。<br>（2）ArrayList比Vector快，它因为有同步，不会过载。<br>（3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表</p>
</blockquote>
<p>Array和ArrayList有何区别？什么时候更适合用Array？</p>
<blockquote>
<p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。<br>Array是指定大小的，而ArrayList大小是固定的。<br>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。<br>（1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。<br>（2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。<br>（3）如果你要使用多维数组，使用[][]比List<list<>&gt;更容易。</list<></p>
</blockquote>
<p>ArrayList和LinkedList有何区别？</p>
<blockquote>
<p>(1）ArrayList是由Array所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，复杂度为O(1)，但LinkedList存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为O(n)，比ArrayList要慢。<br>（2）与ArrayList相比，在LinkedList中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。<br>（3）LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。</p>
</blockquote>
<p>哪些集合类提供对元素的随机访问？</p>
<blockquote>
<p>ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问</p>
</blockquote>
<p>哪些集合类是线程安全的？</p>
<blockquote>
<p>Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。</p>
</blockquote>
<p>并发集合类是什么？</p>
<blockquote>
<p>Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。</p>
</blockquote>
<p>BlockingQueue是什么？</p>
<blockquote>
<p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>
</blockquote>
<p>队列和栈是什么，列出它们的区别？</p>
<blockquote>
<p>栈和队列两者都被用来预存储数据。java.util.Queue是一个接口，它的实现类在Java并发包中。队列允许先进先出（FIFO）检索元素，但并非总是这样。Deque接口允许从两端检索元素。<br>栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。<br>Stack是一个扩展自Vector的类，而Queue是一个接口。</p>
</blockquote>
<p>Collections类是什么？</p>
<blockquote>
<p>Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。这个类包含集合框架算法的方法，比如折半搜索、排序、混编和逆序等。</p>
</blockquote>
<p>Comparable和Comparator接口是什么？</p>
<blockquote>
<p>如果我们想使用Array或Collection的排序方法时，需要在自定义类里实现Java提供Comparable接口。Comparable接口有compareTo(T OBJ)方法，它被排序方法所使用。我们应该重写这个方法，如果“this”对象比传递的对象参数更小、相等或更大时，它返回一个负整数、0或正整数。但是，在大多数实际情况下，我们想根据不同参数进行排序。比如，作为一个CEO，我想对雇员基于薪资进行排序，一个HR想基于年龄对他们进行排序。这就是我们需要使用Comparator接口的情景，因为Comparable.compareTo(Object o)方法实现只能基于一个字段进行排序，我们不能根据对象排序的需要选择字段。Comparator接口的compare(Object o1, Object o2)方法的实现需要传递两个对象参数，若第一个参数比第二个小，返回负整数；若第一个等于第二个，返回0；若第一个比第二个大，返回正整数。</p>
</blockquote>
<p>Comparable和Comparator接口有何区别？</p>
<blockquote>
<p>Comparable和Comparator接口被用来对对象集合或者数组进行排序。Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。<br>Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。</p>
</blockquote>
<p>我们如何对一组对象进行排序？</p>
<blockquote>
<p>如果我们需要对一个对象数组进行排序，我们可以使用Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用Collection.sort()方法。两个类都有用于自然排序（使用Comparable）或基于标准的排序（使用Comparator）的重载方法sort()。Collections内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections需要花时间将列表转换为数组。</p>
</blockquote>
<p>当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？</p>
<blockquote>
<p>在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。</p>
</blockquote>
<p>我们如何从给定集合那里创建一个synchronized的集合？</p>
<blockquote>
<p>我们可以使用Collections.synchronizedCollection(Collection c)根据指定集合来获取一个synchronized（线程安全的）集合。</p>
</blockquote>
<p>大写的O是什么？举几个例子？</p>
<blockquote>
<p>大写的O描述的是，就数据结构中的一系列元素而言，一个算法的性能。Collection类就是实际的数据结构，我们通常基于时间、内存和性能，使用大写的O来选择集合实现。比如：例子1：ArrayList的get(index i)是一个常量时间操作，它不依赖list中元素的数量。所以它的性能是O(1)。例子2：一个对于数组或列表的线性搜索的性能是O(n)，因为我们需要遍历所有的元素来查找需要的元素。</p>
</blockquote>
<p>与Java集合框架相关的有哪些最好的实践？</p>
<blockquote>
<p>（1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。<br>（2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。<br>（3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。<br>（4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。<br>（5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。<br>（6）尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己
    
    </summary>
    
      <category term="面试题" scheme="http://www.myzwl.win/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="学习效果检验" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%95%88%E6%9E%9C%E6%A3%80%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>常见面试题之java集合一</title>
    <link href="http://www.myzwl.win/2017/09/01/face_1/"/>
    <id>http://www.myzwl.win/2017/09/01/face_1/</id>
    <published>2017-09-01T06:48:51.000Z</published>
    <updated>2017-09-04T15:29:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己总结，有的已给出答案。下面是我整理搜集的面试题（虽然，很不甘心以这种方式来获取面试资格，但是没办法，毕竟机会都没，何来发展），有些经过自己的语言转换，有些是参考原文给出，有些自己做实验进行验证，总之通过学习记录。来给自己一个动力</p>
<h4 id="说说java集合框架"><a href="#说说java集合框架" class="headerlink" title="说说java集合框架"></a>说说java集合框架</h4><p>回答思路：集合是什么，作用&gt;分类&gt;各自底层实现原理&gt;各自应用场景</p>
<p>集合框架的部分优点如下：</p>
<blockquote>
<p>一 使用核心集合类降低开发成本，而非实现我们自己的集合类<br>二：随着使用经过严格测试的集合框架类，代码质量会得到提高。<br>三：通过使用JDK附带的集合类，可以降低代码维护成本<br>四：复用性和可操作性。</p>
</blockquote>
<p>集合框架中的泛型有什么优点？</p>
<blockquote>
<p>Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息</p>
</blockquote>
<p>Java集合框架的基础接口有哪些？</p>
<blockquote>
<p>Collection为集合层级的根接口<br>Set是一个不能包含重复元素的集合<br>List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。<br>Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。<br>一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator</p>
</blockquote>
<p>为何Collection不从Cloneable和Serializable接口继承？</p>
<blockquote>
<p>Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。</p>
</blockquote>
<p>为何Map接口不继承Collection接口？<br>尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然<br>如果Map继承Collection接口，Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。</p>
<p>Iterator是什么？</p>
<blockquote>
<p>Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例、迭代器允许调用者在迭代过程中移除元素。</p>
</blockquote>
<p>为何迭代器没有一个方法可以直接获取下一个元素，而不需要移动游标？</p>
<blockquote>
<p>它可以在当前Iterator的顶层实现，但是它用得很少，如果将它加到接口中，每个继承都要去实现它，这没有意义。</p>
</blockquote>
<p>Iterater和ListIterator之间有什么区别？</p>
<blockquote>
<p>一:我们可以使用Iterator来遍历Set和List集合，而ListIterator只能遍历List。<br>二:Iterator只可以向前遍历，而LIstIterator可以双向遍历。<br>三:ListIterator从Iterator接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p>
</blockquote>
<p>通过迭代器fail-fast属性，你明白了什么？</p>
<blockquote>
<p>每次我们尝试获取下一个元素的时候，Iterator fail-fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计的（ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外）。</p>
</blockquote>
<p>fail-fast与fail-safe有什么区别？</p>
<blockquote>
<p>Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-fast的，而java.util.concurrent中的集合类都为fail-safe的。Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。</p>
</blockquote>
<p>在迭代一个集合的时候，如何避免ConcurrentModificationException？</p>
<blockquote>
<p>在遍历一个集合的时候，我们可以使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnWriteArrayList，而不是ArrayList。</p>
</blockquote>
<p>为何Iterator接口没有具体的实现？</p>
<blockquote>
<p>Iterator接口定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的Iterator的集合类都有它自己的Iterator实现内部类。<br>这就允许集合类去选择迭代器是fail-fast还是fail-safe的。比如，ArrayList迭代器是fail-fast的，而CopyOnWriteArrayList迭代器是fail-safe的。</p>
</blockquote>
<p>UnsupportedOperationException是什么？<br>UnsupportedOperationException是用于表明操作不支持的异常。在JDK类中已被大量运用，在集合框架java.util.Collections.UnmodifiableCollection将会在所有add和remove操作中抛出这个异常。</p>
<p>在Java中，HashMap是如何工作的？(重点)</p>
<blockquote>
<p>HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值<br>其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。HashMap默认的初始容量是32，负荷系数是0.75。阀值是为负荷系数乘以容量，无论何时我们尝试添加一个entry，如果map的大小比阀值大的时候，HashMap会对map的内容进行重新哈希，且使用更大的容量。容量总是2的幂，所以如果你知道你需要存储大量的key-value对，比如缓存从数据库里面拉取的数据，使用正确的容量和负荷系数对HashMap进行初始化是个不错的做法。</p>
</blockquote>
<p>hashCode()和equals()方法有何重要性？</p>
<blockquote>
<p>HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：<br>（1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。<br>（2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。</p>
</blockquote>
<p>我们能否使用任何类作为Map的key？</p>
<blockquote>
<p>我们可以使用任何类作为Map的key，然而在使用它们之前，需要考虑以下几点：<br>（1）如果类重写了equals()方法，它也应该重写hashCode()方法。<br>(2）类的所有实例需要遵循与equals()和hashCode()相关的规则。请参考之前提到的这些规则。<br>（3）如果一个类没有使用equals()，你不应该在hashCode()中使用它。<br>（4）用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。<br>比如，我有一个类MyKey，在HashMap中使用它<br>//传递给MyKey的name参数被用于equals()和hashCode()中<br>MyKey key = new MyKey(‘Pankaj’); //assume hashCode=1234<br>myHashMap.put(key, ‘Value’);<br>// 以下的代码会改变key的hashCode()和equals()值<br>key.setName(‘Amit’); //assume new hashCode=7890<br>//下面会返回null，因为HashMap会尝试查找存储同样索引的key，而key已被改变了，匹配失败，返回null<br>myHashMap.get(new MyKey(‘Pankaj’));<br>那就是为何String和Integer被作为HashMap的key大量使用。</p>
</blockquote>
<p>Map接口提供了哪些不同的集合视图？</p>
<blockquote>
<p>Map接口提供三个集合视图：<br>Set keyset()、Collection values()、Set<map.entry<k,v>&gt; entrySet()</map.entry<k,v></p>
</blockquote>
<p>HashMap和HashTable有何不同？</p>
<blockquote>
<p>（1）HashMap允许key和value为null，而HashTable不允许。<br>（2）HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。<br>（3）在Java1.4中引入了LinkedHashMap，HashMap的一个子类，假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。<br>（4）HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。</p>
</blockquote>
<p>如何决定选用HashMap还是TreeMap？</p>
<blockquote>
<p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;出于时间紧张和需要找实习的压力，所以这段时间开始疯狂通过面试题来检验自己的大学的学习效果。以下面试题主要来自贴吧、论坛，有的没有答案需要自己
    
    </summary>
    
      <category term="面试题" scheme="http://www.myzwl.win/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="学习效果检验" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%95%88%E6%9E%9C%E6%A3%80%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>图的深度和广度遍历</title>
    <link href="http://www.myzwl.win/2017/08/01/graph_2/"/>
    <id>http://www.myzwl.win/2017/08/01/graph_2/</id>
    <published>2017-08-01T06:48:51.000Z</published>
    <updated>2017-08-14T12:19:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图是数据结构中最复杂的，正是因为它的复杂，它也是最优魅力的。当然图的存储结构有多种方式，最常用的就是邻接矩阵和邻接表。为了方便，这里图的遍历使用邻接矩阵表示</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><img src="/images/imgs4/35.gif" alt="Alt text"><br>如图，这里只画了无向图，其中顶点由一个一维数组表示，一个二维数组存储图中的边或弧的信息，可以发现无向图是一个对称矩阵，并且约定二维数组arc[i][j]=w，若边（vi，vj）属于该图，arc[i][j]=0，若i=j，否则arc[i][j]=一个无强大值，图中是用1代替了，实际中按上述规则<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">typedef char VertexType; /* 顶点类型应由用户定义 */</div><div class="line">typedef int EdgeType; /* 边上的权值类型应由用户定义 */</div><div class="line"></div><div class="line">#define MAXSIZE 9 /* 存储空间初始分配量 */</div><div class="line">#define MAXEDGE 15</div><div class="line">#define MAXVEX 9</div><div class="line">#define INFINITY 65535</div><div class="line"></div><div class="line">typedef struct&#123;</div><div class="line">	VertexType vexs[MAXVEX];          /* 顶点表 */</div><div class="line">	EdgeType arc[MAXVEX][MAXVEX];     /* 邻接矩阵，可看作边表 */</div><div class="line">	int numVertexes,numEdges;         /* 图中当前的顶点数和边数 */ </div><div class="line">&#125;MGraph;</div><div class="line"></div><div class="line">void CreateMGraph(MGraph *G)</div><div class="line">&#123;</div><div class="line">	int i,j,k,w;</div><div class="line">	printf("输入顶点数和边数:\n");</div><div class="line">	scanf("%d,%d",&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);</div><div class="line">	for(i=0;i&lt;G-&gt;numVertexes;i++)</div><div class="line">		scanf(&amp;G-&gt;vexs[i]);</div><div class="line">	for(i=0;i&lt;G-&gt;numVertexes;i++)</div><div class="line">		for(j=0;j&lt;G-&gt;numVertexes;j++)</div><div class="line">			G-&gt;arc[i][j]=INFINITY;</div><div class="line">		for(k=0;k&lt;G-&gt;numEdges;k++)</div><div class="line">		&#123;</div><div class="line">			printf("输入边（vi，vj）上的下标i，下标j和权值w：\n");</div><div class="line">		     scanf("%d,%d,%d",&amp;i,&amp;j,&amp;w);</div><div class="line">		     G-&gt;arc[i][j]=w;</div><div class="line">		     G-&gt;arc[j][i]=G-&gt;arc[i][j];</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p><img src="/images/imgs4/18.jpg" alt="Alt text"><br>图的遍历就是指从图中某一顶点出发遍历图中其余顶点且使每一个顶点仅被访问一次，然而由于同一个图可能在空间形式上有不同画法，所以造成不能采用之前使用的双亲等方法，所以可以把访问过的顶点打上标记，即设置一个访问数组visited[n]，n是图中原点个数，初值为0，访问过后设置为1，这样就可以避免访问重复的了<br>而深度优先遍历，也叫深度优先搜索，简称DFS，就像在一个房子中搜索一样，从每一个房间开始，而是不留死角的搜索，也就是说该房间内所有地方搜索完，在去搜索其他房间，以此类推<br>从图中可以发现它是一个递归过程，也就是像二叉树的先序遍历，只不过，已经遍历的结点可以跳过</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">void CreateMGraph(MGraph *G)</div><div class="line">&#123;</div><div class="line">	int i, j;</div><div class="line"></div><div class="line">	G-&gt;numEdges=15;</div><div class="line">	G-&gt;numVertexes=9;</div><div class="line"></div><div class="line">	/* 读入顶点信息，建立顶点表 */</div><div class="line">	G-&gt;vexs[0]='A';</div><div class="line">	G-&gt;vexs[1]='B';</div><div class="line">	G-&gt;vexs[2]='C';</div><div class="line">	G-&gt;vexs[3]='D';</div><div class="line">	G-&gt;vexs[4]='E';</div><div class="line">	G-&gt;vexs[5]='F';</div><div class="line">	G-&gt;vexs[6]='G';</div><div class="line">	G-&gt;vexs[7]='H';</div><div class="line">	G-&gt;vexs[8]='I';</div><div class="line"></div><div class="line"></div><div class="line">	for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */</div><div class="line">	&#123;</div><div class="line">		for ( j = 0; j &lt; G-&gt;numVertexes; j++)</div><div class="line">		&#123;</div><div class="line">			G-&gt;arc[i][j]=0;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	G-&gt;arc[0][1]=1;</div><div class="line">	G-&gt;arc[0][5]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[1][2]=1; </div><div class="line">	G-&gt;arc[1][8]=1; </div><div class="line">	G-&gt;arc[1][6]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[2][3]=1; </div><div class="line">	G-&gt;arc[2][8]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[3][4]=1;</div><div class="line">	G-&gt;arc[3][7]=1;</div><div class="line">	G-&gt;arc[3][6]=1;</div><div class="line">	G-&gt;arc[3][8]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[4][5]=1;</div><div class="line">	G-&gt;arc[4][7]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[5][6]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[6][7]=1; </div><div class="line"></div><div class="line">	</div><div class="line">	for(i = 0; i &lt; G-&gt;numVertexes; i++)</div><div class="line">	&#123;</div><div class="line">		for(j = i; j &lt; G-&gt;numVertexes; j++)</div><div class="line">		&#123;</div><div class="line">			G-&gt;arc[j][i] =G-&gt;arc[i][j];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Boolean visited[MAXSIZE];//访问标志的数组</div><div class="line"></div><div class="line">//深度优先递归算法</div><div class="line">void DFS(MGraph G,int i)&#123;</div><div class="line">	int j;</div><div class="line">	visited[i]=TRUE;</div><div class="line">	printf("%c",G.vexs[i]);</div><div class="line">	for(j=0;j&lt;G.numVertexes;j++)</div><div class="line">		if(G.arc[i][j]==1&amp;&amp;!visited[j]) //对未访问的顶点递归调用</div><div class="line">			DFS(G,j);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//深度遍历</div><div class="line">void DFSTraverse(MGraph G)&#123;</div><div class="line">	int i;</div><div class="line">	for(i=0;i&lt;G.numVertexes;i++) //初始化</div><div class="line">		visited[i]=FALSE;</div><div class="line">	for(i=0;i&lt;G.numVertexes;i++)</div><div class="line">		if(!visited[i])</div><div class="line">			DFS(G,i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	MGraph G;</div><div class="line">	CreateMGraph(&amp;G);</div><div class="line">	printf("\n深度遍历：");</div><div class="line">	DFSTraverse(G);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了方便，就创建图的过程写死，最终深度遍历的结果为ABCDEFGHI</p>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>又称为广度优先搜索，简称BFS，它像二叉树遍历中的层序遍历，也就是一层一层的遍历，如上图，与A相连的有B、F，先遍历，又与B相连的有C,I,G，F相连的有G,E，所以下一层为C,I,G,F，依次类推一层一层遍历<br><img src="/images/imgs4/19.jpg" alt="Alt text"><br>如图它的核心思想就是构造一个队列，每一层的结点，如A出队后，与它相连的下一层结点B、F就要入队开始遍历，然后B遍历完出队，与B相连的下一层结点C、I、J入队，依次类推<br><strong>队列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/* 循环队列的顺序存储结构 */</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	int data[MAXSIZE];</div><div class="line">	int front;    	/* 头指针 */</div><div class="line">	int rear;		/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</div><div class="line">&#125;Queue;</div><div class="line"></div><div class="line">/* 初始化一个空队列Q */</div><div class="line">Status InitQueue(Queue *Q)</div><div class="line">&#123;</div><div class="line">	Q-&gt;front=0;</div><div class="line">	Q-&gt;rear=0;</div><div class="line">	return  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */</div><div class="line">Status QueueEmpty(Queue Q)</div><div class="line">&#123; </div><div class="line">	if(Q.front==Q.rear) /* 队列空的标志 */</div><div class="line">		return TRUE;</div><div class="line">	else</div><div class="line">		return FALSE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列未满，则插入元素e为Q新的队尾元素 */</div><div class="line">Status EnQueue(Queue *Q,int e)</div><div class="line">&#123;</div><div class="line">	if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)	/* 队列满的判断 */</div><div class="line">		return ERROR;</div><div class="line">	Q-&gt;data[Q-&gt;rear]=e;			/* 将元素e赋值给队尾 */</div><div class="line">	Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;/* rear指针向后移一位置， */</div><div class="line">								/* 若到最后则转到数组头部 */</div><div class="line">	return  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</div><div class="line">Status DeQueue(Queue *Q,int *e)</div><div class="line">&#123;</div><div class="line">	if (Q-&gt;front == Q-&gt;rear)			/* 队列空的判断 */</div><div class="line">		return ERROR;</div><div class="line">	*e=Q-&gt;data[Q-&gt;front];				/* 将队头元素赋值给e */</div><div class="line">	Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;	/* front指针向后移一位置， */</div><div class="line">									/* 若到最后则转到数组头部 */</div><div class="line">	return  OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>广度遍历</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/* 邻接矩阵的广度遍历算法 */</div><div class="line">void BFSTraverse(MGraph G)</div><div class="line">&#123;</div><div class="line">	int i, j;</div><div class="line">	Queue Q;</div><div class="line">	for(i = 0; i &lt; G.numVertexes; i++)</div><div class="line">       	visited[i] = FALSE;</div><div class="line">    InitQueue(&amp;Q);		/* 初始化一辅助用的队列 */</div><div class="line">    for(i = 0; i &lt; G.numVertexes; i++)  /* 对每一个顶点做循环 */</div><div class="line">    &#123;</div><div class="line">		if (!visited[i])	/* 若是未访问过就处理 */</div><div class="line">		&#123;</div><div class="line">			visited[i]=TRUE;		/* 设置当前顶点访问过 */</div><div class="line">			printf("%c ", G.vexs[i]);/* 打印顶点，也可以其它操作 */</div><div class="line">			EnQueue(&amp;Q,i);		/* 将此顶点入队列 */</div><div class="line">			while(!QueueEmpty(Q))	/* 若当前队列不为空 */</div><div class="line">			&#123;</div><div class="line">				DeQueue(&amp;Q,&amp;i);	/* 将队对元素出队列，赋值给i */</div><div class="line">				for(j=0;j&lt;G.numVertexes;j++) </div><div class="line">				&#123; </div><div class="line">					/* 判断其它顶点若与当前顶点存在边且未访问过  */</div><div class="line">					if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) </div><div class="line">					&#123; </div><div class="line"> 						visited[j]=TRUE;			/* 将找到的此顶点标记为已访问 */</div><div class="line">						printf("%c ", G.vexs[j]);	/* 打印顶点 */</div><div class="line">						EnQueue(&amp;Q,j);				/* 将找到的此顶点入队列  */</div><div class="line">					&#125; </div><div class="line">				&#125; </div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	MGraph G;</div><div class="line">	CreateMGraph(&amp;G);</div><div class="line">	printf("\n深度遍历：");</div><div class="line">	DFSTraverse(G);</div><div class="line">	printf("\n广度遍历：");</div><div class="line">	BFSTraverse(G);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终的结果是</p>
<blockquote>
<p>A B F C I G E D H</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后发现深度优先和广度优先遍历的时间复杂度是一样的，他们的适用场景不一样，深度优先更适合目标比较明确，已找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;图是数据结构中最复杂的，正是因为它的复杂，它也是最优魅力的。当然图的存储结构有多种方式，最常用的就是邻接矩阵和邻接表。为了方便，这里图的遍历
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>反射机制简单总结</title>
    <link href="http://www.myzwl.win/2017/07/31/reflaction_1/"/>
    <id>http://www.myzwl.win/2017/07/31/reflaction_1/</id>
    <published>2017-07-31T06:48:51.000Z</published>
    <updated>2017-08-13T14:55:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>反射机制是java中非常非常重要的东西，比如以前模拟jdk的代理实现和spring的aop实现都用到了反射（见以前设计模式总结），同时，正是由于反射机制，才让我们能更动态的去写程序，比如说在配置文件中配置配置，就能调用某些方法，是在太方便了，下面就开始探索反射机制，下图是类的加载模型<br><img src="/images/imgs4/33.gif" alt="Alt text"></p>
<h4 id="ClassLoad类加载过程"><a href="#ClassLoad类加载过程" class="headerlink" title="ClassLoad类加载过程"></a>ClassLoad类加载过程</h4><p>它的特点是1.并非一次性加载<br>2.需要的时候加载（运行期动态加载）<br>3.static语句块在加载后执行一次<br>4.dynamic语句块每次new新的对象都会执行（等同于构造方法中语句）<br><strong>程序验证</strong><br>在eclipse中有-verbose:class运行命令可详细的打印出jvm虚拟机第一次在内存中加载类的详细信息，如下：<br>先看模拟的程序<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		new A();		</div><div class="line">		System.out.println("**------------------------**");</div><div class="line">		new B();</div><div class="line">        new C();</div><div class="line">        new C();</div><div class="line">        new D();</div><div class="line">        new D();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class A&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C&#123;</div><div class="line">	static&#123;</div><div class="line">		System.out.println("CCCCCCCCCCCCCCCCCCCCCCCCCCC");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class D&#123;</div><div class="line">	&#123;</div><div class="line">		System.out.println("DDDDDDDDDDDDDDDDDDDDDDDDDDDD");</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中d就是动态方法<br>以下是输出结果</p>
<blockquote>
<p>[Opened E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.lang.Object from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.io.Serializable from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>。。。。。。<br>[Loaded com.zwl.tree.A from file:/E:/ecli/shiro/target/classes/]</p>
<hr>
<p>[Loaded com.zwl.tree.B from file:/E:/ecli/shiro/target/classes/]<br>[Loaded com.zwl.tree.C from file:/E:/ecli/shiro/target/classes/]<br>CCCCCCCCCCCCCCCCCCCCCCCCCCC<br>[Loaded com.zwl.tree.D from file:/E:/ecli/shiro/target/classes/]<br>DDDDDDDDDDDDDDDDDDDDDDDDDDDD<br>DDDDDDDDDDDDDDDDDDDDDDDDDDDD<br>[Loaded java.lang.Shutdown from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.lang.Shutdown$Lock from E:\myeclipse\jdk1.8\jre\lib\rt.jar]</p>
</blockquote>
<p>可以发现，jvm在初始化执行程序时需要加载很多类到内存中，并且是动态加载的，就像A和B中间输出语句打印出来，说明不是一次性加载的，这里静态函数只加载了一次，动态方法每次都会加载，其实还有一点，就是jvm会在类加载时，找到jdk中已有的类加载，加载过了一次，就不加载了如D</p>
<h4 id="classLoad类"><a href="#classLoad类" class="headerlink" title="classLoad类"></a>classLoad类</h4><p>事实上，jdk中有各种各样的ClassLoad将类加载进内存，大致分为以下几种</p>
<blockquote>
<p>一：bootstrap class loader<br>implemented by native language and load ths core classes of jdk<br>也就是说，它不是用java写的，而是用操作系统语言，如c、c++写的加载类，它是最核心的类用于加载java中核心的类，当然他没有具体名字<br>二:extesion class loader<br>loader the class from jre/lib/ext<br>三:application class loader<br>load user-define classes and ClassLoader.getSystemClassLoader()<br>也就是说它是java的核心类用于加载用户自定义的类和其他类<br>四:other class loaders<br>SecureClassLoader、URLClassLoader等等，该类是其他加载类加载其它类</p>
</blockquote>
<p><strong>程序验证</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(String.class.getClassLoader());</div><div class="line">	System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());</div><div class="line">	System.out.println(Test.class.getClassLoader().getClass().getName());</div><div class="line">	System.out.println(ClassLoader.getSystemClassLoader().getClass().getName());</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>null<br>sun.misc.Launcher$ExtClassLoader<br>sun.misc.Launcher$AppClassLoader<br>sun.misc.Launcher$AppClassLoader</p>
</blockquote>
<p>分析一下：String类bootstrap类加载的类，但是它的加载类是空，而DESKeyFactory的的加载类是扩展类，而第三和第四都是java核心类加载，总之，我们知道classload是有多种并且有顺序和层次的<br><img src="/images/imgs4/34.gif" alt="Alt text"></p>
<p>如</p>
<blockquote>
<p>ClassLoader c=Test.class.getClassLoader();<br>        while(c!=null){<br>            System.out.println(c.getClass().getName());<br>            c=c.getParent();<br>        }</p>
</blockquote>
<p>结果：</p>
<blockquote>
<p>sun.misc.Launcher$AppClassLoader<br>sun.misc.Launcher$ExtClassLoader</p>
</blockquote>
<p>注意这里的getparent（）是得到引用，不是继承。也就是说jdk底层深层次加载是，问上一层有没有加载我这个类，如果加载了就不加载了</p>
<h4 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h4><p>从classload的角度来看，内存中的一切包括方法等都是对象，也就是说我们可以动态的调用，jdk中为我们提供了类methods类如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;</div><div class="line">		</div><div class="line">		String str="com.zwl.tree.T";</div><div class="line">		Class c=Class.forName(str);</div><div class="line">		Object o=c.newInstance();</div><div class="line">		Method[] methods=c.getMethods();</div><div class="line">		for(Method m:methods)&#123;</div><div class="line">			if(m.getName().equals("mm"))&#123;</div><div class="line">			m.invoke(o);</div><div class="line">			&#125;</div><div class="line">			if(m.getName().equals("m1"))&#123;</div><div class="line">				m.invoke(o, 1,2);</div><div class="line">				System.out.println(m.getReturnType().getName());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	class T&#123;</div><div class="line">	</div><div class="line">	static&#123;</div><div class="line">		System.out.println("T loader!");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public T()&#123;</div><div class="line">		System.out.println("T constructed!");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	int i;</div><div class="line">	String s;</div><div class="line">	public void m1(int i,int j)&#123;</div><div class="line">		this.i=i+j;	</div><div class="line">		System.out.println(this.i);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void mm()&#123;</div><div class="line">		System.out.println("mm");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String getS()&#123;</div><div class="line">		return s;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<blockquote>
<p>T loader!<br>T constructed!<br>mm<br>3<br>void</p>
</blockquote>
<p>上面的程序通过class提供的forname（）方法将相应的类加载至内存，然后通过newInstance()方法取得实例，methods方法能够得到一个类的所有方法，最后通过public Object invoke(Object obj,Object… args)第二个参数是可变参数，也就是可以有多个参数来调用相应对象的相应方法，而getReturnType()是拿到方法的返回类型，也就是说我们通过class和methods可以动态的调用方法，就好比我们只要在配置文件中配置一下类或方法名，就可以动态的调用类或方法，是在是太方便了</p>
<h4 id="反射一些类常用方法"><a href="#反射一些类常用方法" class="headerlink" title="反射一些类常用方法"></a>反射一些类常用方法</h4><p><strong>ClassLoader常用方法</strong></p>
<blockquote>
<p>public abstract class ClassLoaderextends Object<br>构造方法：<br>protected ClassLoader()：使用方法 getSystemClassLoader() 返回的 ClassLoader 创建一个新的类加载器，将该加载器作为父类加载器<br>protected ClassLoader(ClassLoader parent)：使用指定的、用于委托操作的父类加载器创建新的类加载器<br>public final ClassLoader getParent()：返回委托的父类加载器<br>public URL getResource(String name)：查找具有给定名称的资源。</p>
</blockquote>
<p><strong>Class常用方法</strong></p>
<blockquote>
<p>public final class Class<t>extends Objectimplements Serializable, GenericDeclaration, Type, AnnotatedElement<br>Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的<br>public static Class&lt;?&gt; forName(String className)throws ClassNotFoundException：返回与带有给定字符串名的类或接口相关联的 Class 对象<br>public ClassLoader getClassLoader()：返回该类的类加载器<br>public Method[] getMethods()throws SecurityException：返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。<br>public String getName()：以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称<br>public String getName()：查找带有给定名称的资源。<br>public T newInstance()throws InstantiationException,IllegalAccessException： 创建此 Class 对象所表示的类的一个新实例。</t></p>
</blockquote>
<p><strong>Methods类常用方法</strong></p>
<blockquote>
<p>public final class Methodextends AccessibleObjectimplements GenericDeclaration, Member<br>public String getName():以 String 形式返回此 Method 对象表示的方法名称。<br>public Class&lt;?&gt; getReturnType():返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型。<br>public Object invoke(Object obj,<br>                     Object… args)<br>              throws IllegalAccessException,<br>                     IllegalArgumentException,<br>                     InvocationTargetException<br> 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法,此方法为可变参数   </p>
</blockquote>
<p> 反射的知识其实是很复杂的，这里只做了一次简单的总结，反射的应用也是在太广了，像strcts、spring、hibernate、mybatis、spring mvc包括shiro等等框架，你会发现他们的很多底层实现都基于反射机制。。             </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;反射机制是java中非常非常重要的东西，比如以前模拟jdk的代理实现和spring的aop实现都用到了反射（见以前设计模式总结），同时，正是
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树之压缩与解压</title>
    <link href="http://www.myzwl.win/2017/07/30/huffman_2/"/>
    <id>http://www.myzwl.win/2017/07/30/huffman_2/</id>
    <published>2017-07-30T06:48:51.000Z</published>
    <updated>2017-08-13T12:14:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>压缩与解压的另一种说法就是，压缩相当于对文件的加密过程，解压相当于对文件的解密过程，比如说，盲-z，僧-w，那么盲僧-zw，当然加密与解密各种各样，不一定非是字符型的</p>
<h4 id="压缩对比"><a href="#压缩对比" class="headerlink" title="压缩对比"></a>压缩对比</h4><p><img src="/images/imgs4/29.gif" alt="Alt text"><br>如图，最左边是未压缩的原始txt文本文件，里面有38个字节，所以占38字节，中间是利用哈夫曼编码压缩的，居然只占15个字节，最右边是好压自带的压缩，占185个字节，通过对比，发现哈夫曼压缩居然节约这么多空间！</p>
<h4 id="压缩原理"><a href="#压缩原理" class="headerlink" title="压缩原理"></a>压缩原理</h4><p>计算机只能存储二进制数，即非0即1，比如刚学c语言那会接触到的ASCII码，它是专门处理英文的，比如一个字节占8位（由8个01串组成）来表示各种英文字母以及符号，比如0在ASCII编码的十进制表示是48（00110000），a是97，所以英文共有2的8次方个，但是汉字远远不止256个，所以一个汉字用两个字节表示，所以共有2的16次方汉字，而汉字编码一般用UTF-8和GBK等<br><strong>存储过程</strong><br>比如在文件中存储aaabbc，理论上占6个字节，并且存储的二进制为01100001（a）01100001（a）01100001（a）01100010 （b）01100010 （b）01100011 （c）那么哈夫曼是怎么存储该数据的了<br>它是根据某个字出现的次数，比如a出现3次，b出现2次，c出现1次，将次数作为相应字的权值来构造哈夫曼树的<br><img src="/images/imgs4/30.gif" alt="Alt text"><br>所以得到：哈夫曼编码为a（1），b（01），c（00），所以的到压缩后的编码为aaabbc（111010100），注意这里变成2个字节了，然后将该二进制转换成10进制就行了</p>
<h4 id="压缩实现"><a href="#压缩实现" class="headerlink" title="压缩实现"></a>压缩实现</h4><p>一般有以下步骤<br>1.读取文件，统计文件中每个字节出现的次数，将该次数作为权值<br>2.根据权值构建哈夫曼树<br>3，根据哈夫曼树构建码表<br>4在读取文件，通过码表对文件中读取的字节进行加密处理<br><img src="/images/imgs4/31.gif" alt="Alt text"><br>在这里定义了一个256的整型数组（存取次数作为权值）和一个256的字符串数组（存取哈夫曼编码值）</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p><strong>哈夫曼结点</strong><br>与之前不同的是增加了索引，便于搜索<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class HuffmNode &#123;</div><div class="line">	//数据域  </div><div class="line">    private int data;  </div><div class="line">    //索引  </div><div class="line">    private int index;  </div><div class="line">    //左子节点  </div><div class="line">    private HuffmNode left;  </div><div class="line">    //右子节点  </div><div class="line">    private HuffmNode right;  </div><div class="line">      </div><div class="line">    //哈夫曼节点的构造函数  </div><div class="line">    public HuffmNode(int data,int index)&#123;  </div><div class="line">        this.data=data;  </div><div class="line">        this.index=index;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //私有属性的封装  </div><div class="line">    public int getData() &#123;  </div><div class="line">        return data;  </div><div class="line">    &#125;  </div><div class="line">    public void setData(int data) &#123;  </div><div class="line">        this.data = data;  </div><div class="line">    &#125;  </div><div class="line">    public int getIndex() &#123;  </div><div class="line">        return index;  </div><div class="line">    &#125;  </div><div class="line">    public void setIndex(int index) &#123;  </div><div class="line">        this.index = index;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getLeft() &#123;  </div><div class="line">        return left;  </div><div class="line">    &#125;  </div><div class="line">    public void setLeft(HuffmNode left) &#123;  </div><div class="line">        this.left = left;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getRight() &#123;  </div><div class="line">        return right;  </div><div class="line">    &#125;  </div><div class="line">    public void setRight(HuffmNode right) &#123;  </div><div class="line">        this.right = right;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>压缩实现类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">public class Compress &#123;</div><div class="line"></div><div class="line">	 public int[] times=new int[256];</div><div class="line">	 public String[] HuffmCodes=new String[256];</div><div class="line">	 public LinkedList&lt;HuffmNode&gt; list = new LinkedList&lt;HuffmNode&gt;();  </div><div class="line"></div><div class="line">	//初始化 </div><div class="line">     public Compress()&#123;</div><div class="line">    	 for(int i=0;i&lt;HuffmCodes.length;i++)</div><div class="line">    	 &#123;</div><div class="line">    		 HuffmCodes[i]="";</div><div class="line">    	 &#125;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     public void countTimes(String path)throws Exception&#123;</div><div class="line">    	//构造文件输入流</div><div class="line">    	 FileInputStream fis=new FileInputStream(path);</div><div class="line">    	//读取文件  </div><div class="line">    	 int value=fis.read();</div><div class="line">    	 while(value!=-1)&#123;</div><div class="line">    		 times[value]++;</div><div class="line">    		 value=fis.read();</div><div class="line">    	 &#125;</div><div class="line">    	 fis.close(); </div><div class="line">     &#125;</div><div class="line">     </div><div class="line">   //构造哈夫曼树 </div><div class="line">     public HuffmNode createTree()&#123;  </div><div class="line">         //将次数作为权值构造森林  </div><div class="line">         for (int i = 0; i &lt; times.length; i++) &#123;  </div><div class="line">             if(times[i]!=0)&#123;  </div><div class="line">                 HuffmNode node = new HuffmNode(times[i],i);  </div><div class="line">                 //将构造好的节点加入到容器中的正确位置  </div><div class="line">                 list.add(getIndex(node), node);  </div><div class="line">             &#125;  </div><div class="line">         &#125;  </div><div class="line">           </div><div class="line">         //将森林（容器中的各个节点）构造成哈夫曼树  </div><div class="line">         while(list.size()&gt;1) &#123;  </div><div class="line">             //获取容器中第一个元素（权值最小的节点）  </div><div class="line">             HuffmNode firstNode =list.removeFirst();  </div><div class="line">             //获取中新的第一个元素，原来的第一个元素已经被移除了（权值次小的节点）  </div><div class="line">             HuffmNode secondNode =list.removeFirst();  </div><div class="line">             //将权值最小的两个节点构造成父节点  </div><div class="line">             HuffmNode fatherNode =  </div><div class="line">                     new HuffmNode(firstNode.getData()+secondNode.getData(),-1);  </div><div class="line">             fatherNode.setLeft(firstNode);  </div><div class="line">             fatherNode.setRight(secondNode);  </div><div class="line">             //父节点加入到容器中的正确位置  </div><div class="line">             list.add(getIndex(fatherNode),fatherNode);  </div><div class="line">         &#125;  </div><div class="line">         //返回整颗树的根节点  </div><div class="line">         return list.getFirst();  </div><div class="line">     &#125;  </div><div class="line">     </div><div class="line">   //利用前序遍历获取编码表  </div><div class="line">     public void getHuffmCode(HuffmNode root,String code)&#123;  </div><div class="line">         //往左走，哈夫曼编码加0  </div><div class="line">         if(root.getLeft()!=null)&#123;  </div><div class="line">             getHuffmCode(root.getLeft(),code+"0");  </div><div class="line">         &#125;  </div><div class="line">         //往右走，哈夫曼编码加1  </div><div class="line">         if(root.getRight()!=null)&#123;  </div><div class="line">             getHuffmCode(root.getRight(),code+"1");  </div><div class="line">         &#125;  </div><div class="line">         //如果是叶子节点，返回该叶子节点的哈夫曼编码  </div><div class="line">         if(root.getLeft()==null &amp;&amp; root.getRight()==null)&#123;  </div><div class="line">//           System.out.println(root.getIndex()+"的编码为："+code);  </div><div class="line">             HuffmCodes[root.getIndex()]=code;  </div><div class="line">         &#125;  </div><div class="line">     &#125;  </div><div class="line">     </div><div class="line">   //压缩文件 </div><div class="line">     public void compress(String path,String destpath)throws Exception&#123;</div><div class="line">    	//构建文件输出流  </div><div class="line">    	 FileOutputStream fos=new FileOutputStream(destpath);</div><div class="line">    	 FileInputStream fis=new FileInputStream(path);</div><div class="line">    	        </div><div class="line">         //读文件，并将对应的哈夫曼编码串接成字符串  </div><div class="line">    	 int value=fis.read();</div><div class="line">    	 String str="";</div><div class="line">    	 while(value!=-1)&#123;</div><div class="line">    		 str+=HuffmCodes[value];</div><div class="line">    		 value=fis.read();</div><div class="line">    	 &#125;</div><div class="line">    	 System.out.println(str);</div><div class="line">    	 fis.close();</div><div class="line">    	 </div><div class="line">    	 String s="";</div><div class="line">    	 while(str.length()&gt;=8)&#123;</div><div class="line">    		 s=str.substring(0, 8);</div><div class="line">    		 int b=changeStringToInt(s);</div><div class="line">    		 fos.write(b);</div><div class="line">    		 fos.flush();</div><div class="line">    		 str=str.substring(8);</div><div class="line">    	 &#125;</div><div class="line">    	 </div><div class="line">    	 int last1=8-str.length();</div><div class="line">    	 for(int i=0;i&lt;last1;i++)&#123;</div><div class="line">    		 str+="0";</div><div class="line">    	 &#125;</div><div class="line">    	 s=str.substring(0, 8);  </div><div class="line">         int d=changeStringToInt(s);  </div><div class="line">         fos.write(d);</div><div class="line">         fos.close();</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">   //插入元素位置的索引  </div><div class="line">     public int getIndex(HuffmNode node) &#123;  </div><div class="line">         for (int i = 0; i &lt; list.size(); i++) &#123;  </div><div class="line">             if(node.getData()&lt;=list.get(i).getData())&#123;  </div><div class="line">                 return i;  </div><div class="line">             &#125;  </div><div class="line">         &#125;  </div><div class="line">        return list.size();  </div><div class="line">     &#125;  </div><div class="line">	 </div><div class="line">   //将字符串转换成整数  </div><div class="line">     public int changeStringToInt(String s)&#123; </div><div class="line">    	 int v1=(s.charAt(0)-48)*128;  </div><div class="line">         int v2=(s.charAt(1)-48)*64;  </div><div class="line">         int v3=(s.charAt(2)-48)*32;  </div><div class="line">         int v4=(s.charAt(3)-48)*16;  </div><div class="line">         int v5=(s.charAt(4)-48)*8;  </div><div class="line">         int v6=(s.charAt(5)-48)*4;  </div><div class="line">         int v7=(s.charAt(6)-48)*2;  </div><div class="line">         int v8=(s.charAt(7)-48)*1;  </div><div class="line">         return v1+v2+v3+v4+v5+v6+v7+v8;</div><div class="line">     &#125; </div><div class="line">	 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有几处需要注意下，首先changeStringToInt(String s）方法是根据二进制的定义做转换的，void countTimes(String path)throws Exception中那个value是根据其相应的字节的ASCII码值得，比如a是97，就是times[97]++，初始值都是0；<br>然后void compress(String path,String destpath)throws Exception中读文件刚开始是取8位然后转成int在写进文件，然后取第8未到末尾，在循环直至最后不足8位，在后面补0，在写进去。</p>
<p><strong>测试类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//创建压缩对象  </div><div class="line">      Compress compress = new Compress();  </div><div class="line">      //统计文件中0-255出现的次数  </div><div class="line">      compress.countTimes("C:\\Users\\Administrator\\Desktop\\test.txt");  </div><div class="line">      //构造哈夫曼树，并得到根节点  </div><div class="line">      HuffmNode root=compress.createTree();  </div><div class="line">      //得到哈夫曼编码  </div><div class="line">      compress.getHuffmCode(root, "");  </div><div class="line">      //压缩文件  </div><div class="line">      compress.compress("C:\\Users\\Administrator\\Desktop\\test.txt",  </div><div class="line">              "C:\\Users\\Administrator\\Desktop\\tes.zip");</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>1011010101110010110101011011011011100111011110011000010000100111010100010000010011111101101111110111111011000010000100</p>
</blockquote>
<p>同时会生成一个压缩文件，如前面的图所示</p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p><strong>解压原理</strong><br>之前说过哈夫曼编码不会出现像0和01这样前者是后者子串的情况，所以解压采取的办法就是在压缩时写进去每个编码的长度和对应的编码，就像密码本一样，记录着每个密码的详细信息（这里理解每个密码长度和密码数据域唯一确定一个解码）<br>打个比方，假设ab压缩后为0和10，当然压缩后是变成010，那怎么解码了？，首先在压缩时，在之前压缩代码上加上一个记录编码长度和对应的编码，像a不是97吗，那在写入时记录code[97]=1，对应的编码str[97]=0，code[98]=1；str[98]=0，一次类推，写入时是先写入编码长度的，不过要将字符串转换成十进制，然后通过字符串分割成不同编码，这样每个字节也就拿到手了<br>模拟一下，不妨把abbcc先压缩，然后读出它的二进制如下</p>
<blockquote>
<p>000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015214308</p>
</blockquote>
<p>再来分析分析：<br>前面在152之前都是存取密码长度的信息，212是对应ASSII码的相应字节的编码长度，如a（10）、b（0），c（11）所以长度分别对应212，接下来就是152也就是abc的二进制值了，10011，不足8位后面补0，即10011000，对应十进制就是152，后面143就是文本的需要解密的编码，后面08没有弄懂，在压缩文件中并没有输入这个东西，也做了大量实验发现都有后面这些数字，暂且认为就是压缩文件自带的标识吧（逻辑上还没有证明，所以勉强这么认为）<br>所以，解码思路就是先根据长度读取相应位置，然后分割每个位置得到相应二进制编码，最后再转回来，看看编码的打印结果</p>
<blockquote>
<p>0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000212000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000codeLength:1<br>int152<br>哈夫曼编码：10011000<br>huff10<br>huff0<br>huff11<br>需要解密的字符串：10001111<br>截取的字符串：10<br>截取后剩余编码长度：6<br>截取的字符串：0<br>截取后剩余编码长度：5<br>截取的字符串：0<br>截取后剩余编码长度：4<br>截取的字符串：11<br>截取后剩余编码长度：2<br>截取的字符串：11<br>截取后剩余编码长度：0</p>
</blockquote>
<p>不是很规范，但是大概跟踪了过程，长度为5（10011），不足8位不以为，所以codeLength为1,152就是哈夫曼密码手册值了，变成二进制为10011000，然后分割成10,0,11分别对应ASSII码为a、b、c三个字符，需要解密的是10001111，也就是143，解密分别对应abbcc，所以至此完成解密了<br>说了这么多，再来看看代码吧</p>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><p><strong>压缩编码</strong><br>由于解压需要的压缩编码在之前主要修改一点，所以这里就把增加的代码贴出来，分析分析<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//将整个哈夫曼编码以及每个编码的长度写入文件  </div><div class="line">     String code ="";  </div><div class="line">     for (int i = 0; i &lt; 256; i++) &#123;  </div><div class="line">         fos.write(HuffmCodes[i].length());  </div><div class="line">         code+=HuffmCodes[i];  </div><div class="line">         fos.flush();  </div><div class="line">     &#125;  </div><div class="line">     //把哈夫曼编码写入文件  </div><div class="line">       </div><div class="line">  System.out.println("code="+code);  </div><div class="line">     String str1="";  </div><div class="line">     while(code.length()&gt;=8)&#123;  </div><div class="line">         str1=code.substring(0, 8);  </div><div class="line">         int c=changeStringToInt(str1);  </div><div class="line">      System.out.println(c);  </div><div class="line">         fos.write(c);  </div><div class="line">         fos.flush();  </div><div class="line">         code=code.substring(8);  </div><div class="line">     &#125;  </div><div class="line">     //处理最后一个不为8的数  </div><div class="line">     int last=8-code.length();  </div><div class="line">     for (int i = 0; i &lt;last; i++) &#123;  </div><div class="line">         code+="0";  </div><div class="line">     &#125;  </div><div class="line">     str1=code.substring(0, 8);  </div><div class="line">     int c=changeStringToInt(str1); </div><div class="line">     System.out.println("c:"+c);</div><div class="line">     fos.write(c);  </div><div class="line">     fos.flush();</div></pre></td></tr></table></figure></p>
<p>上面代码是说首先我们已经统计了文本中字符出现的次数，压缩那里已经写过了，然后将长度表写入进压缩文件，也就是那一大串000中间含有长度的字符串，存在code里，注意长度为空就是空字符，所以code就是那5位的二进制，然后不足8位的补成8位，再变成十进制也就是152了，这是这段代码与之前增加的部分，我们也称为码表构造</p>
<p><strong>解压实现类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line">//每个编码的长度  </div><div class="line">    public int [] codelengths = new int [256];  </div><div class="line">    //对应的哈夫曼编码值  </div><div class="line">    public String [] codeMap=new String[256];  </div><div class="line">    </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		 Decompress d = new Decompress();  </div><div class="line">	        d.decompress("C:\\Users\\Administrator\\Desktop\\tes.zip",  </div><div class="line">	                "C:\\Users\\Administrator\\Desktop\\mytes.txt"); </div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/* </div><div class="line">     * 解压思路： </div><div class="line">     * 1、读取文件里面的码表 </div><div class="line">     * 2、得到码表 </div><div class="line">     * 3、读取数据 </div><div class="line">     * 4、还原数据 </div><div class="line">     */  </div><div class="line">      </div><div class="line">    public void decompress(String srcpath,String destpath) &#123;  </div><div class="line">    	   </div><div class="line">        try &#123;  </div><div class="line">            FileInputStream fis = new FileInputStream(srcpath);  </div><div class="line">            FileOutputStream fos = new FileOutputStream(destpath);  </div><div class="line">            int zwl;</div><div class="line">            int value;  </div><div class="line">            int codeLength=0;  </div><div class="line">            String code="";  </div><div class="line">            //还原码表  </div><div class="line">            for (int i = 0; i &lt; codelengths.length; i++) &#123;  </div><div class="line">                value=fis.read();  </div><div class="line">                codelengths[i]=value;  </div><div class="line">             System.out.print(codelengths[i]);  </div><div class="line">                codeLength+=codelengths[i];  </div><div class="line">            &#125;  </div><div class="line">           // System.out.println("总长度:"+codeLength);</div><div class="line">            //得到总长度  </div><div class="line">            //将总长度除以8的到字节个数  </div><div class="line">            int len=codeLength/8;  </div><div class="line">            //如果不是8的倍数，则字节个数加1（对应压缩补0的情况）  </div><div class="line">            if((codeLength)%8!=0)&#123;  </div><div class="line">                len++;  </div><div class="line">            &#125;  </div><div class="line">            //读取哈夫曼编码  </div><div class="line">          System.out.println("codeLength:"+len);  </div><div class="line">            for (int i = 0; i &lt; len; i++) &#123;  </div><div class="line">                //把读到的整数转换成二进制  </div><div class="line">            	int s=fis.read();</div><div class="line">            	System.out.println("int"+s);</div><div class="line">                code+=changeIntToString(s);  </div><div class="line">                  </div><div class="line">            &#125;  </div><div class="line">          System.out.println("哈夫曼编码："+code);  </div><div class="line">              </div><div class="line">            for (int i = 0; i &lt; codeMap.length; i++) &#123;  </div><div class="line">                //如果第i个位置不为0 ，则说明第i个位置存储有哈夫曼编码  </div><div class="line">                if(codelengths[i]!=0)&#123;  </div><div class="line">                    //将得到的一串哈夫曼编码按照长度分割分割  </div><div class="line">                    String ss=code.substring(0, codelengths[i]);  </div><div class="line">                    codeMap[i]=ss;  </div><div class="line">                    System.out.println("huff"+codeMap[i]);</div><div class="line">                    code=code.substring(codelengths[i]);  </div><div class="line">                &#125;else&#123;  </div><div class="line">                    //为0则没有对应的哈夫曼编码  </div><div class="line">                    codeMap[i]="";  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">              </div><div class="line">            //读取压缩的文件内容  </div><div class="line">            String codeContent="";  </div><div class="line">            while(fis.available()&gt;1)&#123;  </div><div class="line">                codeContent+=changeIntToString(fis.read());  </div><div class="line">            &#125;  </div><div class="line">            //读取最后一个  </div><div class="line">            value=fis.read();  </div><div class="line">            //把最后补的0给去掉  </div><div class="line">            codeContent=codeContent.substring(0, codeContent.length()-value);  </div><div class="line">                  </div><div class="line">            for (int i = 0; i &lt; codeContent.length(); i++) &#123;  </div><div class="line">                  </div><div class="line">                String codecontent=codeContent.substring(0, i+1);  </div><div class="line">                  </div><div class="line">                for (int j = 0; j &lt; codeMap.length; j++) &#123;  </div><div class="line">                    if(codeMap[j].equals(codecontent))&#123;  </div><div class="line">                     System.out.println("截取的字符串："+codecontent);  </div><div class="line">                        fos.write(j);  </div><div class="line">                        fos.flush();   </div><div class="line">                        codeContent=codeContent.substring(i+1);  </div><div class="line">                    System.out.println("截取后剩余编码长度："+codeContent.length());  </div><div class="line"> </div><div class="line">                        i=-1;  </div><div class="line">                        break;  </div><div class="line">                    &#125;  </div><div class="line">            &#125;  </div><div class="line">            &#125;  </div><div class="line"></div><div class="line">              </div><div class="line">            fos.close();  </div><div class="line">            fis.close();  </div><div class="line">              </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //十进制转二进制字符串  </div><div class="line">    public String changeIntToString(int value) &#123;  </div><div class="line">        String s="";  </div><div class="line">        for (int i = 0; i &lt; 8; i++) &#123;  </div><div class="line">            s=value%2+s;  </div><div class="line">            value=value/2;  </div><div class="line">        &#125;  </div><div class="line">        return s;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的codelengths[]和codeMap[]就是分别存放码表和码表值的数组，流程就是先读取文本内容，拿到长度表中有长度的编码，如212，然后判断其是多少个字节，然后读哈夫曼编码，根据字节数，转成二进制后，找到对应的码表，然后就是分割编码了，最后就得到我们想要的解码了。最后<br><img src="/images/imgs4/32.gif" alt="Alt text"><br>分别为压缩前，压缩后的，会发现压缩居然比压缩前占得空间还大，那是因为我们压缩的文件太小了，而之前也比较过了，压缩一般都是针对大文件的</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后不得不说哈夫曼树的精妙让人惊叹和着迷，同时也认识到了计算机底层知识的重要性，当你回过头来再去看以前的知识，会有另一种不同的感受，当然当再去看压缩与解压，原来是这么回事。当然探索的过程是很累的，会遇到各种难题和挫折，而在当下这个追求功利主义，很多时候都是表象的去用一些东西，当然有时候你把时间花在一些与收益不是很正相关的上面，可能会让你的性价比不是很高，但是正是由于这种自娱自乐的快乐，才更让人充实，而不是每天都去追求“外功”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;压缩与解压的另一种说法就是，压缩相当于对文件的加密过程，解压相当于对文件的解密过程，比如说，盲-z，僧-w，那么盲僧-zw，当然加密与解密各
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树之构建</title>
    <link href="http://www.myzwl.win/2017/07/30/huffman_1/"/>
    <id>http://www.myzwl.win/2017/07/30/huffman_1/</id>
    <published>2017-07-30T05:48:51.000Z</published>
    <updated>2017-08-13T12:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到哈夫曼树，就不得不说它在压缩与解压方面的应用太完美了，就是把一个大的文件，通过算法压缩成一个较小的文件，从而大大节约了空间</p>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>通俗的说就是给定n个权值作为n个叶子结点，构造一颗二叉树，若带权路径长度达到最小，称这样的树为哈夫曼树，也称为最优二叉树，同时，由定义可知，哈夫曼树是带权路径长度最短的树，所以权值较大的结点离根较近<br><img src="/images/imgs4/17.jpg" alt="Alt text"></p>
<h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><p><strong>路径长度</strong><br>结点路径长度：从树中一个结点到另一个结点之间的分支，构成两个结点之间路径，路径上的分支数目称为结点长度，如结点100到结点29的结点路径长度就是2</p>
<p>树的路径长度：从树根到每一个结点的路径长度之和</p>
<p><strong>权值</strong><br>所有叶子结点的date域，也就是当前叶子结点存放的数据域<br><strong>带权路径长度</strong><br>结点带权路径长度：从该节点到树根之间的路径长度与结点上权值的乘积<br>树的带权路径长度：树中所有结点的带权路径长度之和，并且几位WPL，如果WPL最小，则称该二叉树为哈夫曼树</p>
<p><strong>哈夫曼树构建过程</strong><br>它的构建思想其实很简单的，大概如下<br>1.根据给定的n个权值{w1,w2,..wn}构成n棵二叉树的集合F={T1,T2,..Tn};其中每棵二叉树Ti中只有一个带权为wi的根结点，器左右子树为空<br>2：在F中选取两颗根结点权值最小的树作为左右子树构造一颗新二叉树，并且新二叉树的根结点权值为左右子根结点的权值之和<br>3:在F中删除这两颗树，同时将新二叉树加入F中<br>4:重复2和3步骤，知道F中只含一棵树为止</p>
<h4 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h4><p>哈夫曼结点<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class HuffmNode &#123;</div><div class="line">	//构造HuffmNode类  </div><div class="line">    private int data;  </div><div class="line">    private HuffmNode left;  </div><div class="line">    private HuffmNode right;  </div><div class="line">    //HuffmNode类构造函数  </div><div class="line">    public  HuffmNode(int data) &#123;  </div><div class="line">        this.data=data;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //封装属性  </div><div class="line">    public int getData() &#123;  </div><div class="line">        return data;  </div><div class="line">    &#125;  </div><div class="line">    public void setData(int data) &#123;  </div><div class="line">        this.data = data;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getLeft() &#123;  </div><div class="line">        return left;  </div><div class="line">    &#125;  </div><div class="line">    public void setLeft(HuffmNode left) &#123;  </div><div class="line">        this.left = left;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getRight() &#123;  </div><div class="line">        return right;  </div><div class="line">    &#125;  </div><div class="line">    public void setRight(HuffmNode right) &#123;  </div><div class="line">        this.right = right;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造哈夫曼树<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class HuffmTree &#123;  </div><div class="line">      </div><div class="line">    public int [] datas =&#123;42,8,19,100,58,15,29&#125;;  </div><div class="line">    public LinkedList&lt;HuffmNode&gt; list = new LinkedList&lt;HuffmNode&gt;();  </div><div class="line">      </div><div class="line">    public HuffmNode createTree() &#123;  </div><div class="line">        //按照从小到大的将数据封装成节点  </div><div class="line">        for (int i = 0; i &lt; datas.length; i++) &#123;  </div><div class="line">            HuffmNode node = new HuffmNode(datas[i]);  </div><div class="line">            //得到需要插入的位置索引  </div><div class="line">            int index=getIndex(node);  </div><div class="line">            //将数据添加到容器中  </div><div class="line">            list.add(index, node);  </div><div class="line">        &#125;  </div><div class="line">        //构造哈夫曼树  </div><div class="line">        while(list.size()&gt;1)&#123;  </div><div class="line">            //移除容器中的第一个节点  </div><div class="line">            HuffmNode firstNode =list.removeFirst();  </div><div class="line">            //容器中原来的第二个节点变成新的第一个节点  </div><div class="line">            HuffmNode secondNode =list.removeFirst();  </div><div class="line">            //构造父节点数据域  </div><div class="line">            HuffmNode fatherNode = new HuffmNode(firstNode.getData()+secondNode.getData());  </div><div class="line">            //构造父节点左子叶  </div><div class="line">            fatherNode.setLeft(firstNode);  </div><div class="line">            //构造父节点右子叶  </div><div class="line">            fatherNode.setRight(secondNode);  </div><div class="line">            //得到构造好的父节点的索引  </div><div class="line">            int index=getIndex(fatherNode);  </div><div class="line">            //将父节点加入森林  </div><div class="line">            list.add(index, fatherNode);  </div><div class="line">        &#125;  </div><div class="line">        //返回根节点  </div><div class="line">        return list.getFirst();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //得到索引  </div><div class="line">    public int getIndex(HuffmNode node) &#123;  </div><div class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;  </div><div class="line">            if(node.getData()&gt;list.get(i).getData())&#123;  </div><div class="line">                continue;  </div><div class="line">            &#125;else &#123;  </div><div class="line">                return i;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        //如果比容器中的任何一个数大，则插入最后面  </div><div class="line">        return list.size();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //得到哈夫曼编码  </div><div class="line">    public void getHuffmCode(HuffmNode root,String code) &#123;  </div><div class="line">        if(root.getLeft()!=null)&#123;  </div><div class="line">            getHuffmCode(root.getLeft(),code+"0");  </div><div class="line">        &#125;  </div><div class="line">        if(root.getRight()!=null)&#123;  </div><div class="line">            getHuffmCode(root.getRight(),code+"1");  </div><div class="line">        &#125;  </div><div class="line">        if(root.getLeft()==null &amp;&amp; root.getRight()==null)&#123;  </div><div class="line">            System.out.println(root.getData()+":"+code);  </div><div class="line">        &#125;  </div><div class="line">    &#125;   </div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实这段代码就是上述四个步骤的实现，代码也很好理解，带权值为datas，将结点放到链表中，然后注意利用非正规的选择排序将链表集合里权值从小到大排好序，然后开始选择权值最小的两个构造一个新的权值结点，同时删除那两个，加入这个新的。。重复直到只剩一个根结点为止，很明显此时就是哈夫曼树了，最后通过后序遍历得到哈夫曼编码值，这里我们约定左子树一个路径为0，右子树一个路径为1，所以一定不存在像01与010这样前面是后面子串的编码值<br><strong>测试类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		 HuffmTree tree = new HuffmTree();  </div><div class="line">	        HuffmNode root = tree.createTree();</div><div class="line">	        tree.getHuffmCode(root, ""); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>8:000<br>11:001<br>23:01<br>14:100<br>7:1010<br>3:10110<br>5:10111<br>29:11</p>
</blockquote>
<p>注意这里的结果和图示有一个地方不一样，就是那个几点8，这里的结点8是合成的，可以根据结果画出哈夫曼树，比较就会看出不同</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;说到哈夫曼树，就不得不说它在压缩与解压方面的应用太完美了，就是把一个大的文件，通过算法压缩成一个较小的文件，从而大大节约了空间&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>网络编程简单总结</title>
    <link href="http://www.myzwl.win/2017/07/29/socket_1/"/>
    <id>http://www.myzwl.win/2017/07/29/socket_1/</id>
    <published>2017-07-29T05:48:51.000Z</published>
    <updated>2017-08-12T08:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/images/imgs4/16.jpg" alt="Alt text"><br>在java网络编程中最主要的是tcp/ip协议，这个协议也是Internet最基本的协议，而其就是由网络层的ip协议和传输层的tcp协议组成，同时由于分层的思想，也就是每一层只能与它下面的层打交道，也就是说，应用层只跟传输层打交道，传输层只跟网络层打交道</p>
<h4 id="ip协议"><a href="#ip协议" class="headerlink" title="ip协议"></a>ip协议</h4><p><img src="/images/imgs4/27.gif" alt="Alt text"><br>关于底层协议的具体过程是在太复杂了，当初学习计算机网络的时候也是被各种细节弄得云里雾里的，总之ip层就是唯一确定了一台机器，就像我们住的房间地址一样，唯一确定了我们的住处<br>这里需要注意的是，ip地址由四位字节组成，每个字节由8位二进制组成，同时有a，b，c三类地址，如图由网络号和主机号组成，当然这是公网，如果是局域网的话，就需要配网关和子网掩码了，如192.168.1.1和255.255.0.0那么255.255就是确定了ip地址哪几位字节是网络号，如192.168就是网络号，当然其配置各种内网ip是很复杂的，具体参考计算机网络</p>
<h4 id="TCP与UDP协议"><a href="#TCP与UDP协议" class="headerlink" title="TCP与UDP协议"></a>TCP与UDP协议</h4><p><strong>tcp协议</strong></p>
<blockquote>
<p>它是专门设计用于在不可靠的因特网上提供端到端的字节流通信的协议，它是一种面向连接的协议，它连接的是字节流。<br>这里面有几个注意的地方：<br>可靠性：就是建立三次握手过程，就是说，我把信息传给你，等待，收到回复后，在确认。。最后在发送消息，它保证了数据一定发送给了对方，所以是一种可靠传输，但是遇到阻塞效率会很低<br>端口：ip地址唯一确定了这台机器，相当于一个房子，但是你消息总不能发给整个电脑吧，比如qq，而端口就相当于一间房间，具体发给那个，比如送到qq这间房间</p>
</blockquote>
<p><strong>端口分类</strong></p>
<blockquote>
<p>有65536个端口    0号是保留端口<br>1-1024是固定端口<br>又叫有名端口，即被某些程序固定使用，一般程序员不使用。<br>22：SSH远程登录协议    23：telnet使用    21：ftp使用<br>25：smtp服务使用    80：iis使用    7：echo服务<br>1025-65535是动态端口<br>这些端口，程序员可以使用<br>端口(port)–注意事项<br>1、在计算机(尤其是做服务器)要尽可能的少开端口；<br>2、一个端口只能被一个程序监听；<br>3、如果使用netstat -an可以查看本机有哪些端口在监听</p>
</blockquote>
<p><strong>UDP协议</strong><br>UDP向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接。<br>简单来说，就是只发一次数据，不管对方有没有接收到都不会再发了，但是有时候效率会很高，像网络拥堵时</p>
<p><strong>url</strong><br>统一资源定义符也被称为网页地址。Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL地址，这种地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是Internet上的站点，简单地说，URL就是Web地址，俗称“网址”，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法，如：<br><a href="http://www.sina.com:8080/index.html" target="_blank" rel="external">http://www.sina.com:8080/index.html</a><br>1、协议；2、ip地址(32位)；3、端口号(16位)0-65535；4、资源名称。</p>
<p><strong>单工、半双工和全双工</strong><br> 如果甲可以向乙发送数据，但是乙不能向甲发送数据，这样的通信就是单工通信(Simplex Communication)。<br>    单工数据传输只支持数据在一个方向上传输，就和传呼机一样。<br>    半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信，就和对讲机(步话机)一样；<br>全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力，就和电话一样</p>
<h4 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h4><p><img src="/images/imgs4/28.gif" alt="Alt text"><br>如模拟的客户端与服务端<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class MyServer &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new MyServer();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyServer()&#123;</div><div class="line">		try &#123;</div><div class="line">			//在9999号端口上监听</div><div class="line">			ServerSocket ss=new ServerSocket(9999);</div><div class="line">			System.out.println("9999端口监听...");</div><div class="line">			//等待某个客户端来连接，该函数会返回一个Socket连接</div><div class="line">			Socket s=ss.accept();</div><div class="line">			//要读取s中传递的数据</div><div class="line">			InputStreamReader isr=new InputStreamReader(s.getInputStream());</div><div class="line">			BufferedReader br=new BufferedReader(isr);</div><div class="line">			</div><div class="line">			String info=br.readLine();</div><div class="line">			System.out.println("服务器接收到:\t"+info);</div><div class="line">			</div><div class="line">			PrintWriter pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			pw.println("我是服务器，已收到你发送的信息!");</div><div class="line"></div><div class="line"></div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class MyClient &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new MyClient();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyClient()&#123;</div><div class="line">		try &#123;</div><div class="line">			//Socket()就是去连接某个服务器端 127.0.0.1表示服务器的ip</div><div class="line">			//9999是服务器的端口号</div><div class="line">			Socket s=new Socket("127.0.0.1",9999);</div><div class="line">			//如果s连接成功，就可以发送数据到服务器端</div><div class="line">			//我们通过pw向s写数据,true表示即时刷新</div><div class="line">			PrintWriter pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			pw.println("你好吗？我是客户端");</div><div class="line">			//要读取s中传递的数据</div><div class="line">			InputStreamReader isr=new InputStreamReader(s.getInputStream());</div><div class="line">			BufferedReader br=new BufferedReader(isr);</div><div class="line">			String info=br.readLine();</div><div class="line">			System.out.println("接收到服务器：\t"+info);</div><div class="line"></div><div class="line"></div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要注意的几个地方，必须是服务端先开启，然后accept（）等待客户端，没有客户端连接，它将处于阻塞状态，一旦有了客户端它将回应，其次这是理由tcp实现的，UDP实现用java提供的另外类，最后这里有一个问题，就是只能接受一次，需要改进，也就是不断循环接收客户端连接</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">			//在9999号端口上监听</div><div class="line">			ServerSocket ss=new ServerSocket(9999);</div><div class="line">			//等待客户端连接，该函数会返回一个Socket连接</div><div class="line">			Socket s=ss.accept();</div><div class="line">			//要读取s中传递的数据</div><div class="line">			isr=new InputStreamReader(s.getInputStream());</div><div class="line">			br=new BufferedReader(isr);</div><div class="line">			</div><div class="line">			pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			</div><div class="line">			//接收从控制台输入的信息</div><div class="line">			isr2=new InputStreamReader(System.in);</div><div class="line">			br2=new BufferedReader(isr2);</div><div class="line">			while(true)&#123;</div><div class="line">				//接收客户端信息</div><div class="line">				String infoFromClient=br.readLine();</div><div class="line">				System.out.println("服务器接收到:\t"+infoFromClient);</div><div class="line">				//接收从控制台输入的信息</div><div class="line">				System.out.println("请输入要发送到客户端的信息：");</div><div class="line">				String response=br2.readLine();</div><div class="line">				//服务器从控制台上接收bye服务器端退出</div><div class="line">				if(response.equals("bye"))&#123;</div><div class="line">					System.out.println("退出对话");</div><div class="line">					s.close();</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">				//把从控制台输入的信息，回送给客户端</div><div class="line">				pw.println(response);</div><div class="line">			&#125;</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;finally&#123;</div><div class="line">			try &#123;</div><div class="line">				if(br2!=null) br2.close();</div><div class="line">				if(isr2!=null) isr2.close();</div><div class="line">				if(pw!=null) pw.close();</div><div class="line">				if(br!=null) br.close();</div><div class="line">				if(isr!=null) isr.close();</div><div class="line">			&#125; catch (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>最后当然网络编程中也就是流的数据传送的应用，也不得不说网络底层协议其实很复杂的，只有当我们有精力了，再去细细研究它，才会有更多的收获</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/imgs4/16.jpg&quot; alt=&quot;Alt text&quot;&gt;&lt;br&gt;在java网络编程中最主要的是tcp/
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="http://www.myzwl.win/2017/07/28/balace_1/"/>
    <id>http://www.myzwl.win/2017/07/28/balace_1/</id>
    <published>2017-07-28T05:48:51.000Z</published>
    <updated>2017-08-12T07:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AVL树，也叫平衡二叉树，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。同时，将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，还将距离插入结点最近的且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树<br><img src="/images/imgs4/25.gif" alt="Alt text"><br>如图：一为一个不平衡二叉排序树，显然时间复杂度较大，二为改进后的平衡二叉树，而在改进的过程中，最重要的就是通过平衡因子来判断是进行左旋还是右旋，如右旋，新增一个节点N后，平衡被打破，需要平衡因子2大于0，需要右旋，就是将其左子树作为根结点，左子树的右子树作为原根结点的左子树，这样做的原因就是根据二叉排序树的左右子树特点来的，很容易想明白</p>
<h4 id="模拟平衡二叉树"><a href="#模拟平衡二叉树" class="headerlink" title="模拟平衡二叉树"></a>模拟平衡二叉树</h4><p>不妨构造一个a[10]={3,2,1,4,5,6,7,10,9,8};<br><img src="/images/imgs4/26.gif" alt="Alt text"><br>大概过程如图所示，其中最重要的就是平衡因子的判断，如果是同号，且绝对值大于1的话，就要做相应的旋转操作，如果是不同号的话，就要通过旋转先转换成同号，在做操作</p>
<h4 id="左右旋操作"><a href="#左右旋操作" class="headerlink" title="左右旋操作"></a>左右旋操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">typedef struct BiTNode</div><div class="line">&#123;</div><div class="line">	int data;</div><div class="line">	int bf;</div><div class="line">	struct BiTNode *lchild,*rchild;</div><div class="line">&#125;BiTNode,*BiTree;</div><div class="line"></div><div class="line">//左旋处理</div><div class="line">void R_Rotate(BiTree *p)&#123;</div><div class="line">	BiTree L;</div><div class="line">	L=(*p)-&gt;lchild;   //L指向p的左子树根结点</div><div class="line">	(*p)-&gt;lchild=L-&gt;rchild; //L的右子树挂接为p的左子树</div><div class="line">	L-&gt;rchild=(*p);  </div><div class="line">	*p=L;           //p指向新的根结点</div><div class="line">&#125;</div><div class="line"></div><div class="line">//右旋处理</div><div class="line">void L_Ronate(BiTree *p)</div><div class="line">&#123;</div><div class="line">	BiTree R;</div><div class="line">	R=(*p)-&gt;rchild; //R指向p的右子树根结点</div><div class="line">	(*p)-&gt;rchild=R-&gt;lchild;  //R的左子树挂接为P的右子树</div><div class="line">	R-&gt;lchild=(*p);</div><div class="line">	*p=R;            //p指向新的根结点</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过之前的图来对比看，其实质也就是交互根结点位置和挂接新左右子树</p>
<h4 id="左右平衡旋转"><a href="#左右平衡旋转" class="headerlink" title="左右平衡旋转"></a>左右平衡旋转</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#define LH +1 /*  左高 */ </div><div class="line">#define EH 0  /*  等高 */ </div><div class="line">#define RH -1 /*  右高 */ </div><div class="line"></div><div class="line">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */</div><div class="line">/*  本算法结束时，指针T指向新的根结点 */</div><div class="line">void LeftBalance(BiTree *T)</div><div class="line">&#123; </div><div class="line">	BiTree L,Lr;</div><div class="line">	L=(*T)-&gt;lchild; /*  L指向T的左子树根结点 */ </div><div class="line">	switch(L-&gt;bf)</div><div class="line">	&#123; /*  检查T的左子树的平衡度，并作相应平衡处理 */ </div><div class="line">		 case LH: /*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */ </div><div class="line">			(*T)-&gt;bf=L-&gt;bf=EH;</div><div class="line">			R_Rotate(T);</div><div class="line">			break;</div><div class="line">		 case RH: /*  新结点插入在T的左孩子的右子树上，要作双旋处理 */ </div><div class="line">			Lr=L-&gt;rchild; /*  Lr指向T的左孩子的右子树根 */ </div><div class="line">			switch(Lr-&gt;bf)</div><div class="line">			&#123; /*  修改T及其左孩子的平衡因子 */ </div><div class="line">				case LH: (*T)-&gt;bf=RH;</div><div class="line">						 L-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case EH: (*T)-&gt;bf=L-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case RH: (*T)-&gt;bf=EH;</div><div class="line">						 L-&gt;bf=LH;</div><div class="line">						 break;</div><div class="line">			&#125;</div><div class="line">			Lr-&gt;bf=EH;</div><div class="line">			L_Rotate(&amp;(*T)-&gt;lchild); /*  对T的左子树作左旋平衡处理 */ </div><div class="line">			R_Rotate(T); /*  对T作右旋平衡处理 */ </div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */ </div><div class="line">/*  本算法结束时，指针T指向新的根结点 */ </div><div class="line">void RightBalance(BiTree *T)</div><div class="line">&#123; </div><div class="line">	BiTree R,Rl;</div><div class="line">	R=(*T)-&gt;rchild; /*  R指向T的右子树根结点 */ </div><div class="line">	switch(R-&gt;bf)</div><div class="line">	&#123; /*  检查T的右子树的平衡度，并作相应平衡处理 */ </div><div class="line">	 case RH: /*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */ </div><div class="line">			  (*T)-&gt;bf=R-&gt;bf=EH;</div><div class="line">			  L_Rotate(T);</div><div class="line">			  break;</div><div class="line">	 case LH: /*  新结点插入在T的右孩子的左子树上，要作双旋处理 */ </div><div class="line">			  Rl=R-&gt;lchild; /*  Rl指向T的右孩子的左子树根 */ </div><div class="line">			  switch(Rl-&gt;bf)</div><div class="line">			  &#123; /*  修改T及其右孩子的平衡因子 */ </div><div class="line">				case RH: (*T)-&gt;bf=LH;</div><div class="line">						 R-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case EH: (*T)-&gt;bf=R-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case LH: (*T)-&gt;bf=EH;</div><div class="line">						 R-&gt;bf=RH;</div><div class="line">						 break;</div><div class="line">			  &#125;</div><div class="line">			  Rl-&gt;bf=EH;</div><div class="line">			  R_Rotate(&amp;(*T)-&gt;rchild); /*  对T的右子树作右旋平衡处理 */ </div><div class="line">			  L_Rotate(T); /*  对T作左旋平衡处理 */ </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="插入与主函数"><a href="#插入与主函数" class="headerlink" title="插入与主函数"></a>插入与主函数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */ </div><div class="line">/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */ </div><div class="line">/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */</div><div class="line">Status InsertAVL(BiTree *T,int e,Status *taller)</div><div class="line">&#123;  </div><div class="line">	if(!*T)</div><div class="line">	&#123; /*  插入新结点，树“长高”，置taller为TRUE */ </div><div class="line">		 *T=(BiTree)malloc(sizeof(BiTNode));</div><div class="line">		 (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=NULL; (*T)-&gt;bf=EH;</div><div class="line">		 *taller=TRUE;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if (e==(*T)-&gt;data)</div><div class="line">		&#123; /*  树中已存在和e有相同关键字的结点则不再插入 */ </div><div class="line">			*taller=FALSE; return FALSE;</div><div class="line">		&#125;</div><div class="line">		if (e&lt;(*T)-&gt;data)</div><div class="line">		&#123; /*  应继续在T的左子树中进行搜索 */ </div><div class="line">			if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) /*  未插入 */ </div><div class="line">				return FALSE;</div><div class="line">			if(taller) /*   已插入到T的左子树中且左子树“长高” */ </div><div class="line">				switch((*T)-&gt;bf) /*  检查T的平衡度 */ </div><div class="line">				&#123;</div><div class="line">					case LH: /*  原本左子树比右子树高，需要作左平衡处理 */ </div><div class="line">							LeftBalance(T);	*taller=FALSE; break;</div><div class="line">					case EH: /*  原本左、右子树等高，现因左子树增高而使树增高 */ </div><div class="line">							(*T)-&gt;bf=LH; *taller=TRUE; break;</div><div class="line">					case RH: /*  原本右子树比左子树高，现左、右子树等高 */  </div><div class="line">							(*T)-&gt;bf=EH; *taller=FALSE; break;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123; /*  应继续在T的右子树中进行搜索 */ </div><div class="line">			if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) /*  未插入 */ </div><div class="line">				return FALSE;</div><div class="line">			if(*taller) /*  已插入到T的右子树且右子树“长高” */ </div><div class="line">				switch((*T)-&gt;bf) /*  检查T的平衡度 */ </div><div class="line">				&#123;</div><div class="line">					case LH: /*  原本左子树比右子树高，现左、右子树等高 */ </div><div class="line">							(*T)-&gt;bf=EH; *taller=FALSE;	break;</div><div class="line">					case EH: /*  原本左、右子树等高，现因右子树增高而使树增高  */</div><div class="line">							(*T)-&gt;bf=RH; *taller=TRUE; break;</div><div class="line">					case RH: /*  原本右子树比左子树高，需要作右平衡处理 */ </div><div class="line">							RightBalance(T); *taller=FALSE; break;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	int i;</div><div class="line">	int a[10]=&#123;3,2,1,4,5,6,7,10,9,8&#125;;</div><div class="line">	BiTree T=NULL;</div><div class="line">	Status taller;</div><div class="line">	for(i=0;i&lt;10;i++)</div><div class="line">	&#123;</div><div class="line">		InsertAVL(&amp;T,a[i],&amp;taller);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后不得不说，AVL树是在是太复杂了，但是其思想是在是太精妙了，它克服了二叉排序树在查找效率上的不足，通过在插入数据时，就将其变成一个平衡二叉树，从而使其时间复杂度为O(logn)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;AVL树，也叫平衡二叉树，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。同时，将二叉树上结点的左子树深度减去右子树深度
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="http://www.myzwl.win/2017/07/27/BSTSort_1/"/>
    <id>http://www.myzwl.win/2017/07/27/BSTSort_1/</id>
    <published>2017-07-27T05:48:51.000Z</published>
    <updated>2017-08-12T05:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>二叉排序树，又称为二分查找树，它或者是一颗空树，或者具有如下性质<br>1.若它的左子树不为空，则左子树上所有结点的值均小于根结点值<br>2.若它的右子树不为空，则右子树上所有结点的值均小于根结点值<br>3.它的左右子树也分别为二叉排序树<br><img src="/images/imgs4/23.gif" alt="Alt text"></p>
<h4 id="二叉排序树查找操作"><a href="#二叉排序树查找操作" class="headerlink" title="二叉排序树查找操作"></a>二叉排序树查找操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">typedef struct BiTNode</div><div class="line">&#123;</div><div class="line">	int data;</div><div class="line">	struct BiTNode *lchild,*rchild;</div><div class="line">&#125;BiTNode,*BiTree;</div><div class="line"></div><div class="line"></div><div class="line">//递归查找二叉排序树中是否存在key</div><div class="line">//f指向T的双亲，初始值为NULL</div><div class="line">//若查找成功，则p指向该节点，并返回true</div><div class="line">//若查找失败，则p指向查找路径上访问的最后一个结点，并返回FALSE</div><div class="line">Status SearchBST(BiTree T,int key,BiTree f,BiTree *p)</div><div class="line">&#123;</div><div class="line">	if(!T)     //查找不成功</div><div class="line">	&#123;</div><div class="line">		*p=f;</div><div class="line">		return FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	else if(key==T-&gt;data) //查找成功</div><div class="line">	&#123;</div><div class="line">		*p=T;</div><div class="line">		return TRUE;</div><div class="line">	&#125;</div><div class="line">	else if(key&gt;T-&gt;data)&#123;         //在右子树中递归查找</div><div class="line">		return SearchBST(T-&gt;rchild,key,T,p);</div><div class="line">	&#125;</div><div class="line">	else if(key&lt;T-&gt;data)          //在左子树中递归查找</div><div class="line">		return SearchBST(T-&gt;lchild,key,T,p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看看它的过程是如何运行的，比如现在要查找93，显然初始化为SearchBST(T,93,NULL,p),因为93&gt;62，所以递归执行SearchBST(T-rchild,93,T,p),即SearchBST(88,93,62,P)这里用结点data值表示结点，又93&gt;88,继续SearchBST(99,93,88,P)，又93&lt;99，SearchBST(93,93,99,P)，所以93==93，得到最终p=T=93，f=99，查找成功。<br>可以发现二叉排序树的查找算法如此精妙而又优雅</p>
<h4 id="二叉排序树的插入操作"><a href="#二叉排序树的插入操作" class="headerlink" title="二叉排序树的插入操作"></a>二叉排序树的插入操作</h4><p>插入操作是基于查找操作的，也就是如果该二叉树为空，则新插入点为根结点，如果不为空，在先查找是否存在此元素，存在返回FALSE，否则在查找路径上的最后一个结点，通过比较插入到左孩子还是右孩子，最终返回TRUE<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Status InsertBST(BiTree *T,int key)</div><div class="line">&#123;</div><div class="line">	BiTree p,s;</div><div class="line">	if(!SearchBST(T,key,NULL,&amp;p)) //查找不成功</div><div class="line">	&#123;</div><div class="line">		s=(BiTree)malloc(sizeof(BiTNode));</div><div class="line">		 s-&gt;data=key;</div><div class="line">		 s-&gt;lchild=s-&gt;rchild=NULL;</div><div class="line">		 if(!p)                    //插入s为新的根结点</div><div class="line">		 	*T=s;</div><div class="line">		 else if(key&lt;s-data)      //插入s为左孩子</div><div class="line">		 	p-&gt;lchild=s;</div><div class="line">		 else                     //插入s为右孩子</div><div class="line">		 	p-&gt;rchild=s;</div><div class="line">		 return TRUE;</div><div class="line">	&#125;</div><div class="line">	else                       //树中已存在此关键字，则不插入</div><div class="line">		return FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="二叉排序树的删除操作"><a href="#二叉排序树的删除操作" class="headerlink" title="二叉排序树的删除操作"></a>二叉排序树的删除操作</h4><p>删除操作需要考虑三种情况，因为删除之后要保证还是一颗二叉排序树。如图<br><img src="/images/imgs4/24.gif" alt="Alt text"><br>一：删除叶子结点，这对这个二叉树来说并无影响，所以不移动其它元素<br>二：删除只含有左子树或者右子树的二叉排序树，因为根据二叉排序树的特点，很明显只要将它的左子树或右子树全部移动到它双亲的左子树或右子树就行了<br>三：删除既有左子树又有右子树的结点，我们可以通过它的中序遍历，也就是让它的直接前驱或者直接后继来替换它的位置，然后直接后继在分三种情况，直至只有一个孩子或者无孩子来替换<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">Status DeleteBST(BiTree *T,int key) //找到待删结点</div><div class="line">&#123;</div><div class="line">	if(!*T)</div><div class="line">		return FALSE;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if(key==(*T)-&gt;data)</div><div class="line">			return Delete(T);</div><div class="line">		else if(key&lt;(*T)-&gt;data)</div><div class="line">			return DeleteBST(&amp;(*T)-&gt;lchild,key);</div><div class="line">		else</div><div class="line">			return DeleteBST(&amp;(*T)-&gt;rchild,key);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//从二叉树中删除结点p，并重接它的左或右子树</div><div class="line">Status Delete(BiTree *p)</div><div class="line">&#123;</div><div class="line">	BiTree q,s;</div><div class="line">	if((*p)-&gt;rchild==NULL)  //右子树空则重接它的左子树</div><div class="line">	&#123;</div><div class="line">		q=*p;</div><div class="line">		*p=(*p)-&gt;lchild;</div><div class="line">		free(q);</div><div class="line">	&#125;</div><div class="line">	else if((*p)-&gt;lchild==NULL) //左子树空则重接它的右子树</div><div class="line">	&#123;</div><div class="line">		q=*p;</div><div class="line">		*p=(*p)-&gt;rchild;</div><div class="line">		free(q);</div><div class="line">	&#125;</div><div class="line">	else&#123;         //左右子树均不为空</div><div class="line">		q=*p;</div><div class="line">		s=(*p)-&gt;lchild;</div><div class="line">		while(s-&gt;lchild) //找到待删结点的前驱</div><div class="line">		&#123;</div><div class="line">			q=s;</div><div class="line">			s=s-&gt;rchild;</div><div class="line">		&#125;</div><div class="line">		(*p)-&gt;data=s-&gt;data;</div><div class="line">		if(q!=*p)        //重接q的右子树</div><div class="line">			q-&gt;rchild=s-&gt;lchild;</div><div class="line">		else             //重接q的左子树</div><div class="line">			q-&gt;lchild=s-&gt;lchild;</div><div class="line">		free(s);</div><div class="line">	&#125;</div><div class="line">	return TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>二叉排序树是以链式结构进行存储，所以在插入和删除元素上高效，，但是查找上走的是从根路径到结点的路径，其比较次数与数的层数有关如果该数是一颗斜数，那么查找就会比较很多次，如果该树是一颗完全二叉树，那么比较次数就最优，此时时间复杂度为O(logn),但是平均来说时间复杂度为O(n)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;二叉排序树，又称为二分查找树，它或者是一颗空树，或者具有如下性质&lt;br&gt;1.若它的左子树不为空，则左子树上所有结点的值均小于根结点值&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>死锁和生产者消费者问题</title>
    <link href="http://www.myzwl.win/2017/07/26/procos_1/"/>
    <id>http://www.myzwl.win/2017/07/26/procos_1/</id>
    <published>2017-07-26T05:48:51.000Z</published>
    <updated>2017-08-10T08:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>线程同步操作的是同一个线程对象，所以可能造成线程不安全，出现非数据的原子操作，所以，需要加锁，同时线程是程序的执行顺序，也就是cpu根据不同时间片选择某个时间执行某个线程，关于线程并发，在以前的总结中做过了几个简单的总结。<br>而死锁最经典的例子就是哲学家进餐问题，每个哲学家都左手拿着一只筷子，并且总共有五个哲学家，5个筷子，只有当哲学家左右手都有筷子时才能进餐，所以每个哲学家都在等右边哲学家方上筷子，处于僵持等待状态，称为死锁。<br>这里模仿两个线程死锁的情况<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class LockTest implements Runnable&#123;</div><div class="line"></div><div class="line">	public int flag=1;</div><div class="line">	 static Object o1=new Object(),o2=new Object();</div><div class="line">	   </div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println("flag="+flag);</div><div class="line">		 if(flag==1)&#123;</div><div class="line">		 synchronized (o1) &#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(5000);</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			synchronized (o2) &#123;</div><div class="line">				System.out.println("1");</div><div class="line">			&#125;</div><div class="line">		 &#125;	 </div><div class="line">		&#125;</div><div class="line">		if(flag==0)&#123;</div><div class="line">			 synchronized (o2) &#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(5000);</div><div class="line">					&#125; catch (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					synchronized (o1) &#123;</div><div class="line">						System.out.println("0");</div><div class="line">					&#125;</div><div class="line">				 &#125;	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LockTest lt1=new LockTest();</div><div class="line">		LockTest lt2=new LockTest();</div><div class="line">		 lt1.flag=1;</div><div class="line">		 lt2.flag=0;</div><div class="line">		  Thread t1=new Thread(lt1);</div><div class="line">		  Thread t2=new Thread(lt2);</div><div class="line">		  t1.start();</div><div class="line">		  t2.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>flag=1<br>flag=0</p>
</blockquote>
<p>大概分析一下，该类本身是一个线程类，flag用来控制执行哪个锁，O1和O2是两个被锁住对象，flag为1时先锁住o1，在锁住o2，flag为0则相反，而死锁发生就在此处两个线程启动了，o1被锁住了，另一个o2被锁住了，都在等待对方释放锁，显然处于僵持，产生死锁，<br>解决死锁的一个简单办法就是增大锁的粒度，扩大锁对象，比如讲前面的O1与O2改成this<br>结果：</p>
<blockquote>
<p>flag=1<br>flag=0<br>1<br>0</p>
</blockquote>
<h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><p>概述，模拟一个生产者利用生产食物放到篮子里，而一个消费者从篮子里消费食物<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">public class Food &#123; //食物类</div><div class="line"> int id;</div><div class="line"> public Food(int id)&#123;</div><div class="line">	 this.id=id;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class UtilStack &#123;//工具，用来放食物</div><div class="line"></div><div class="line">	int index=0; //食物计数变量</div><div class="line">	Food[] arrFD=new Food[4]; //最多工具能放食物容量</div><div class="line">	</div><div class="line">	public synchronized void push(Food fd)&#123; //生产食物，必须加锁，保证生产过程不被打断</div><div class="line">		while(index==arrFD.length)</div><div class="line">		&#123;</div><div class="line">			try &#123;</div><div class="line">				System.out.println("full");</div><div class="line">				this.wait();  //生产满了，就去休息区休息，等待被唤醒</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		this.notify();//唤醒当前在休息区的线程</div><div class="line">		arrFD[index]=fd;</div><div class="line">		index++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public synchronized Food pop()&#123; //消费</div><div class="line">		while(index==0) //消费完了，进休息区</div><div class="line">			try &#123;</div><div class="line">				System.out.println("empty");</div><div class="line">				this.wait();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		this.notify();</div><div class="line">		index--;</div><div class="line">		return arrFD[index];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Producer implements Runnable&#123;//生产者</div><div class="line"></div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Producer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=new Food(i);</div><div class="line">			ss.push(fd);</div><div class="line">			System.out.println("生产了"+fd.id);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(1000);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Consumer implements Runnable&#123;//消费者</div><div class="line"></div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Consumer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=ss.pop();</div><div class="line">			System.out.println("消费了"+fd.id);</div><div class="line">		 try &#123;</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>消费利用一对生产者和消费者模拟</p>
<blockquote>
<pre><code>UtilStack ss=new UtilStack();
    Producer p=new Producer(ss);
    Consumer c=new Consumer(ss);
    new Thread(p).start();
    new Thread(c).start();
</code></pre></blockquote>
<p>结果如下：</p>
<blockquote>
<p>生产了0<br>消费了0<br>生产了1<br>生产了2<br>消费了2<br>生产了3<br>生产了4<br>消费了4<br>生产了5<br>生产了6<br>消费了6<br>生产了7<br>full<br>消费了7<br>生产了8<br>full<br>消费了8<br>生产了9<br>full<br>消费了9<br>生产了10<br>full<br>消费了10<br>生产了11<br>full<br>消费了11<br>生产了12<br>full<br>消费了12<br>生产了13<br>full<br>消费了13<br>生产了14<br>full<br>消费了14<br>生产了15<br>full</p>
</blockquote>
<p>这里优于设置了消费者消费时间长，所以导致index不一样。可以发现当生产者满了，生产者不生产了，进入休息区，等待被唤醒，关于wait（）、notify（）、notifyAll（），在之前的多线程总结中已总结了</p>
<p><strong>结果分析</strong><br>从中我们可以看到生产者有满了的情况，但是消费者消费完了，index就不满了，然后就去叫醒了生产者继续生产，同样如果我们把消费者时间设置短一点看看，预测应该是empty的，在被生产者叫醒</p>
<blockquote>
<p>生产了0<br>消费了0<br>empty<br>消费了1<br>生产了1<br>empty<br>消费了2<br>生产了2<br>empty<br>消费了3<br>生产了3<br>empty<br>生产了4<br>消费了4<br>empty</p>
</blockquote>
<p>最后不得不说生产者与消费者问题可以解决平时在项目开发配置中不求甚解的一些问题，像缓冲区、连接池、消息队列、死锁、同步等等，</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h4&gt;&lt;p&gt;线程同步操作的是同一个线程对象，所以可能造成线程不安全，出现非数据的原子操作，所以，需要加锁，同时线程是程序的执行顺序，也就是cpu根据不同
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://www.myzwl.win/2017/07/25/quick_1/"/>
    <id>http://www.myzwl.win/2017/07/25/quick_1/</id>
    <published>2017-07-25T05:48:51.000Z</published>
    <updated>2017-08-10T04:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速排序被列为20世纪十大算法之一，正如其名一样，排序的速度非常快。<br>而它的基本思想就是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续排序，最终达到有序的目的<br><img src="/images/imgs4/22.gif" alt="Alt text"></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>采取同样的策略，从计算机的角度看看程序是怎么执行的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void QuickSort(SqList *L)&#123;</div><div class="line">  QSort(L,1,L-&gt;length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void QSort(SqList *L,int low,int high)&#123;</div><div class="line">  int pivot;</div><div class="line">   if(low&lt;high)&#123;</div><div class="line">    pivot=Partition(L,low,high);//将L-&gt;r[low..high]一分为二</div><div class="line">     QSort(L,low,pivor-1); //对低子表递归排序</div><div class="line">      QSort(L,pivot+1,high); //对高子表递归排序</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>里面有个函数Partition(L,low,high),和归并排序一样，暂时先不管它，初始化数组为{50,10,90,30,70,40,80,60,20}，初始low=1，high=9；<br>pivot为选择其中一个关键字，比pivot小的排到左边，比pivot大的排到右边，显然此时pivot=5，然后执行 QSort(L，1,4）直至排好序，同样右边也是递归调用QSort（L，6,9），这里的核心算法也就是Partition(L,low,high)如何排序的了<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int Partition(SqList *L,int low,int high)&#123;</div><div class="line">  int pivotkey;</div><div class="line">   pivotkey=L-&gt;[low]; //用子表的第一个记录做关键字</div><div class="line">    while(low&lt;high)</div><div class="line">    &#123;</div><div class="line">      while(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</div><div class="line">        high--;</div><div class="line">      swap(L,low,high);//交换low和high的记录</div><div class="line">      while(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</div><div class="line">         low++;</div><div class="line">       swap(L,low,high);</div><div class="line">    &#125;</div><div class="line">    return low;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样一行一行的看，这里默认选取子表的第一个记录作为关键字pivotkey=L-&gt;[low];接下来，由于low=1<high=9，执行内部程序，然后比较l->r[high]=L-&gt;r[9]=20与pivotkey=50大小，显然前者小于后者，不满足，将high与low交换，也就是说小的在左边，此时为{20,10,90.。。50},；然后明显20<50，所以low++；得low=2；并且10<50，在循环，得low=3，此时90>50,退出循环，在此交换位置，得{20,10,50.。。。90}；<br>最后low=3<9在循环，90>50,满足，high–，high=8，有L-&gt;high[8]=60&gt;50;high–;有80&gt;50;high–,有40&lt;50,退出循环，此时high=6，交换，依次类推，最终low=high=5，退出整个循环<br>最后在分别递归低和高的子表，最后我们发现他的规律如此只简单，遇到比关键字小的，依次递增比较，直到有比它大的，在换另一边比较，不得不说快速排序实在是太精妙了</9在循环，90></50，所以low++；得low=2；并且10<50，在循环，得low=3，此时90></high=9，执行内部程序，然后比较l-></p>
<p>最后再来看一下快速排序的时间复杂度，在最优的情况下为O（nlogn);</p>
<h4 id="排序算法间的比较"><a href="#排序算法间的比较" class="headerlink" title="排序算法间的比较"></a>排序算法间的比较</h4><p><img src="/images/imgs4/2.png" alt="Alt text"><br>分类<br><img src="/images/imgs4/15.jpg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;快速排序被列为20世纪十大算法之一，正如其名一样，排序的速度非常快。&lt;br&gt;而它的基本思想就是通过一趟排序将待排序的记录分割成独立的两部分，
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://www.myzwl.win/2017/07/24/guibin_1/"/>
    <id>http://www.myzwl.win/2017/07/24/guibin_1/</id>
    <published>2017-07-24T05:48:51.000Z</published>
    <updated>2017-08-10T08:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>归并的意思就是将两个或者两个以上的有序数组合成一个有序表。而归并排序就是将含有n个记录的子序列，每个子序列长度为1，然后两两归并，得到[n/2]个长度为2或者1的有序子序列，在两两归并，。。。。，如此重复，直到得到一个长度为n的有序序列为止<br><img src="/images/imgs4/14.jpg" alt="Alt text"></p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>不妨先看代码，在从计算机角度去看看是如何执行代码过程的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void MergeSort(SqList *L)&#123;</div><div class="line">  MSort(L-&gt;r,L-&gt;r,1,L-&gt;length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//将SR[s..t]归并到TR1[s..t]</div><div class="line">void MSort(int SR[],int TR1[],int s,int t)&#123;</div><div class="line">  int m;</div><div class="line">  int TR2[MAXSIZE+1];</div><div class="line">  if(s==t)</div><div class="line">    TR1[s]=SR[s];</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    m=(s+t)/2;</div><div class="line">    MSort(SR,TR2,s,m);</div><div class="line">    MSort(SR,TR2,m+1,t);</div><div class="line">    Merge(TR2,TR1,s,m,t);//将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>里面有个递归 Merge(TR2,TR1,s,m,t);暂时先不管它，假设模拟的数组为{50,10,90,30,70,40,80,60,20}，所以知道初始化时SR和TR1都是该数组，s=1，t-9；由于s！=t，所以执行else中的语句。此时m=5，也就是正中间下标，所以开始先执行递归MSort(SR,TR2,1,5)，递归过程如下所示<br><img src="/images/imgs4/21.gif" alt="Alt text"><br>其核心部分就是最后都变成叶子结点，递归结束，然后执行if里语句，不过此时TR1[s]=SR[s]，注意这里s是元素下标，所以第一次TR2={50,10}，然后就要执行Merge(TR2,TR1,s,m,t);前面是50与10已结归并了，暂时我们知道它就是把无需归并为有序就行了，即TR2={10,50}后面在详细分析它，<br>接下来同理，依次向上归并，最后得到{10,30,50,70,90}，同理，根结点右子树也一样，最终完成了归并</p>
<p>再来看看Merge(TR2,TR1,s,m,t)函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void Merge(int SR[],int TR[],int i,int m,int n)</div><div class="line">&#123;</div><div class="line">  int j,k,l;</div><div class="line">   for(j=m+1,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++)</div><div class="line">   &#123;</div><div class="line">    if(SR[i]&lt;SR[j])</div><div class="line">      TR[k]=SR[i++];</div><div class="line">    else</div><div class="line">      TR[k]=SR[j++];</div><div class="line">   &#125;</div><div class="line">   if(i&lt;=m)&#123;  //将剩余元素归并</div><div class="line">    for(l=0;l&lt;=m-1;l++)</div><div class="line">      TR[k+1]=SR[i+1];</div><div class="line">  &#125;</div><div class="line"> if(j&lt;=n)</div><div class="line"> &#123;</div><div class="line">  for(l=0;l&lt;n-j;l++)</div><div class="line">    TR[k+1]=SR[j+1];</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就拿{10,30,50,70,90}和{20,40,60,80}归并为有序序列来说，此时i=1，m=5,n=9；进入for循环，此时j从6到9，i由1到5，k由1开始每次加1，并且k就是TR数组的下标，然后开始归并，左右子树的SR[i]=SR[1]=10与SR[j]=SR[6]=20开始比较，将较小数放入到一个初始化时空的TR[]中，比如是10，然后i++；否则j++，这样就可以得到有序序列了，但是最终当j=10时退出循环，而后面还有一些元素未归并，将执行后面if语句，将最后的90复制到最后，最终完成了归并</p>
<p>最后再来看看归并排序的时间复杂度，由于其与完全二叉树有关，最终得到其为O（nlogn)，而它也是比较占用内存但是很稳定的一种算法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;归并的意思就是将两个或者两个以上的有序数组合成一个有序表。而归并排序就是将含有n个记录的子序列，每个子序列长度为1，然后两两归并，得到[n/
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java IO简单总结</title>
    <link href="http://www.myzwl.win/2017/07/23/IO_1/"/>
    <id>http://www.myzwl.win/2017/07/23/IO_1/</id>
    <published>2017-07-23T05:48:51.000Z</published>
    <updated>2017-08-09T07:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在涉及IO流之前需要知道文件的概念。文件是数据源（保存数据的的地方）的一种，比如word文件、txt文件。他既可以保存一张图片，也可以保存视频、声音。。。等等<br><strong>文件流</strong><br><img src="/images/imgs4/19.gif" alt="Alt text"><br>文件在程序中是以流的形式来操作的<br>流：数据在数据源（文件）和程序（内存）之间经历的路径<br>输入流：数据从数据源到内存的路径<br>输出流：数据从内存到数据源的路径</p>
<h4 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h4><p>1.根据处理数据类型的不同分为：字符流和字节流<br>字节流：可以用于读写二进制文件及任何类型的byte，也就是一个字节一个的读<br>字符流：可以用于读写文本文件，不能操作二进制文件，也就是两个字节两个字节的读<br>2.根据数据流向不同分为：输入流和输出流<br>3。节点流和处理流<br>节点流：直接与数据源相连，读入或读出，可以发现使用该流过于频繁操作硬件，从而使读写很不方便<br>常用的结点流：</p>
<blockquote>
<p>父类：InputStream、OutputStream、Reader、Writer<br>文件 ：FileInputStream 、 FileOutputStrean 、FileReader、FileWriter 文件进行处理的节点流<br>数　组 ：ByteArrayInputStream、 ByteArrayOutputStream、 CharArrayReader 、CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）<br>字符串 ：StringReader、 StringWriter 对字符串进行处理的节点流<br>管　道 ：PipedInputStream 、PipedOutputStream 、PipedReader 、PipedWriter 对管道进行处理的节点流</p>
</blockquote>
<p>处理流：处理流和节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。<br><img src="/images/imgs4/20.gif" alt="Alt text"><br>常用的处理流：</p>
<blockquote>
<p>缓冲流：BufferedInputStrean 、BufferedOutputStream、 BufferedReader、 BufferedWriter 增加缓冲功能，避免频繁读写硬盘<br>转换流：InputStreamReader 、OutputStreamReader实现字节流和字符流之间的转换<br>数据流： DataInputStream 、DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来</p>
</blockquote>
<p><img src="/images/imgs4/13.jpg" alt="Alt text"></p>
<h4 id="文件File类"><a href="#文件File类" class="headerlink" title="文件File类"></a>文件File类</h4><p><strong>File常用方法</strong></p>
<blockquote>
<p>创建：<br>createNewFile()在指定位置创建一个空文件，成功就返回true，如果已存在就不创建，然后返回false。<br>mkdir()  在指定位置创建一个单级文件夹。<br>mkdirs()  在指定位置创建一个多级文件夹。<br>renameTo(File dest)如果目标文件与源文件是在同一个路径下，那么renameTo的作用是重命名， 如果目标文件与源文件不是在同一个路径下，那么renameTo的作用就是剪切，而且还不能操作文件夹。<br>删除：<br>delete()  删除文件或者一个空文件夹，不能删除非空文件夹，马上删除文件，返回一个布尔值。<br>deleteOnExit()jvm退出时删除文件或者文件夹，用于删除临时文件，无返回值。<br> 判断：<br>exists()  文件或文件夹是否存在。<br>isFile()  是否是一个文件，如果不存在，则始终为false。<br>isDirectory()  是否是一个目录，如果不存在，则始终为false。<br>isHidden()  是否是一个隐藏的文件或是否是隐藏的目录。<br>isAbsolute()  测试此抽象路径名是否为绝对路径名。<br> 获取：<br>getName()  获取文件或文件夹的名称，不包含上级路径。<br>getAbsolutePath()获取文件的绝对路径，与文件是否存在没关系<br>length()  获取文件的大小（字节数），如果文件不存在则返回0L，如果是文件夹也返回0L。<br>getParent()  返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回null。<br>lastModified()获取最后一次被修改的时间。<br>文件夹相关：<br>static File[] listRoots()列出所有的根目录（Window中就是所有系统的盘符）<br>list()  返回目录下的文件或者目录名，包含隐藏文件。对于文件这样操作会返回null。<br>listFiles()  返回目录下的文件或者目录对象（File类实例），包含隐藏文件。对于文件这样操作会返回null。<br>list(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。<br>listFiles(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> //创建一个文件对象</div><div class="line">  File f1=new File("e:\\aa.txt");</div><div class="line">  //得到文件的路径</div><div class="line">  System.out.println("文件路径"+f1.getAbsolutePath());</div><div class="line">//得到文件的大小,字节数</div><div class="line">  System.out.println("文件的大小"+f1.length());</div><div class="line">//创建文件夹</div><div class="line">		File f3=new File("e:\\ff");</div><div class="line">		//判断文件夹是否存在</div><div class="line">		if(f3.isDirectory())&#123;</div><div class="line">			System.out.println("文件夹存在，不能创建!");</div><div class="line">		&#125;else&#123;</div><div class="line">			//创建文件夹</div><div class="line">			f3.mkdir();</div><div class="line">		&#125;</div><div class="line">		//创建文件和创建文件夹</div><div class="line">		File f2=new File("e:\\ff\\zwl.txt");</div><div class="line">		//判断文件是否存在</div><div class="line">		if(!f2.exists())//可以创建</div><div class="line">			try &#123;</div><div class="line">				f2.createNewFile();//创建一个新文件</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		else&#123;</div><div class="line">			System.out.println("文件存在，不能创建!");</div><div class="line">		&#125;</div><div class="line">		//列出一个文件夹下面的所有文件</div><div class="line">		File f4=new File("e:\\ff");</div><div class="line">		//判断文件夹是事存在</div><div class="line">		if(f4.isDirectory())&#123;</div><div class="line">			//将文件夹的文件，传给lists数组</div><div class="line">			//将文件夹的文件，传给lists数组</div><div class="line">			File lists[]=f4.listFiles();</div><div class="line">			//遍历数组</div><div class="line">			for(int i=0;i&lt;lists.length;i++)&#123;</div><div class="line">				//输出文件夹下所有文件文件名</div><div class="line">				System.out.println("显示出文件名是"+lists[i].getName());</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>对应的结果：</p>
<blockquote>
<p>文件路径e:\aa.txt<br>文件的大小0<br>显示出文件名是zwl.txt</p>
</blockquote>
<h4 id="文件字节与字符流"><a href="#文件字节与字符流" class="headerlink" title="文件字节与字符流"></a>文件字节与字符流</h4><p><strong>InputStream常用方法</strong></p>
<blockquote>
<p>public abstract int read() throws IOException:从输入流中读取数据的下一个字节,到达末尾，返回-1；<br> public int read(byte[] b)throws IOException：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中<br> public int read(byte[] b,int off,int len)throws IOException：将输入流中最多 len 个数据字节读入 byte 数组<br> public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源</p>
</blockquote>
<p><strong>OutputStream常用方法</strong></p>
<blockquote>
<p>public void flush()throws IOException:刷新此输出流并强制写出所有缓冲的输出字节<br> public abstract void write(int b)throws IOException:将 b.length 个字节从指定的 byte 数组写入此输出流。<br> public void write(byte[] b, int off, int len)throws IOException:将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流<br> public void write(byte[] b)throws IOException:将指定的字节写入此输出流。</p>
</blockquote>
<p> Reader与Writer和上述方法基本类似，只不过它操作的是字符。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">int b=0;</div><div class="line">  //FileInputStream in=null;</div><div class="line">  FileReader in=null;</div><div class="line">   FileOutputStream out=null;</div><div class="line">    try &#123;</div><div class="line">		in=new FileReader("E:\\php练习\\readmeFirst.txt");</div><div class="line">		out=new FileOutputStream("E:\\php练习\\ttl.txt");</div><div class="line">	&#125; catch (Exception e) &#123;</div><div class="line">		System.out.println("not file");</div><div class="line">		 System.exit(-1);</div><div class="line">	&#125;</div><div class="line">    try &#123;</div><div class="line">		long num=0;</div><div class="line">		while((b=in.read())!=-1)&#123;</div><div class="line">			System.out.print((char)b);</div><div class="line">			//out.write(b);;</div><div class="line">			num++;</div><div class="line">		&#125;</div><div class="line">		in.close();</div><div class="line">		out.close();</div><div class="line">		System.out.println();</div><div class="line">		System.out.println("共读取了"+num+"个字符");</div><div class="line">	&#125; catch (Exception e) &#123;</div><div class="line">		System.out.println("error!");</div><div class="line">		 System.exit(-1);</div><div class="line">	&#125;</div><div class="line">    System.out.println("copy ok");</div></pre></td></tr></table></figure></p>
<p>上面程序是将已存在的一个文件复制到另一个文件中</p>
<p><strong>缓冲字节与字符流</strong><br>它是在原来节点流基础上增加了一根管道，用于缓存数据，用法基本类似，但是它的构造函数必须是结点流，同时在字符缓冲流中有一个可以读取或存取字符串的方法如：</p>
<blockquote>
<p>public String readLine()throws IOException:读取一个文本行</p>
</blockquote>
<p><strong>Object流</strong><br>Object流的意思将是像一根节点流插入一根Object流管道，专门操作Object，而它必须实现Serializable接口，该接口的意思是可序列化，就是说将一个对象流序列化成子节流写进网络或者文件，比如说游戏存盘，有各个游戏的记录，如果以面向对象来写进管道，它的各个成员变量，会在内存中被序列化成二进制写进去，而Serializable接口无方法，它只是个标记接口，编译器看到实现该接口的类就知道它应该被序列化，同样有一个transient关键字，是使可序列化的某个属性变成透明，也就是它不能变成字节写进去，那个属性只能为默认属性写进去<br>ok，接下来就来看看Object流相关常用方法</p>
<blockquote>
<p>ObjectOutput:有一个void writeObject(Object obj) throws IOException：将对象写入底层存储或流。<br>ObjectInput：Object readObject()throws ClassNotFoundException,IOException：读取并返回对象</p>
</blockquote>
<p>最后不得不说IO流是在太复杂，就是一根管道不断套接着另一根管道，但是IO流是非常有用的，不仅能帮助我们了解计算机底层，而且涉及到数据传输都离不开它。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在涉及IO流之前需要知道文件的概念。文件是数据源（保存数据的的地方）的一种，比如word文件、txt文件。他既可以保存一张图片，也可以保存视
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>直接插入和希尔排序</title>
    <link href="http://www.myzwl.win/2017/07/22/inserSort_1/"/>
    <id>http://www.myzwl.win/2017/07/22/inserSort_1/</id>
    <published>2017-07-22T05:48:51.000Z</published>
    <updated>2017-08-09T04:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>直接插入在本质上改良了之前的冒泡和选择排序，而希尔排序更是超越O（n^2)的传统排序的改良算法</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>算法描述：直接插入排序就是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表<br>首先先定义数据结构</p>
<blockquote>
<p>#define MAXSIZE 10<br>typedef struct{<br>    int r[Maxsize+1]//用于存储要排序的数组，r[0]用作哨兵或者临时变量<br>    int length; //记录顺序表的长度<br>}SqList;</p>
</blockquote>
<p>接下来不妨以5个数模拟该算法执行过程</p>
<blockquote>
<p>初始化为{0,5,3,4,6,2}<br>从第二个数开始往前比较，如3比5小，那么，3赋值给哨兵，5后移到3位置，哨兵赋值给5位置，此时变成<br>{3,3,5,4,6,2}；<br>继续循环，哨兵初始化为0,4比5小，4给哨兵，5后移至4，在比较哨兵与3大小，如果比3小，3后移，在插入到该位置，否则直接插到5位置，ok这就是该算法的核心，在合适的位置直接插入</p>
</blockquote>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>下面在来看算法，一般理解算法的过程，就把自己当做计算机，自我调试，然后就会发现其中无穷的乐趣<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;    </div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;ctype.h&gt;      </div><div class="line">#include &lt;stdlib.h&gt;   </div><div class="line">#include &lt;io.h&gt;  </div><div class="line">#include &lt;math.h&gt;  </div><div class="line">#include &lt;time.h&gt;</div><div class="line"></div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define TRUE 1</div><div class="line">#define FALSE 0</div><div class="line"></div><div class="line"></div><div class="line">typedef int Status; </div><div class="line"></div><div class="line"></div><div class="line">#define MAXSIZE 10000  /* 用于要排序数组个数最大值，可根据需要修改 */</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	int r[MAXSIZE+1];	/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</div><div class="line">	int length;			/* 用于记录顺序表的长度 */</div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line">void InsertSort(SqList *L)</div><div class="line">&#123;</div><div class="line">	int i,j; //i用来控制外层循环，也就是r[i]中每个数，j用来控制r[i]与前面的数大小，并插到合适的位置</div><div class="line">for(i=2;i&lt;=L-&gt;length;i++)&#123;</div><div class="line">   if(L-&gt;r[i]&lt;L-&gt;r[i-1]) //要插的数比前一个数大</div><div class="line">   &#123;</div><div class="line">   	L-&gt;r[0]=L-&gt;r[i];    //要插入的数先放到哨兵</div><div class="line">   	 for(j=i-1;L-&gt;r[j]&gt;L-&gt;r[0];j--) //依次比较插入的数前面的数，放到合适的位置</div><div class="line">   	 	L-&gt;r[j+1]=L-&gt;r[j]; //记录后移</div><div class="line">   	 L-&gt;r[j+1]=L-&gt;r[0];  //插入合适的位置</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void print(SqList L) //打印元素</div><div class="line">&#123;</div><div class="line">	int i;</div><div class="line">	for(i=1;i&lt;L.length;i++)</div><div class="line">		printf("%d,",L.r[i]);</div><div class="line">	printf("%d",L.r[i]);</div><div class="line">	printf("\n");</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	int i;</div><div class="line">      int d[5]=&#123;5,3,4,6,2&#125;;</div><div class="line">        SqList L;</div><div class="line">          for(i=0;i&lt;5;i++)</div><div class="line">          	L.r[i+1]=d[i];</div><div class="line">             L.r[0]=0;</div><div class="line">             L.length=5;</div><div class="line">            printf("直接插入排序:\n");</div><div class="line">             InsertSort(&amp;L);</div><div class="line">              print(L);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面在看看它的时间复杂度，最好的情况就是{2,3,4,5,6}，也就是说其本身已经是一个有序的，很显然只需要L-&gt;r[i]与L-&gt;r[r-1]大小，所以此时时间复杂度为O(n);最坏的情况就是{6,5,4,3,2}，即2+3+。。+n为（n+2)(n-1)/2<br>所以最后根据平局原则，知道直接插入排序的时间复杂度为O(n^2);</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>基本有序</strong><br>首先需要了解一下基本有序的概念，就是指小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，如{2,1,3,6,4,7,5,8,9}，但如{1,5,9,3,7,8,2,4,6}这种9在第三位，2在倒数第三位就不叫基本有序</p>
<p>希尔排序的关键就是将相隔某个”增量”的记录组成一个子序列，实现跳跃式的移动</p>
<blockquote>
<p>初始一个数组{0,9,1,5,8,3,7,4,6,2}，其中0为哨兵<br>并且初始化增量为数组长度（哨兵不算），所以为9，并约定一个循环，当且仅当增量小于等于1退出循环，并且每次增量都执行增量=增量/3+1（也可以是其他增量原则），第一次就是4了<br>然后一个循环变量i从增量+1开始直到小于等于数组长度，然后比较该i值与i-增量值，也就是第一个值大小，后面就是直接插入算法思想了，有一点不一样，就是循环变量j控制不太一样</p>
</blockquote>
<p>然后看看上述数组怎么比较的</p>
<blockquote>
<p>第一次：i=增量+1=5开始，也就是3与9比较，明显满足3&lt;9,然后交换（直接插入思想），依次7与1，不交换，4与5交换，6与8交换，2与9交换这里那个j条件也满足并且2&lt;3在交换，ok得到一个交换后的数组<br>{2,1,4,6,3,7,5,8,9}可以发现经过第一轮后，该数组基本有序了<br>紧接着开始进行第二轮，即增量=增量/3+1=2，即从第三个2与4不交换，1与6不交换，4与3交换，6与7不交换，4与5不交换，7与8不交换，5与9不交换，即得到{2,1,3,6,4,7,5,,8,9};<br>最后一轮：增量为1,2与1交换，2与4不交换，然后依次比较，由于目前已经基本有序，所以交换的比较少，<br>最后得到{1,2,3,4,5,6,7,8,9}</p>
</blockquote>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>通过上面的例子，大概就是希尔排序的模拟过程，可以发现增量值是一个很巧妙的地方<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">void ShellSort(SqList *L)</div><div class="line">&#123;</div><div class="line">  int i,j;</div><div class="line">  int increment=L-&gt;length; //初始化增量为数组长度</div><div class="line">  do&#123;</div><div class="line">    increment=increment/3+1; //增量序列</div><div class="line">    for(i=increment+1;i&lt;=L-&gt;length;i++) //从增量序列后一位开始</div><div class="line">    &#123;</div><div class="line">      if(L-&gt;r[i]&lt;L-&gt;r[i-increment]) //该位置与第一位比较，是否交换</div><div class="line">      &#123;</div><div class="line">        L-&gt;r[0]=L-&gt;r[i]; //若交换，先放到哨兵位置</div><div class="line">         for(j=i-increment;j&gt;0&amp;&amp;L-&gt;r[0]&lt;L-&gt;r[j];j-=increment)</div><div class="line">           L-&gt;r[j+increment]=L-&gt;r[j]; //记录后移</div><div class="line">            L-&gt;r[j+increment]=L-&gt;r[0];//插入到正确位置</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;while(increment&gt;1);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	int i;</div><div class="line">      int d[5]=&#123;5,3,4,6,2&#125;;</div><div class="line">        SqList L;</div><div class="line">          for(i=0;i&lt;5;i++)</div><div class="line">          	L.r[i+1]=d[i];</div><div class="line">             L.r[0]=0;</div><div class="line">             L.length=5;</div><div class="line">            printf("希尔排序:\n");</div><div class="line">           ShellSort(&amp;L);</div><div class="line">               print(L);</div><div class="line">              print(L);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现希尔排序的关键就是增量的选择，而它的时间复杂度是O(n^(3/2)),显然比传统的算法O(n^2)时间复杂度要小很多</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;直接插入在本质上改良了之前的冒泡和选择排序，而希尔排序更是超越O（n^2)的传统排序的改良算法&lt;/p&gt;
&lt;h4 id=&quot;直接插入排序&quot;&gt;&lt;a
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
