<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2017-08-14T12:19:56.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图的深度和广度遍历</title>
    <link href="http://www.myzwl.win/2017/08/01/graph_2/"/>
    <id>http://www.myzwl.win/2017/08/01/graph_2/</id>
    <published>2017-08-01T06:48:51.000Z</published>
    <updated>2017-08-14T12:19:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图是数据结构中最复杂的，正是因为它的复杂，它也是最优魅力的。当然图的存储结构有多种方式，最常用的就是邻接矩阵和邻接表。为了方便，这里图的遍历使用邻接矩阵表示</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><img src="/images/imgs4/35.gif" alt="Alt text"><br>如图，这里只画了无向图，其中顶点由一个一维数组表示，一个二维数组存储图中的边或弧的信息，可以发现无向图是一个对称矩阵，并且约定二维数组arc[i][j]=w，若边（vi，vj）属于该图，arc[i][j]=0，若i=j，否则arc[i][j]=一个无强大值，图中是用1代替了，实际中按上述规则<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">typedef char VertexType; /* 顶点类型应由用户定义 */</div><div class="line">typedef int EdgeType; /* 边上的权值类型应由用户定义 */</div><div class="line"></div><div class="line">#define MAXSIZE 9 /* 存储空间初始分配量 */</div><div class="line">#define MAXEDGE 15</div><div class="line">#define MAXVEX 9</div><div class="line">#define INFINITY 65535</div><div class="line"></div><div class="line">typedef struct&#123;</div><div class="line">	VertexType vexs[MAXVEX];          /* 顶点表 */</div><div class="line">	EdgeType arc[MAXVEX][MAXVEX];     /* 邻接矩阵，可看作边表 */</div><div class="line">	int numVertexes,numEdges;         /* 图中当前的顶点数和边数 */ </div><div class="line">&#125;MGraph;</div><div class="line"></div><div class="line">void CreateMGraph(MGraph *G)</div><div class="line">&#123;</div><div class="line">	int i,j,k,w;</div><div class="line">	printf("输入顶点数和边数:\n");</div><div class="line">	scanf("%d,%d",&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);</div><div class="line">	for(i=0;i&lt;G-&gt;numVertexes;i++)</div><div class="line">		scanf(&amp;G-&gt;vexs[i]);</div><div class="line">	for(i=0;i&lt;G-&gt;numVertexes;i++)</div><div class="line">		for(j=0;j&lt;G-&gt;numVertexes;j++)</div><div class="line">			G-&gt;arc[i][j]=INFINITY;</div><div class="line">		for(k=0;k&lt;G-&gt;numEdges;k++)</div><div class="line">		&#123;</div><div class="line">			printf("输入边（vi，vj）上的下标i，下标j和权值w：\n");</div><div class="line">		     scanf("%d,%d,%d",&amp;i,&amp;j,&amp;w);</div><div class="line">		     G-&gt;arc[i][j]=w;</div><div class="line">		     G-&gt;arc[j][i]=G-&gt;arc[i][j];</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p><img src="/images/imgs4/18.jpg" alt="Alt text"><br>图的遍历就是指从图中某一顶点出发遍历图中其余顶点且使每一个顶点仅被访问一次，然而由于同一个图可能在空间形式上有不同画法，所以造成不能采用之前使用的双亲等方法，所以可以把访问过的顶点打上标记，即设置一个访问数组visited[n]，n是图中原点个数，初值为0，访问过后设置为1，这样就可以避免访问重复的了<br>而深度优先遍历，也叫深度优先搜索，简称DFS，就像在一个房子中搜索一样，从每一个房间开始，而是不留死角的搜索，也就是说该房间内所有地方搜索完，在去搜索其他房间，以此类推<br>从图中可以发现它是一个递归过程，也就是像二叉树的先序遍历，只不过，已经遍历的结点可以跳过</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">void CreateMGraph(MGraph *G)</div><div class="line">&#123;</div><div class="line">	int i, j;</div><div class="line"></div><div class="line">	G-&gt;numEdges=15;</div><div class="line">	G-&gt;numVertexes=9;</div><div class="line"></div><div class="line">	/* 读入顶点信息，建立顶点表 */</div><div class="line">	G-&gt;vexs[0]='A';</div><div class="line">	G-&gt;vexs[1]='B';</div><div class="line">	G-&gt;vexs[2]='C';</div><div class="line">	G-&gt;vexs[3]='D';</div><div class="line">	G-&gt;vexs[4]='E';</div><div class="line">	G-&gt;vexs[5]='F';</div><div class="line">	G-&gt;vexs[6]='G';</div><div class="line">	G-&gt;vexs[7]='H';</div><div class="line">	G-&gt;vexs[8]='I';</div><div class="line"></div><div class="line"></div><div class="line">	for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */</div><div class="line">	&#123;</div><div class="line">		for ( j = 0; j &lt; G-&gt;numVertexes; j++)</div><div class="line">		&#123;</div><div class="line">			G-&gt;arc[i][j]=0;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	G-&gt;arc[0][1]=1;</div><div class="line">	G-&gt;arc[0][5]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[1][2]=1; </div><div class="line">	G-&gt;arc[1][8]=1; </div><div class="line">	G-&gt;arc[1][6]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[2][3]=1; </div><div class="line">	G-&gt;arc[2][8]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[3][4]=1;</div><div class="line">	G-&gt;arc[3][7]=1;</div><div class="line">	G-&gt;arc[3][6]=1;</div><div class="line">	G-&gt;arc[3][8]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[4][5]=1;</div><div class="line">	G-&gt;arc[4][7]=1;</div><div class="line"></div><div class="line">	G-&gt;arc[5][6]=1; </div><div class="line">	</div><div class="line">	G-&gt;arc[6][7]=1; </div><div class="line"></div><div class="line">	</div><div class="line">	for(i = 0; i &lt; G-&gt;numVertexes; i++)</div><div class="line">	&#123;</div><div class="line">		for(j = i; j &lt; G-&gt;numVertexes; j++)</div><div class="line">		&#123;</div><div class="line">			G-&gt;arc[j][i] =G-&gt;arc[i][j];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Boolean visited[MAXSIZE];//访问标志的数组</div><div class="line"></div><div class="line">//深度优先递归算法</div><div class="line">void DFS(MGraph G,int i)&#123;</div><div class="line">	int j;</div><div class="line">	visited[i]=TRUE;</div><div class="line">	printf("%c",G.vexs[i]);</div><div class="line">	for(j=0;j&lt;G.numVertexes;j++)</div><div class="line">		if(G.arc[i][j]==1&amp;&amp;!visited[j]) //对未访问的顶点递归调用</div><div class="line">			DFS(G,j);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//深度遍历</div><div class="line">void DFSTraverse(MGraph G)&#123;</div><div class="line">	int i;</div><div class="line">	for(i=0;i&lt;G.numVertexes;i++) //初始化</div><div class="line">		visited[i]=FALSE;</div><div class="line">	for(i=0;i&lt;G.numVertexes;i++)</div><div class="line">		if(!visited[i])</div><div class="line">			DFS(G,i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	MGraph G;</div><div class="line">	CreateMGraph(&amp;G);</div><div class="line">	printf("\n深度遍历：");</div><div class="line">	DFSTraverse(G);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了方便，就创建图的过程写死，最终深度遍历的结果为ABCDEFGHI</p>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>又称为广度优先搜索，简称BFS，它像二叉树遍历中的层序遍历，也就是一层一层的遍历，如上图，与A相连的有B、F，先遍历，又与B相连的有C,I,G，F相连的有G,E，所以下一层为C,I,G,F，依次类推一层一层遍历<br><img src="/images/imgs4/19.jpg" alt="Alt text"><br>如图它的核心思想就是构造一个队列，每一层的结点，如A出队后，与它相连的下一层结点B、F就要入队开始遍历，然后B遍历完出队，与B相连的下一层结点C、I、J入队，依次类推<br><strong>队列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/* 循环队列的顺序存储结构 */</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	int data[MAXSIZE];</div><div class="line">	int front;    	/* 头指针 */</div><div class="line">	int rear;		/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</div><div class="line">&#125;Queue;</div><div class="line"></div><div class="line">/* 初始化一个空队列Q */</div><div class="line">Status InitQueue(Queue *Q)</div><div class="line">&#123;</div><div class="line">	Q-&gt;front=0;</div><div class="line">	Q-&gt;rear=0;</div><div class="line">	return  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */</div><div class="line">Status QueueEmpty(Queue Q)</div><div class="line">&#123; </div><div class="line">	if(Q.front==Q.rear) /* 队列空的标志 */</div><div class="line">		return TRUE;</div><div class="line">	else</div><div class="line">		return FALSE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列未满，则插入元素e为Q新的队尾元素 */</div><div class="line">Status EnQueue(Queue *Q,int e)</div><div class="line">&#123;</div><div class="line">	if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)	/* 队列满的判断 */</div><div class="line">		return ERROR;</div><div class="line">	Q-&gt;data[Q-&gt;rear]=e;			/* 将元素e赋值给队尾 */</div><div class="line">	Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;/* rear指针向后移一位置， */</div><div class="line">								/* 若到最后则转到数组头部 */</div><div class="line">	return  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</div><div class="line">Status DeQueue(Queue *Q,int *e)</div><div class="line">&#123;</div><div class="line">	if (Q-&gt;front == Q-&gt;rear)			/* 队列空的判断 */</div><div class="line">		return ERROR;</div><div class="line">	*e=Q-&gt;data[Q-&gt;front];				/* 将队头元素赋值给e */</div><div class="line">	Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;	/* front指针向后移一位置， */</div><div class="line">									/* 若到最后则转到数组头部 */</div><div class="line">	return  OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>广度遍历</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/* 邻接矩阵的广度遍历算法 */</div><div class="line">void BFSTraverse(MGraph G)</div><div class="line">&#123;</div><div class="line">	int i, j;</div><div class="line">	Queue Q;</div><div class="line">	for(i = 0; i &lt; G.numVertexes; i++)</div><div class="line">       	visited[i] = FALSE;</div><div class="line">    InitQueue(&amp;Q);		/* 初始化一辅助用的队列 */</div><div class="line">    for(i = 0; i &lt; G.numVertexes; i++)  /* 对每一个顶点做循环 */</div><div class="line">    &#123;</div><div class="line">		if (!visited[i])	/* 若是未访问过就处理 */</div><div class="line">		&#123;</div><div class="line">			visited[i]=TRUE;		/* 设置当前顶点访问过 */</div><div class="line">			printf("%c ", G.vexs[i]);/* 打印顶点，也可以其它操作 */</div><div class="line">			EnQueue(&amp;Q,i);		/* 将此顶点入队列 */</div><div class="line">			while(!QueueEmpty(Q))	/* 若当前队列不为空 */</div><div class="line">			&#123;</div><div class="line">				DeQueue(&amp;Q,&amp;i);	/* 将队对元素出队列，赋值给i */</div><div class="line">				for(j=0;j&lt;G.numVertexes;j++) </div><div class="line">				&#123; </div><div class="line">					/* 判断其它顶点若与当前顶点存在边且未访问过  */</div><div class="line">					if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) </div><div class="line">					&#123; </div><div class="line"> 						visited[j]=TRUE;			/* 将找到的此顶点标记为已访问 */</div><div class="line">						printf("%c ", G.vexs[j]);	/* 打印顶点 */</div><div class="line">						EnQueue(&amp;Q,j);				/* 将找到的此顶点入队列  */</div><div class="line">					&#125; </div><div class="line">				&#125; </div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	MGraph G;</div><div class="line">	CreateMGraph(&amp;G);</div><div class="line">	printf("\n深度遍历：");</div><div class="line">	DFSTraverse(G);</div><div class="line">	printf("\n广度遍历：");</div><div class="line">	BFSTraverse(G);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终的结果是</p>
<blockquote>
<p>A B F C I G E D H</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后发现深度优先和广度优先遍历的时间复杂度是一样的，他们的适用场景不一样，深度优先更适合目标比较明确，已找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;图是数据结构中最复杂的，正是因为它的复杂，它也是最优魅力的。当然图的存储结构有多种方式，最常用的就是邻接矩阵和邻接表。为了方便，这里图的遍历
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>反射机制简单总结</title>
    <link href="http://www.myzwl.win/2017/07/31/reflaction_1/"/>
    <id>http://www.myzwl.win/2017/07/31/reflaction_1/</id>
    <published>2017-07-31T06:48:51.000Z</published>
    <updated>2017-08-13T14:55:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>反射机制是java中非常非常重要的东西，比如以前模拟jdk的代理实现和spring的aop实现都用到了反射（见以前设计模式总结），同时，正是由于反射机制，才让我们能更动态的去写程序，比如说在配置文件中配置配置，就能调用某些方法，是在太方便了，下面就开始探索反射机制，下图是类的加载模型<br><img src="/images/imgs4/33.gif" alt="Alt text"></p>
<h4 id="ClassLoad类加载过程"><a href="#ClassLoad类加载过程" class="headerlink" title="ClassLoad类加载过程"></a>ClassLoad类加载过程</h4><p>它的特点是1.并非一次性加载<br>2.需要的时候加载（运行期动态加载）<br>3.static语句块在加载后执行一次<br>4.dynamic语句块每次new新的对象都会执行（等同于构造方法中语句）<br><strong>程序验证</strong><br>在eclipse中有-verbose:class运行命令可详细的打印出jvm虚拟机第一次在内存中加载类的详细信息，如下：<br>先看模拟的程序<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		new A();		</div><div class="line">		System.out.println("**------------------------**");</div><div class="line">		new B();</div><div class="line">        new C();</div><div class="line">        new C();</div><div class="line">        new D();</div><div class="line">        new D();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class A&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C&#123;</div><div class="line">	static&#123;</div><div class="line">		System.out.println("CCCCCCCCCCCCCCCCCCCCCCCCCCC");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class D&#123;</div><div class="line">	&#123;</div><div class="line">		System.out.println("DDDDDDDDDDDDDDDDDDDDDDDDDDDD");</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中d就是动态方法<br>以下是输出结果</p>
<blockquote>
<p>[Opened E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.lang.Object from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.io.Serializable from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>。。。。。。<br>[Loaded com.zwl.tree.A from file:/E:/ecli/shiro/target/classes/]</p>
<hr>
<p>[Loaded com.zwl.tree.B from file:/E:/ecli/shiro/target/classes/]<br>[Loaded com.zwl.tree.C from file:/E:/ecli/shiro/target/classes/]<br>CCCCCCCCCCCCCCCCCCCCCCCCCCC<br>[Loaded com.zwl.tree.D from file:/E:/ecli/shiro/target/classes/]<br>DDDDDDDDDDDDDDDDDDDDDDDDDDDD<br>DDDDDDDDDDDDDDDDDDDDDDDDDDDD<br>[Loaded java.lang.Shutdown from E:\myeclipse\jdk1.8\jre\lib\rt.jar]<br>[Loaded java.lang.Shutdown$Lock from E:\myeclipse\jdk1.8\jre\lib\rt.jar]</p>
</blockquote>
<p>可以发现，jvm在初始化执行程序时需要加载很多类到内存中，并且是动态加载的，就像A和B中间输出语句打印出来，说明不是一次性加载的，这里静态函数只加载了一次，动态方法每次都会加载，其实还有一点，就是jvm会在类加载时，找到jdk中已有的类加载，加载过了一次，就不加载了如D</p>
<h4 id="classLoad类"><a href="#classLoad类" class="headerlink" title="classLoad类"></a>classLoad类</h4><p>事实上，jdk中有各种各样的ClassLoad将类加载进内存，大致分为以下几种</p>
<blockquote>
<p>一：bootstrap class loader<br>implemented by native language and load ths core classes of jdk<br>也就是说，它不是用java写的，而是用操作系统语言，如c、c++写的加载类，它是最核心的类用于加载java中核心的类，当然他没有具体名字<br>二:extesion class loader<br>loader the class from jre/lib/ext<br>三:application class loader<br>load user-define classes and ClassLoader.getSystemClassLoader()<br>也就是说它是java的核心类用于加载用户自定义的类和其他类<br>四:other class loaders<br>SecureClassLoader、URLClassLoader等等，该类是其他加载类加载其它类</p>
</blockquote>
<p><strong>程序验证</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(String.class.getClassLoader());</div><div class="line">	System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());</div><div class="line">	System.out.println(Test.class.getClassLoader().getClass().getName());</div><div class="line">	System.out.println(ClassLoader.getSystemClassLoader().getClass().getName());</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>null<br>sun.misc.Launcher$ExtClassLoader<br>sun.misc.Launcher$AppClassLoader<br>sun.misc.Launcher$AppClassLoader</p>
</blockquote>
<p>分析一下：String类bootstrap类加载的类，但是它的加载类是空，而DESKeyFactory的的加载类是扩展类，而第三和第四都是java核心类加载，总之，我们知道classload是有多种并且有顺序和层次的<br><img src="/images/imgs4/34.gif" alt="Alt text"></p>
<p>如</p>
<blockquote>
<p>ClassLoader c=Test.class.getClassLoader();<br>        while(c!=null){<br>            System.out.println(c.getClass().getName());<br>            c=c.getParent();<br>        }</p>
</blockquote>
<p>结果：</p>
<blockquote>
<p>sun.misc.Launcher$AppClassLoader<br>sun.misc.Launcher$ExtClassLoader</p>
</blockquote>
<p>注意这里的getparent（）是得到引用，不是继承。也就是说jdk底层深层次加载是，问上一层有没有加载我这个类，如果加载了就不加载了</p>
<h4 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h4><p>从classload的角度来看，内存中的一切包括方法等都是对象，也就是说我们可以动态的调用，jdk中为我们提供了类methods类如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;</div><div class="line">		</div><div class="line">		String str="com.zwl.tree.T";</div><div class="line">		Class c=Class.forName(str);</div><div class="line">		Object o=c.newInstance();</div><div class="line">		Method[] methods=c.getMethods();</div><div class="line">		for(Method m:methods)&#123;</div><div class="line">			if(m.getName().equals("mm"))&#123;</div><div class="line">			m.invoke(o);</div><div class="line">			&#125;</div><div class="line">			if(m.getName().equals("m1"))&#123;</div><div class="line">				m.invoke(o, 1,2);</div><div class="line">				System.out.println(m.getReturnType().getName());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	class T&#123;</div><div class="line">	</div><div class="line">	static&#123;</div><div class="line">		System.out.println("T loader!");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public T()&#123;</div><div class="line">		System.out.println("T constructed!");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	int i;</div><div class="line">	String s;</div><div class="line">	public void m1(int i,int j)&#123;</div><div class="line">		this.i=i+j;	</div><div class="line">		System.out.println(this.i);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void mm()&#123;</div><div class="line">		System.out.println("mm");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String getS()&#123;</div><div class="line">		return s;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<blockquote>
<p>T loader!<br>T constructed!<br>mm<br>3<br>void</p>
</blockquote>
<p>上面的程序通过class提供的forname（）方法将相应的类加载至内存，然后通过newInstance()方法取得实例，methods方法能够得到一个类的所有方法，最后通过public Object invoke(Object obj,Object… args)第二个参数是可变参数，也就是可以有多个参数来调用相应对象的相应方法，而getReturnType()是拿到方法的返回类型，也就是说我们通过class和methods可以动态的调用方法，就好比我们只要在配置文件中配置一下类或方法名，就可以动态的调用类或方法，是在是太方便了</p>
<h4 id="反射一些类常用方法"><a href="#反射一些类常用方法" class="headerlink" title="反射一些类常用方法"></a>反射一些类常用方法</h4><p><strong>ClassLoader常用方法</strong></p>
<blockquote>
<p>public abstract class ClassLoaderextends Object<br>构造方法：<br>protected ClassLoader()：使用方法 getSystemClassLoader() 返回的 ClassLoader 创建一个新的类加载器，将该加载器作为父类加载器<br>protected ClassLoader(ClassLoader parent)：使用指定的、用于委托操作的父类加载器创建新的类加载器<br>public final ClassLoader getParent()：返回委托的父类加载器<br>public URL getResource(String name)：查找具有给定名称的资源。</p>
</blockquote>
<p><strong>Class常用方法</strong></p>
<blockquote>
<p>public final class Class<t>extends Objectimplements Serializable, GenericDeclaration, Type, AnnotatedElement<br>Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的<br>public static Class&lt;?&gt; forName(String className)throws ClassNotFoundException：返回与带有给定字符串名的类或接口相关联的 Class 对象<br>public ClassLoader getClassLoader()：返回该类的类加载器<br>public Method[] getMethods()throws SecurityException：返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。<br>public String getName()：以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称<br>public String getName()：查找带有给定名称的资源。<br>public T newInstance()throws InstantiationException,IllegalAccessException： 创建此 Class 对象所表示的类的一个新实例。</t></p>
</blockquote>
<p><strong>Methods类常用方法</strong></p>
<blockquote>
<p>public final class Methodextends AccessibleObjectimplements GenericDeclaration, Member<br>public String getName():以 String 形式返回此 Method 对象表示的方法名称。<br>public Class&lt;?&gt; getReturnType():返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型。<br>public Object invoke(Object obj,<br>                     Object… args)<br>              throws IllegalAccessException,<br>                     IllegalArgumentException,<br>                     InvocationTargetException<br> 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法,此方法为可变参数   </p>
</blockquote>
<p> 反射的知识其实是很复杂的，这里只做了一次简单的总结，反射的应用也是在太广了，像strcts、spring、hibernate、mybatis、spring mvc包括shiro等等框架，你会发现他们的很多底层实现都基于反射机制。。             </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;反射机制是java中非常非常重要的东西，比如以前模拟jdk的代理实现和spring的aop实现都用到了反射（见以前设计模式总结），同时，正是
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树之压缩与解压</title>
    <link href="http://www.myzwl.win/2017/07/30/huffman_2/"/>
    <id>http://www.myzwl.win/2017/07/30/huffman_2/</id>
    <published>2017-07-30T06:48:51.000Z</published>
    <updated>2017-08-13T12:14:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>压缩与解压的另一种说法就是，压缩相当于对文件的加密过程，解压相当于对文件的解密过程，比如说，盲-z，僧-w，那么盲僧-zw，当然加密与解密各种各样，不一定非是字符型的</p>
<h4 id="压缩对比"><a href="#压缩对比" class="headerlink" title="压缩对比"></a>压缩对比</h4><p><img src="/images/imgs4/29.gif" alt="Alt text"><br>如图，最左边是未压缩的原始txt文本文件，里面有38个字节，所以占38字节，中间是利用哈夫曼编码压缩的，居然只占15个字节，最右边是好压自带的压缩，占185个字节，通过对比，发现哈夫曼压缩居然节约这么多空间！</p>
<h4 id="压缩原理"><a href="#压缩原理" class="headerlink" title="压缩原理"></a>压缩原理</h4><p>计算机只能存储二进制数，即非0即1，比如刚学c语言那会接触到的ASCII码，它是专门处理英文的，比如一个字节占8位（由8个01串组成）来表示各种英文字母以及符号，比如0在ASCII编码的十进制表示是48（00110000），a是97，所以英文共有2的8次方个，但是汉字远远不止256个，所以一个汉字用两个字节表示，所以共有2的16次方汉字，而汉字编码一般用UTF-8和GBK等<br><strong>存储过程</strong><br>比如在文件中存储aaabbc，理论上占6个字节，并且存储的二进制为01100001（a）01100001（a）01100001（a）01100010 （b）01100010 （b）01100011 （c）那么哈夫曼是怎么存储该数据的了<br>它是根据某个字出现的次数，比如a出现3次，b出现2次，c出现1次，将次数作为相应字的权值来构造哈夫曼树的<br><img src="/images/imgs4/30.gif" alt="Alt text"><br>所以得到：哈夫曼编码为a（1），b（01），c（00），所以的到压缩后的编码为aaabbc（111010100），注意这里变成2个字节了，然后将该二进制转换成10进制就行了</p>
<h4 id="压缩实现"><a href="#压缩实现" class="headerlink" title="压缩实现"></a>压缩实现</h4><p>一般有以下步骤<br>1.读取文件，统计文件中每个字节出现的次数，将该次数作为权值<br>2.根据权值构建哈夫曼树<br>3，根据哈夫曼树构建码表<br>4在读取文件，通过码表对文件中读取的字节进行加密处理<br><img src="/images/imgs4/31.gif" alt="Alt text"><br>在这里定义了一个256的整型数组（存取次数作为权值）和一个256的字符串数组（存取哈夫曼编码值）</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p><strong>哈夫曼结点</strong><br>与之前不同的是增加了索引，便于搜索<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class HuffmNode &#123;</div><div class="line">	//数据域  </div><div class="line">    private int data;  </div><div class="line">    //索引  </div><div class="line">    private int index;  </div><div class="line">    //左子节点  </div><div class="line">    private HuffmNode left;  </div><div class="line">    //右子节点  </div><div class="line">    private HuffmNode right;  </div><div class="line">      </div><div class="line">    //哈夫曼节点的构造函数  </div><div class="line">    public HuffmNode(int data,int index)&#123;  </div><div class="line">        this.data=data;  </div><div class="line">        this.index=index;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //私有属性的封装  </div><div class="line">    public int getData() &#123;  </div><div class="line">        return data;  </div><div class="line">    &#125;  </div><div class="line">    public void setData(int data) &#123;  </div><div class="line">        this.data = data;  </div><div class="line">    &#125;  </div><div class="line">    public int getIndex() &#123;  </div><div class="line">        return index;  </div><div class="line">    &#125;  </div><div class="line">    public void setIndex(int index) &#123;  </div><div class="line">        this.index = index;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getLeft() &#123;  </div><div class="line">        return left;  </div><div class="line">    &#125;  </div><div class="line">    public void setLeft(HuffmNode left) &#123;  </div><div class="line">        this.left = left;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getRight() &#123;  </div><div class="line">        return right;  </div><div class="line">    &#125;  </div><div class="line">    public void setRight(HuffmNode right) &#123;  </div><div class="line">        this.right = right;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>压缩实现类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">public class Compress &#123;</div><div class="line"></div><div class="line">	 public int[] times=new int[256];</div><div class="line">	 public String[] HuffmCodes=new String[256];</div><div class="line">	 public LinkedList&lt;HuffmNode&gt; list = new LinkedList&lt;HuffmNode&gt;();  </div><div class="line"></div><div class="line">	//初始化 </div><div class="line">     public Compress()&#123;</div><div class="line">    	 for(int i=0;i&lt;HuffmCodes.length;i++)</div><div class="line">    	 &#123;</div><div class="line">    		 HuffmCodes[i]="";</div><div class="line">    	 &#125;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     public void countTimes(String path)throws Exception&#123;</div><div class="line">    	//构造文件输入流</div><div class="line">    	 FileInputStream fis=new FileInputStream(path);</div><div class="line">    	//读取文件  </div><div class="line">    	 int value=fis.read();</div><div class="line">    	 while(value!=-1)&#123;</div><div class="line">    		 times[value]++;</div><div class="line">    		 value=fis.read();</div><div class="line">    	 &#125;</div><div class="line">    	 fis.close(); </div><div class="line">     &#125;</div><div class="line">     </div><div class="line">   //构造哈夫曼树 </div><div class="line">     public HuffmNode createTree()&#123;  </div><div class="line">         //将次数作为权值构造森林  </div><div class="line">         for (int i = 0; i &lt; times.length; i++) &#123;  </div><div class="line">             if(times[i]!=0)&#123;  </div><div class="line">                 HuffmNode node = new HuffmNode(times[i],i);  </div><div class="line">                 //将构造好的节点加入到容器中的正确位置  </div><div class="line">                 list.add(getIndex(node), node);  </div><div class="line">             &#125;  </div><div class="line">         &#125;  </div><div class="line">           </div><div class="line">         //将森林（容器中的各个节点）构造成哈夫曼树  </div><div class="line">         while(list.size()&gt;1) &#123;  </div><div class="line">             //获取容器中第一个元素（权值最小的节点）  </div><div class="line">             HuffmNode firstNode =list.removeFirst();  </div><div class="line">             //获取中新的第一个元素，原来的第一个元素已经被移除了（权值次小的节点）  </div><div class="line">             HuffmNode secondNode =list.removeFirst();  </div><div class="line">             //将权值最小的两个节点构造成父节点  </div><div class="line">             HuffmNode fatherNode =  </div><div class="line">                     new HuffmNode(firstNode.getData()+secondNode.getData(),-1);  </div><div class="line">             fatherNode.setLeft(firstNode);  </div><div class="line">             fatherNode.setRight(secondNode);  </div><div class="line">             //父节点加入到容器中的正确位置  </div><div class="line">             list.add(getIndex(fatherNode),fatherNode);  </div><div class="line">         &#125;  </div><div class="line">         //返回整颗树的根节点  </div><div class="line">         return list.getFirst();  </div><div class="line">     &#125;  </div><div class="line">     </div><div class="line">   //利用前序遍历获取编码表  </div><div class="line">     public void getHuffmCode(HuffmNode root,String code)&#123;  </div><div class="line">         //往左走，哈夫曼编码加0  </div><div class="line">         if(root.getLeft()!=null)&#123;  </div><div class="line">             getHuffmCode(root.getLeft(),code+"0");  </div><div class="line">         &#125;  </div><div class="line">         //往右走，哈夫曼编码加1  </div><div class="line">         if(root.getRight()!=null)&#123;  </div><div class="line">             getHuffmCode(root.getRight(),code+"1");  </div><div class="line">         &#125;  </div><div class="line">         //如果是叶子节点，返回该叶子节点的哈夫曼编码  </div><div class="line">         if(root.getLeft()==null &amp;&amp; root.getRight()==null)&#123;  </div><div class="line">//           System.out.println(root.getIndex()+"的编码为："+code);  </div><div class="line">             HuffmCodes[root.getIndex()]=code;  </div><div class="line">         &#125;  </div><div class="line">     &#125;  </div><div class="line">     </div><div class="line">   //压缩文件 </div><div class="line">     public void compress(String path,String destpath)throws Exception&#123;</div><div class="line">    	//构建文件输出流  </div><div class="line">    	 FileOutputStream fos=new FileOutputStream(destpath);</div><div class="line">    	 FileInputStream fis=new FileInputStream(path);</div><div class="line">    	        </div><div class="line">         //读文件，并将对应的哈夫曼编码串接成字符串  </div><div class="line">    	 int value=fis.read();</div><div class="line">    	 String str="";</div><div class="line">    	 while(value!=-1)&#123;</div><div class="line">    		 str+=HuffmCodes[value];</div><div class="line">    		 value=fis.read();</div><div class="line">    	 &#125;</div><div class="line">    	 System.out.println(str);</div><div class="line">    	 fis.close();</div><div class="line">    	 </div><div class="line">    	 String s="";</div><div class="line">    	 while(str.length()&gt;=8)&#123;</div><div class="line">    		 s=str.substring(0, 8);</div><div class="line">    		 int b=changeStringToInt(s);</div><div class="line">    		 fos.write(b);</div><div class="line">    		 fos.flush();</div><div class="line">    		 str=str.substring(8);</div><div class="line">    	 &#125;</div><div class="line">    	 </div><div class="line">    	 int last1=8-str.length();</div><div class="line">    	 for(int i=0;i&lt;last1;i++)&#123;</div><div class="line">    		 str+="0";</div><div class="line">    	 &#125;</div><div class="line">    	 s=str.substring(0, 8);  </div><div class="line">         int d=changeStringToInt(s);  </div><div class="line">         fos.write(d);</div><div class="line">         fos.close();</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">   //插入元素位置的索引  </div><div class="line">     public int getIndex(HuffmNode node) &#123;  </div><div class="line">         for (int i = 0; i &lt; list.size(); i++) &#123;  </div><div class="line">             if(node.getData()&lt;=list.get(i).getData())&#123;  </div><div class="line">                 return i;  </div><div class="line">             &#125;  </div><div class="line">         &#125;  </div><div class="line">        return list.size();  </div><div class="line">     &#125;  </div><div class="line">	 </div><div class="line">   //将字符串转换成整数  </div><div class="line">     public int changeStringToInt(String s)&#123; </div><div class="line">    	 int v1=(s.charAt(0)-48)*128;  </div><div class="line">         int v2=(s.charAt(1)-48)*64;  </div><div class="line">         int v3=(s.charAt(2)-48)*32;  </div><div class="line">         int v4=(s.charAt(3)-48)*16;  </div><div class="line">         int v5=(s.charAt(4)-48)*8;  </div><div class="line">         int v6=(s.charAt(5)-48)*4;  </div><div class="line">         int v7=(s.charAt(6)-48)*2;  </div><div class="line">         int v8=(s.charAt(7)-48)*1;  </div><div class="line">         return v1+v2+v3+v4+v5+v6+v7+v8;</div><div class="line">     &#125; </div><div class="line">	 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有几处需要注意下，首先changeStringToInt(String s）方法是根据二进制的定义做转换的，void countTimes(String path)throws Exception中那个value是根据其相应的字节的ASCII码值得，比如a是97，就是times[97]++，初始值都是0；<br>然后void compress(String path,String destpath)throws Exception中读文件刚开始是取8位然后转成int在写进文件，然后取第8未到末尾，在循环直至最后不足8位，在后面补0，在写进去。</p>
<p><strong>测试类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//创建压缩对象  </div><div class="line">      Compress compress = new Compress();  </div><div class="line">      //统计文件中0-255出现的次数  </div><div class="line">      compress.countTimes("C:\\Users\\Administrator\\Desktop\\test.txt");  </div><div class="line">      //构造哈夫曼树，并得到根节点  </div><div class="line">      HuffmNode root=compress.createTree();  </div><div class="line">      //得到哈夫曼编码  </div><div class="line">      compress.getHuffmCode(root, "");  </div><div class="line">      //压缩文件  </div><div class="line">      compress.compress("C:\\Users\\Administrator\\Desktop\\test.txt",  </div><div class="line">              "C:\\Users\\Administrator\\Desktop\\tes.zip");</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>1011010101110010110101011011011011100111011110011000010000100111010100010000010011111101101111110111111011000010000100</p>
</blockquote>
<p>同时会生成一个压缩文件，如前面的图所示</p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p><strong>解压原理</strong><br>之前说过哈夫曼编码不会出现像0和01这样前者是后者子串的情况，所以解压采取的办法就是在压缩时写进去每个编码的长度和对应的编码，就像密码本一样，记录着每个密码的详细信息（这里理解每个密码长度和密码数据域唯一确定一个解码）<br>打个比方，假设ab压缩后为0和10，当然压缩后是变成010，那怎么解码了？，首先在压缩时，在之前压缩代码上加上一个记录编码长度和对应的编码，像a不是97吗，那在写入时记录code[97]=1，对应的编码str[97]=0，code[98]=1；str[98]=0，一次类推，写入时是先写入编码长度的，不过要将字符串转换成十进制，然后通过字符串分割成不同编码，这样每个字节也就拿到手了<br>模拟一下，不妨把abbcc先压缩，然后读出它的二进制如下</p>
<blockquote>
<p>000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015214308</p>
</blockquote>
<p>再来分析分析：<br>前面在152之前都是存取密码长度的信息，212是对应ASSII码的相应字节的编码长度，如a（10）、b（0），c（11）所以长度分别对应212，接下来就是152也就是abc的二进制值了，10011，不足8位后面补0，即10011000，对应十进制就是152，后面143就是文本的需要解密的编码，后面08没有弄懂，在压缩文件中并没有输入这个东西，也做了大量实验发现都有后面这些数字，暂且认为就是压缩文件自带的标识吧（逻辑上还没有证明，所以勉强这么认为）<br>所以，解码思路就是先根据长度读取相应位置，然后分割每个位置得到相应二进制编码，最后再转回来，看看编码的打印结果</p>
<blockquote>
<p>0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000212000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000codeLength:1<br>int152<br>哈夫曼编码：10011000<br>huff10<br>huff0<br>huff11<br>需要解密的字符串：10001111<br>截取的字符串：10<br>截取后剩余编码长度：6<br>截取的字符串：0<br>截取后剩余编码长度：5<br>截取的字符串：0<br>截取后剩余编码长度：4<br>截取的字符串：11<br>截取后剩余编码长度：2<br>截取的字符串：11<br>截取后剩余编码长度：0</p>
</blockquote>
<p>不是很规范，但是大概跟踪了过程，长度为5（10011），不足8位不以为，所以codeLength为1,152就是哈夫曼密码手册值了，变成二进制为10011000，然后分割成10,0,11分别对应ASSII码为a、b、c三个字符，需要解密的是10001111，也就是143，解密分别对应abbcc，所以至此完成解密了<br>说了这么多，再来看看代码吧</p>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><p><strong>压缩编码</strong><br>由于解压需要的压缩编码在之前主要修改一点，所以这里就把增加的代码贴出来，分析分析<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//将整个哈夫曼编码以及每个编码的长度写入文件  </div><div class="line">     String code ="";  </div><div class="line">     for (int i = 0; i &lt; 256; i++) &#123;  </div><div class="line">         fos.write(HuffmCodes[i].length());  </div><div class="line">         code+=HuffmCodes[i];  </div><div class="line">         fos.flush();  </div><div class="line">     &#125;  </div><div class="line">     //把哈夫曼编码写入文件  </div><div class="line">       </div><div class="line">  System.out.println("code="+code);  </div><div class="line">     String str1="";  </div><div class="line">     while(code.length()&gt;=8)&#123;  </div><div class="line">         str1=code.substring(0, 8);  </div><div class="line">         int c=changeStringToInt(str1);  </div><div class="line">      System.out.println(c);  </div><div class="line">         fos.write(c);  </div><div class="line">         fos.flush();  </div><div class="line">         code=code.substring(8);  </div><div class="line">     &#125;  </div><div class="line">     //处理最后一个不为8的数  </div><div class="line">     int last=8-code.length();  </div><div class="line">     for (int i = 0; i &lt;last; i++) &#123;  </div><div class="line">         code+="0";  </div><div class="line">     &#125;  </div><div class="line">     str1=code.substring(0, 8);  </div><div class="line">     int c=changeStringToInt(str1); </div><div class="line">     System.out.println("c:"+c);</div><div class="line">     fos.write(c);  </div><div class="line">     fos.flush();</div></pre></td></tr></table></figure></p>
<p>上面代码是说首先我们已经统计了文本中字符出现的次数，压缩那里已经写过了，然后将长度表写入进压缩文件，也就是那一大串000中间含有长度的字符串，存在code里，注意长度为空就是空字符，所以code就是那5位的二进制，然后不足8位的补成8位，再变成十进制也就是152了，这是这段代码与之前增加的部分，我们也称为码表构造</p>
<p><strong>解压实现类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line">//每个编码的长度  </div><div class="line">    public int [] codelengths = new int [256];  </div><div class="line">    //对应的哈夫曼编码值  </div><div class="line">    public String [] codeMap=new String[256];  </div><div class="line">    </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		 Decompress d = new Decompress();  </div><div class="line">	        d.decompress("C:\\Users\\Administrator\\Desktop\\tes.zip",  </div><div class="line">	                "C:\\Users\\Administrator\\Desktop\\mytes.txt"); </div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/* </div><div class="line">     * 解压思路： </div><div class="line">     * 1、读取文件里面的码表 </div><div class="line">     * 2、得到码表 </div><div class="line">     * 3、读取数据 </div><div class="line">     * 4、还原数据 </div><div class="line">     */  </div><div class="line">      </div><div class="line">    public void decompress(String srcpath,String destpath) &#123;  </div><div class="line">    	   </div><div class="line">        try &#123;  </div><div class="line">            FileInputStream fis = new FileInputStream(srcpath);  </div><div class="line">            FileOutputStream fos = new FileOutputStream(destpath);  </div><div class="line">            int zwl;</div><div class="line">            int value;  </div><div class="line">            int codeLength=0;  </div><div class="line">            String code="";  </div><div class="line">            //还原码表  </div><div class="line">            for (int i = 0; i &lt; codelengths.length; i++) &#123;  </div><div class="line">                value=fis.read();  </div><div class="line">                codelengths[i]=value;  </div><div class="line">             System.out.print(codelengths[i]);  </div><div class="line">                codeLength+=codelengths[i];  </div><div class="line">            &#125;  </div><div class="line">           // System.out.println("总长度:"+codeLength);</div><div class="line">            //得到总长度  </div><div class="line">            //将总长度除以8的到字节个数  </div><div class="line">            int len=codeLength/8;  </div><div class="line">            //如果不是8的倍数，则字节个数加1（对应压缩补0的情况）  </div><div class="line">            if((codeLength)%8!=0)&#123;  </div><div class="line">                len++;  </div><div class="line">            &#125;  </div><div class="line">            //读取哈夫曼编码  </div><div class="line">          System.out.println("codeLength:"+len);  </div><div class="line">            for (int i = 0; i &lt; len; i++) &#123;  </div><div class="line">                //把读到的整数转换成二进制  </div><div class="line">            	int s=fis.read();</div><div class="line">            	System.out.println("int"+s);</div><div class="line">                code+=changeIntToString(s);  </div><div class="line">                  </div><div class="line">            &#125;  </div><div class="line">          System.out.println("哈夫曼编码："+code);  </div><div class="line">              </div><div class="line">            for (int i = 0; i &lt; codeMap.length; i++) &#123;  </div><div class="line">                //如果第i个位置不为0 ，则说明第i个位置存储有哈夫曼编码  </div><div class="line">                if(codelengths[i]!=0)&#123;  </div><div class="line">                    //将得到的一串哈夫曼编码按照长度分割分割  </div><div class="line">                    String ss=code.substring(0, codelengths[i]);  </div><div class="line">                    codeMap[i]=ss;  </div><div class="line">                    System.out.println("huff"+codeMap[i]);</div><div class="line">                    code=code.substring(codelengths[i]);  </div><div class="line">                &#125;else&#123;  </div><div class="line">                    //为0则没有对应的哈夫曼编码  </div><div class="line">                    codeMap[i]="";  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">              </div><div class="line">            //读取压缩的文件内容  </div><div class="line">            String codeContent="";  </div><div class="line">            while(fis.available()&gt;1)&#123;  </div><div class="line">                codeContent+=changeIntToString(fis.read());  </div><div class="line">            &#125;  </div><div class="line">            //读取最后一个  </div><div class="line">            value=fis.read();  </div><div class="line">            //把最后补的0给去掉  </div><div class="line">            codeContent=codeContent.substring(0, codeContent.length()-value);  </div><div class="line">                  </div><div class="line">            for (int i = 0; i &lt; codeContent.length(); i++) &#123;  </div><div class="line">                  </div><div class="line">                String codecontent=codeContent.substring(0, i+1);  </div><div class="line">                  </div><div class="line">                for (int j = 0; j &lt; codeMap.length; j++) &#123;  </div><div class="line">                    if(codeMap[j].equals(codecontent))&#123;  </div><div class="line">                     System.out.println("截取的字符串："+codecontent);  </div><div class="line">                        fos.write(j);  </div><div class="line">                        fos.flush();   </div><div class="line">                        codeContent=codeContent.substring(i+1);  </div><div class="line">                    System.out.println("截取后剩余编码长度："+codeContent.length());  </div><div class="line"> </div><div class="line">                        i=-1;  </div><div class="line">                        break;  </div><div class="line">                    &#125;  </div><div class="line">            &#125;  </div><div class="line">            &#125;  </div><div class="line"></div><div class="line">              </div><div class="line">            fos.close();  </div><div class="line">            fis.close();  </div><div class="line">              </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //十进制转二进制字符串  </div><div class="line">    public String changeIntToString(int value) &#123;  </div><div class="line">        String s="";  </div><div class="line">        for (int i = 0; i &lt; 8; i++) &#123;  </div><div class="line">            s=value%2+s;  </div><div class="line">            value=value/2;  </div><div class="line">        &#125;  </div><div class="line">        return s;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的codelengths[]和codeMap[]就是分别存放码表和码表值的数组，流程就是先读取文本内容，拿到长度表中有长度的编码，如212，然后判断其是多少个字节，然后读哈夫曼编码，根据字节数，转成二进制后，找到对应的码表，然后就是分割编码了，最后就得到我们想要的解码了。最后<br><img src="/images/imgs4/32.gif" alt="Alt text"><br>分别为压缩前，压缩后的，会发现压缩居然比压缩前占得空间还大，那是因为我们压缩的文件太小了，而之前也比较过了，压缩一般都是针对大文件的</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后不得不说哈夫曼树的精妙让人惊叹和着迷，同时也认识到了计算机底层知识的重要性，当你回过头来再去看以前的知识，会有另一种不同的感受，当然当再去看压缩与解压，原来是这么回事。当然探索的过程是很累的，会遇到各种难题和挫折，而在当下这个追求功利主义，很多时候都是表象的去用一些东西，当然有时候你把时间花在一些与收益不是很正相关的上面，可能会让你的性价比不是很高，但是正是由于这种自娱自乐的快乐，才更让人充实，而不是每天都去追求“外功”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;压缩与解压的另一种说法就是，压缩相当于对文件的加密过程，解压相当于对文件的解密过程，比如说，盲-z，僧-w，那么盲僧-zw，当然加密与解密各
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树之构建</title>
    <link href="http://www.myzwl.win/2017/07/30/huffman_1/"/>
    <id>http://www.myzwl.win/2017/07/30/huffman_1/</id>
    <published>2017-07-30T05:48:51.000Z</published>
    <updated>2017-08-13T12:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到哈夫曼树，就不得不说它在压缩与解压方面的应用太完美了，就是把一个大的文件，通过算法压缩成一个较小的文件，从而大大节约了空间</p>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>通俗的说就是给定n个权值作为n个叶子结点，构造一颗二叉树，若带权路径长度达到最小，称这样的树为哈夫曼树，也称为最优二叉树，同时，由定义可知，哈夫曼树是带权路径长度最短的树，所以权值较大的结点离根较近<br><img src="/images/imgs4/17.jpg" alt="Alt text"></p>
<h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><p><strong>路径长度</strong><br>结点路径长度：从树中一个结点到另一个结点之间的分支，构成两个结点之间路径，路径上的分支数目称为结点长度，如结点100到结点29的结点路径长度就是2</p>
<p>树的路径长度：从树根到每一个结点的路径长度之和</p>
<p><strong>权值</strong><br>所有叶子结点的date域，也就是当前叶子结点存放的数据域<br><strong>带权路径长度</strong><br>结点带权路径长度：从该节点到树根之间的路径长度与结点上权值的乘积<br>树的带权路径长度：树中所有结点的带权路径长度之和，并且几位WPL，如果WPL最小，则称该二叉树为哈夫曼树</p>
<p><strong>哈夫曼树构建过程</strong><br>它的构建思想其实很简单的，大概如下<br>1.根据给定的n个权值{w1,w2,..wn}构成n棵二叉树的集合F={T1,T2,..Tn};其中每棵二叉树Ti中只有一个带权为wi的根结点，器左右子树为空<br>2：在F中选取两颗根结点权值最小的树作为左右子树构造一颗新二叉树，并且新二叉树的根结点权值为左右子根结点的权值之和<br>3:在F中删除这两颗树，同时将新二叉树加入F中<br>4:重复2和3步骤，知道F中只含一棵树为止</p>
<h4 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h4><p>哈夫曼结点<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class HuffmNode &#123;</div><div class="line">	//构造HuffmNode类  </div><div class="line">    private int data;  </div><div class="line">    private HuffmNode left;  </div><div class="line">    private HuffmNode right;  </div><div class="line">    //HuffmNode类构造函数  </div><div class="line">    public  HuffmNode(int data) &#123;  </div><div class="line">        this.data=data;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //封装属性  </div><div class="line">    public int getData() &#123;  </div><div class="line">        return data;  </div><div class="line">    &#125;  </div><div class="line">    public void setData(int data) &#123;  </div><div class="line">        this.data = data;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getLeft() &#123;  </div><div class="line">        return left;  </div><div class="line">    &#125;  </div><div class="line">    public void setLeft(HuffmNode left) &#123;  </div><div class="line">        this.left = left;  </div><div class="line">    &#125;  </div><div class="line">    public HuffmNode getRight() &#123;  </div><div class="line">        return right;  </div><div class="line">    &#125;  </div><div class="line">    public void setRight(HuffmNode right) &#123;  </div><div class="line">        this.right = right;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造哈夫曼树<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class HuffmTree &#123;  </div><div class="line">      </div><div class="line">    public int [] datas =&#123;42,8,19,100,58,15,29&#125;;  </div><div class="line">    public LinkedList&lt;HuffmNode&gt; list = new LinkedList&lt;HuffmNode&gt;();  </div><div class="line">      </div><div class="line">    public HuffmNode createTree() &#123;  </div><div class="line">        //按照从小到大的将数据封装成节点  </div><div class="line">        for (int i = 0; i &lt; datas.length; i++) &#123;  </div><div class="line">            HuffmNode node = new HuffmNode(datas[i]);  </div><div class="line">            //得到需要插入的位置索引  </div><div class="line">            int index=getIndex(node);  </div><div class="line">            //将数据添加到容器中  </div><div class="line">            list.add(index, node);  </div><div class="line">        &#125;  </div><div class="line">        //构造哈夫曼树  </div><div class="line">        while(list.size()&gt;1)&#123;  </div><div class="line">            //移除容器中的第一个节点  </div><div class="line">            HuffmNode firstNode =list.removeFirst();  </div><div class="line">            //容器中原来的第二个节点变成新的第一个节点  </div><div class="line">            HuffmNode secondNode =list.removeFirst();  </div><div class="line">            //构造父节点数据域  </div><div class="line">            HuffmNode fatherNode = new HuffmNode(firstNode.getData()+secondNode.getData());  </div><div class="line">            //构造父节点左子叶  </div><div class="line">            fatherNode.setLeft(firstNode);  </div><div class="line">            //构造父节点右子叶  </div><div class="line">            fatherNode.setRight(secondNode);  </div><div class="line">            //得到构造好的父节点的索引  </div><div class="line">            int index=getIndex(fatherNode);  </div><div class="line">            //将父节点加入森林  </div><div class="line">            list.add(index, fatherNode);  </div><div class="line">        &#125;  </div><div class="line">        //返回根节点  </div><div class="line">        return list.getFirst();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //得到索引  </div><div class="line">    public int getIndex(HuffmNode node) &#123;  </div><div class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;  </div><div class="line">            if(node.getData()&gt;list.get(i).getData())&#123;  </div><div class="line">                continue;  </div><div class="line">            &#125;else &#123;  </div><div class="line">                return i;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        //如果比容器中的任何一个数大，则插入最后面  </div><div class="line">        return list.size();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //得到哈夫曼编码  </div><div class="line">    public void getHuffmCode(HuffmNode root,String code) &#123;  </div><div class="line">        if(root.getLeft()!=null)&#123;  </div><div class="line">            getHuffmCode(root.getLeft(),code+"0");  </div><div class="line">        &#125;  </div><div class="line">        if(root.getRight()!=null)&#123;  </div><div class="line">            getHuffmCode(root.getRight(),code+"1");  </div><div class="line">        &#125;  </div><div class="line">        if(root.getLeft()==null &amp;&amp; root.getRight()==null)&#123;  </div><div class="line">            System.out.println(root.getData()+":"+code);  </div><div class="line">        &#125;  </div><div class="line">    &#125;   </div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实这段代码就是上述四个步骤的实现，代码也很好理解，带权值为datas，将结点放到链表中，然后注意利用非正规的选择排序将链表集合里权值从小到大排好序，然后开始选择权值最小的两个构造一个新的权值结点，同时删除那两个，加入这个新的。。重复直到只剩一个根结点为止，很明显此时就是哈夫曼树了，最后通过后序遍历得到哈夫曼编码值，这里我们约定左子树一个路径为0，右子树一个路径为1，所以一定不存在像01与010这样前面是后面子串的编码值<br><strong>测试类</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		 HuffmTree tree = new HuffmTree();  </div><div class="line">	        HuffmNode root = tree.createTree();</div><div class="line">	        tree.getHuffmCode(root, ""); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>8:000<br>11:001<br>23:01<br>14:100<br>7:1010<br>3:10110<br>5:10111<br>29:11</p>
</blockquote>
<p>注意这里的结果和图示有一个地方不一样，就是那个几点8，这里的结点8是合成的，可以根据结果画出哈夫曼树，比较就会看出不同</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;说到哈夫曼树，就不得不说它在压缩与解压方面的应用太完美了，就是把一个大的文件，通过算法压缩成一个较小的文件，从而大大节约了空间&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>网络编程简单总结</title>
    <link href="http://www.myzwl.win/2017/07/29/socket_1/"/>
    <id>http://www.myzwl.win/2017/07/29/socket_1/</id>
    <published>2017-07-29T05:48:51.000Z</published>
    <updated>2017-08-12T08:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/images/imgs4/16.jpg" alt="Alt text"><br>在java网络编程中最主要的是tcp/ip协议，这个协议也是Internet最基本的协议，而其就是由网络层的ip协议和传输层的tcp协议组成，同时由于分层的思想，也就是每一层只能与它下面的层打交道，也就是说，应用层只跟传输层打交道，传输层只跟网络层打交道</p>
<h4 id="ip协议"><a href="#ip协议" class="headerlink" title="ip协议"></a>ip协议</h4><p><img src="/images/imgs4/27.gif" alt="Alt text"><br>关于底层协议的具体过程是在太复杂了，当初学习计算机网络的时候也是被各种细节弄得云里雾里的，总之ip层就是唯一确定了一台机器，就像我们住的房间地址一样，唯一确定了我们的住处<br>这里需要注意的是，ip地址由四位字节组成，每个字节由8位二进制组成，同时有a，b，c三类地址，如图由网络号和主机号组成，当然这是公网，如果是局域网的话，就需要配网关和子网掩码了，如192.168.1.1和255.255.0.0那么255.255就是确定了ip地址哪几位字节是网络号，如192.168就是网络号，当然其配置各种内网ip是很复杂的，具体参考计算机网络</p>
<h4 id="TCP与UDP协议"><a href="#TCP与UDP协议" class="headerlink" title="TCP与UDP协议"></a>TCP与UDP协议</h4><p><strong>tcp协议</strong></p>
<blockquote>
<p>它是专门设计用于在不可靠的因特网上提供端到端的字节流通信的协议，它是一种面向连接的协议，它连接的是字节流。<br>这里面有几个注意的地方：<br>可靠性：就是建立三次握手过程，就是说，我把信息传给你，等待，收到回复后，在确认。。最后在发送消息，它保证了数据一定发送给了对方，所以是一种可靠传输，但是遇到阻塞效率会很低<br>端口：ip地址唯一确定了这台机器，相当于一个房子，但是你消息总不能发给整个电脑吧，比如qq，而端口就相当于一间房间，具体发给那个，比如送到qq这间房间</p>
</blockquote>
<p><strong>端口分类</strong></p>
<blockquote>
<p>有65536个端口    0号是保留端口<br>1-1024是固定端口<br>又叫有名端口，即被某些程序固定使用，一般程序员不使用。<br>22：SSH远程登录协议    23：telnet使用    21：ftp使用<br>25：smtp服务使用    80：iis使用    7：echo服务<br>1025-65535是动态端口<br>这些端口，程序员可以使用<br>端口(port)–注意事项<br>1、在计算机(尤其是做服务器)要尽可能的少开端口；<br>2、一个端口只能被一个程序监听；<br>3、如果使用netstat -an可以查看本机有哪些端口在监听</p>
</blockquote>
<p><strong>UDP协议</strong><br>UDP向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接。<br>简单来说，就是只发一次数据，不管对方有没有接收到都不会再发了，但是有时候效率会很高，像网络拥堵时</p>
<p><strong>url</strong><br>统一资源定义符也被称为网页地址。Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL地址，这种地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是Internet上的站点，简单地说，URL就是Web地址，俗称“网址”，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法，如：<br><a href="http://www.sina.com:8080/index.html" target="_blank" rel="external">http://www.sina.com:8080/index.html</a><br>1、协议；2、ip地址(32位)；3、端口号(16位)0-65535；4、资源名称。</p>
<p><strong>单工、半双工和全双工</strong><br> 如果甲可以向乙发送数据，但是乙不能向甲发送数据，这样的通信就是单工通信(Simplex Communication)。<br>    单工数据传输只支持数据在一个方向上传输，就和传呼机一样。<br>    半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信，就和对讲机(步话机)一样；<br>全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力，就和电话一样</p>
<h4 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h4><p><img src="/images/imgs4/28.gif" alt="Alt text"><br>如模拟的客户端与服务端<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class MyServer &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new MyServer();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyServer()&#123;</div><div class="line">		try &#123;</div><div class="line">			//在9999号端口上监听</div><div class="line">			ServerSocket ss=new ServerSocket(9999);</div><div class="line">			System.out.println("9999端口监听...");</div><div class="line">			//等待某个客户端来连接，该函数会返回一个Socket连接</div><div class="line">			Socket s=ss.accept();</div><div class="line">			//要读取s中传递的数据</div><div class="line">			InputStreamReader isr=new InputStreamReader(s.getInputStream());</div><div class="line">			BufferedReader br=new BufferedReader(isr);</div><div class="line">			</div><div class="line">			String info=br.readLine();</div><div class="line">			System.out.println("服务器接收到:\t"+info);</div><div class="line">			</div><div class="line">			PrintWriter pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			pw.println("我是服务器，已收到你发送的信息!");</div><div class="line"></div><div class="line"></div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class MyClient &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new MyClient();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyClient()&#123;</div><div class="line">		try &#123;</div><div class="line">			//Socket()就是去连接某个服务器端 127.0.0.1表示服务器的ip</div><div class="line">			//9999是服务器的端口号</div><div class="line">			Socket s=new Socket("127.0.0.1",9999);</div><div class="line">			//如果s连接成功，就可以发送数据到服务器端</div><div class="line">			//我们通过pw向s写数据,true表示即时刷新</div><div class="line">			PrintWriter pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			pw.println("你好吗？我是客户端");</div><div class="line">			//要读取s中传递的数据</div><div class="line">			InputStreamReader isr=new InputStreamReader(s.getInputStream());</div><div class="line">			BufferedReader br=new BufferedReader(isr);</div><div class="line">			String info=br.readLine();</div><div class="line">			System.out.println("接收到服务器：\t"+info);</div><div class="line"></div><div class="line"></div><div class="line">		&#125;catch (Exception e) &#123;</div><div class="line">			// TODO: handle exception</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要注意的几个地方，必须是服务端先开启，然后accept（）等待客户端，没有客户端连接，它将处于阻塞状态，一旦有了客户端它将回应，其次这是理由tcp实现的，UDP实现用java提供的另外类，最后这里有一个问题，就是只能接受一次，需要改进，也就是不断循环接收客户端连接</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">			//在9999号端口上监听</div><div class="line">			ServerSocket ss=new ServerSocket(9999);</div><div class="line">			//等待客户端连接，该函数会返回一个Socket连接</div><div class="line">			Socket s=ss.accept();</div><div class="line">			//要读取s中传递的数据</div><div class="line">			isr=new InputStreamReader(s.getInputStream());</div><div class="line">			br=new BufferedReader(isr);</div><div class="line">			</div><div class="line">			pw=new PrintWriter(s.getOutputStream(),true);</div><div class="line">			</div><div class="line">			//接收从控制台输入的信息</div><div class="line">			isr2=new InputStreamReader(System.in);</div><div class="line">			br2=new BufferedReader(isr2);</div><div class="line">			while(true)&#123;</div><div class="line">				//接收客户端信息</div><div class="line">				String infoFromClient=br.readLine();</div><div class="line">				System.out.println("服务器接收到:\t"+infoFromClient);</div><div class="line">				//接收从控制台输入的信息</div><div class="line">				System.out.println("请输入要发送到客户端的信息：");</div><div class="line">				String response=br2.readLine();</div><div class="line">				//服务器从控制台上接收bye服务器端退出</div><div class="line">				if(response.equals("bye"))&#123;</div><div class="line">					System.out.println("退出对话");</div><div class="line">					s.close();</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">				//把从控制台输入的信息，回送给客户端</div><div class="line">				pw.println(response);</div><div class="line">			&#125;</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;finally&#123;</div><div class="line">			try &#123;</div><div class="line">				if(br2!=null) br2.close();</div><div class="line">				if(isr2!=null) isr2.close();</div><div class="line">				if(pw!=null) pw.close();</div><div class="line">				if(br!=null) br.close();</div><div class="line">				if(isr!=null) isr.close();</div><div class="line">			&#125; catch (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>最后当然网络编程中也就是流的数据传送的应用，也不得不说网络底层协议其实很复杂的，只有当我们有精力了，再去细细研究它，才会有更多的收获</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/imgs4/16.jpg&quot; alt=&quot;Alt text&quot;&gt;&lt;br&gt;在java网络编程中最主要的是tcp/
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="http://www.myzwl.win/2017/07/28/balace_1/"/>
    <id>http://www.myzwl.win/2017/07/28/balace_1/</id>
    <published>2017-07-28T05:48:51.000Z</published>
    <updated>2017-08-12T07:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AVL树，也叫平衡二叉树，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。同时，将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，还将距离插入结点最近的且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树<br><img src="/images/imgs4/25.gif" alt="Alt text"><br>如图：一为一个不平衡二叉排序树，显然时间复杂度较大，二为改进后的平衡二叉树，而在改进的过程中，最重要的就是通过平衡因子来判断是进行左旋还是右旋，如右旋，新增一个节点N后，平衡被打破，需要平衡因子2大于0，需要右旋，就是将其左子树作为根结点，左子树的右子树作为原根结点的左子树，这样做的原因就是根据二叉排序树的左右子树特点来的，很容易想明白</p>
<h4 id="模拟平衡二叉树"><a href="#模拟平衡二叉树" class="headerlink" title="模拟平衡二叉树"></a>模拟平衡二叉树</h4><p>不妨构造一个a[10]={3,2,1,4,5,6,7,10,9,8};<br><img src="/images/imgs4/26.gif" alt="Alt text"><br>大概过程如图所示，其中最重要的就是平衡因子的判断，如果是同号，且绝对值大于1的话，就要做相应的旋转操作，如果是不同号的话，就要通过旋转先转换成同号，在做操作</p>
<h4 id="左右旋操作"><a href="#左右旋操作" class="headerlink" title="左右旋操作"></a>左右旋操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">typedef struct BiTNode</div><div class="line">&#123;</div><div class="line">	int data;</div><div class="line">	int bf;</div><div class="line">	struct BiTNode *lchild,*rchild;</div><div class="line">&#125;BiTNode,*BiTree;</div><div class="line"></div><div class="line">//左旋处理</div><div class="line">void R_Rotate(BiTree *p)&#123;</div><div class="line">	BiTree L;</div><div class="line">	L=(*p)-&gt;lchild;   //L指向p的左子树根结点</div><div class="line">	(*p)-&gt;lchild=L-&gt;rchild; //L的右子树挂接为p的左子树</div><div class="line">	L-&gt;rchild=(*p);  </div><div class="line">	*p=L;           //p指向新的根结点</div><div class="line">&#125;</div><div class="line"></div><div class="line">//右旋处理</div><div class="line">void L_Ronate(BiTree *p)</div><div class="line">&#123;</div><div class="line">	BiTree R;</div><div class="line">	R=(*p)-&gt;rchild; //R指向p的右子树根结点</div><div class="line">	(*p)-&gt;rchild=R-&gt;lchild;  //R的左子树挂接为P的右子树</div><div class="line">	R-&gt;lchild=(*p);</div><div class="line">	*p=R;            //p指向新的根结点</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过之前的图来对比看，其实质也就是交互根结点位置和挂接新左右子树</p>
<h4 id="左右平衡旋转"><a href="#左右平衡旋转" class="headerlink" title="左右平衡旋转"></a>左右平衡旋转</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#define LH +1 /*  左高 */ </div><div class="line">#define EH 0  /*  等高 */ </div><div class="line">#define RH -1 /*  右高 */ </div><div class="line"></div><div class="line">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */</div><div class="line">/*  本算法结束时，指针T指向新的根结点 */</div><div class="line">void LeftBalance(BiTree *T)</div><div class="line">&#123; </div><div class="line">	BiTree L,Lr;</div><div class="line">	L=(*T)-&gt;lchild; /*  L指向T的左子树根结点 */ </div><div class="line">	switch(L-&gt;bf)</div><div class="line">	&#123; /*  检查T的左子树的平衡度，并作相应平衡处理 */ </div><div class="line">		 case LH: /*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */ </div><div class="line">			(*T)-&gt;bf=L-&gt;bf=EH;</div><div class="line">			R_Rotate(T);</div><div class="line">			break;</div><div class="line">		 case RH: /*  新结点插入在T的左孩子的右子树上，要作双旋处理 */ </div><div class="line">			Lr=L-&gt;rchild; /*  Lr指向T的左孩子的右子树根 */ </div><div class="line">			switch(Lr-&gt;bf)</div><div class="line">			&#123; /*  修改T及其左孩子的平衡因子 */ </div><div class="line">				case LH: (*T)-&gt;bf=RH;</div><div class="line">						 L-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case EH: (*T)-&gt;bf=L-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case RH: (*T)-&gt;bf=EH;</div><div class="line">						 L-&gt;bf=LH;</div><div class="line">						 break;</div><div class="line">			&#125;</div><div class="line">			Lr-&gt;bf=EH;</div><div class="line">			L_Rotate(&amp;(*T)-&gt;lchild); /*  对T的左子树作左旋平衡处理 */ </div><div class="line">			R_Rotate(T); /*  对T作右旋平衡处理 */ </div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */ </div><div class="line">/*  本算法结束时，指针T指向新的根结点 */ </div><div class="line">void RightBalance(BiTree *T)</div><div class="line">&#123; </div><div class="line">	BiTree R,Rl;</div><div class="line">	R=(*T)-&gt;rchild; /*  R指向T的右子树根结点 */ </div><div class="line">	switch(R-&gt;bf)</div><div class="line">	&#123; /*  检查T的右子树的平衡度，并作相应平衡处理 */ </div><div class="line">	 case RH: /*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */ </div><div class="line">			  (*T)-&gt;bf=R-&gt;bf=EH;</div><div class="line">			  L_Rotate(T);</div><div class="line">			  break;</div><div class="line">	 case LH: /*  新结点插入在T的右孩子的左子树上，要作双旋处理 */ </div><div class="line">			  Rl=R-&gt;lchild; /*  Rl指向T的右孩子的左子树根 */ </div><div class="line">			  switch(Rl-&gt;bf)</div><div class="line">			  &#123; /*  修改T及其右孩子的平衡因子 */ </div><div class="line">				case RH: (*T)-&gt;bf=LH;</div><div class="line">						 R-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case EH: (*T)-&gt;bf=R-&gt;bf=EH;</div><div class="line">						 break;</div><div class="line">				case LH: (*T)-&gt;bf=EH;</div><div class="line">						 R-&gt;bf=RH;</div><div class="line">						 break;</div><div class="line">			  &#125;</div><div class="line">			  Rl-&gt;bf=EH;</div><div class="line">			  R_Rotate(&amp;(*T)-&gt;rchild); /*  对T的右子树作右旋平衡处理 */ </div><div class="line">			  L_Rotate(T); /*  对T作左旋平衡处理 */ </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="插入与主函数"><a href="#插入与主函数" class="headerlink" title="插入与主函数"></a>插入与主函数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */ </div><div class="line">/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */ </div><div class="line">/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */</div><div class="line">Status InsertAVL(BiTree *T,int e,Status *taller)</div><div class="line">&#123;  </div><div class="line">	if(!*T)</div><div class="line">	&#123; /*  插入新结点，树“长高”，置taller为TRUE */ </div><div class="line">		 *T=(BiTree)malloc(sizeof(BiTNode));</div><div class="line">		 (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=NULL; (*T)-&gt;bf=EH;</div><div class="line">		 *taller=TRUE;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if (e==(*T)-&gt;data)</div><div class="line">		&#123; /*  树中已存在和e有相同关键字的结点则不再插入 */ </div><div class="line">			*taller=FALSE; return FALSE;</div><div class="line">		&#125;</div><div class="line">		if (e&lt;(*T)-&gt;data)</div><div class="line">		&#123; /*  应继续在T的左子树中进行搜索 */ </div><div class="line">			if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) /*  未插入 */ </div><div class="line">				return FALSE;</div><div class="line">			if(taller) /*   已插入到T的左子树中且左子树“长高” */ </div><div class="line">				switch((*T)-&gt;bf) /*  检查T的平衡度 */ </div><div class="line">				&#123;</div><div class="line">					case LH: /*  原本左子树比右子树高，需要作左平衡处理 */ </div><div class="line">							LeftBalance(T);	*taller=FALSE; break;</div><div class="line">					case EH: /*  原本左、右子树等高，现因左子树增高而使树增高 */ </div><div class="line">							(*T)-&gt;bf=LH; *taller=TRUE; break;</div><div class="line">					case RH: /*  原本右子树比左子树高，现左、右子树等高 */  </div><div class="line">							(*T)-&gt;bf=EH; *taller=FALSE; break;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123; /*  应继续在T的右子树中进行搜索 */ </div><div class="line">			if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) /*  未插入 */ </div><div class="line">				return FALSE;</div><div class="line">			if(*taller) /*  已插入到T的右子树且右子树“长高” */ </div><div class="line">				switch((*T)-&gt;bf) /*  检查T的平衡度 */ </div><div class="line">				&#123;</div><div class="line">					case LH: /*  原本左子树比右子树高，现左、右子树等高 */ </div><div class="line">							(*T)-&gt;bf=EH; *taller=FALSE;	break;</div><div class="line">					case EH: /*  原本左、右子树等高，现因右子树增高而使树增高  */</div><div class="line">							(*T)-&gt;bf=RH; *taller=TRUE; break;</div><div class="line">					case RH: /*  原本右子树比左子树高，需要作右平衡处理 */ </div><div class="line">							RightBalance(T); *taller=FALSE; break;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;    </div><div class="line">	int i;</div><div class="line">	int a[10]=&#123;3,2,1,4,5,6,7,10,9,8&#125;;</div><div class="line">	BiTree T=NULL;</div><div class="line">	Status taller;</div><div class="line">	for(i=0;i&lt;10;i++)</div><div class="line">	&#123;</div><div class="line">		InsertAVL(&amp;T,a[i],&amp;taller);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后不得不说，AVL树是在是太复杂了，但是其思想是在是太精妙了，它克服了二叉排序树在查找效率上的不足，通过在插入数据时，就将其变成一个平衡二叉树，从而使其时间复杂度为O(logn)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;AVL树，也叫平衡二叉树，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。同时，将二叉树上结点的左子树深度减去右子树深度
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="http://www.myzwl.win/2017/07/27/BSTSort_1/"/>
    <id>http://www.myzwl.win/2017/07/27/BSTSort_1/</id>
    <published>2017-07-27T05:48:51.000Z</published>
    <updated>2017-08-12T05:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>二叉排序树，又称为二分查找树，它或者是一颗空树，或者具有如下性质<br>1.若它的左子树不为空，则左子树上所有结点的值均小于根结点值<br>2.若它的右子树不为空，则右子树上所有结点的值均小于根结点值<br>3.它的左右子树也分别为二叉排序树<br><img src="/images/imgs4/23.gif" alt="Alt text"></p>
<h4 id="二叉排序树查找操作"><a href="#二叉排序树查找操作" class="headerlink" title="二叉排序树查找操作"></a>二叉排序树查找操作</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">typedef struct BiTNode</div><div class="line">&#123;</div><div class="line">	int data;</div><div class="line">	struct BiTNode *lchild,*rchild;</div><div class="line">&#125;BiTNode,*BiTree;</div><div class="line"></div><div class="line"></div><div class="line">//递归查找二叉排序树中是否存在key</div><div class="line">//f指向T的双亲，初始值为NULL</div><div class="line">//若查找成功，则p指向该节点，并返回true</div><div class="line">//若查找失败，则p指向查找路径上访问的最后一个结点，并返回FALSE</div><div class="line">Status SearchBST(BiTree T,int key,BiTree f,BiTree *p)</div><div class="line">&#123;</div><div class="line">	if(!T)     //查找不成功</div><div class="line">	&#123;</div><div class="line">		*p=f;</div><div class="line">		return FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	else if(key==T-&gt;data) //查找成功</div><div class="line">	&#123;</div><div class="line">		*p=T;</div><div class="line">		return TRUE;</div><div class="line">	&#125;</div><div class="line">	else if(key&gt;T-&gt;data)&#123;         //在右子树中递归查找</div><div class="line">		return SearchBST(T-&gt;rchild,key,T,p);</div><div class="line">	&#125;</div><div class="line">	else if(key&lt;T-&gt;data)          //在左子树中递归查找</div><div class="line">		return SearchBST(T-&gt;lchild,key,T,p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看看它的过程是如何运行的，比如现在要查找93，显然初始化为SearchBST(T,93,NULL,p),因为93&gt;62，所以递归执行SearchBST(T-rchild,93,T,p),即SearchBST(88,93,62,P)这里用结点data值表示结点，又93&gt;88,继续SearchBST(99,93,88,P)，又93&lt;99，SearchBST(93,93,99,P)，所以93==93，得到最终p=T=93，f=99，查找成功。<br>可以发现二叉排序树的查找算法如此精妙而又优雅</p>
<h4 id="二叉排序树的插入操作"><a href="#二叉排序树的插入操作" class="headerlink" title="二叉排序树的插入操作"></a>二叉排序树的插入操作</h4><p>插入操作是基于查找操作的，也就是如果该二叉树为空，则新插入点为根结点，如果不为空，在先查找是否存在此元素，存在返回FALSE，否则在查找路径上的最后一个结点，通过比较插入到左孩子还是右孩子，最终返回TRUE<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Status InsertBST(BiTree *T,int key)</div><div class="line">&#123;</div><div class="line">	BiTree p,s;</div><div class="line">	if(!SearchBST(T,key,NULL,&amp;p)) //查找不成功</div><div class="line">	&#123;</div><div class="line">		s=(BiTree)malloc(sizeof(BiTNode));</div><div class="line">		 s-&gt;data=key;</div><div class="line">		 s-&gt;lchild=s-&gt;rchild=NULL;</div><div class="line">		 if(!p)                    //插入s为新的根结点</div><div class="line">		 	*T=s;</div><div class="line">		 else if(key&lt;s-data)      //插入s为左孩子</div><div class="line">		 	p-&gt;lchild=s;</div><div class="line">		 else                     //插入s为右孩子</div><div class="line">		 	p-&gt;rchild=s;</div><div class="line">		 return TRUE;</div><div class="line">	&#125;</div><div class="line">	else                       //树中已存在此关键字，则不插入</div><div class="line">		return FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="二叉排序树的删除操作"><a href="#二叉排序树的删除操作" class="headerlink" title="二叉排序树的删除操作"></a>二叉排序树的删除操作</h4><p>删除操作需要考虑三种情况，因为删除之后要保证还是一颗二叉排序树。如图<br><img src="/images/imgs4/24.gif" alt="Alt text"><br>一：删除叶子结点，这对这个二叉树来说并无影响，所以不移动其它元素<br>二：删除只含有左子树或者右子树的二叉排序树，因为根据二叉排序树的特点，很明显只要将它的左子树或右子树全部移动到它双亲的左子树或右子树就行了<br>三：删除既有左子树又有右子树的结点，我们可以通过它的中序遍历，也就是让它的直接前驱或者直接后继来替换它的位置，然后直接后继在分三种情况，直至只有一个孩子或者无孩子来替换<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">Status DeleteBST(BiTree *T,int key) //找到待删结点</div><div class="line">&#123;</div><div class="line">	if(!*T)</div><div class="line">		return FALSE;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if(key==(*T)-&gt;data)</div><div class="line">			return Delete(T);</div><div class="line">		else if(key&lt;(*T)-&gt;data)</div><div class="line">			return DeleteBST(&amp;(*T)-&gt;lchild,key);</div><div class="line">		else</div><div class="line">			return DeleteBST(&amp;(*T)-&gt;rchild,key);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//从二叉树中删除结点p，并重接它的左或右子树</div><div class="line">Status Delete(BiTree *p)</div><div class="line">&#123;</div><div class="line">	BiTree q,s;</div><div class="line">	if((*p)-&gt;rchild==NULL)  //右子树空则重接它的左子树</div><div class="line">	&#123;</div><div class="line">		q=*p;</div><div class="line">		*p=(*p)-&gt;lchild;</div><div class="line">		free(q);</div><div class="line">	&#125;</div><div class="line">	else if((*p)-&gt;lchild==NULL) //左子树空则重接它的右子树</div><div class="line">	&#123;</div><div class="line">		q=*p;</div><div class="line">		*p=(*p)-&gt;rchild;</div><div class="line">		free(q);</div><div class="line">	&#125;</div><div class="line">	else&#123;         //左右子树均不为空</div><div class="line">		q=*p;</div><div class="line">		s=(*p)-&gt;lchild;</div><div class="line">		while(s-&gt;lchild) //找到待删结点的前驱</div><div class="line">		&#123;</div><div class="line">			q=s;</div><div class="line">			s=s-&gt;rchild;</div><div class="line">		&#125;</div><div class="line">		(*p)-&gt;data=s-&gt;data;</div><div class="line">		if(q!=*p)        //重接q的右子树</div><div class="line">			q-&gt;rchild=s-&gt;lchild;</div><div class="line">		else             //重接q的左子树</div><div class="line">			q-&gt;lchild=s-&gt;lchild;</div><div class="line">		free(s);</div><div class="line">	&#125;</div><div class="line">	return TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>二叉排序树是以链式结构进行存储，所以在插入和删除元素上高效，，但是查找上走的是从根路径到结点的路径，其比较次数与数的层数有关如果该数是一颗斜数，那么查找就会比较很多次，如果该树是一颗完全二叉树，那么比较次数就最优，此时时间复杂度为O(logn),但是平均来说时间复杂度为O(n)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;二叉排序树，又称为二分查找树，它或者是一颗空树，或者具有如下性质&lt;br&gt;1.若它的左子树不为空，则左子树上所有结点的值均小于根结点值&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>死锁和生产者消费者问题</title>
    <link href="http://www.myzwl.win/2017/07/26/procos_1/"/>
    <id>http://www.myzwl.win/2017/07/26/procos_1/</id>
    <published>2017-07-26T05:48:51.000Z</published>
    <updated>2017-08-10T08:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>线程同步操作的是同一个线程对象，所以可能造成线程不安全，出现非数据的原子操作，所以，需要加锁，同时线程是程序的执行顺序，也就是cpu根据不同时间片选择某个时间执行某个线程，关于线程并发，在以前的总结中做过了几个简单的总结。<br>而死锁最经典的例子就是哲学家进餐问题，每个哲学家都左手拿着一只筷子，并且总共有五个哲学家，5个筷子，只有当哲学家左右手都有筷子时才能进餐，所以每个哲学家都在等右边哲学家方上筷子，处于僵持等待状态，称为死锁。<br>这里模仿两个线程死锁的情况<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class LockTest implements Runnable&#123;</div><div class="line"></div><div class="line">	public int flag=1;</div><div class="line">	 static Object o1=new Object(),o2=new Object();</div><div class="line">	   </div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println("flag="+flag);</div><div class="line">		 if(flag==1)&#123;</div><div class="line">		 synchronized (o1) &#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(5000);</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			synchronized (o2) &#123;</div><div class="line">				System.out.println("1");</div><div class="line">			&#125;</div><div class="line">		 &#125;	 </div><div class="line">		&#125;</div><div class="line">		if(flag==0)&#123;</div><div class="line">			 synchronized (o2) &#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(5000);</div><div class="line">					&#125; catch (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					synchronized (o1) &#123;</div><div class="line">						System.out.println("0");</div><div class="line">					&#125;</div><div class="line">				 &#125;	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LockTest lt1=new LockTest();</div><div class="line">		LockTest lt2=new LockTest();</div><div class="line">		 lt1.flag=1;</div><div class="line">		 lt2.flag=0;</div><div class="line">		  Thread t1=new Thread(lt1);</div><div class="line">		  Thread t2=new Thread(lt2);</div><div class="line">		  t1.start();</div><div class="line">		  t2.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<blockquote>
<p>flag=1<br>flag=0</p>
</blockquote>
<p>大概分析一下，该类本身是一个线程类，flag用来控制执行哪个锁，O1和O2是两个被锁住对象，flag为1时先锁住o1，在锁住o2，flag为0则相反，而死锁发生就在此处两个线程启动了，o1被锁住了，另一个o2被锁住了，都在等待对方释放锁，显然处于僵持，产生死锁，<br>解决死锁的一个简单办法就是增大锁的粒度，扩大锁对象，比如讲前面的O1与O2改成this<br>结果：</p>
<blockquote>
<p>flag=1<br>flag=0<br>1<br>0</p>
</blockquote>
<h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><p>概述，模拟一个生产者利用生产食物放到篮子里，而一个消费者从篮子里消费食物<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">public class Food &#123; //食物类</div><div class="line"> int id;</div><div class="line"> public Food(int id)&#123;</div><div class="line">	 this.id=id;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class UtilStack &#123;//工具，用来放食物</div><div class="line"></div><div class="line">	int index=0; //食物计数变量</div><div class="line">	Food[] arrFD=new Food[4]; //最多工具能放食物容量</div><div class="line">	</div><div class="line">	public synchronized void push(Food fd)&#123; //生产食物，必须加锁，保证生产过程不被打断</div><div class="line">		while(index==arrFD.length)</div><div class="line">		&#123;</div><div class="line">			try &#123;</div><div class="line">				System.out.println("full");</div><div class="line">				this.wait();  //生产满了，就去休息区休息，等待被唤醒</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		this.notify();//唤醒当前在休息区的线程</div><div class="line">		arrFD[index]=fd;</div><div class="line">		index++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public synchronized Food pop()&#123; //消费</div><div class="line">		while(index==0) //消费完了，进休息区</div><div class="line">			try &#123;</div><div class="line">				System.out.println("empty");</div><div class="line">				this.wait();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		this.notify();</div><div class="line">		index--;</div><div class="line">		return arrFD[index];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Producer implements Runnable&#123;//生产者</div><div class="line"></div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Producer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=new Food(i);</div><div class="line">			ss.push(fd);</div><div class="line">			System.out.println("生产了"+fd.id);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(1000);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Consumer implements Runnable&#123;//消费者</div><div class="line"></div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Consumer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=ss.pop();</div><div class="line">			System.out.println("消费了"+fd.id);</div><div class="line">		 try &#123;</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>消费利用一对生产者和消费者模拟</p>
<blockquote>
<pre><code>UtilStack ss=new UtilStack();
    Producer p=new Producer(ss);
    Consumer c=new Consumer(ss);
    new Thread(p).start();
    new Thread(c).start();
</code></pre></blockquote>
<p>结果如下：</p>
<blockquote>
<p>生产了0<br>消费了0<br>生产了1<br>生产了2<br>消费了2<br>生产了3<br>生产了4<br>消费了4<br>生产了5<br>生产了6<br>消费了6<br>生产了7<br>full<br>消费了7<br>生产了8<br>full<br>消费了8<br>生产了9<br>full<br>消费了9<br>生产了10<br>full<br>消费了10<br>生产了11<br>full<br>消费了11<br>生产了12<br>full<br>消费了12<br>生产了13<br>full<br>消费了13<br>生产了14<br>full<br>消费了14<br>生产了15<br>full</p>
</blockquote>
<p>这里优于设置了消费者消费时间长，所以导致index不一样。可以发现当生产者满了，生产者不生产了，进入休息区，等待被唤醒，关于wait（）、notify（）、notifyAll（），在之前的多线程总结中已总结了</p>
<p><strong>结果分析</strong><br>从中我们可以看到生产者有满了的情况，但是消费者消费完了，index就不满了，然后就去叫醒了生产者继续生产，同样如果我们把消费者时间设置短一点看看，预测应该是empty的，在被生产者叫醒</p>
<blockquote>
<p>生产了0<br>消费了0<br>empty<br>消费了1<br>生产了1<br>empty<br>消费了2<br>生产了2<br>empty<br>消费了3<br>生产了3<br>empty<br>生产了4<br>消费了4<br>empty</p>
</blockquote>
<p>最后不得不说生产者与消费者问题可以解决平时在项目开发配置中不求甚解的一些问题，像缓冲区、连接池、消息队列、死锁、同步等等，</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h4&gt;&lt;p&gt;线程同步操作的是同一个线程对象，所以可能造成线程不安全，出现非数据的原子操作，所以，需要加锁，同时线程是程序的执行顺序，也就是cpu根据不同
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://www.myzwl.win/2017/07/25/quick_1/"/>
    <id>http://www.myzwl.win/2017/07/25/quick_1/</id>
    <published>2017-07-25T05:48:51.000Z</published>
    <updated>2017-08-10T04:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速排序被列为20世纪十大算法之一，正如其名一样，排序的速度非常快。<br>而它的基本思想就是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续排序，最终达到有序的目的<br><img src="/images/imgs4/22.gif" alt="Alt text"></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>采取同样的策略，从计算机的角度看看程序是怎么执行的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void QuickSort(SqList *L)&#123;</div><div class="line">  QSort(L,1,L-&gt;length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void QSort(SqList *L,int low,int high)&#123;</div><div class="line">  int pivot;</div><div class="line">   if(low&lt;high)&#123;</div><div class="line">    pivot=Partition(L,low,high);//将L-&gt;r[low..high]一分为二</div><div class="line">     QSort(L,low,pivor-1); //对低子表递归排序</div><div class="line">      QSort(L,pivot+1,high); //对高子表递归排序</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>里面有个函数Partition(L,low,high),和归并排序一样，暂时先不管它，初始化数组为{50,10,90,30,70,40,80,60,20}，初始low=1，high=9；<br>pivot为选择其中一个关键字，比pivot小的排到左边，比pivot大的排到右边，显然此时pivot=5，然后执行 QSort(L，1,4）直至排好序，同样右边也是递归调用QSort（L，6,9），这里的核心算法也就是Partition(L,low,high)如何排序的了<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int Partition(SqList *L,int low,int high)&#123;</div><div class="line">  int pivotkey;</div><div class="line">   pivotkey=L-&gt;[low]; //用子表的第一个记录做关键字</div><div class="line">    while(low&lt;high)</div><div class="line">    &#123;</div><div class="line">      while(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</div><div class="line">        high--;</div><div class="line">      swap(L,low,high);//交换low和high的记录</div><div class="line">      while(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</div><div class="line">         low++;</div><div class="line">       swap(L,low,high);</div><div class="line">    &#125;</div><div class="line">    return low;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样一行一行的看，这里默认选取子表的第一个记录作为关键字pivotkey=L-&gt;[low];接下来，由于low=1<high=9，执行内部程序，然后比较l->r[high]=L-&gt;r[9]=20与pivotkey=50大小，显然前者小于后者，不满足，将high与low交换，也就是说小的在左边，此时为{20,10,90.。。50},；然后明显20<50，所以low++；得low=2；并且10<50，在循环，得low=3，此时90>50,退出循环，在此交换位置，得{20,10,50.。。。90}；<br>最后low=3<9在循环，90>50,满足，high–，high=8，有L-&gt;high[8]=60&gt;50;high–;有80&gt;50;high–,有40&lt;50,退出循环，此时high=6，交换，依次类推，最终low=high=5，退出整个循环<br>最后在分别递归低和高的子表，最后我们发现他的规律如此只简单，遇到比关键字小的，依次递增比较，直到有比它大的，在换另一边比较，不得不说快速排序实在是太精妙了</9在循环，90></50，所以low++；得low=2；并且10<50，在循环，得low=3，此时90></high=9，执行内部程序，然后比较l-></p>
<p>最后再来看一下快速排序的时间复杂度，在最优的情况下为O（nlogn);</p>
<h4 id="排序算法间的比较"><a href="#排序算法间的比较" class="headerlink" title="排序算法间的比较"></a>排序算法间的比较</h4><p><img src="/images/imgs4/2.png" alt="Alt text"><br>分类<br><img src="/images/imgs4/15.jpg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;快速排序被列为20世纪十大算法之一，正如其名一样，排序的速度非常快。&lt;br&gt;而它的基本思想就是通过一趟排序将待排序的记录分割成独立的两部分，
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://www.myzwl.win/2017/07/24/guibin_1/"/>
    <id>http://www.myzwl.win/2017/07/24/guibin_1/</id>
    <published>2017-07-24T05:48:51.000Z</published>
    <updated>2017-08-10T08:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>归并的意思就是将两个或者两个以上的有序数组合成一个有序表。而归并排序就是将含有n个记录的子序列，每个子序列长度为1，然后两两归并，得到[n/2]个长度为2或者1的有序子序列，在两两归并，。。。。，如此重复，直到得到一个长度为n的有序序列为止<br><img src="/images/imgs4/14.jpg" alt="Alt text"></p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>不妨先看代码，在从计算机角度去看看是如何执行代码过程的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void MergeSort(SqList *L)&#123;</div><div class="line">  MSort(L-&gt;r,L-&gt;r,1,L-&gt;length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//将SR[s..t]归并到TR1[s..t]</div><div class="line">void MSort(int SR[],int TR1[],int s,int t)&#123;</div><div class="line">  int m;</div><div class="line">  int TR2[MAXSIZE+1];</div><div class="line">  if(s==t)</div><div class="line">    TR1[s]=SR[s];</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    m=(s+t)/2;</div><div class="line">    MSort(SR,TR2,s,m);</div><div class="line">    MSort(SR,TR2,m+1,t);</div><div class="line">    Merge(TR2,TR1,s,m,t);//将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>里面有个递归 Merge(TR2,TR1,s,m,t);暂时先不管它，假设模拟的数组为{50,10,90,30,70,40,80,60,20}，所以知道初始化时SR和TR1都是该数组，s=1，t-9；由于s！=t，所以执行else中的语句。此时m=5，也就是正中间下标，所以开始先执行递归MSort(SR,TR2,1,5)，递归过程如下所示<br><img src="/images/imgs4/21.gif" alt="Alt text"><br>其核心部分就是最后都变成叶子结点，递归结束，然后执行if里语句，不过此时TR1[s]=SR[s]，注意这里s是元素下标，所以第一次TR2={50,10}，然后就要执行Merge(TR2,TR1,s,m,t);前面是50与10已结归并了，暂时我们知道它就是把无需归并为有序就行了，即TR2={10,50}后面在详细分析它，<br>接下来同理，依次向上归并，最后得到{10,30,50,70,90}，同理，根结点右子树也一样，最终完成了归并</p>
<p>再来看看Merge(TR2,TR1,s,m,t)函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void Merge(int SR[],int TR[],int i,int m,int n)</div><div class="line">&#123;</div><div class="line">  int j,k,l;</div><div class="line">   for(j=m+1,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++)</div><div class="line">   &#123;</div><div class="line">    if(SR[i]&lt;SR[j])</div><div class="line">      TR[k]=SR[i++];</div><div class="line">    else</div><div class="line">      TR[k]=SR[j++];</div><div class="line">   &#125;</div><div class="line">   if(i&lt;=m)&#123;  //将剩余元素归并</div><div class="line">    for(l=0;l&lt;=m-1;l++)</div><div class="line">      TR[k+1]=SR[i+1];</div><div class="line">  &#125;</div><div class="line"> if(j&lt;=n)</div><div class="line"> &#123;</div><div class="line">  for(l=0;l&lt;n-j;l++)</div><div class="line">    TR[k+1]=SR[j+1];</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就拿{10,30,50,70,90}和{20,40,60,80}归并为有序序列来说，此时i=1，m=5,n=9；进入for循环，此时j从6到9，i由1到5，k由1开始每次加1，并且k就是TR数组的下标，然后开始归并，左右子树的SR[i]=SR[1]=10与SR[j]=SR[6]=20开始比较，将较小数放入到一个初始化时空的TR[]中，比如是10，然后i++；否则j++，这样就可以得到有序序列了，但是最终当j=10时退出循环，而后面还有一些元素未归并，将执行后面if语句，将最后的90复制到最后，最终完成了归并</p>
<p>最后再来看看归并排序的时间复杂度，由于其与完全二叉树有关，最终得到其为O（nlogn)，而它也是比较占用内存但是很稳定的一种算法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;归并的意思就是将两个或者两个以上的有序数组合成一个有序表。而归并排序就是将含有n个记录的子序列，每个子序列长度为1，然后两两归并，得到[n/
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java IO简单总结</title>
    <link href="http://www.myzwl.win/2017/07/23/IO_1/"/>
    <id>http://www.myzwl.win/2017/07/23/IO_1/</id>
    <published>2017-07-23T05:48:51.000Z</published>
    <updated>2017-08-09T07:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在涉及IO流之前需要知道文件的概念。文件是数据源（保存数据的的地方）的一种，比如word文件、txt文件。他既可以保存一张图片，也可以保存视频、声音。。。等等<br><strong>文件流</strong><br><img src="/images/imgs4/19.gif" alt="Alt text"><br>文件在程序中是以流的形式来操作的<br>流：数据在数据源（文件）和程序（内存）之间经历的路径<br>输入流：数据从数据源到内存的路径<br>输出流：数据从内存到数据源的路径</p>
<h4 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h4><p>1.根据处理数据类型的不同分为：字符流和字节流<br>字节流：可以用于读写二进制文件及任何类型的byte，也就是一个字节一个的读<br>字符流：可以用于读写文本文件，不能操作二进制文件，也就是两个字节两个字节的读<br>2.根据数据流向不同分为：输入流和输出流<br>3。节点流和处理流<br>节点流：直接与数据源相连，读入或读出，可以发现使用该流过于频繁操作硬件，从而使读写很不方便<br>常用的结点流：</p>
<blockquote>
<p>父类：InputStream、OutputStream、Reader、Writer<br>文件 ：FileInputStream 、 FileOutputStrean 、FileReader、FileWriter 文件进行处理的节点流<br>数　组 ：ByteArrayInputStream、 ByteArrayOutputStream、 CharArrayReader 、CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）<br>字符串 ：StringReader、 StringWriter 对字符串进行处理的节点流<br>管　道 ：PipedInputStream 、PipedOutputStream 、PipedReader 、PipedWriter 对管道进行处理的节点流</p>
</blockquote>
<p>处理流：处理流和节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。<br><img src="/images/imgs4/20.gif" alt="Alt text"><br>常用的处理流：</p>
<blockquote>
<p>缓冲流：BufferedInputStrean 、BufferedOutputStream、 BufferedReader、 BufferedWriter 增加缓冲功能，避免频繁读写硬盘<br>转换流：InputStreamReader 、OutputStreamReader实现字节流和字符流之间的转换<br>数据流： DataInputStream 、DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来</p>
</blockquote>
<p><img src="/images/imgs4/13.jpg" alt="Alt text"></p>
<h4 id="文件File类"><a href="#文件File类" class="headerlink" title="文件File类"></a>文件File类</h4><p><strong>File常用方法</strong></p>
<blockquote>
<p>创建：<br>createNewFile()在指定位置创建一个空文件，成功就返回true，如果已存在就不创建，然后返回false。<br>mkdir()  在指定位置创建一个单级文件夹。<br>mkdirs()  在指定位置创建一个多级文件夹。<br>renameTo(File dest)如果目标文件与源文件是在同一个路径下，那么renameTo的作用是重命名， 如果目标文件与源文件不是在同一个路径下，那么renameTo的作用就是剪切，而且还不能操作文件夹。<br>删除：<br>delete()  删除文件或者一个空文件夹，不能删除非空文件夹，马上删除文件，返回一个布尔值。<br>deleteOnExit()jvm退出时删除文件或者文件夹，用于删除临时文件，无返回值。<br> 判断：<br>exists()  文件或文件夹是否存在。<br>isFile()  是否是一个文件，如果不存在，则始终为false。<br>isDirectory()  是否是一个目录，如果不存在，则始终为false。<br>isHidden()  是否是一个隐藏的文件或是否是隐藏的目录。<br>isAbsolute()  测试此抽象路径名是否为绝对路径名。<br> 获取：<br>getName()  获取文件或文件夹的名称，不包含上级路径。<br>getAbsolutePath()获取文件的绝对路径，与文件是否存在没关系<br>length()  获取文件的大小（字节数），如果文件不存在则返回0L，如果是文件夹也返回0L。<br>getParent()  返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回null。<br>lastModified()获取最后一次被修改的时间。<br>文件夹相关：<br>static File[] listRoots()列出所有的根目录（Window中就是所有系统的盘符）<br>list()  返回目录下的文件或者目录名，包含隐藏文件。对于文件这样操作会返回null。<br>listFiles()  返回目录下的文件或者目录对象（File类实例），包含隐藏文件。对于文件这样操作会返回null。<br>list(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。<br>listFiles(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> //创建一个文件对象</div><div class="line">  File f1=new File("e:\\aa.txt");</div><div class="line">  //得到文件的路径</div><div class="line">  System.out.println("文件路径"+f1.getAbsolutePath());</div><div class="line">//得到文件的大小,字节数</div><div class="line">  System.out.println("文件的大小"+f1.length());</div><div class="line">//创建文件夹</div><div class="line">		File f3=new File("e:\\ff");</div><div class="line">		//判断文件夹是否存在</div><div class="line">		if(f3.isDirectory())&#123;</div><div class="line">			System.out.println("文件夹存在，不能创建!");</div><div class="line">		&#125;else&#123;</div><div class="line">			//创建文件夹</div><div class="line">			f3.mkdir();</div><div class="line">		&#125;</div><div class="line">		//创建文件和创建文件夹</div><div class="line">		File f2=new File("e:\\ff\\zwl.txt");</div><div class="line">		//判断文件是否存在</div><div class="line">		if(!f2.exists())//可以创建</div><div class="line">			try &#123;</div><div class="line">				f2.createNewFile();//创建一个新文件</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		else&#123;</div><div class="line">			System.out.println("文件存在，不能创建!");</div><div class="line">		&#125;</div><div class="line">		//列出一个文件夹下面的所有文件</div><div class="line">		File f4=new File("e:\\ff");</div><div class="line">		//判断文件夹是事存在</div><div class="line">		if(f4.isDirectory())&#123;</div><div class="line">			//将文件夹的文件，传给lists数组</div><div class="line">			//将文件夹的文件，传给lists数组</div><div class="line">			File lists[]=f4.listFiles();</div><div class="line">			//遍历数组</div><div class="line">			for(int i=0;i&lt;lists.length;i++)&#123;</div><div class="line">				//输出文件夹下所有文件文件名</div><div class="line">				System.out.println("显示出文件名是"+lists[i].getName());</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>对应的结果：</p>
<blockquote>
<p>文件路径e:\aa.txt<br>文件的大小0<br>显示出文件名是zwl.txt</p>
</blockquote>
<h4 id="文件字节与字符流"><a href="#文件字节与字符流" class="headerlink" title="文件字节与字符流"></a>文件字节与字符流</h4><p><strong>InputStream常用方法</strong></p>
<blockquote>
<p>public abstract int read() throws IOException:从输入流中读取数据的下一个字节,到达末尾，返回-1；<br> public int read(byte[] b)throws IOException：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中<br> public int read(byte[] b,int off,int len)throws IOException：将输入流中最多 len 个数据字节读入 byte 数组<br> public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源</p>
</blockquote>
<p><strong>OutputStream常用方法</strong></p>
<blockquote>
<p>public void flush()throws IOException:刷新此输出流并强制写出所有缓冲的输出字节<br> public abstract void write(int b)throws IOException:将 b.length 个字节从指定的 byte 数组写入此输出流。<br> public void write(byte[] b, int off, int len)throws IOException:将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流<br> public void write(byte[] b)throws IOException:将指定的字节写入此输出流。</p>
</blockquote>
<p> Reader与Writer和上述方法基本类似，只不过它操作的是字符。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">int b=0;</div><div class="line">  //FileInputStream in=null;</div><div class="line">  FileReader in=null;</div><div class="line">   FileOutputStream out=null;</div><div class="line">    try &#123;</div><div class="line">		in=new FileReader("E:\\php练习\\readmeFirst.txt");</div><div class="line">		out=new FileOutputStream("E:\\php练习\\ttl.txt");</div><div class="line">	&#125; catch (Exception e) &#123;</div><div class="line">		System.out.println("not file");</div><div class="line">		 System.exit(-1);</div><div class="line">	&#125;</div><div class="line">    try &#123;</div><div class="line">		long num=0;</div><div class="line">		while((b=in.read())!=-1)&#123;</div><div class="line">			System.out.print((char)b);</div><div class="line">			//out.write(b);;</div><div class="line">			num++;</div><div class="line">		&#125;</div><div class="line">		in.close();</div><div class="line">		out.close();</div><div class="line">		System.out.println();</div><div class="line">		System.out.println("共读取了"+num+"个字符");</div><div class="line">	&#125; catch (Exception e) &#123;</div><div class="line">		System.out.println("error!");</div><div class="line">		 System.exit(-1);</div><div class="line">	&#125;</div><div class="line">    System.out.println("copy ok");</div></pre></td></tr></table></figure></p>
<p>上面程序是将已存在的一个文件复制到另一个文件中</p>
<p><strong>缓冲字节与字符流</strong><br>它是在原来节点流基础上增加了一根管道，用于缓存数据，用法基本类似，但是它的构造函数必须是结点流，同时在字符缓冲流中有一个可以读取或存取字符串的方法如：</p>
<blockquote>
<p>public String readLine()throws IOException:读取一个文本行</p>
</blockquote>
<p><strong>Object流</strong><br>Object流的意思将是像一根节点流插入一根Object流管道，专门操作Object，而它必须实现Serializable接口，该接口的意思是可序列化，就是说将一个对象流序列化成子节流写进网络或者文件，比如说游戏存盘，有各个游戏的记录，如果以面向对象来写进管道，它的各个成员变量，会在内存中被序列化成二进制写进去，而Serializable接口无方法，它只是个标记接口，编译器看到实现该接口的类就知道它应该被序列化，同样有一个transient关键字，是使可序列化的某个属性变成透明，也就是它不能变成字节写进去，那个属性只能为默认属性写进去<br>ok，接下来就来看看Object流相关常用方法</p>
<blockquote>
<p>ObjectOutput:有一个void writeObject(Object obj) throws IOException：将对象写入底层存储或流。<br>ObjectInput：Object readObject()throws ClassNotFoundException,IOException：读取并返回对象</p>
</blockquote>
<p>最后不得不说IO流是在太复杂，就是一根管道不断套接着另一根管道，但是IO流是非常有用的，不仅能帮助我们了解计算机底层，而且涉及到数据传输都离不开它。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在涉及IO流之前需要知道文件的概念。文件是数据源（保存数据的的地方）的一种，比如word文件、txt文件。他既可以保存一张图片，也可以保存视
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>直接插入和希尔排序</title>
    <link href="http://www.myzwl.win/2017/07/22/inserSort_1/"/>
    <id>http://www.myzwl.win/2017/07/22/inserSort_1/</id>
    <published>2017-07-22T05:48:51.000Z</published>
    <updated>2017-08-09T04:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>直接插入在本质上改良了之前的冒泡和选择排序，而希尔排序更是超越O（n^2)的传统排序的改良算法</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>算法描述：直接插入排序就是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表<br>首先先定义数据结构</p>
<blockquote>
<p>#define MAXSIZE 10<br>typedef struct{<br>    int r[Maxsize+1]//用于存储要排序的数组，r[0]用作哨兵或者临时变量<br>    int length; //记录顺序表的长度<br>}SqList;</p>
</blockquote>
<p>接下来不妨以5个数模拟该算法执行过程</p>
<blockquote>
<p>初始化为{0,5,3,4,6,2}<br>从第二个数开始往前比较，如3比5小，那么，3赋值给哨兵，5后移到3位置，哨兵赋值给5位置，此时变成<br>{3,3,5,4,6,2}；<br>继续循环，哨兵初始化为0,4比5小，4给哨兵，5后移至4，在比较哨兵与3大小，如果比3小，3后移，在插入到该位置，否则直接插到5位置，ok这就是该算法的核心，在合适的位置直接插入</p>
</blockquote>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>下面在来看算法，一般理解算法的过程，就把自己当做计算机，自我调试，然后就会发现其中无穷的乐趣<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;    </div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;ctype.h&gt;      </div><div class="line">#include &lt;stdlib.h&gt;   </div><div class="line">#include &lt;io.h&gt;  </div><div class="line">#include &lt;math.h&gt;  </div><div class="line">#include &lt;time.h&gt;</div><div class="line"></div><div class="line">#define OK 1</div><div class="line">#define ERROR 0</div><div class="line">#define TRUE 1</div><div class="line">#define FALSE 0</div><div class="line"></div><div class="line"></div><div class="line">typedef int Status; </div><div class="line"></div><div class="line"></div><div class="line">#define MAXSIZE 10000  /* 用于要排序数组个数最大值，可根据需要修改 */</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	int r[MAXSIZE+1];	/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</div><div class="line">	int length;			/* 用于记录顺序表的长度 */</div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line">void InsertSort(SqList *L)</div><div class="line">&#123;</div><div class="line">	int i,j; //i用来控制外层循环，也就是r[i]中每个数，j用来控制r[i]与前面的数大小，并插到合适的位置</div><div class="line">for(i=2;i&lt;=L-&gt;length;i++)&#123;</div><div class="line">   if(L-&gt;r[i]&lt;L-&gt;r[i-1]) //要插的数比前一个数大</div><div class="line">   &#123;</div><div class="line">   	L-&gt;r[0]=L-&gt;r[i];    //要插入的数先放到哨兵</div><div class="line">   	 for(j=i-1;L-&gt;r[j]&gt;L-&gt;r[0];j--) //依次比较插入的数前面的数，放到合适的位置</div><div class="line">   	 	L-&gt;r[j+1]=L-&gt;r[j]; //记录后移</div><div class="line">   	 L-&gt;r[j+1]=L-&gt;r[0];  //插入合适的位置</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void print(SqList L) //打印元素</div><div class="line">&#123;</div><div class="line">	int i;</div><div class="line">	for(i=1;i&lt;L.length;i++)</div><div class="line">		printf("%d,",L.r[i]);</div><div class="line">	printf("%d",L.r[i]);</div><div class="line">	printf("\n");</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	int i;</div><div class="line">      int d[5]=&#123;5,3,4,6,2&#125;;</div><div class="line">        SqList L;</div><div class="line">          for(i=0;i&lt;5;i++)</div><div class="line">          	L.r[i+1]=d[i];</div><div class="line">             L.r[0]=0;</div><div class="line">             L.length=5;</div><div class="line">            printf("直接插入排序:\n");</div><div class="line">             InsertSort(&amp;L);</div><div class="line">              print(L);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面在看看它的时间复杂度，最好的情况就是{2,3,4,5,6}，也就是说其本身已经是一个有序的，很显然只需要L-&gt;r[i]与L-&gt;r[r-1]大小，所以此时时间复杂度为O(n);最坏的情况就是{6,5,4,3,2}，即2+3+。。+n为（n+2)(n-1)/2<br>所以最后根据平局原则，知道直接插入排序的时间复杂度为O(n^2);</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>基本有序</strong><br>首先需要了解一下基本有序的概念，就是指小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，如{2,1,3,6,4,7,5,8,9}，但如{1,5,9,3,7,8,2,4,6}这种9在第三位，2在倒数第三位就不叫基本有序</p>
<p>希尔排序的关键就是将相隔某个”增量”的记录组成一个子序列，实现跳跃式的移动</p>
<blockquote>
<p>初始一个数组{0,9,1,5,8,3,7,4,6,2}，其中0为哨兵<br>并且初始化增量为数组长度（哨兵不算），所以为9，并约定一个循环，当且仅当增量小于等于1退出循环，并且每次增量都执行增量=增量/3+1（也可以是其他增量原则），第一次就是4了<br>然后一个循环变量i从增量+1开始直到小于等于数组长度，然后比较该i值与i-增量值，也就是第一个值大小，后面就是直接插入算法思想了，有一点不一样，就是循环变量j控制不太一样</p>
</blockquote>
<p>然后看看上述数组怎么比较的</p>
<blockquote>
<p>第一次：i=增量+1=5开始，也就是3与9比较，明显满足3&lt;9,然后交换（直接插入思想），依次7与1，不交换，4与5交换，6与8交换，2与9交换这里那个j条件也满足并且2&lt;3在交换，ok得到一个交换后的数组<br>{2,1,4,6,3,7,5,8,9}可以发现经过第一轮后，该数组基本有序了<br>紧接着开始进行第二轮，即增量=增量/3+1=2，即从第三个2与4不交换，1与6不交换，4与3交换，6与7不交换，4与5不交换，7与8不交换，5与9不交换，即得到{2,1,3,6,4,7,5,,8,9};<br>最后一轮：增量为1,2与1交换，2与4不交换，然后依次比较，由于目前已经基本有序，所以交换的比较少，<br>最后得到{1,2,3,4,5,6,7,8,9}</p>
</blockquote>
<h4 id="码上有戏-1"><a href="#码上有戏-1" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>通过上面的例子，大概就是希尔排序的模拟过程，可以发现增量值是一个很巧妙的地方<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">void ShellSort(SqList *L)</div><div class="line">&#123;</div><div class="line">  int i,j;</div><div class="line">  int increment=L-&gt;length; //初始化增量为数组长度</div><div class="line">  do&#123;</div><div class="line">    increment=increment/3+1; //增量序列</div><div class="line">    for(i=increment+1;i&lt;=L-&gt;length;i++) //从增量序列后一位开始</div><div class="line">    &#123;</div><div class="line">      if(L-&gt;r[i]&lt;L-&gt;r[i-increment]) //该位置与第一位比较，是否交换</div><div class="line">      &#123;</div><div class="line">        L-&gt;r[0]=L-&gt;r[i]; //若交换，先放到哨兵位置</div><div class="line">         for(j=i-increment;j&gt;0&amp;&amp;L-&gt;r[0]&lt;L-&gt;r[j];j-=increment)</div><div class="line">           L-&gt;r[j+increment]=L-&gt;r[j]; //记录后移</div><div class="line">            L-&gt;r[j+increment]=L-&gt;r[0];//插入到正确位置</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;while(increment&gt;1);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	int i;</div><div class="line">      int d[5]=&#123;5,3,4,6,2&#125;;</div><div class="line">        SqList L;</div><div class="line">          for(i=0;i&lt;5;i++)</div><div class="line">          	L.r[i+1]=d[i];</div><div class="line">             L.r[0]=0;</div><div class="line">             L.length=5;</div><div class="line">            printf("希尔排序:\n");</div><div class="line">           ShellSort(&amp;L);</div><div class="line">               print(L);</div><div class="line">              print(L);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现希尔排序的关键就是增量的选择，而它的时间复杂度是O(n^(3/2)),显然比传统的算法O(n^2)时间复杂度要小很多</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;直接插入在本质上改良了之前的冒泡和选择排序，而希尔排序更是超越O（n^2)的传统排序的改良算法&lt;/p&gt;
&lt;h4 id=&quot;直接插入排序&quot;&gt;&lt;a
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常用集合类简单总结</title>
    <link href="http://www.myzwl.win/2017/07/21/jihes_1/"/>
    <id>http://www.myzwl.win/2017/07/21/jihes_1/</id>
    <published>2017-07-21T05:48:51.000Z</published>
    <updated>2017-08-08T12:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在没有集合之前我们都是直接用数组存放对象，但是这样操作会很不方便，于是利用数据结构封装了一些列集合，而集合中不存放输几局的基本类型，只存放对象的引用，如图（部分集合源码分析在之前的总结中已经简单研究过）<br><img src="/images/imgs4/1.png" alt="Alt text"><br>java集合主要分为以下三种类型：<br>Set(集)：集合中的对象不按特定方式排序，且没有重复对象。它的有些实现类能对集合中的对象按照特地方式排序。<br>List(列表)：集合中的对象按照索引位置排序，可以有重复对象，允许使用索引检索对象。<br>Map(映射)：集合中的每一个元素都包含一对键对象和值对象（key-value），集合中的键对象是不能重复的,它的一些实现类能对集合中的键对象进行排序。</p>
<p>注意这里的不能重复与比较hashcode和equals有关</p>
<h4 id="集合底层概述"><a href="#集合底层概述" class="headerlink" title="集合底层概述"></a>集合底层概述</h4><p><strong>Collection接口</strong><br>Collection接口是Set、List、Queue接口的父接口，提供了多数集合常用的方法声明，包括 add()、remove()、contains() 、size() 、iterator() 等</p>
<p><strong>List接口</strong><br>它的特点是有序可重复，使用此接口能够精确的控制每个元素插入的位置用户能够使用索引来访问List中的元素并且允许有可重复的元素</p>
<p><strong>ArrayList</strong><br>底层实现是一个动态的数组，查询快，增删慢，线程不安全，效率高</p>
<p><strong>LinkedList</strong><br>底层实现是一个双向循环链表，查询慢，增删快，线程不安全，效率较高</p>
<p><strong>Vector</strong><br>是ArrlyList的线程安全版，底层同它基本一致，但是效率低，现在基本很少用</p>
<p><strong>Set接口</strong><br>它的特点就是唯一性并且不允许出现重复元素和是无序的</p>
<p><strong>hashSet</strong><br>底层是基于哈希表实现的，而其核心就是先比较hashCode（）值是否相同（相当于索引），然后在用equals比较是否相同，从而确定元素是否重复，所以当不希望集合中有重复值，并且不关心元素之间的顺序时可以使用此类</p>
<p><strong>LinkedHashSet</strong><br>底层实现是使用链表和哈希表，它由链表保证元素有序，哈希表保证元素唯一，因此当不希望集合中有重复值，并且希望按照元素的插入顺序进行迭代遍历时可采用此类</p>
<p><strong>TreeSet</strong><br>底层实现是红黑树，也就是一种平衡AVL树，通过比较返回值是否是0来保证元素唯一性，并且通过自然排序来保证元素的排序（自然排序也就是让元素所属的类实现Comparable接口，比如abc排在abd前面，总之就是和插入顺序无关，只和元素本身的内容和特质有关）</p>
<p><strong>Queue接口</strong><br>它的特点就是队列，即用于保存将要执行的任务列表</p>
<p><strong>LinkedList</strong><br>实现了该接口，可以实现先进先出的队列</p>
<p><strong>PriorityQueue</strong><br>底层采用某种排序的单链表存储队列元素，用来创建自然排序的优先级队列</p>
<p><strong>Map接口</strong><br>Map关心的是唯一的标识符，也就是将唯一的键映射到某个元素，以键值对形式存储，键唯一，值可重复</p>
<p><strong>HashMap</strong><br>底层实现是基于哈希表依赖于hashCode（）和equals（）方法，线程不安全，允许key和value为NULL，效率高</p>
<p><strong>Hashtable</strong><br>HashMap的线程安全版，效率低，不允许key和value为NULL</p>
<p><strong>LinkedHashMap</strong><br>底层是由链表和哈希表组成，链表保证元素有序，哈希表保证元素唯一，所以当需要键值对，并且关心插入顺序时可采用它</p>
<p><strong>TreeMap</strong><br>底层是由红黑树实现，当需要键值对，并关心元素的自然排序时可采用它</p>
<p><strong>Collections</strong><br>内置了一些常见的集合算法，像排序，查找算法等</p>
<h4 id="如何选择哪种集合"><a href="#如何选择哪种集合" class="headerlink" title="如何选择哪种集合"></a>如何选择哪种集合</h4><p>1 首先看是否是键值对形式<br>  是的话就选择Map<br>   然后再看是否需要排序：<br>     是的话就是TreeMap<br>     不是的话就是HashMap<br>     一般情况下都使用HashMap<br>   不是键值对的话就选择Collection<br>     再看元素是否唯一：<br>       是的话就选set<br>         元素是否需要排序<br>           是的话就选TreeSet<br>           反之选择HashSet<br>          一般情况选择HashSet<br>        不是元素唯一就选List<br>          再看是否是否需要线程安全：<br>           是的话就选Vector<br>            不是的话就选择ArrayList或者LinkedList<br>             增删选择：LinkedList<br>              查询选择ArrayList<br>              一般情况下都选择ArrayList</p>
<h4 id="集合常见方法"><a href="#集合常见方法" class="headerlink" title="集合常见方法"></a>集合常见方法</h4><p><strong>Collection的常见方法</strong></p>
<blockquote>
<p>1，添加。<br>    boolean add(Object obj):<br>    boolean addAll(Collection coll):<br>2，删除。<br>    boolean remove(object obj):<br>    boolean removeAll(Collection coll);<br>    void clear();<br>3，判断：<br>    boolean contains(object obj):<br>    boolean containsAll(Colllection coll);<br>    boolean isEmpty():判断集合中是否有元素。<br>4，获取：<br>    int size():<br>    Iterator iterator():取出元素的方式：迭代器。<br> 5，其他：<br>    boolean retainAll(Collection coll);取交集。<br>    Object[] toArray():将集合转成数组。 </p>
</blockquote>
<p><strong>Map的常见方法</strong></p>
<blockquote>
<p> 1，添加。<br>          value put(key,value):返回前一个和key关联的值，如果没有返回null.<br> 2，删除。<br>            void  clear():清空map集合。<br>            value remove(key):根据指定的key翻出这个键值对。<br> 3，判断。<br>                boolean containsKey(key):<br>                boolean containsValue(value):<br>                boolean isEmpty();<br> 4，获取。<br>                value get(key):通过键获取值，如果没有该键返回null。                        当然可以通过返回null，来判断是否包含指定键。<br>                int size(): 获取键值对的个数。<br>5.特殊方法： Collection<v> values() 包含的值的 Collection 视图。<br>             Set<map.entry<k,v>&gt; entrySet()方法：返回一个set集合，里面装的是Map.Entry接口类型的键值对象</map.entry<k,v></v></p>
</blockquote>
<p><strong>Map遍历方法</strong></p>
<blockquote>
<p>  第一种遍历的方法<br>  Set<k> keySet()：返回键的set集合<br> 取出map中的所有元素。<br> 原理，通过keySet方法获取map中所有的键所在的Set集合，在通过Set的迭代器获取到每一个键，<br>  在对每一个键通过map集合的get方法获取其对应的值即可。<br>    Set<integer> keySet = map.keySet();<br>        System.out.println(keySet);//键的set集合<br>        Iterator<integer> it = keySet.iterator();//迭代keySet<br>        while(it.hasNext()){<br>            Integer key = it.next();<br>            String value = map.get(key);<br>            System.out.println(key+”:”+value);<br>        }</integer></integer></k></p>
<p>第二种遍历map的方式：通过看API:Set<map.entry<k,v>&gt; entrySet()：Map.Entry<k,v>接口类型，<br>  里面有K getKey() 返回与此项对应的键。 V getValue()  返回与此项对应的值。<br>  Set<map.entry<integer, string="">&gt;entrySet = map.entrySet();<br>        System.out.println(entrySet);//键值对对象<br>        Iterator<map.entry<integer, string="">&gt;it = entrySet.iterator();<br>        while(it.hasNext()){<br>            Map.Entry<integer, string=""> entryMap = it.next();<br>            Integer key = entryMap.getKey();//获取键<br>            String value = entryMap.getValue();//获取值<br>            System.out.println(key+”:”+value);<br>  }</integer,></map.entry<integer,></map.entry<integer,></k,v></map.entry<k,v></p>
</blockquote>
<h4 id="collections常用方法"><a href="#collections常用方法" class="headerlink" title="collections常用方法"></a>collections常用方法</h4><p>由于该集合工具类方法太多，只总结出部分<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">sort</span><span class="params">(Collection)</span></span>：对集合进行自然排序</div><div class="line"><span class="function"><span class="title">reverse</span><span class="params">()</span></span>：反转集合中元素的顺序</div><div class="line"><span class="function"><span class="title">shuffle</span><span class="params">(Collection)</span></span>：对集合进行随机排序</div><div class="line"><span class="function"><span class="title">fill</span><span class="params">(List list,Object o)</span></span>：用对象o替换集合list中的所有元素</div><div class="line"><span class="function"><span class="title">copy</span><span class="params">(List m,List n)</span></span>：将集合n中的元素全部复制到m中,并且覆盖相应索引的元素</div><div class="line"><span class="function"><span class="title">min</span><span class="params">(Collection)</span></span>,min(Collection,Comparator)：前者采用Collection内含自然比较法，后者采用Comparator进行比较</div><div class="line"><span class="function"><span class="title">max</span><span class="params">(Collection)</span></span>,max(Collection,Comparator)：同上</div><div class="line"><span class="function"><span class="title">indexOfSubList</span><span class="params">(List list,List subList)</span></span>：查找subList在list中首次出现位置的索引</div><div class="line"><span class="function"><span class="title">swap</span><span class="params">(List list,int i,int j)</span></span>：交换集合中指定元素索引的位置</div><div class="line">.binarySearch(Collection,Object)：查找指定集合中的元素，返回所查找元素的索引</div><div class="line"><span class="function"><span class="title">replaceAll</span><span class="params">(List list,Object old,Object new)</span></span>：替换批定元素为某元素,若要替换的值存在刚返回true,反之返回false</div></pre></td></tr></table></figure></p>
<p>最后不得不说集合容器是在太复杂了，它包装了许许多多的数据结构和算法，也正是因为如此，才大大简化了难度，但同时也说明了数据结构与算法的重要性，只有我们真正理解了算法和数据结构，才能更好的驾驭集合类</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在没有集合之前我们都是直接用数组存放对象，但是这样操作会很不方便，于是利用数据结构封装了一些列集合，而集合中不存放输几局的基本类型，只存放对
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String与StringBuffer常用方法总结</title>
    <link href="http://www.myzwl.win/2017/07/20/StringBuf_1/"/>
    <id>http://www.myzwl.win/2017/07/20/StringBuf_1/</id>
    <published>2017-07-20T05:48:51.000Z</published>
    <updated>2017-08-07T06:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>String与StringBuffer的区别，简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。</p>
<h4 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h4><p>在之前的数据结构与算法中已经模拟了部分String常用的方法</p>
<blockquote>
<p>public final class Stringextends Objectimplements Serializable, Comparable<string>, CharSequence</string></p>
</blockquote>
<p><strong>构造方法</strong></p>
<blockquote>
<p>public String()：初始化一个新创建的 String 对象，使其表示一个空字符序列。注意，由于 String 是不可变的，所以无需使用此构造方法。<br> public String(String original）：创建一个String对象为original的拷贝<br> public String(char[] value)：用一个字符数组创建一个String对象<br> public String(char[] value, int offset,int count)：用一个字符数组从offset项开始的count个字符序列创建一个String对象</p>
</blockquote>
<p><strong>普通方法</strong></p>
<blockquote>
<p>public char charAt(int index):返回字符串中第index个字符<br> public int length():返回字符串的长度<br> public int indexOf(String str):返回字符串中出现str的第一个位置<br> public int indexOf(String str,int fromIndex):返回字符串中从fromIndex开始起出现str的第一个位置<br> public boolean equalsIgnoreCase(String another):比较字符串与another是否一样（忽略大小写）<br> public String replace(char oldChar,char newChar):在字符串中用newChar替换oldChar<br> public boolean startWith(String prefix):判断字符串是否以prefix字符串开头<br> public boolean endsWith(String suffix):判断字符串是否以suffix为结尾<br> public String toLowerCase():返回一个字符串为该字符串的小写形式<br> public String substring(int beginIndex):返回该字符串从beginIndex开始到结尾的字符串<br> public String substring(int beginIndex,int endIndex):返回该字符串从beginIndex开始到endIndex结尾的字符串<br> public String trim():返回将该字符串去掉开头和结尾空格后的字符串</p>
</blockquote>
<p><strong>静态重载方法</strong></p>
<blockquote>
<p>public static String valueOf(..):将基本类型数据转化为字符串，如<br> public static String valueOf(double d)</p>
</blockquote>
<p><strong>其它常用方法</strong></p>
<blockquote>
<p>public String[] split(String regix):可以将一个字符串按照指定的分隔符分隔，返回分隔后的字符串数组<br>public String concat(String str)//将参数中的字符串str连接到当前字符串的后面，效果等价于”+”；<br>contains(String str)//判断参数s是否被包含在字符串中，并返回一个布尔类型的值。<br>字符串转换为基本类型<br>java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：<br>1)public static byte parseByte(String s)<br>2)public static short parseShort(String s)<br>3)public static short parseInt(String s)<br>4)public static long parseLong(String s)<br>5)public static float parseFloat(String s)<br>6)public static double parseDouble(String s)</p>
</blockquote>
<p><strong>字符串比较</strong></p>
<blockquote>
<p>1)public int compareTo(String anotherString)//该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。<br>2)public int compareToIgnore(String anotherString)//与compareTo方法相似，但忽略大小写。<br>3)public boolean equals(Object anotherObject)//比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。<br>4)public boolean equalsIgnoreCase(String anotherString)//与equals方法相似，但忽略大小写。</p>
</blockquote>
<h4 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h4><p><strong>构造方法</strong></p>
<blockquote>
<p>StringBuffer() ：构造一个没有任何字符的StringBuffer类。<br>StringBuffer(int length) ：：构造一个没有任何字符的StringBuffer类，并且，其长度为length。<br>StringBuffer(String str) ：以str为初始值构造一个StringBuffer类。</p>
</blockquote>
<p><strong>append方法</strong><br>为该对象添加字符序列，返回添加后的该对象引用，同时是调用了toString方法转化为字符串</p>
<blockquote>
<ol>
<li>StringBuffer append(boolean b)</li>
<li>StringBuffer append(char c)</li>
<li>StringBuffer append(char[] str)</li>
<li>StringBuffer append(char[] str, int offset, int len)</li>
<li>StringBuffer append(double d)</li>
<li>StringBuffer append(float f)</li>
<li>StringBuffer append(int i)</li>
<li>StringBuffer append(long l)</li>
<li>StringBuffer append(Object obj)</li>
<li>StringBuffer append(String str)</li>
<li>StringBuffer append(StringBuffer sb)</li>
</ol>
</blockquote>
<p><strong>其他方法</strong></p>
<blockquote>
<p>12.int capacity() ：返回当前StringBuffer对象（字符串缓冲区）的总空间，而非字符号串的长度。</p>
<ol>
<li>char charAt(int index) ：在当前StringBuffer对象中取索引号为index的字符。第一个字符的索引为“0”</li>
<li>StringBuffer delete(int start, int end) ：删除当前StringBuffer对象中以索引号start开始，到end结束的子串。</li>
<li>StringBuffer deleteCharAt(int index) ：删除当前StringBuffer对象中索引号为index的字符。</li>
<li>void ensureCapacity(int minimumCapacity) ：重新设置字符号串缓冲区的总空间。如果minimumCapacity大于当前的总空间，则新的空间被设置：一种结果是minimumCapacity；另一种结果是{“老空间”乘2加2}<br>17.void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) ：从当前StringBuffer对象的索引号srcBegin开始，到srcEnd结束的子串，赋值到字符数组dst中，并且从dst的索引号dstBegin开始</li>
<li>int indexOf(String str) ：返回当前StringBuffer对象中，第一个满足str子串的位置。</li>
<li>int indexOf(String str, int fromIndex) ：从当前StringBuffer对象的fromIndex开始查找，返回第一个满足str子串的位置。</li>
<li>StringBuffer insert(int offset, boolean b)</li>
<li>StringBuffer insert(int offset, char c)</li>
<li>StringBuffer insert(int offset, char[] str)</li>
<li>StringBuffer insert(int index, char[] str, int offset, int len)</li>
<li>StringBuffer insert(int offset, double d)</li>
<li>StringBuffer insert(int offset, float f)</li>
<li>StringBuffer insert(int offset, int i)</li>
<li>StringBuffer insert(int offset, long l)</li>
<li>StringBuffer insert(int offset, Object obj)</li>
<li>StringBuffer insert(int offset, String str)</li>
<li>int lastIndexOf(String str) ：返回当前StringBuffer对象中，最后一个满足str子串的位置。</li>
<li>int lastIndexOf(String str, int fromIndex) ：从当前StringBuffer对象的fromIndex开始查找，返回最后一个满足str子串的位置。</li>
<li>int length() ：返回当前StringBuffer对象（字符缓冲区）中，字符串的长度。注意：此方法与capacity() 不同。</li>
<li>StringBuffer replace(int start, int end, String str) ：替换当前StringBuffer对象的字符串。从start开始，到end结束的位置替换成str。</li>
<li>StringBuffer reverse() ：将字符串翻转。</li>
<li>void setCharAt(int index, char ch) ：设置索引号index的字符为ch。</li>
<li>void setLength(int newLength) ：重新设置字符串缓冲区中字符串的长度，如果newLength小于当前的字符串长度，将截去多余的字符。</li>
<li>String substring(int start) ：取当前StringBuffer对象中，从start开始到结尾的子串。</li>
<li>String substring(int start, int end) ：取当前StringBuffer对象中，从start开始到end的子串。</li>
<li>String toString() ：将当前StringBuffer对象转换成String对象。</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;String与StringBuffer的区别，简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Brute-Force与KMP算法</title>
    <link href="http://www.myzwl.win/2017/07/19/suanfa_2/"/>
    <id>http://www.myzwl.win/2017/07/19/suanfa_2/</id>
    <published>2017-07-19T05:48:51.000Z</published>
    <updated>2017-08-07T05:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设有两个串：目标串target和模式串pattern，在目标串中查找与模式串pattern相等得一个子串并确定孩子串位置的操作称为串的模式匹配。而匹配的结果有两种，如果target中存在等于pattern的子串，则匹配成功，给出孩子串在target中的位置，否则匹配失败</p>
<h4 id="Brute-Force算法"><a href="#Brute-Force算法" class="headerlink" title="Brute-Force算法"></a>Brute-Force算法</h4><p><img src="/images/imgs4/16.gif" alt="Alt text"><br>算法描述：如图，该算法的核心就是在target中从begin位置，这里begin=0开始，比较ti与pi是否相等，如果有一个不相等，则begin开始从之前的下一个字符开始匹配，同时pattern中退回到第一个字符，在依次比较，知道存在相等字符，返回相应位置，可以发现该算法是一个回溯算法。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//模式匹配，pattern为待匹配子串，begin为起始匹配位置</div><div class="line">public int indexOf(MyString pattern,int begin)&#123;</div><div class="line">	//待匹配子串不为空并且长度大于0和目标串大于等于带匹配子串</div><div class="line">	if(pattern!=null&amp;&amp;pattern.length()&gt;0&amp;&amp;this.length()&gt;=pattern.length())</div><div class="line">	&#123;</div><div class="line">		int i=begin,j=0; //记录i为开始位置，j为待匹配子串计数器</div><div class="line">		while(i&gt;this.length())&#123; //目标串全部匹配完，退出</div><div class="line">			if(this.charAt(i)==pattern.charAt(j))//如果，有字符相等</div><div class="line">			&#123;</div><div class="line">				i++; //计数器都加1，并且开始比较后一个字符</div><div class="line">				j++;</div><div class="line">			&#125;</div><div class="line">			else&#123;</div><div class="line">				i=i+j+1; //i回溯，变成上一个目标串匹配字符的下一个字符</div><div class="line">				j=0;    //待匹配字符，回溯为0</div><div class="line">			&#125;</div><div class="line">			if(j==pattern.length())</div><div class="line">				return i-j; //返回匹配到的位置</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	           return -1; //匹配失败</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回当前目标串的首次位置，从第一个位置开始</div><div class="line">public int indexOf(MyString pattern)&#123;</div><div class="line">	return this.indexOf(pattern, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="模式匹配应用"><a href="#模式匹配应用" class="headerlink" title="模式匹配应用"></a>模式匹配应用</h4><p>一般我们要替换或者删除相关子串时，首先就是查找是否存在此串，然后在进行相关操作<br>首先是替换操作<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//返回当前串替换之后的串</div><div class="line">public MyString replaceFirst(MyString pattern,MyString replacement)&#123;</div><div class="line">	int i=this.indexOf(pattern, 0);//找到要替换串的下标</div><div class="line">	 if(i==-1)</div><div class="line">		 return this; //不存在要替换的部分，返回当前串</div><div class="line">	 //连接三个串</div><div class="line">	 return this.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length()));		 </div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyString replaceAll(MyString pattern,MyString replacement)&#123;</div><div class="line">	MyString temp=new MyString(this);</div><div class="line">	 int i=this.indexOf(pattern, 0);</div><div class="line">	  while(1!=-1)</div><div class="line">	  &#123;</div><div class="line">		  temp=temp.substring(0, i).concat(replacement).concat(this.substring(i+pattern.length()));</div><div class="line">		  i=temp.indexOf(pattern, i+replacement.length());//从下一个字符开始继续寻找匹配</div><div class="line">	  &#125;</div><div class="line">	  return temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，String是不变类型，也就是一个新的字符串是在堆栈上又开辟了一个新空间，不是原来的对象<br>下面是删除操作<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public MyString deleteFirst(MyString target,MyString pattern)&#123;</div><div class="line">	int i=target.indexOf(pattern);</div><div class="line">	 if(i==-1)</div><div class="line">		 return target;</div><div class="line">	  return target.substring(0, i)+target.substring(i+pattern.length());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyString deleteAll(MyString target,MyString pattern)&#123;</div><div class="line">	int i=target.indexOf(pattern);</div><div class="line">	 while(i!=-1)</div><div class="line">	 &#123;</div><div class="line">		 target=target.substring(0, i)+target.substring(i+pattern.length());</div><div class="line">		  i=target.indexOf(pattern, i);</div><div class="line">	 &#125;</div><div class="line">	 return target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心思想就是先模式匹配，然后在构造一个新的串</p>
<p>最后分析一下该模式匹配算法，假设模式串长度为m，可以发现他的时间复杂度为O(m);并且匹配中存在很多重复，所以算法效率是很低的</p>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>由之前的算法我们知道，它存在重复匹配，如之前的pattern=abc，此时p的各个字符都不相等，而在匹配时target=ababdabcd中，第一次从a匹配，到第三位不等，开始从第二位匹配，但由于第一次已经知道pi各位不等，所以第二位就不用匹配了，他肯定与第一位不等，所以可省略，而这恰恰是KMP算法的核心</p>
<p><strong>next数组</strong><br>next数组的作用就是研究pattern串，依次确定如果不匹配下一次target串从哪一位开始匹配。并且这样定义next数组</p>
<blockquote>
<p>next[J]=-1，当j=0；<br>next[j]=k 当0&lt;=k&lt;f时且使p_0..p_k-1=p_j-k..p_j-1的最大整数</p>
</blockquote>
<p><img src="/images/imgs4/17.gif" alt="Alt text"><br>如图：pattern=”abcabc”，当j=0时，next[0]=-1；当j=1,2,3时，”a”,”ab”,”abc”都没有相同前缀子串和后缀子串next[j]=k=0；当j=4时，”abca”钟相同的前缀子串和后缀子串是”a”，所以k=1；当j=5时，为”ab”，所以k=2，依次类推<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private int[] getNext(String pattern)&#123;  //求next</div><div class="line">		int j=0,k=-1;                   //初始化j，k，next</div><div class="line">		int[] next=new int[pattern.length()];</div><div class="line">		next[0]=-1;</div><div class="line">		while(j&lt;pattern.length()-1)    //当j遍历完pattern字符串，结束</div><div class="line">		&#123;</div><div class="line">			if(k==-1||pattern.charAt(j)==pattern.charAt(k)) //k为初始值或者pattern的后缀字符与前缀相同</div><div class="line">			&#123; </div><div class="line">				j++;           //j后移，k加一，同时第j个字符的next值为k</div><div class="line">				k++;</div><div class="line">				next[j]=k;</div><div class="line">			&#125; </div><div class="line">			else              //否则，k重新回到前缀值，继续比较</div><div class="line">				k=next[k];</div><div class="line">			return next;</div><div class="line">		&#125;</div><div class="line">		return next;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下面是KMP的算法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int indexOf(String target,String pattern,int begin)&#123;</div><div class="line">		if(pattern!=null&amp;&amp;pattern.length()&gt;0&amp;&amp;this.length()&gt;=pattern.length())</div><div class="line">		&#123;</div><div class="line">		int i=begin,j=0;</div><div class="line">		int[] next=getNext(pattern); //求得next数组，这样就可以避免一些重复比较了</div><div class="line">		while(i&lt;target.length())&#123;</div><div class="line">			if(j==-1||target.charAt(i)==pattern.charAt(j))</div><div class="line">			&#123;</div><div class="line">				i++;</div><div class="line">				j++;</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">				j=next[j]; //退回到next[J]个字符开始比较</div><div class="line">			if(j==pattern.length())</div><div class="line">				return i-j;</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		return -1;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h4 id="改进的KMP算法"><a href="#改进的KMP算法" class="headerlink" title="改进的KMP算法"></a>改进的KMP算法</h4><p>当target=”aaaabcde”时，pattern=”aaaax”时，发现，a重复了，按照之前的算法，当i=5时，有重复比较四个a，所以可改进<br><img src="/images/imgs4/18.gif" alt="Alt text"><br>如图：改进的nextval是在next数组基础上，这里约定的next初始值为-1，所以如j=3，与next[j]+1比较，如果相等，则其值等于next[j]+1的next值，否则，保持原next值不变<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private int[] getNext(String pattern)&#123;</div><div class="line">		int j=0,k=-1;</div><div class="line">		int[] next=new int[pattern.length()];</div><div class="line">		next[0]=-1;</div><div class="line">		while(j&lt;pattern.length()-1)</div><div class="line">		&#123;</div><div class="line">			if(k==-1||pattern.charAt(j)==pattern.charAt(k))</div><div class="line">			&#123;</div><div class="line">				j++;</div><div class="line">				k++;</div><div class="line">				if(pattern.charAt(j)!=pattern.charAt(k))//改进之处</div><div class="line">				next[j]=k;</div><div class="line">				else</div><div class="line">					next[j]=next[k];</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">				k=next[k];</div><div class="line">			return next;</div><div class="line">		&#125;</div><div class="line">		return next;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>由此发现KMP算法的时间复杂度为O(n);</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;设有两个串：目标串target和模式串pattern，在目标串中查找与模式串pattern相等得一个子串并确定孩子串位置的操作称为串的模式匹
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>冒泡与选择排序</title>
    <link href="http://www.myzwl.win/2017/07/18/suanfa_1/"/>
    <id>http://www.myzwl.win/2017/07/18/suanfa_1/</id>
    <published>2017-07-18T05:48:51.000Z</published>
    <updated>2017-08-06T12:56:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>算法描述：冒泡排序是一种交换排序，它的基本思想就是两两比较相邻的关键字，如果反序则交换，直到没有反序的记录为止<br><img src="/images/imgs4/14.gif" alt="Alt text"><br>就像冒泡一样，第一次先把最大的选出来冒到最后，依次类推，从下个继续冒最大的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int a[])&#123;</div><div class="line">		int temp;  //临时变量，用于交换</div><div class="line">		for(int i=a.length-1;i&gt;0;i--) //外层循环，用于控制需要冒泡的个数</div><div class="line">			for(int j=0;j&lt;=i-1;j++) //内存循环</div><div class="line">				if(a[j]&gt;a[j+1]) //如果需要交换，则交换</div><div class="line">				&#123;</div><div class="line">					temp=a[j+1];</div><div class="line">					a[j+1]=a[j];</div><div class="line">					a[j]=temp;</div><div class="line">				&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出这个冒泡的实现是很简单的，但是效率上存在严重问题，比如有序数列2,1,3,4,5这个除了第一个，其余都已经是有序了，但是根据算法还是不断循环，比较增加了冗余，所以需要改进<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int a[])&#123;</div><div class="line">	int temp;</div><div class="line">	boolean flag=true; //用来作为标记</div><div class="line">	for(int i=a.length-1;i&gt;0&amp;&amp;flag;i--)&#123; //如果flag为false，也就是已经有序了，退出</div><div class="line">		flag=false;  //初始化为false</div><div class="line">		for(int j=0;j&lt;=i-1;j++)</div><div class="line">			if(a[j]&gt;a[j+1])</div><div class="line">			&#123;</div><div class="line">				temp=a[j+1];</div><div class="line">				a[j+1]=a[j];</div><div class="line">				a[j]=temp;</div><div class="line">				flag=true;  //如果有数据交换，则设为true</div><div class="line">			&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>显然从效率上提高了许多，由内外循环次数可以得出其时间复杂度为o(n^2)</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>算法描述：选择排序就是通过n-i此关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换<br><img src="/images/imgs4/15.gif" alt="Alt text"><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void ChooseSort(int[] a)&#123;</div><div class="line">	int min,temp;  //分别为每一次循环的当前最小变量和临时变量</div><div class="line">	for(int i=0;i&lt;a.length;i++)&#123;</div><div class="line">		 min=i; //初始化最小变量，为当前循环的第一个变量</div><div class="line">	 for(int j=i+1;j&lt;a.length;j++)</div><div class="line">	 &#123;</div><div class="line">		 if(a[j]&lt;a[i])  //找到比当前循环的最小变量小的记录，并记录下标</div><div class="line">			 min=j;</div><div class="line">	 &#125;</div><div class="line">	 if(min!=i) //如果有比当前最小变量小，则交换记录</div><div class="line">	 &#123;</div><div class="line">		 temp=a[min];</div><div class="line">		 a[min]=a[i];</div><div class="line">		 a[i]=temp;			 </div><div class="line">	 &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出它的时间复杂度仍然是O(n^2)</p>
<h4 id="约瑟夫环的另一种解法"><a href="#约瑟夫环的另一种解法" class="headerlink" title="约瑟夫环的另一种解法"></a>约瑟夫环的另一种解法</h4><p>至于问题描述就不描述了，在之前的数据结构总结中已经有了这个问题的描述<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public static void Count3Quit()&#123;</div><div class="line">		boolean[] arr=new boolean[500]; //初始化500个人围成圈</div><div class="line">		 for(int i=0;i&lt;arr.length;i++) //假设每个人值都为true</div><div class="line">	      arr[i]=true;</div><div class="line">		    int len=arr.length; //记录总人数</div><div class="line">		    int index=0;  //记录每个人的索引</div><div class="line">		    int count=0;  //记录数数变量，这里是数三退一</div><div class="line">		     while(len&gt;1)//直到只剩最后一个人为止</div><div class="line">		     &#123;</div><div class="line">		    	 if(arr[index]==true) //人还在圈内</div><div class="line">		    	 &#123;</div><div class="line">		    		 count++; //数数加一</div><div class="line">		    		 if(count==3) //数到三时，退一个人</div><div class="line">		    		 &#123;</div><div class="line">		    			 count=0; //计数重置为0</div><div class="line">		    			  arr[index]=false; //该人退出</div><div class="line">		    			   len--; //总人数减一</div><div class="line">		    		 &#125;</div><div class="line">		    	 &#125;</div><div class="line">		    	 index++; //索引加一</div><div class="line">		    	 if(index==arr.length)//索引超出人数长度，循环从0开始</div><div class="line">		    		 index=0;</div><div class="line">		     &#125;</div><div class="line">		     for(int i=0;i&lt;arr.length;i++)//输出最后一个人</div><div class="line">		    	 if(arr[i]==true)</div><div class="line">		    		 System.out.println(i);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h4&gt;&lt;p&gt;算法描述：冒泡排序是一种交换排序，它的基本思想就是两两比较相邻的关键字，如果反序则交换，直到没有反序的记录为止&lt;br&gt;&lt;im
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java异常处理二</title>
    <link href="http://www.myzwl.win/2017/07/17/yc_2/"/>
    <id>http://www.myzwl.win/2017/07/17/yc_2/</id>
    <published>2017-07-17T05:48:51.000Z</published>
    <updated>2017-08-05T10:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过一已经初步了解了异常的一些原理和相关性质，当然在平时写程序时被各种各样的异常类型弄得叫苦不堪<br><img src="/images/imgs4/12.gif" alt="Alt text"></p>
<h4 id="java常见异常"><a href="#java常见异常" class="headerlink" title="java常见异常"></a>java常见异常</h4><p>从api文档中可以看出，java已经为我们内置了很多异常<br><img src="/images/imgs4/13.gif" alt="Alt text"><br>先来看看RuntimeException中常见异常</p>
<blockquote>
<p>  1java.lang.ArrayIndexOutOfBoundsException<br>    数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。<br>    2、java.lang.ArithmeticException<br>    算术条件异常。譬如：整数除零等。<br>    3、java.lang.NullPointerException<br>    空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等<br>    4、java.lang.ClassNotFoundException<br>    找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。<br>   5、java.lang.NegativeArraySizeException  数组长度为负异常<br>   6、java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常<br>   7、java.lang.SecurityException 安全性异常<br>   8、java.lang.IllegalArgumentException 非法参数异常</p>
</blockquote>
<p><strong>IOException</strong></p>
<blockquote>
<p>IOException：操作输入流和输出流时可能出现的异常。<br>  EOFException   文件已结束异常<br>  FileNotFoundException   文件未找到异常</p>
</blockquote>
<p><strong>其他异常</strong></p>
<blockquote>
<p> ClassCastException    类型转换异常类<br>   ArrayStoreException  数组中包含不兼容的值抛出的异常<br>    SQLException   操作数据库异常类<br>    NoSuchFieldException   字段未找到异常<br>    NoSuchMethodException   方法未找到抛出的异常<br>    NumberFormatException    字符串转换为数字抛出的异常<br>    StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常<br>    IllegalAccessException  不允许访问某类异常<br>    InstantiationException  当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</p>
</blockquote>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>在Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。<br> 所有异常都必须是 Throwable 的子类。<br> 如果希望写一个检查性异常类，则需要继承 Exception 类。<br> 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。<br> 如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class MyException extends Exception&#123;</div><div class="line"></div><div class="line">	private int id;</div><div class="line">	</div><div class="line">	public MyException()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyException(String msg,int id)&#123;</div><div class="line">		super(msg);</div><div class="line">		this.id=id;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int getId()&#123;</div><div class="line">		return this.id;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Ttest &#123;</div><div class="line">  public void regist(int num) throws MyException&#123;</div><div class="line">	  if(num&lt;0)&#123;</div><div class="line">		  throw new MyException("不能为负数",404);</div><div class="line">	  &#125;</div><div class="line">	  System.out.println("it is"+num);		  </div><div class="line">  &#125;</div><div class="line">  public void manager()&#123;</div><div class="line">	  try &#123;</div><div class="line">		regist(-10);</div><div class="line">	&#125; catch (MyException e) &#123;</div><div class="line">		System.out.println("Error Code"+e.getId());</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">	  System.out.println("over");</div><div class="line">  &#125;</div><div class="line">  public static void main(String args[])&#123;</div><div class="line">	  Ttest t=new Ttest();</div><div class="line">	  t.manager();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果有异常时运行结果如下：</p>
<blockquote>
<p>com.test.QQ.MyException: 不能为负数<br>    at com.test.QQ.Ttest.regist(Ttest.java:6)<br>    at com.test.QQ.Ttest.manager(Ttest.java:12)<br>    at com.test.QQ.Ttest.main(Ttest.java:21)<br>Error Code404<br>over</p>
</blockquote>
<p>将regist（-10）改为regist（10），如下</p>
<blockquote>
<p>it is10<br>over</p>
</blockquote>
<h4 id="spring异常处理"><a href="#spring异常处理" class="headerlink" title="spring异常处理"></a>spring异常处理</h4><p>前面我们都是用try..catch来捕获异常，造成业务逻辑较多，而spring通过注解式使捕获异常更方便。核心如下：</p>
<blockquote>
<p>  @ExceptionHandler：统一处理某一类异常，从而能够减少代码重复率和复杂度<br>    @ControllerAdvice：异常集中处理，更好的使业务逻辑与异常处理剥离开<br>    @ResponseStatus：可以将某种异常映射为HTTP状态码</p>
</blockquote>
<p>@ExceptionHandler源码如下：</p>
<blockquote>
<p>@Target({ElementType.METHOD})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface ExceptionHandler {<br>    Class&lt;? extends Throwable&gt;[] value() default {};<br> }</p>
</blockquote>
<p> 首先是注解的说明：<br> @Retention: 定义注解的保留策略<br>@Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在class字节码文件中不包含<br>@Retention(RetentionPolicy.CLASS)     // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，<br>@Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到</p>
<p>@Target：定义注解的作用目标<br>@Target(ElementType.TYPE)   //接口、类、枚举、注解<br>@Target(ElementType.FIELD) //字段、枚举的常量<br>@Target(ElementType.METHOD) //方法<br>@Target(ElementType.PARAMETER) //方法参数<br>@Target(ElementType.CONSTRUCTOR)  //构造函数<br>@Target(ElementType.LOCAL_VARIABLE)//局部变量<br>@Target(ElementType.ANNOTATION_TYPE)//注解<br>@Target(ElementType.PACKAGE) ///包    </p>
<p>@Document：说明该注解将被包含在javadoc中<br>@Inherited：说明子类可以继承父类中的该注解</p>
<p>该注解作用对象为方法，并且在运行时有效，value()可以指定异常类<br>方法返回值可以为：<br>    ModelAndView对象<br>    Model对象<br>    Map对象<br>    View对象<br>    String对象<br>    还有@ResponseBody、HttpEntity&lt;?&gt;或ResponseEntity&lt;?&gt;，以及void</p>
<p>如</p>
<blockquote>
<p>@ControllerAdvice //在所有的controller中执行该异常<br>public class DefaultExceptionHandler {<br>    /**</p>
<pre><code> * 没有权限 异常
 * &lt;p/&gt;
 * 后续根据不同的需求定制即可
 */
@ExceptionHandler({UnauthorizedException.class}) //不同的异常处理
@ResponseStatus(HttpStatus.UNAUTHORIZED)
public String processUnauthenticatedException(NativeWebRequest request, UnauthorizedException e) {
    System.out.println(&quot;un&quot;);
    return null;
</code></pre><p>}</p>
</blockquote>
<pre><code>@ExceptionHandler(RuntimeException.class)
@ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)  
public String handleUnexpectedServerError(RuntimeException ex) { 
    System.out.println(&quot;500&quot;);
    return null;
}

@ExceptionHandler(ServletException.class)
@ResponseStatus(value = HttpStatus.NOT_FOUND)  
public String handleNotFoundError() {     
       System.out.println(&quot;404&quot;);
      return null;       
}
</code></pre><p>}</p>
<p>如上的500和404错误，先给出错误的异常，在给出错误的状态码并且异常与状态码必须是对应的，该类的源码在org.springframework.http下，如</p>
<blockquote>
<p>public enum HttpStatus {<br>成功<br>   OK(200, “OK”),<br>   创建<br>   CREATED(201, “Created”),<br>   /接受<br>   ACCEPTED(202, “Accepted”),<br>   BAD_REQUEST(400, “Bad Request”),<br>   没有认证权限<br>   UNAUTHORIZED(401, “Unauthorized”),</p>
</blockquote>
<p>   PAYMENT_REQUIRED(402, “Payment Required”),<br>   禁止<br>   FORBIDDEN(403, “Forbidden”),</p>
<p>   NOT_FOUND(404, “Not Found”),</p>
<p>   有了上述全局处理的异常，就不许要在每个类里面重复写了，同时如果我们是在页面中需要捕获异常，如页面的404和500，只需在web.xml中配置一下（在spring配置文件中注入无效，也不知道怎么回事），如下：</p>
<blockquote>
<p><error-page><br>        <error-code>404</error-code><br>        <location>/404.jsp</location><br>    </error-page><br>    <error-page><br>    <error-code>500</error-code><br>     <location>/500.jsp</location><br> </error-page></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过一已经初步了解了异常的一些原理和相关性质，当然在平时写程序时被各种各样的异常类型弄得叫苦不堪&lt;br&gt;&lt;img src=&quot;/images/
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java异常处理一</title>
    <link href="http://www.myzwl.win/2017/07/16/yc_1/"/>
    <id>http://www.myzwl.win/2017/07/16/yc_1/</id>
    <published>2017-07-16T05:48:51.000Z</published>
    <updated>2017-08-05T05:27:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不得不说，我们平时在写程序时遇到最多的情形或者最头疼的事情就是遇到异常，然后各种调试，各种方法用尽最后才解决它，那么异常主要分为几类，每个类又有什么特征了（如图）<br><img src="/images/imgs4/11.gif" alt="Alt text"><br>从大的角度说主要分成两类：Error类代表了编译和系统的错误，不允许捕获，也就是我们自己无法主动去处理它；Exception类代表了我们可捕获并且可自己可处理异常，而Exception有包括两类，一个是你必须要处理的异常，如某个类有throws异常了，在未进入运行期就必须处理，另一类就是Runtime Exception（运行期异常），就是只有在运行时（也就是编译成class文件）时才知道，这个异常可处理或不处理</p>
<h4 id="处理异常机制"><a href="#处理异常机制" class="headerlink" title="处理异常机制"></a>处理异常机制</h4><p>在java应用程序中，异常处理机制主要为两种:抛出异常和捕获异常<br><strong>抛出异常</strong><br>简单的说，就是不处理异常，将异常不断抛给上一级，直至某一级有有处理异常措施，一般用throws、throw如</p>
<blockquote>
<p>public readFile() throws IOException{<br>    throw new xxx();<br>}</p>
</blockquote>
<p><strong>捕获异常</strong><br>定义是这样说的，在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。<br>一般有try..catch语句块，其语法格式如下：</p>
<blockquote>
<p>   try {<br>        // 可能会发生异常的程序代码<br>    } catch (Type1 id1){<br>        // 捕获并处置try抛出的异常类型Type1<br>    }<br>    catch (Type2 id2){<br>         //捕获并处置try抛出的异常类型Type2<br>    }  </p>
</blockquote>
<pre><code>如果，不管异常有没有捕获，都要执行某段代码，如数据库查询后都要关闭等等，就可以用finally，上面修改
</code></pre><blockquote>
<p>   try {<br>        // 可能会发生异常的程序代码<br>    } catch (Type1 id1){<br>        // 捕获并处置try抛出的异常类型Type1<br>    }<br>    catch (Type2 id2){<br>         //捕获并处置try抛出的异常类型Type2<br>    }  finally{<br>        //必须执行的代码<br>    }</p>
</blockquote>
<h4 id="try-catch-finally-规则"><a href="#try-catch-finally-规则" class="headerlink" title="try-catch-finally 规则"></a>try-catch-finally 规则</h4><pre><code>try块：用于捕获异常。其后可接0个或多个catch块，如果没有catch块，则必须跟一个finally块
catch块：用于处理try捕获到的异常。
finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行：
</code></pre><p>1）在finally语句块中发生了异常。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）关闭CPU。</p>
<p>try..catch..拥有执行顺序，即第一个catch之后，后面不在执行catch，所以一般将较详细的catch放在最前面，如先捕获IOException在捕获Exception</p>
<h4 id="throws规则"><a href="#throws规则" class="headerlink" title="throws规则"></a>throws规则</h4><p>1) 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</p>
<p>2）必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</p>
<p>3)仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出</p>
<p>4）调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。<br>如下</p>
<blockquote>
<pre><code>void method1() throws IOException{}  //合法    
</code></pre></blockquote>
<pre><code>//编译错误，必须捕获或声明抛出IOException    
void method2(){    
  method1();    
}    

//合法，声明抛出IOException    
void method3()throws IOException {    
  method1();    
}    

//合法，声明抛出Exception，IOException是Exception的子类    
void method4()throws Exception {    
  method1();    
}    

//合法，捕获IOException    
void method5(){    
 try{    
    method1();    
 }catch(IOException e){…}    
}    

//编译错误，必须捕获或声明抛出Exception    
void method6(){    
  try{    
    method1();    
  }catch(IOException e){throw new Exception();}    
}    

//合法，声明抛出Exception    
void method7()throws Exception{    
 try{    
  method1();    
 }catch(IOException e){throw new Exception();}    
}   

这里需要注意的是throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象
</code></pre><p><strong>Throwable类源码分析</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div></pre></td><td class="code"><pre><div class="line">/**  </div><div class="line">    *   </div><div class="line">    * Throwable是所有Error和Exceptiong的父类  </div><div class="line">    * 注意它有四个构造函数:  </div><div class="line">    * Throwable()  </div><div class="line">    * Throwable(String message)  </div><div class="line">    * Throwable(Throwable cause)  </div><div class="line">    * Throwable(String message, Throwable cause)  </div><div class="line">    *   </div><div class="line">    */    </div><div class="line">    public class Throwable implements Serializable &#123;    </div><div class="line">          private static final long serialVersionUID = -3042686055658047285L;    </div><div class="line">        </div><div class="line">          /**  </div><div class="line">           * Native code saves some indication of the stack backtrace in this slot.  </div><div class="line">           */    </div><div class="line">          private transient Object backtrace;     </div><div class="line">          /** </div><div class="line">       * 描述此异常的信息 </div><div class="line">       */  </div><div class="line">      private String detailMessage;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 表示当前异常由那个Throwable引起 </div><div class="line">        * 如果为null表示此异常不是由其他Throwable引起的 </div><div class="line">        * 如果此对象与自己相同,表明此异常的起因对象还没有被初始化 </div><div class="line">       */  </div><div class="line">      private Throwable cause = this;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 描述异常轨迹的数组 </div><div class="line">       */  </div><div class="line">      private StackTraceElement[] stackTrace;  </div><div class="line">      /** </div><div class="line">       * 构造函数,起因对象没有被初始化可以在以后使用initCause进行初始化 </div><div class="line">        * fillInStackTrace可以用来初始化它的异常轨迹的数组 </div><div class="line">       */  </div><div class="line">      public Throwable() &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数 </div><div class="line">       */  </div><div class="line">      public Throwable(String message) &#123;  </div><div class="line">         //填充异常轨迹数组  </div><div class="line">          fillInStackTrace();  </div><div class="line">         //初始化异常描述信息  </div><div class="line">          detailMessage = message;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数,cause表示起因对象 </div><div class="line">       */  </div><div class="line">      public Throwable(String message, Throwable cause) &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">          detailMessage = message;  </div><div class="line">          this.cause = cause;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 构造函数 </div><div class="line">       */  </div><div class="line">      public Throwable(Throwable cause) &#123;  </div><div class="line">          fillInStackTrace();  </div><div class="line">          detailMessage = (cause==null ? null : cause.toString());  </div><div class="line">          this.cause = cause;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 获取详细信息 </div><div class="line">       */  </div><div class="line">      public String getMessage() &#123;  </div><div class="line">          return detailMessage;  </div><div class="line">      &#125;  </div><div class="line"></div><div class="line">      /** </div><div class="line">       * 获取详细信息 </div><div class="line">       */  </div><div class="line">      public String getLocalizedMessage() &#123;  </div><div class="line">          return getMessage();  </div><div class="line">      &#125;  </div><div class="line">       /** </div><div class="line">       * 获取起因对象 </div><div class="line">       */  </div><div class="line">      public Throwable getCause() &#123;  </div><div class="line">          return (cause==this ? null : cause);  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 初始化起因对象,这个方法只能在未被初始化的情况下调用一次 </div><div class="line">       */  </div><div class="line">      public synchronized Throwable initCause(Throwable cause) &#123;  </div><div class="line">         //如果不是未初始化状态则抛出异常  </div><div class="line">          if (this.cause != this)  </div><div class="line">              throw new IllegalStateException("Can't overwrite cause");  </div><div class="line">          </div><div class="line">         //要设置的起因对象与自身相等则抛出异常  </div><div class="line">          if (cause == this)  </div><div class="line">              throw new IllegalArgumentException("Self-causation not permitted");  </div><div class="line">          </div><div class="line">         //设置起因对象  </div><div class="line">          this.cause = cause;  </div><div class="line">         //返回设置的起因的对象  </div><div class="line">          return this;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 字符串表示形式 </div><div class="line">       */  </div><div class="line">      public String toString() &#123;       </div><div class="line">          String s = getClass().getName();          </div><div class="line">          String message = getLocalizedMessage();        </div><div class="line">          return (message != null) ? (s + ": " + message) : s;  </div><div class="line">      &#125;  </div><div class="line">      /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace() &#123;   </div><div class="line">          printStackTrace(System.err);  </div><div class="line">      &#125;  </div><div class="line"></div><div class="line">       /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace(PrintStream s) &#123;  </div><div class="line">          synchronized (s) &#123;  </div><div class="line">            //调用当前对象的toString方法  </div><div class="line">              s.println(this);  </div><div class="line">            //获取异常轨迹数组  </div><div class="line">              StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">              </div><div class="line">            //打印出每个元素的字符串表示  </div><div class="line">              for (int i=0; i &lt; trace.length; i++)  </div><div class="line">                s.println("\tat " + trace[i]);  </div><div class="line">  </div><div class="line">            //获取起因对象  </div><div class="line">              Throwable ourCause = getCause();  </div><div class="line">              </div><div class="line">            //递归的打印出起因对象的信息  </div><div class="line">              if (ourCause != null)  </div><div class="line">                ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">       /** </div><div class="line">       * 打印起因对象的信息 </div><div class="line">       * @param s 打印的流 </div><div class="line">        * @param causedTrace 有此对象引起的异常的异常轨迹  </div><div class="line">       */  </div><div class="line">      private void printStackTraceAsCause(PrintStream s,  </div><div class="line">                                          StackTraceElement[] causedTrace)  </div><div class="line">      &#123;  </div><div class="line">         //获得当前的异常轨迹  </div><div class="line">          StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">         //m为当前异常轨迹数组的最后一个元素位置,   </div><div class="line">         //n为当前对象引起的异常的异常轨迹数组的最后一个元素  </div><div class="line">          int m = trace.length-1, n = causedTrace.length-1;  </div><div class="line">         //分别从两个数组的后面做循环,如果相等则一直循环,直到不等或数组到头  </div><div class="line">          while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(causedTrace[n])) &#123;  </div><div class="line">              m--; n--;  </div><div class="line">         &#125;  </div><div class="line">          </div><div class="line">         //相同的个数  </div><div class="line">          int framesInCommon = trace.length - 1 - m;  </div><div class="line">          </div><div class="line">         //打印出不同的错误轨迹  </div><div class="line">          s.println("Caused by: " + this);  </div><div class="line">          for (int i=0; i &lt;= m; i++)  </div><div class="line">              s.println("\tat " + trace[i]);  </div><div class="line">          //如果有相同的则打印出相同的个数  </div><div class="line">          if (framesInCommon != 0)  </div><div class="line">              s.println("\t... " + framesInCommon + " more");  </div><div class="line">  </div><div class="line">         //获得此对象的起因对象,并递归打印出信息  </div><div class="line">          Throwable ourCause = getCause();  </div><div class="line">          if (ourCause != null)  </div><div class="line">              ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 打印出错误轨迹 </div><div class="line">       */  </div><div class="line">      public void printStackTrace(PrintWriter s) &#123;   </div><div class="line">          synchronized (s) &#123;  </div><div class="line">              s.println(this);  </div><div class="line">              StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">              for (int i=0; i &lt; trace.length; i++)  </div><div class="line">                  s.println("\tat " + trace[i]);  </div><div class="line">  </div><div class="line">              Throwable ourCause = getCause();  </div><div class="line">              if (ourCause != null)  </div><div class="line">                  ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 打印起因对象的信息 </div><div class="line">        */  </div><div class="line">      private void printStackTraceAsCause(PrintWriter s,  </div><div class="line">                                          StackTraceElement[] causedTrace)  </div><div class="line">      &#123;  </div><div class="line">          // assert Thread.holdsLock(s);  </div><div class="line">  </div><div class="line">          // Compute number of frames in common between this and caused  </div><div class="line">          StackTraceElement[] trace = getOurStackTrace();  </div><div class="line">          int m = trace.length-1, n = causedTrace.length-1;  </div><div class="line">          while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(causedTrace[n])) &#123;  </div><div class="line">              m--; n--;  </div><div class="line">          &#125;  </div><div class="line">          int framesInCommon = trace.length - 1 - m;  </div><div class="line">  </div><div class="line">          s.println("Caused by: " + this);  </div><div class="line">          for (int i=0; i &lt;= m; i++)  </div><div class="line">              s.println("\tat " + trace[i]);  </div><div class="line">          if (framesInCommon != 0)  </div><div class="line">              s.println("\t... " + framesInCommon + " more");  </div><div class="line">  </div><div class="line">          // Recurse if we have a cause  </div><div class="line">          Throwable ourCause = getCause();  </div><div class="line">          if (ourCause != null)  </div><div class="line">              ourCause.printStackTraceAsCause(s, trace);  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 填充异常轨迹 </div><div class="line">       */  </div><div class="line">      public synchronized native Throwable fillInStackTrace();  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 返回当前的异常轨迹的拷贝 </div><div class="line">       */  </div><div class="line">      public StackTraceElement[] getStackTrace() &#123;  </div><div class="line">          return (StackTraceElement[]) getOurStackTrace().clone();  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      </div><div class="line">      /** </div><div class="line">       * 获取当前的异常轨迹 </div><div class="line">        */  </div><div class="line">      private synchronized StackTraceElement[] getOurStackTrace() &#123;  </div><div class="line">         //如果第一次调用此方法则初始化异常轨迹数组  </div><div class="line">          if (stackTrace == null) &#123;  </div><div class="line">            //获得异常轨迹深度  </div><div class="line">              int depth = getStackTraceDepth();  </div><div class="line">            //创建新的异常轨迹数组,并填充它  </div><div class="line">              stackTrace = new StackTraceElement[depth];  </div><div class="line">              </div><div class="line">            for (int i=0; i &lt; depth; i++)  </div><div class="line">                stackTrace[i] = getStackTraceElement(i);//获取指定位标的异常轨迹  </div><div class="line">          &#125;  </div><div class="line">          </div><div class="line">          return stackTrace;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 设置异常轨迹 </div><div class="line">       */  </div><div class="line">      public void setStackTrace(StackTraceElement[] stackTrace) &#123;  </div><div class="line">         //拷贝设置参数  </div><div class="line">          StackTraceElement[] defensiveCopy =  </div><div class="line">              (StackTraceElement[]) stackTrace.clone();  </div><div class="line">          </div><div class="line">         //如果设置参数有空元素则抛出异常  </div><div class="line">          for (int i = 0; i &lt; defensiveCopy.length; i++)  </div><div class="line">              if (defensiveCopy[i] == null)  </div><div class="line">                  throw new NullPointerException("stackTrace[" + i + "]");  </div><div class="line">  </div><div class="line">         //设置当前对象的异常轨迹  </div><div class="line">          this.stackTrace = defensiveCopy;  </div><div class="line">      &#125;  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 异常轨迹的深度,0表示无法获得 </div><div class="line">       */  </div><div class="line">      private native int getStackTraceDepth();  </div><div class="line">  </div><div class="line">      /** </div><div class="line">       * 获取指定位标的异常轨迹 </div><div class="line">       */  </div><div class="line">      private native StackTraceElement getStackTraceElement(int index);  </div><div class="line">  </div><div class="line">      </div><div class="line">      private synchronized void writeObject(java.io.ObjectOutputStream s)  </div><div class="line">          throws IOException  </div><div class="line">      &#123;  </div><div class="line">          getOurStackTrace();  </div><div class="line">          s.defaultWriteObject();  </div><div class="line">      &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上源码分析来自于互联网，同时由于目前是jdk1.8和这个源码有一小部分不一样，但不影响整体分析。当然，我们真正关心的是他的下面几个方法</p>
<blockquote>
<p>e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息:<br>   getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。<br>　 getMeage()：返回异常的消息信息。<br>　 printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。<br>而当我们出现异常时，就形成一条异常链，一个一个堆栈的打印出相关信息和异常</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;不得不说，我们平时在写程序时遇到最多的情形或者最头疼的事情就是遇到异常，然后各种调试，各种方法用尽最后才解决它，那么异常主要分为几类，每个类
    
    </summary>
    
      <category term="java基础" scheme="http://www.myzwl.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://www.myzwl.win/source/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://www.myzwl.win/2017/07/15/sjjg_10/"/>
    <id>http://www.myzwl.win/2017/07/15/sjjg_10/</id>
    <published>2017-07-15T05:48:51.000Z</published>
    <updated>2017-07-27T14:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>查找操作，通俗的讲，就是给定一个值key，在一个数据结构中找出关键字为key的元素。而基于线性表的查找算法有顺序查找（O（n）），二分查找和分块查找</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>主要用于已排序的顺序表<br>算法描述：假定顺序表已按照升序排列，从表的中间位置开始比较，如果当前元素的关键字等于给定值，则查找成功，否则，若给定的值小于当前元素关键字，则在表的前半段继续查找，反之，在后半段查找，以此重复，直到获得查找结果<br><img src="/images/imgs4/10.gif" alt="Alt text"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class BSArray &#123;</div><div class="line"></div><div class="line">	//在升序排列的数组中，若找到关键字，则返回相应下标，否则返回-1</div><div class="line">	public static&lt;T&gt; int binarySearch(Comparable&lt;T&gt;[] value,T key)&#123;</div><div class="line">		return binarySearch(value,0,value.length-1,key);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static&lt;T&gt; int binarySearch(Comparable&lt;T&gt;[] value,int begin,int end,T key)&#123;</div><div class="line">		if(key!=null)</div><div class="line">			while(begin&lt;=end)&#123;    //边界有效</div><div class="line">				int mid=(begin+end)/2;  //中间位置，当前比较元素位置</div><div class="line">		System.out.println(value[mid]+"?");</div><div class="line">		if(value[mid].compareTo(key)==0) //对象比较大小</div><div class="line">			return mid;                  //查找成功</div><div class="line">		if(value[mid].compareTo(key)&gt;0)  </div><div class="line">			end=mid-1;                    //缩小到前半段</div><div class="line">		else</div><div class="line">			begin=mid+1;                 //缩小到后半段</div><div class="line">	&#125; </div><div class="line">	return -1;                           //查找不成功</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;查找操作，通俗的讲，就是给定一个值key，在一个数据结构中找出关键字为key的元素。而基于线性表的查找算法有顺序查找（O（n）），二分查找和
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>hash散列表</title>
    <link href="http://www.myzwl.win/2017/07/14/sjjg_9/"/>
    <id>http://www.myzwl.win/2017/07/14/sjjg_9/</id>
    <published>2017-07-14T05:48:51.000Z</published>
    <updated>2017-07-27T11:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>散列（hash）表是一种支持高效的查找、插入和删除操作的数据结构，它是针对查找效率接近O（1）而专门设计的。它根据元素的关键字确定元素的存储位置，而其中主要解决两个问题，设计散列函数和处理冲突</p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>在数据元素的关键字和该元素的存储位置之间建立一种对应关系，称为散列函数，而由散列函数决定元素存储位置的存储结构称为散列表，散列函数声明为</p>
<blockquote>
<p>public int hash(int key) //散列函数，确定关键字为key元素的散列地址</p>
</blockquote>
<p>散列函数实质上是关键字集合到地址集合的映射，如果这种映射是一一对应的，则查找效率是O（1），但是由于散列表是一个压缩映射，即存储容量有限，即映射关系是多对一的映射，所以会产生冲突<br><img src="/images/imgs4/9.gif" alt="Alt text"></p>
<h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>设两个关键字k1和k2（k1！=k2），如果有hash（k1）=hash（k2），即它们的散列值相同，表示不同关键字的多个元素映射到同一个存储位置，称为冲突，如图，所设的关键字序列是（1,4,3,11,12,6,14,74,16,96），元素个数是10，关键字范围是0~99，如果散列值的容量是100，很明显是一对一不会产生冲突，但是空间利用率此时只有10%，如果容量是10或者20，冲突差生的频率会减少</p>
<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>该散列函数定义为hash（k）=k%p，函数结果范围为0~p-1，图示就是采用这种方法，而p取值为小于散列表长度的最大素数，如散列表长度分别为8,16,128，则对应的p（最大素数）分别为7,13,127</p>
<h4 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h4><p><strong>开放定址法</strong><br>当产生冲突时，开放定址法在散列表内寻找另一个位置存储冲突的元素，如利用线性探查发实现，即设一个元素关键字为k，其散列地址为i=hash（k），若散列表中i位置已存储元素，则产生冲突，探测下一个位置i+1是否为空，。。直到找到一个空位置，但是它的缺陷就是在散列表内处理冲突，使得一个存储地址i可被任意一个元素抢占，这样就破坏了散列函数i=hash（k）的规则</p>
<p><strong>链地址法</strong><br><img src="/images/imgs4/12.jpg" alt="Alt text"><br>该方法是将多个冲突的元素存储在一条单链表中（称为同义词单链表），如图示<br>而对链地址法表进行插入、删除、查找等操作主要分两步完成<br>1.计算元素的散列函数值<br>2.根据元素的散列函数值，对某一条同义词单链表进行插入、删除和查找操作<br>规定查找成功的平均查找长度为（根据图示）ASL=(9<em>1+3</em>2)/12<br>并且有如下结论：<br>1.查找操作的时间复杂度为O（m），其中m为一条痛一次单链表的长度，插入操作为O(1),删除操作为O(m)</p>
<h4 id="模拟HashSet类"><a href="#模拟HashSet类" class="headerlink" title="模拟HashSet类"></a>模拟HashSet类</h4><p>这里同义词单链表采用单链表<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class HashSet&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	private SinglyLinkenList&lt;T&gt;[] table;    //散列表，同义词单链表对象数组</div><div class="line">	public HashSet(int size)&#123;               //构造指定容量的散列表</div><div class="line">		this.table=new SinglyLinkenList[Math.abs(size)];</div><div class="line">		for(int i=0;i&lt;table.length;i++)</div><div class="line">			table[i]=new SinglyLinkenList&lt;T&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public HashSet()&#123; //构造最大质数为97的容量</div><div class="line">		this(97);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private int hash(T x)&#123;  //散列函数，确定关键字为key元素的散列地址</div><div class="line">		int key=Math.abs(x.hashCode()); //每个对象的hashcode（）方法返回散列码，并且每个对象不同</div><div class="line">		return key%table.length; //出留余数法，除数是散列表长度</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void insert(T x)&#123;//插入x元素</div><div class="line">		table[hash(x)].insert(0, x);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void remove(T x)&#123; //删除x元素</div><div class="line">		table[hash(x)].remove((Integer) x);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public T search(T key)&#123; //返回查找到的关键字为key元素，查找不成功返回null</div><div class="line">		return table[hash(key)].search(key);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean contain(T key)&#123; //判断散列表是否包含关键字为key元素</div><div class="line">		return this.search(key)!=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String toString()&#123;</div><div class="line">		String str="";</div><div class="line">		for(int i=0;i&lt;table.length;i++)  //遍历各同义词单链表</div><div class="line">			if(!table[i].isEmpty())</div><div class="line">				str+=table[i].toString()+"\n";</div><div class="line">		return str;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;散列（hash）表是一种支持高效的查找、插入和删除操作的数据结构，它是针对查找效率接近O（1）而专门设计的。它根据元素的关键字确定元素的存储
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
