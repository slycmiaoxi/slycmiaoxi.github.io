<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2019-07-20T19:05:16.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手写简单策略版游戏匹配算法</title>
    <link href="http://www.myzwl.win/2019/07/21/algo_match1/"/>
    <id>http://www.myzwl.win/2019/07/21/algo_match1/</id>
    <published>2019-07-20T16:48:51.000Z</published>
    <updated>2019-07-20T19:05:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>游戏一般分为房间场和匹配场，现实中游戏匹配的算法需要考虑的因素比较多。笔者只是纯粹娱乐，分析一下一个简单的游戏匹配。<br>假设场景是简单的LOL玩家匹配<br>1.当玩家数量达到一定规定最小数时匹配，比如最小玩家匹配数是2吧<br>2.有时候玩家匹配的数量不确定，比如匹配是只要小于最大玩家数，比如3个玩家也可以玩游戏<br>总结上面，匹配到2或3个人数时，开始游戏</p>
<h4 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h4><p>整个匹配分为两个阶段</p>
<ol>
<li>第一阶段match：一直等到满足最低人数要求，然后进入第二阶段match2</li>
<li>第二阶段match2：额外等待一段时间，然后创建房间<br>所以需要的属性至少得包括房间最小人数、房间最小人数额外等的人的数量、额外需要等待的秒数、游戏类型的名称、玩家队列、匹配日志<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  /**</div><div class="line">     * 是否显示匹配日志：显示(true), 不显示(false)</div><div class="line">     */</div><div class="line">    private static final boolean SHOW_MATCH_LOG = true;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 房间最小人数</div><div class="line">     */</div><div class="line">    private static final int ROOM_MIN_NUM = 2;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 房间最小人数额外等的人的数量</div><div class="line">     */</div><div class="line">    private static final int ROOM_ADDITION_NUM = 1;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 额外需要等待的秒数</div><div class="line">     */</div><div class="line">    private static final int ROOM_ADDITION_SECOND = 5;</div><div class="line">    </div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 游戏类型的名称</div><div class="line">     */</div><div class="line">    private static final Map&lt;Integer, String&gt; GAME_TYPE_NAME = new HashMap&lt;Integer, String&gt;()</div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            put(0, "匹配自选模式");</div><div class="line">            put(1, "极地大乱斗");</div><div class="line">            put(2, "单双排");</div><div class="line">            put(3, "灵活排位");</div><div class="line">            put(4, "无线火力");</div><div class="line">            put(5, "镜像模式");</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 玩家队列</div><div class="line">     */</div><div class="line">    private static final Map&lt;Integer, List&lt;BaseUser&gt;&gt; PLAYER_QUEUE = new ConcurrentHashMap&lt;Integer, List&lt;BaseUser&gt;&gt;()</div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            put(0, new ArrayList&lt;&gt;());</div><div class="line">            put(1, new ArrayList&lt;&gt;());</div><div class="line">            put(2, new ArrayList&lt;&gt;());</div><div class="line">            put(3, new ArrayList&lt;&gt;());</div><div class="line">            put(4, new ArrayList&lt;&gt;());</div><div class="line">            put(5, new ArrayList&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">    public class BaseUser &#123;</div><div class="line">    private int id ;</div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    public BaseUser(int id, String name) &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getId() &#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setId(int id) &#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="玩家匹配加入"><a href="#玩家匹配加入" class="headerlink" title="玩家匹配加入"></a>玩家匹配加入</h4><p>当玩家点击开始匹配时，将玩家加入对应的游戏中的玩家队列中<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line">  * 将玩家加入匹配</div><div class="line">  *</div><div class="line">  * @param user 进行匹配的玩家</div><div class="line">  * @param type 房间类型：</div><div class="line">  * @return 操作成功(true), 操作失败(false)</div><div class="line">  */</div><div class="line"> public static boolean put(BaseUser user, int type) &#123;</div><div class="line">     add(user, type);</div><div class="line">     System.out.println("startMatch");</div><div class="line">     return true;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">  * 向匹配池添加玩家</div><div class="line">  *</div><div class="line">  * @param user 进行匹配的玩家</div><div class="line">  * @param type 需要匹配的类型</div><div class="line">  * @return 操作成功(true), 操作失败(false)</div><div class="line">  */</div><div class="line"> private synchronized static boolean add(BaseUser user, int type) &#123;</div><div class="line">     if (!PLAYER_QUEUE.containsKey(type)) &#123;</div><div class="line">         PLAYER_QUEUE.put(type, new ArrayList&lt;&gt;());</div><div class="line">     &#125;</div><div class="line">     List&lt;BaseUser&gt; playerQueue = PLAYER_QUEUE.computeIfAbsent(type, k -&gt; new ArrayList&lt;&gt;());</div><div class="line">     if (!playerQueue.contains(user)) &#123;</div><div class="line">         playerQueue.add(user);</div><div class="line">     &#125;</div><div class="line">     return true;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h4 id="匹配第一阶段"><a href="#匹配第一阶段" class="headerlink" title="匹配第一阶段"></a>匹配第一阶段</h4><p>先用最简单的方式，这里简化了（应该用while（true）控制，匹配线程一直处于监听状态。<br>核心思想就是遍历玩家队列，如果规定指定人数开局，那么就不需要下一阶段，直接创建房间，队列中踢出玩家即可。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  /**</div><div class="line">    * 匹配第一阶段</div><div class="line">    */</div><div class="line">   private static void match() &#123;</div><div class="line">           try &#123;</div><div class="line"></div><div class="line">               synchronized (PLAYER_QUEUE) &#123;</div><div class="line">                   PLAYER_QUEUE.forEach((type, userList) -&gt; &#123;</div><div class="line">                       if (ROOM_MIN_NUM &gt; 0 &amp;&amp; userList.size() &gt;= ROOM_MIN_NUM) &#123;</div><div class="line">                           // 已达到最低可开局人数，还需要额外等一会儿</div><div class="line">                           scheduledExecutorService.schedule(() -&gt; match2(type), 0, TimeUnit.SECONDS);           </div><div class="line">                       &#125;</div><div class="line">                   &#125;);</div><div class="line">                   if (SHOW_MATCH_LOG) &#123;</div><div class="line">                       testLog();</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               Thread.sleep(1000);</div><div class="line">           &#125;</div><div class="line">           catch (InterruptedException e) &#123;</div><div class="line">               log.error(e.getMessage());</div><div class="line">           &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line">    * 线程池</div><div class="line">    */</div><div class="line">   public static ScheduledExecutorService scheduledExecutorService =</div><div class="line">       Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors() * 2);</div><div class="line">   </div><div class="line"></div><div class="line"></div><div class="line">   public static void sleepSomeMillis(long millis) &#123;</div><div class="line">       try &#123;</div><div class="line">           Thread.sleep(millis);</div><div class="line">       &#125;</div><div class="line">       catch (InterruptedException e) &#123;</div><div class="line">           log.error("睡眠等待时出现错误：" + e.getMessage());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   /**</div><div class="line">    * 匹配日志</div><div class="line">    */</div><div class="line">   private static void testLog() &#123;</div><div class="line">       PLAYER_QUEUE.forEach((type, userList) -&gt; &#123;</div><div class="line">           if (userList.size() &gt; 0) &#123;</div><div class="line">               System.out.println(GAME_TYPE_NAME.get(type) + "人数为：" + userList.size());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h4 id="匹配第二阶段"><a href="#匹配第二阶段" class="headerlink" title="匹配第二阶段"></a>匹配第二阶段</h4><p>该阶段主要考虑的因素包括等待额外的时间，以及玩家队列是否有人取消匹配导致不满足最小匹配人数等等，然后去匹配，<br>用线程池去控制匹配第二阶段<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line">  * 匹配第二阶段</div><div class="line">  *</div><div class="line">  * @param type 房间类型</div><div class="line">  */</div><div class="line"> private static void match2(int type) &#123;</div><div class="line">     List&lt;BaseUser&gt; users = PLAYER_QUEUE.get(type);</div><div class="line">     long deadline = System.currentTimeMillis() + ROOM_ADDITION_SECOND * 1000;</div><div class="line">     // 需要的最大的人数</div><div class="line">     int realNeedNum = ROOM_MIN_NUM + ROOM_ADDITION_NUM;</div><div class="line">     while (true) &#123;</div><div class="line">         if (System.currentTimeMillis() &gt; deadline) &#123;</div><div class="line">             break;</div><div class="line">         &#125;</div><div class="line">         synchronized (PLAYER_QUEUE) &#123;</div><div class="line">             if (users.size() &lt; ROOM_MIN_NUM) &#123;</div><div class="line">                 return;</div><div class="line">             &#125;</div><div class="line">             if (users.size() &gt;= realNeedNum) &#123;</div><div class="line">                 break;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         sleepSomeMillis(500);</div><div class="line">     &#125;</div><div class="line">     synchronized (PLAYER_QUEUE) &#123;</div><div class="line">         // 等待结束之后实际的人数</div><div class="line">         int realNum = users.size() &gt; realNeedNum ? realNeedNum : users.size();</div><div class="line">         // 如果人数仍然满足最小匹配人数，则创建房间</div><div class="line">         if (realNum &gt;= ROOM_MIN_NUM) &#123;</div><div class="line">             createRoom(type, realNum);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h4 id="创建房间"><a href="#创建房间" class="headerlink" title="创建房间"></a>创建房间</h4><p>该阶段显示在玩家队列中踢出已匹配的玩家，然后在创建房间<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * 创建房间</div><div class="line"> *</div><div class="line"> * @param type 房间类型</div><div class="line"> * @param playerNum 房间人数</div><div class="line"> */</div><div class="line">private static void createRoom(int type, int playerNum) &#123;</div><div class="line">    synchronized (PLAYER_QUEUE) &#123;</div><div class="line">        BaseUser[] baseUsers = new BaseUser[playerNum];</div><div class="line">        List&lt;BaseUser&gt; users = PLAYER_QUEUE.get(type);</div><div class="line">        if (users.size() &gt;= playerNum) &#123;</div><div class="line">            for (int i = 0; i &lt; playerNum; i++) &#123;</div><div class="line">                baseUsers[i] = users.get(i);</div><div class="line">            &#125;</div><div class="line">            users.removeAll(Arrays.asList(baseUsers));</div><div class="line">            // 创建房间            </div><div class="line">            System.out.println("create room success");          </div><div class="line">           </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>这里是每增加一个用户匹配一次，事实上match方法应该是一个类似监听器<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Test</div><div class="line"> public  void matchUser() throws InterruptedException &#123;</div><div class="line">     int type = 0;</div><div class="line">     BaseUser user1 = new BaseUser(1, "aa");</div><div class="line">     BaseUser user2 = new BaseUser(2, "bb");</div><div class="line">     BaseUser user3 = new BaseUser(3, "cc");</div><div class="line">     Match.put(user1, type);</div><div class="line">     Match.match();</div><div class="line">     Match.put(user2, type);</div><div class="line">     Match.match();</div><div class="line">     Match.put(user3, type);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>最后显示的结果为<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  startMatch</div><div class="line">匹配自选模式人数为：<span class="number">1</span></div><div class="line">startMatch</div><div class="line">匹配自选模式人数为：<span class="number">2</span></div><div class="line">startMatch</div><div class="line">[cn<span class="selector-class">.slycmiaoxi</span><span class="selector-class">.match</span><span class="selector-class">.BaseUser</span>@<span class="number">21001</span>, cn<span class="selector-class">.slycmiaoxi</span><span class="selector-class">.match</span><span class="selector-class">.BaseUser</span>@c5e0b1, cn<span class="selector-class">.slycmiaoxi</span><span class="selector-class">.match</span><span class="selector-class">.BaseUser</span>@fa7b71]</div><div class="line">create room success</div></pre></td></tr></table></figure></p>
<h4 id="最后说明"><a href="#最后说明" class="headerlink" title="最后说明"></a>最后说明</h4><p>1.至于取消匹配，做法类似<br>2.现实中匹配要考虑好多因素，可以想象LOL中的匹配~<br>当然目前只是一个简单的demo，仅供参考！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;游戏一般分为房间场和匹配场，现实中游戏匹配的算法需要考虑的因素比较多。笔者只是纯粹娱乐，分析一下一个简单的游戏匹配。&lt;br&gt;假设场景是简单的
    
    </summary>
    
      <category term="算法" scheme="http://www.myzwl.win/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.myzwl.win/source/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试官的question之一</title>
    <link href="http://www.myzwl.win/2019/07/17/saveMe_1/"/>
    <id>http://www.myzwl.win/2019/07/17/saveMe_1/</id>
    <published>2019-07-17T13:48:51.000Z</published>
    <updated>2019-07-20T18:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>离职后的自己经历了高潮-颓废-兴奋-理性-责任（对父母，对爱人)<br>差不多花了20天把自己大学原创的项目重写了一遍，然后备案（吐槽一下，都2个星期了，太慢了)<br>这个星期才开始投简历，玩也玩够了，不多说，总结一下这两天的面试（记得的）</p>
<h4 id="电话面试"><a href="#电话面试" class="headerlink" title="电话面试"></a>电话面试</h4><p>差不多下午4点钟开始，一面技术关电话面试，很基础（AC)<br>1.了解spring的ioc和aop吗？说说原理？在你之前做过的项目中应用在哪些场景？<br>2.ArrayList和set集合区别<br>3.spring mvc场景注解？<br>4.拦截器有什么用？你在项目中哪些地方用到了？<br>5.@ResponseBody有什么用？</p>
<h4 id="一次算法与算法之间的较量"><a href="#一次算法与算法之间的较量" class="headerlink" title="一次算法与算法之间的较量"></a>一次算法与算法之间的较量</h4><p>大概下午两点半到了公司，公司也挺大的，自己也迟到了。但是hr很友好，显示做了一份笔试题，很基础的题（全AC），中间还来了一个年纪很大的面试官，因为自己简历上侧重于算法和数据结构，正好这位面试官对这些很感兴趣，于是乎，聊嗨了，最后将近一问一答弄了三个小时左右<br>笔试题：（很基础）<br>1.举例说明==与equals区别？<br>2.将字符串啊啊a,b,c以逗号分隔成数组？<br>3.列举出你在项目中常见的异常？<br>4.set，list，map区别？<br>5.分别用js，jquery在页面加载时，打印出“页面已被加载”<br>6.分别用js，jquery实现取出id为username的值？<br>7.sql题，一个部门表，一个用户表（关联部门id)，增删改和关联查询</p>
<p>然后是面试题，层层深入<br>1.先自我介绍，工作经历，主要侧重工作的流程，让面试者知道自己熟悉整个软件开发的完整流程<br>2.你最熟悉哪些排序算法？手写出其中最熟悉的几个，并且说说思想<br>我选择了快排，冒泡，选择，直接插入，希尔排序手写和说了原理，只说了归并排序原理</p>
<p>2.1 说说其中一些算法的空间和时间复杂度，并说说熟悉的算法应用之处<br>我说了快排，冒泡，选择<br>2.2 举例说说你在项目中或者哪些你知道的为什么会有时间换空间或者空间换时间的？<br>我当时首先想到的就是数据库的存储原理，基于B+树。说了B+树的原理，以及b树，b-树，红黑树，<br>以及mysql利用b+树存取数据，如何空间换时间的原理。说到了如何选择建立索引（离散度），索引回表原理<br>说到这里，突然面试官问了，我你到B是啥意思吗？这个我还真不知道，然后他说banlance<br>2.3 然后面试官问为什么取b?<br>当时立马想到AVL数，然后说了下二叉树，二分查找，然后演变为二叉平衡树以及斜度太高导致复杂度高，所以需要AVL树，以及AVL树特点通过二分查找很快定位，但是AVL树在插入或者删除的时候需要先确定旋转因子，然后。。。<br>2.4 紧接着面试官，说你之前说到索引回表，说下聚簇索引吧，顺表说了下说说你知道的sql优化<br>这个当时只答了四条优化，面试官看我说不出来，就换了个话题（对着简历)</p>
<p>3.游戏中玩家各组牌是怎么初始化的？作弊牌是怎么做的<br>这个自己很熟悉，毕竟自己还优化过~但是这里面有一个地方不是很好，就是洗牌的时候只是重新shuffle了一下，也就是牌没洗开<br>3.1 能不能设计一个算法让牌的洗开度更高？<br>只是给了一种想法，类似于归并，将数据分成多组（因为牌数并不多)，从下层洗牌，然后依次向上递归在洗牌<br>3.2 出了一道算法题，利用数据结构实现一个计算机<br>当时想到了双栈</p>
<p>4.问了linux相关的命令，安装各种软件，挑了几个说了下<br>主要回答了grep，scp，wget，rm -rf，ssh免登陆说到这里又问了工作中操作linux的环节<br>4.1 接着又问了ssh免登陆是否做过？<br>我说了git搭建hexo博客用到了</p>
<p>5.问了你熟悉的设计模式？<br>我说了迭代器设计模式（现场模拟了Arraylist实现迭代器，主要有collection，Iterator，ArrayListIteartor实现）<br>然后就是里面扩容问题<br>接着就是代理模式，实现在线编程</p>
<p>6.开始问项目中遇到到的国难<br>我讲了两个，一个是多数据源因为磁盘满了怎么定位，另一个是netty版本太低导致经常socket断开连接，使用实时刷新，断线重连重载信息</p>
<p>7.接着问了编程习惯注意的问题以及工作中的那些事<br>这个阿里巴巴规范的那些，基本自己在编程中都会注意</p>
<p>8.然后我开始问面试官问题<br>科班学的这些像算法，数据结构，操作系统到底有什么用，现在技术那么多，学历也不是特别好，很多公司注重框架学习和应用，自己是否坚持和对以后学历不好的我有什么用？虽然这个问题很弱智。<br>面试官说了，看问题的深度，和对以后的技术学习的理解度和灵感度</p>
<p>全场面试大概3个小时，但是也使自己受益最深的，基本上没有问到框架，全是cs基础知识,然后等待后续二面</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;离职后的自己经历了高潮-颓废-兴奋-理性-责任（对父母，对爱人)&lt;br&gt;差不多花了20天把自己大学原创的项目重写了一遍，然后备案（吐槽一下，
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>x-blog之算法建模简单介绍</title>
    <link href="http://www.myzwl.win/2019/07/14/xblog_1/"/>
    <id>http://www.myzwl.win/2019/07/14/xblog_1/</id>
    <published>2019-07-14T13:48:51.000Z</published>
    <updated>2019-07-14T09:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里的算法建模知识简单的建模。等同于数学公式，利用某种语言编好算法，利用一定逻辑存取，然后正确展示。里面涉及的细节包括对算法的理解和编写，数据模型的建立，高效存取，用户输入，编程规范以及涉及到web的一些知识等等。如下图所示。<br><img src="/images/xblog/1.jpg" alt="Alt text"></p>
<h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>为了方便直接贴出截图（以下是按照自己的想法建的结构，仅作为项目说明，如不合理，请谅解)<br>设计到三张表t_algotithms_info(算法建模表),t_algotithms_type(算法类型名称),t_algotithms_type_info_rel(算法-类型-关系表)</p>
<ol>
<li>t_algotithms_type 由于类型极少，就没必要建立索引，各含义如字段所示，这里说明一下，最后七个字段，原则上是每个表都应该加上的。<br><img src="/images/xblog/1_2.jpg" alt="Alt text"><br><br></li>
<li>t_algotithms_info<br>算法建模核心表，其中，algotithms_code算法最核心底层代码，controller_code交互代码，func_name请求的唯一函数名，也就是每个算法都有唯一的函数名，func_index唯一索引，主要有两个用处，一、快速定位函数详情记录，二、用于redis中定位记录，因为主键可能各种原因变化导致不能与redis中正确对应。<br><img src="/images/xblog/1_3.jpg" alt="Alt text"></li>
<li>t_algotithms_type_info_rel<br><img src="/images/xblog/1_4.jpg" alt="Alt text"><br>ok，表已建好，下面就是数据的建立，存与取了</li>
</ol>
<p>笔者一直坚信算法是程序的灵魂。好了，不贼多说了，这里建立我按照算法来源归类为不同类，比如原生的数据结构（ DataStructService），剑指offer（OfferAlgorithmsService），目前就建了这两个类，还有其他像数学建模类，LeetCode类等等。<br>另一方面，这里可以按照微服务思想，将该模块单独抽象成一个微服务，然后通过dubbo服务发布与调用。目前版本为了方便，直接作为core包下接口，然后实现。<br>就以约瑟夫环为例，从数据的建立-&gt;存数据库-&gt;页面展示-&gt;按条件从数据库取出-&gt;应用算法-&gt;计算返回结果</p>
<h4 id="算法建立"><a href="#算法建立" class="headerlink" title="算法建立"></a>算法建立</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line">  * 约瑟夫环</div><div class="line">  * </div><div class="line">  * @param total 总人数</div><div class="line">  * @param n 每次需要处死的第n位置人</div><div class="line">  * @return 最后被赦免的人的位置</div><div class="line">  * @Auther: slycmiaoxi</div><div class="line">  * @Date: 2019/6/20</div><div class="line">  */</div><div class="line"> int CountnQuit(int total, int n);</div><div class="line"></div><div class="line"></div><div class="line">@Override</div><div class="line"> public int CountnQuit(int total, int n) &#123;</div><div class="line">     boolean[] arr = new boolean[total];</div><div class="line">     for (int i = 0; i &lt; total; i++) &#123;</div><div class="line">         arr[i] = true;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     int count = 0;</div><div class="line">     int index = 0;</div><div class="line">     int len = arr.length;</div><div class="line">     while (len &gt; 1) &#123;</div><div class="line">         if (arr[index] == true) &#123;</div><div class="line">             count++;</div><div class="line">             if (count == n) &#123;</div><div class="line">                 count = 0;</div><div class="line">                 arr[index] = false;</div><div class="line">                 len--;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         index++;</div><div class="line">         if (index == arr.length) &#123;</div><div class="line">             index = 0;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     for (int i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">         if (arr[i] == true) &#123;</div><div class="line">             return i + 1;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     return 0;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h4 id="存数据库"><a href="#存数据库" class="headerlink" title="存数据库"></a>存数据库</h4><p>首先需要在后台里先初始化算法类型，然后在算法建模，如图所示<br><img src="/images/xblog/1_5.jpg" alt="Alt text"><br>点击算法建模后，通过dto对象传数据-&gt;controller-&gt;service-&gt;dao-&gt;mysql<br>另外这里的事务也需要注意和处理，目前没处理好<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public boolean add(AlgotithmsInfoDto dto) &#123;</div><div class="line">        // 1.校验参数</div><div class="line">        boolean checkParams = convert(dto);</div><div class="line">        if (!checkParams) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 2.dto -&gt; po</div><div class="line">        TAlgotithmsInfo po = getPoByDto(dto);</div><div class="line">        </div><div class="line">        // 3.入数据库</div><div class="line">        tAlgotithmsInfoMapper.insert(po);</div><div class="line">        itAlgotithmsTypeInfoRelService.add(po.getAlgotithmsInfoId(), po.getAlgotithmsTypeId());</div><div class="line">        </div><div class="line">        // 4.入redis(存dto)</div><div class="line">        Integer algotithmsInfoId = po.getAlgotithmsInfoId();</div><div class="line">        long funcIndex = po.getFuncIndex();</div><div class="line">        dto.setAlgotithmsInfoId(CodecUtils.encodeData(String.valueOf(algotithmsInfoId)));</div><div class="line">        dto.setFuncIndex(funcIndex);</div><div class="line">        // 4.1 算法建模详情（集合数据结构)</div><div class="line">        jedisClient.lpush(REDIS_ALGORITHMS_LIST_KEY, JSON.toJSONString(dto));</div><div class="line">        </div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="页面加载"><a href="#页面加载" class="headerlink" title="页面加载"></a>页面加载</h4><p>对于数据加载，一次性加载肯定效率不高，目前由于前端短板和数据并不多，先从redis中取出，异常本地取出<br>。而数据的显示结果类似于[string，list<object>]类型的json数据格式，在将部分显示格式转化下，其中listDtoByTypeGroupWithLocal（）就是直接从数据库中取出</object></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public List&lt;TBean&lt;String&gt;&gt; listGroupDto() &#123;</div><div class="line">        final List&lt;TBean&lt;String&gt;&gt; resultList = new ArrayList&lt;&gt;();</div><div class="line">        </div><div class="line">        // 1.获得所有算法类型</div><div class="line">        List&lt;TAlgotithmsType&gt; typeList = itAlgotithmsTypeService.listPojo();</div><div class="line">        if (CollectionUtils.isEmpty(typeList)) &#123;</div><div class="line">            return resultList;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 2.从redis中取出数据</div><div class="line">        List&lt;String&gt; list = jedisClient.lrange(REDIS_ALGORITHMS_LIST_KEY, 0, -1);</div><div class="line">        if (CollectionUtils.isEmpty(list)) &#123;</div><div class="line">            return listDtoByTypeGroupWithLocal(typeList);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 3.String -&gt; dto</div><div class="line">        final List&lt;AlgotithmsInfoDto&gt; dtos = new LinkedList&lt;&gt;();</div><div class="line">        try &#123;</div><div class="line">            list.stream().filter(x -&gt; x != null).forEach(x -&gt; &#123;</div><div class="line">                AlgotithmsInfoDto dto = JSON.parseObject(x, AlgotithmsInfoDto.class);</div><div class="line">                dtos.add(dto);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        catch (Exception e) &#123;</div><div class="line">            return listDtoByTypeGroupWithLocal(typeList);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 4.分类组合</div><div class="line">        typeList.stream().filter(k -&gt; k != null).forEach(k -&gt; &#123;</div><div class="line">            List&lt;AlgotithmsInfoDto&gt; newDtos = new ArrayList&lt;&gt;();</div><div class="line">            dtos.stream().filter(dto -&gt; dto != null).forEach(dto -&gt; &#123;</div><div class="line">                String encodeTypeId = CodecUtils.encodeData(String.valueOf(k.getAlgotithmsTypeId()));</div><div class="line">                if (dto.getAlgotithmsTypeId().equals(encodeTypeId)) &#123;</div><div class="line">                    // 排序后的集合</div><div class="line">                    newDtos.add(dto);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            resultList.add(new TBean&lt;&gt;(newDtos, k.getAlgotithmsTypeName()));</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        return resultList;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="按条件从数据库取出"><a href="#按条件从数据库取出" class="headerlink" title="按条件从数据库取出"></a>按条件从数据库取出</h4><p>利用索引直接取出函数详情，如约瑟夫环。得到函数名，然后通过校验用户输入格式，最后返回结果给页面，<br>至此一个简单的算法建模完成。</p>
<h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>前端页面不好弄，和起始之初会遇到前端出现一些列问题，后端代码格式，另外就是核心算法的理解和实现起来会很伤脑筋。当然，里面还有很多不完善的地方，由于个人经验受限，请谅解！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这里的算法建模知识简单的建模。等同于数学公式，利用某种语言编好算法，利用一定逻辑存取，然后正确展示。里面涉及的细节包括对算法的理解和编写，数
    
    </summary>
    
      <category term="x-blog" scheme="http://www.myzwl.win/categories/x-blog/"/>
    
    
      <category term="x-blog" scheme="http://www.myzwl.win/source/tags/x-blog/"/>
    
  </entry>
  
  <entry>
    <title>x-blog之留言版简单介绍</title>
    <link href="http://www.myzwl.win/2019/07/11/xblog_2/"/>
    <id>http://www.myzwl.win/2019/07/11/xblog_2/</id>
    <published>2019-07-11T13:48:51.000Z</published>
    <updated>2019-07-13T18:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>留言版的设计本质就是树结构的设计<a href="https://slycmiaoxi.github.io/2018/03/10/sys_1/#more" target="_blank" rel="external">留言版设计（旧）</a>，之前的设计是从模仿B树写的，发现在数据存取时有一些需要优化，所以优化了下表结构和数据存取。<br><img src="/images/xblog/2_1.jpg" alt="Alt text"></p>
<h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>为了方便直接贴出截图（以下是按照自己的想法建的结构，仅作为项目说明，如不合理，请谅解)<br>直接设计一张数据结构表t_message_info，其中parent_node为父节点编号，如果为0，表示为顶层留言，无父节点，否层则是孩子结点<br><img src="/images/xblog/2_2.jpg" alt="Alt text"></p>
<p>而其大概流程就是页面加载留言</p>
<h4 id="父-子结构dto建立"><a href="#父-子结构dto建立" class="headerlink" title="父-子结构dto建立"></a>父-子结构dto建立</h4><p>在旧版本基础上优化了数据结构之后，就可以直接建立dto，在里面套一个子dto集合，并且重新equals和hashcode，最后只要去dto集合数据，按照父-子集合依次放入即可，而不需要兄弟结点了<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  /**</div><div class="line"> * 留言id</div><div class="line"> */</div><div class="line">private String messageId;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 留言内容</div><div class="line"> */</div><div class="line">private String messageContent;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 当前结点用户名</div><div class="line"> */</div><div class="line">private String currentName;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 父节点用户名</div><div class="line"> */</div><div class="line">private String parentName;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 父节点id</div><div class="line"> */</div><div class="line">private String parentNode;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 添加日期</div><div class="line"> */</div><div class="line">private String time;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 添加日期</div><div class="line"> */</div><div class="line">private Date gmtCreate;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 该节点下的所有子节点集合</div><div class="line"> */</div><div class="line">private List&lt;MessageDto&gt; child;</div><div class="line"></div><div class="line"> @Override</div><div class="line">public boolean equals(Object o) &#123;</div><div class="line">    if (this == o) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    if (o == null || getClass() != o.getClass()) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MessageDto that = (MessageDto) o;</div><div class="line"></div><div class="line">    return messageId.equals(that.messageId);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public int hashCode() &#123;</div><div class="line">    return messageId.hashCode();</div><div class="line">&#125;</div><div class="line"></div><div class="line">省略set和get方法......</div></pre></td></tr></table></figure></p>
<h4 id="取出数据"><a href="#取出数据" class="headerlink" title="取出数据"></a>取出数据</h4><p>由于重写了equals和hashcode，就可以直接通过messageId得到父节点。大概流程就是取出留言数据-&gt;分类（所有父，所有子集合)-&gt;遍历子集合，依次放到父节点<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> @Override</div><div class="line">public PageModal queryListbyPage(Page page, Map&lt;String, Object&gt; map) &#123;</div><div class="line">    </div><div class="line">    // 1.分页处理</div><div class="line">    page = PageUtil.createPage(page, tMessageInfoMapper.queryTotal(map).intValue());</div><div class="line">    map.put("beginIndex", page.getBeginIndex());</div><div class="line">    map.put("everyPage", page.getEveryPage());</div><div class="line">    PageModal pg = new PageModal();</div><div class="line">    pg.setPage(page);</div><div class="line">    </div><div class="line">    // 2. 查询所有有效留言记录</div><div class="line">    List&lt;MessageDto&gt; pageList = tMessageInfoMapper.queryList(map);</div><div class="line">    if (CollectionUtils.isEmpty(pageList)) &#123;</div><div class="line">        pg.setList(pageList);</div><div class="line">        return pg;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 3. 留言数据结构分类（父-子)</div><div class="line">    final List&lt;MessageDto&gt; parent = new ArrayList&lt;&gt;();</div><div class="line">    final List&lt;MessageDto&gt; child = new ArrayList&lt;&gt;();</div><div class="line">    </div><div class="line">    pageList.stream().filter(x -&gt; x != null).forEach(dto -&gt; &#123;</div><div class="line">        // 3.1 格式化日期</div><div class="line">        dto.setTime(DateUtil.formatDate(dto.getGmtCreate(), DateUtil.fullPattern));</div><div class="line">        dto.setGmtCreate(null);</div><div class="line">        if (dto.getParentNode().equals(String.valueOf(Const.ZERO))) &#123;</div><div class="line">            parent.add(dto);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            child.add(dto);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    if (CollectionUtils.isEmpty(child)) &#123;</div><div class="line">        pg.setList(parent);</div><div class="line">        return pg;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 4.子节点归类</div><div class="line">    child.stream().filter(x -&gt; x != null).forEach(x -&gt; &#123;</div><div class="line">        MessageDto parDto = parent.get(parent.indexOf(new MessageDto(x.getParentNode())));</div><div class="line">        if (CollectionUtils.isEmpty(parDto.getChild())) &#123;</div><div class="line">            parDto.setChild(new ArrayList&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        parDto.getChild().add(x);</div><div class="line">    &#125;);</div><div class="line">    pg.setList(parent);</div><div class="line">    return pg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h4><p>前端由于短板，主要为数据加载趁现在页面初始化中，并且是通过动态语句创建div，所以分页没弄出来，导致数据量大会出现问题</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;留言版的设计本质就是树结构的设计&lt;a href=&quot;https://slycmiaoxi.github.io/2018/03/10/sys_1
    
    </summary>
    
      <category term="x-blog" scheme="http://www.myzwl.win/categories/x-blog/"/>
    
    
      <category term="x-blog" scheme="http://www.myzwl.win/source/tags/x-blog/"/>
    
  </entry>
  
  <entry>
    <title>x-blog之在线编程简单介绍</title>
    <link href="http://www.myzwl.win/2019/07/10/xblog_3/"/>
    <id>http://www.myzwl.win/2019/07/10/xblog_3/</id>
    <published>2019-07-10T13:48:51.000Z</published>
    <updated>2019-07-14T09:07:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该模块是在认认真真理解并动手完成马士兵老师<a href="https://slycmiaoxi.github.io/2017/03/13/dyproxy2/" target="_blank" rel="external">代理模式</a>的情景下完成，目前实现方法和<a href="https://slycmiaoxi.github.io/2018/03/10/sys_1/#more" target="_blank" rel="external">旧版本</a>一样</p>
<h4 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h4><p>这里遇到一个问题，如何高效率执行并发在线编程?<br>这个最终的解决办法并不是很好，但是探索的过程总是充满乐趣</p>
<ol>
<li>怎么才能实现在线编程？<br>刚开始用记事本写java的时候，对这个问题肯定贼深刻，但随着工具的方便性，很多底层的东西越来越变得不透明。<br>其具体思路就是代码变成字符串，然后拿到当前编译器进行编译，最后将编译的结果输出即可。<br>但是如果不加以控制的话，最后如果并发量大的话，同时写入和读出造成错误，会使编译效率很低</li>
</ol>
<p>2.如何保证编译并行执行？<br>由于个人经验和能力问题，这个问题最终没有本解决。但是探索的过程是很有趣的。<br>记得当时首先使用lock写锁，控制。假设是单线程执行，一个用户写完还必须按照时间等待，并发量高效率很低。很自然想到线程池，封装一个线程池工具类，创建一个编译线程任务类，然后就是按照线程创建时间创建不同的文件夹，每个文件夹来自不同的用户线程，这样就解决了记录问题，剩下就是怎么保证每个用户都知道自己执行哪个编译线程，然后拿到对应的编译结果（在这里遇到了瓶颈）<br><img src="/images/xblog/2_3.png" alt="Alt text"><br>最终是可以并行执行编译，而不是串行等待，但是编译的结果随机发给了等待的用户，当然可以直接用synchronized控制同步，但是代价和执行效果就不怎么好了。</p>
<p>3.低效的解决办法<br>最后直接用synchronized控制同步，也就没有必要使用线程池了，只要保证不同用户编译和返回的结果是正确就行了<br>旧版本将该功能做成微服务，利用dubbo管理，这样尽可能降低并发带来的性能问题</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public String getCompileResult(String originStr) &#123;</div><div class="line">        // 1.创建需要动态编译的代码字符串</div><div class="line">        // 回车</div><div class="line">        String nr = "\r\n";</div><div class="line">        String source = "package temp.com; " + nr + originStr;</div><div class="line">        </div><div class="line">        // 2.将欲动态编译的代码写入文件中 1.创建临时目录 2.写入临时文件目录</div><div class="line">        File dir = new File(System.getProperty("user.dir") + "/temp");</div><div class="line">        // 如果 \temp 不存在 就创建</div><div class="line">        if (!dir.exists()) &#123;</div><div class="line">            dir.mkdir();</div><div class="line">        &#125;</div><div class="line">        logger.info(dir.toString());</div><div class="line">        FileWriter writer;</div><div class="line">        try &#123;</div><div class="line">            writer = new FileWriter(new File(dir, "Main.java"));</div><div class="line">            writer.write(source);</div><div class="line">            writer.flush();</div><div class="line">            writer.close();</div><div class="line">        &#125;</div><div class="line">        catch (IOException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 3.取得当前系统的编译器</div><div class="line">        JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">        // 4.获取一个文件管理器</div><div class="line">        StandardJavaFileManager javaFileManager = javaCompiler.getStandardFileManager(null, null, null);</div><div class="line">        // 5.文件管理器根与文件连接起来</div><div class="line">        Iterable it = javaFileManager.getJavaFileObjects(new File(dir, "Main.java"));</div><div class="line">        // 6.创建编译任务</div><div class="line">        JavaCompiler.CompilationTask task =</div><div class="line">            javaCompiler.getTask(null, javaFileManager, null, Arrays.asList("-d", "./temp"), null, it);</div><div class="line">        boolean k = false;</div><div class="line">        Exception ee = new RuntimeException();</div><div class="line">        try &#123;</div><div class="line">            // 7.执行编译</div><div class="line">            k = task.call();</div><div class="line">            if (!k) &#123;</div><div class="line">                return "sorry ! your code has some problems,please check!";</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // 8.运行程序</div><div class="line">            Runtime run = Runtime.getRuntime();</div><div class="line">            Process process = null;</div><div class="line">            try &#123;</div><div class="line">                try &#123;</div><div class="line">                    process = run.exec("java -cp ./temp temp/com/Main");</div><div class="line">                &#125;</div><div class="line">                catch (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                InputStream in = process.getInputStream();</div><div class="line">                BufferedReader reader = new BufferedReader(new InputStreamReader(in));</div><div class="line">                String info;</div><div class="line">                StringBuilder sb = new StringBuilder();</div><div class="line">                try &#123;</div><div class="line">                    while ((info = reader.readLine()) != null) &#123;</div><div class="line">                        sb.append(info + "&lt;br/&gt;");</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                catch (IOException e) &#123;</div><div class="line">                    // TODO Auto-generated catch block</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                logger.info(sb.toString());</div><div class="line">                return sb.toString();</div><div class="line">            &#125;</div><div class="line">            catch (RuntimeException e) &#123;</div><div class="line">                return "err";</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        finally &#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;该模块是在认认真真理解并动手完成马士兵老师&lt;a href=&quot;https://slycmiaoxi.github.io/2017/03/13/
    
    </summary>
    
      <category term="x-blog" scheme="http://www.myzwl.win/categories/x-blog/"/>
    
    
      <category term="x-blog" scheme="http://www.myzwl.win/source/tags/x-blog/"/>
    
  </entry>
  
  <entry>
    <title>x-blog之并发登陆人数控制简单介绍</title>
    <link href="http://www.myzwl.win/2019/07/09/xblog_4/"/>
    <id>http://www.myzwl.win/2019/07/09/xblog_4/</id>
    <published>2019-07-09T13:48:51.000Z</published>
    <updated>2019-07-14T09:08:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>并发登陆人数控制就是控制同一账号最大有效会话数。而项目中会话管理交给shiro控制，shiro的sessionId每次是不一样的，也就是说，同一用户登录，在缓存中通过用户名产生的会话id不一样，造成同一用户登录重新登录会变成不同用户而使在线人数不对。<br>当然，对于这些实时性的统计，我觉得利用redis缓存会话更优，但鉴于个人经验和能力问题，暂时用shiro管理。</p>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>首先定义一个KickoutSessionFilter过滤器继承shiro的AccessControlFilter，用于拦截登录请求，并且在shiro配置文件中<br>配置和初始化相应属性，在echache.xml配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">  &lt;!--并发登录控制--&gt;</div><div class="line">  &lt;bean id=<span class="string">"kickoutSessionFilter"</span> class=<span class="string">"cn.slycmiaoxi.filter.KickoutSessionFilter"</span>&gt;</div><div class="line">      &lt;property name=<span class="string">"cacheManager"</span> ref=<span class="string">"cacheManager"</span>/&gt;</div><div class="line">      &lt;property name=<span class="string">"sessionManager"</span> ref=<span class="string">"sessionManager"</span>/&gt;</div><div class="line">      &lt;property name=<span class="string">"kickoutAfter"</span> value=<span class="string">"false"</span>/&gt;</div><div class="line">      &lt;property name=<span class="string">"maxSession"</span> value=<span class="string">"1"</span>/&gt;</div><div class="line">      &lt;property name=<span class="string">"kickoutUrl"</span> value=<span class="string">"/index.jsp"</span>/&gt;</div><div class="line">  &lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;cache name=<span class="string">"shiro-kickout-session"</span></div><div class="line">         maxEntriesLocalHeap=<span class="string">"2000"</span></div><div class="line">         eternal=<span class="string">"false"</span></div><div class="line">         timeToIdleSeconds=<span class="string">"3600"</span></div><div class="line">         timeToLiveSeconds=<span class="string">"0"</span></div><div class="line">         overflowToDisk=<span class="string">"false"</span></div><div class="line">         statistics=<span class="string">"true"</span>&gt;</div><div class="line">  &lt;/cache&gt;</div></pre></td></tr></table></figure></p>
<p>一般涉及缓存都需要同步缓存，也就是当有会话失效时。利用一个监听器将该会话同步掉</p>
<p>而过滤器核心思想就是先判断该会话是否有效或者是否已存在，然后放在一个缓存队列中，如果其大小超过该会话数，就踢出头或尾会话，在加入该会话，然后就是这个缓存队列是通过ehcache中命名用户名设置的，然后将其放在shiro拦截器，放在登录请求中，这是如果有会话被提出，但是本地缓存sessionDAO中任然有那个被踢掉的缓存，需要个监听器根据那个用户名得到sessionId然后踢掉，缓存同步</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line">    &lt;!--并发登录控制--&gt;</div><div class="line">   public class KickoutSessionFilter extends AccessControlFilter &#123;</div><div class="line">    private Logger logger = (Logger)LoggerFactory.getLogger(this.getClass().getName());</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 踢出后到的地址</div><div class="line">     */</div><div class="line">    private String kickoutUrl;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 踢出之前登录的/之后登录的用户 默认踢出之前登录的用户</div><div class="line">     */</div><div class="line">    private boolean kickoutAfter = false;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 同一个帐号最大会话数 默认1</div><div class="line">     */</div><div class="line">    private int maxSession;</div><div class="line">    </div><div class="line">    private SessionManager sessionManager;</div><div class="line">    </div><div class="line">    private Cache&lt;String, Deque&lt;Serializable&gt;&gt; cache;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)</div><div class="line">        throws Exception &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected boolean onAccessDenied(ServletRequest request, ServletResponse response)</div><div class="line">        throws Exception &#123;</div><div class="line">        Subject subject = getSubject(request, response);</div><div class="line">        Session session = subject.getSession();</div><div class="line">        String nickName = (String)subject.getPrincipal();</div><div class="line">        Serializable sessionId = session.getId();</div><div class="line">        if (!subject.isAuthenticated() &amp;&amp; !subject.isRemembered()) &#123;</div><div class="line">            // 如果没有登录，直接进行之后的流程</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        synchronized (this.cache) &#123;</div><div class="line">            Deque&lt;Serializable&gt; deque = this.cache.get(nickName);</div><div class="line">            if (deque == null) &#123;</div><div class="line">                deque = new ConcurrentLinkedDeque&lt;Serializable&gt;();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if (!deque.contains(sessionId) &amp;&amp; session.getAttribute("kickOut") == null) &#123;</div><div class="line">                session.setAttribute("nickName", nickName);</div><div class="line">                deque.addLast(sessionId);</div><div class="line">            &#125;</div><div class="line">            this.logger.debug("deque = " + deque);</div><div class="line">            if (deque.size() &gt; this.maxSession) &#123;</div><div class="line">                if (!this.kickoutAfter) &#123;</div><div class="line">                    sessionId = deque.removeFirst();</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    sessionId = deque.removeLast();</div><div class="line">                &#125;</div><div class="line">                try &#123;</div><div class="line">                    Session kickoutSession = sessionManager.getSession(new DefaultSessionKey(sessionId));</div><div class="line">                    if (kickoutSession != null) &#123;</div><div class="line">                        kickoutSession.stop();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                catch (Exception e) &#123;// ignore exception</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            this.cache.put(nickName, deque);</div><div class="line">        &#125;</div><div class="line">        // 如果被踢出了，直接退出，重定向到踢出后的地址</div><div class="line">        if (session.getAttribute("kickout") != null) &#123;</div><div class="line">            // 会话被踢出了</div><div class="line">            try &#123;</div><div class="line">                subject.logout();</div><div class="line">            &#125;</div><div class="line">            catch (Exception e) &#123; // ignore</div><div class="line">            &#125;</div><div class="line">            saveRequest(request);</div><div class="line">            WebUtils.issueRedirect(request, response, kickoutUrl);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setKickoutUrl(String kickoutUrl) &#123;</div><div class="line">        this.kickoutUrl = kickoutUrl;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setKickoutAfter(boolean kickoutAfter) &#123;</div><div class="line">        this.kickoutAfter = kickoutAfter;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setMaxSession(int maxSession) &#123;</div><div class="line">        this.maxSession = maxSession;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setSessionManager(SessionManager sessionManager) &#123;</div><div class="line">        this.sessionManager = sessionManager;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setCacheManager(CacheManager cacheManager) &#123;</div><div class="line">        this.cache = cacheManager.getCache(Constants.LOGIN_SESSION);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class KickOutSessionListener implements SessionListener &#123;</div><div class="line">    private Logger logger = (Logger)LoggerFactory.getLogger(this.getClass().getName());</div><div class="line">    </div><div class="line">    private Cache&lt;String, Deque&lt;Serializable&gt;&gt; cache;</div><div class="line">    </div><div class="line">    @Autowired</div><div class="line">    private SessionDAO sessionDAO;</div><div class="line">    </div><div class="line">    public void setCacheManager(CacheManager cacheManager) &#123;</div><div class="line">        this.cache = cacheManager.getCache("shiro-kickout-session");</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private void removeSessionFromCache(Session session) &#123;</div><div class="line">        String nickName = (String)session.getAttribute("nickName");</div><div class="line">        if (nickName != null) &#123;</div><div class="line">            logger.info("remove session: " + session.getId() + " in deque of " + nickName + "@shiro-kickout-session");</div><div class="line">            synchronized (this.cache) &#123;</div><div class="line">                </div><div class="line">                Deque&lt;Serializable&gt; deque = this.cache.get(nickName);</div><div class="line">                deque.remove(session.getId());</div><div class="line">                sessionDAO.delete(session);</div><div class="line">                </div><div class="line">                this.cache.put(nickName, deque);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void onStop(Session session) &#123;</div><div class="line">        this.removeSessionFromCache(session);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void onExpiration(Session session) &#123;</div><div class="line">        this.removeSessionFromCache(session);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void onStart(Session session) &#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;并发登陆人数控制就是控制同一账号最大有效会话数。而项目中会话管理交给shiro控制，shiro的sessionId每次是不一样的，也就是说，
    
    </summary>
    
      <category term="x-blog" scheme="http://www.myzwl.win/categories/x-blog/"/>
    
    
      <category term="x-blog" scheme="http://www.myzwl.win/source/tags/x-blog/"/>
    
  </entry>
  
  <entry>
    <title>x-blog之实时显示在线登录人数简单介绍</title>
    <link href="http://www.myzwl.win/2019/07/08/xblog_5/"/>
    <id>http://www.myzwl.win/2019/07/08/xblog_5/</id>
    <published>2019-07-08T14:48:51.000Z</published>
    <updated>2019-07-14T09:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先怎么才算登录人数，一般规定用户登录后才算，但是登陆后会出现几种情况，用户主动退出登录，长时间不点击和主动关闭浏览器都会导致会话失效，另外并发登录人数限制和管理员在线踢出用户都会影响登录人数<br>而一般的做法就是写个servlet会话监听器去监听登录，当有会话建立时并且已经成功登录和先判断该用户是否已经正在线，统计相关信息，然后就是退出浏览器只能等会话失效才算离线。用这种方法去做，简单.但是实时效果不是太好但是发现我得session是用shiro管理的，大部分应用离不开shiro，而且shiro的sessionId每次是不一样的，也就是说，同一用户登录，在缓存中通过用户名产生的会话id不一样，造成同一用户登录重新登录会变成不同用户而在线人数不对。<br>而另一种更好并且统计更准确的是利用redis缓存信息（遇到了瓶颈，也是这个sessionId每次不一样，但是如果把shiro换掉或者做成分布式可以解决），大概是这样的想法，现在redis中放两组key，根据需求一组存放登陆用户的SessionId与ClientUser的Json数据，另一组存放存放登录用户的UID与SessionId对于的数据，然后利用该监听器，，只要一有会话差生，就从redis登记表（封装各类实时统计的方法）中查看，以一定规则查看是否登录，这里可以判断是游客还是会员，然后记录相关登记信息等等，放在session中，这种统计方法更实时，统计内容更多，但是因为shiro的问题，最终统计很不准确，因为这个sessionId还必须是准确才行</p>
<h4 id="会话列表"><a href="#会话列表" class="headerlink" title="会话列表"></a>会话列表</h4><p>要能准确的实时统计，得先解决上面涉及的5个影响因素</p>
<ol>
<li>并发登录人数控制 核心思想就是利用监听器根据那个用户名得到sessionId然后踢掉，缓存同步（见并发登陆人数控制）</li>
<li>用户主动退出和会话正常死亡通过监听器解决<br>3.关闭浏览器通过缩短会话存活时间保证（不一定合理，因为该项目纯粹娱乐所以可以这样做)</li>
<li>强制用户退出 根据sessionId让session失效，logout就行了<br>不过这里比较棘手的就是的就是那个强制退出的会话怎么清除，如果不清除，缓存中会得到空指针，最头疼的是服务器崩溃，利用缓存中的方法可以得到所有活跃的会话，包括失效的。通过异常删选出失效的会话并删除，最后就剩下正常的会话列表了</li>
</ol>
<p>当然这时传统的做法，不能完全模拟实时统计，最有效的方法就是用心跳方式解决</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"> **</div><div class="line"> * &lt;p&gt;</div><div class="line"> * 在线人数服务实现类</div><div class="line"> * &lt;/p&gt;</div><div class="line"> *</div><div class="line"> * @author slycmiaoxi</div><div class="line"> * @since 2019-06-23</div><div class="line"> */</div><div class="line">@Service</div><div class="line">@Slf4j</div><div class="line">public class ITSessionServiceImpl implements ITSessionService &#123;</div><div class="line">    @Autowired</div><div class="line">    private SessionDAO sessionDAO;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public int countActivesSession() &#123;</div><div class="line">        return CollectionUtils.isEmpty(listActivesSession()) ? 0 : listActivesSession().size();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public Collection&lt;Session&gt; listActivesSession() &#123;</div><div class="line">        // 1. 获得当前所有活跃的在线用户</div><div class="line">        Collection&lt;Session&gt; currentSessionList = sessionDAO.getActiveSessions();</div><div class="line">        </div><div class="line">        // 2.仍然存在缓存中但已失效的的用户会话</div><div class="line">        Collection&lt;Session&gt; invalidSessionList = new LinkedList&lt;&gt;();</div><div class="line">        </div><div class="line">        // 3.筛选出失效的会话</div><div class="line">        Iterator&lt;Session&gt; it = currentSessionList.iterator();</div><div class="line">        while (it.hasNext()) &#123;</div><div class="line">            try &#123;</div><div class="line">                Session session = it.next();</div><div class="line">                PrincipalCollection principalCollection =</div><div class="line">                    (PrincipalCollection)session.getAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY);</div><div class="line">                invalidSessionList.add(session);</div><div class="line">            &#125;</div><div class="line">            catch (Exception e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 4.删除缓存活跃会话中失效的会话</div><div class="line">        invalidSessionList.stream().filter(x -&gt; x != null).forEach(x -&gt; &#123;</div><div class="line">            if (currentSessionList.contains(x)) &#123;</div><div class="line">                sessionDAO.delete(x);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        // 5. 剩下正常的在线用户</div><div class="line">        Collection&lt;Session&gt; normalSessionList = sessionDAO.getActiveSessions();</div><div class="line">        return normalSessionList;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public SessionDAO getSessionDAO() &#123;</div><div class="line">        return this.sessionDAO;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;首先怎么才算登录人数，一般规定用户登录后才算，但是登陆后会出现几种情况，用户主动退出登录，长时间不点击和主动关闭浏览器都会导致会话失效，另外
    
    </summary>
    
      <category term="x-blog" scheme="http://www.myzwl.win/categories/x-blog/"/>
    
    
      <category term="x-blog" scheme="http://www.myzwl.win/source/tags/x-blog/"/>
    
  </entry>
  
  <entry>
    <title>x-blog之论坛核心表简单设计</title>
    <link href="http://www.myzwl.win/2019/07/05/xblog_6/"/>
    <id>http://www.myzwl.win/2019/07/05/xblog_6/</id>
    <published>2019-07-05T14:48:51.000Z</published>
    <updated>2019-07-14T09:08:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果放在一张表里，控制起来很复杂，所以干脆设置成三张表<br>t_blog_info(帖子表)、t_comment_info（评论表)、t_floor_info（楼中楼表)<br>为了方便直接贴出截图（以下是按照自己的想法建的结构，仅作为项目说明，如不合理，请谅解)</p>
<h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><ol>
<li><p>t_blog_info(帖子表)<br><img src="/images/xblog/2_3.jpg" alt="Alt text"><br>其中visitor_hasread为帖子访问量，<br>blog_item帖子唯一索引，用来快速定义帖子详情，blog_state帖子状态，标记是普通贴还是精贴等等，用枚举值标记。</p>
</li>
<li><p>t_comment_info(顶层评论表)<br><img src="/images/xblog/2_4.jpg" alt="Alt text"><br>其中blog_id用来定位所属那篇帖子</p>
</li>
<li><p>t_floor_info（楼中楼表)<br><img src="/images/xblog/2_5.jpg" alt="Alt text"><br>其中blog_id,comment_id用来定位唯一楼中楼评论</p>
</li>
</ol>
<p>ok，以上三张基础表建好了，就可以在此基础上扩展功能了</p>
<h4 id="功能简单介绍"><a href="#功能简单介绍" class="headerlink" title="功能简单介绍"></a>功能简单介绍</h4><p>围绕论坛基本功能主要分为搜索帖子，所有帖子展示（包含不同状态的帖子)，用户个人所有帖子展示，访问量控制，评论与楼中楼加载等等</p>
<ol>
<li>搜索帖子改进由like模糊查询-&gt;lucene-&gt;es，其中将帖子标题和内容进行分词和搜索，具体见es包下封装</li>
<li>所有帖子展示，分页查询所有帖子和热门贴，一般要门后端分类号直接给前端，要么前端加载利用jstl进行判断分类，由于目前每页显示数据量不大，所有直接通过前端判断分类显示了<br>3.用户个人所有帖子展示 同所有帖子，只不过加个用户id<br>4.访问量计算 按照ip和用户的访问表进行登记判断，以一天为准，通过定时器凌晨自动清空访问表，并且访问量记录在帖子表更新下<br><img src="/images/xblog/2_6.jpg" alt="Alt text"><br>5.评论与楼中楼加载，按照所属哪个帖子直接加载其下所有数据即可，如下代码<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * 返回帖子内容页</div><div class="line">    *</div><div class="line">    * @param currentPage 当前页</div><div class="line">    * @param encodeBlogId 帖子id</div><div class="line">    * @param mv ModelAndView对象</div><div class="line">    * @param request 域对象</div><div class="line">    * @return 帖子内容页</div><div class="line">    * @author slycmiaoxi</div><div class="line">    * @since 2019-06-28</div><div class="line">    */</div><div class="line">   @RequestMapping("show/&#123;currentPage&#125;/&#123;encodeBlogId&#125;")</div><div class="line">   public ModelAndView show(@PathVariable int currentPage, @PathVariable String encodeBlogId, ModelAndView mv,</div><div class="line">       HttpServletRequest request) &#123;</div><div class="line">       long blogId = Long.parseLong(CodecUtils.decodeData(encodeBlogId));</div><div class="line">       // 1.该篇文章数据</div><div class="line">       ArticleDto articleDto = itBlogInfoService.getDtoById(blogId);</div><div class="line">       </div><div class="line">       // 2.楼中楼数据</div><div class="line">       List&lt;FloorDto&gt; floorDtos =</div><div class="line">           (List&lt;FloorDto&gt;)itFloorInfoService.queryListbyPage(new Page(), new ResultMap("blogId", blogId).toMap())</div><div class="line">               .getList();</div><div class="line">       </div><div class="line">       // 3.访问量统计</div><div class="line">       boolean checked = itCritiquerecordInfoService.checkRepeat(blogId, request.getRemoteAddr());</div><div class="line">       if (!checked) &#123;</div><div class="line">           TCritiquerecordInfo po = new TCritiquerecordInfo();</div><div class="line">           po.setBlogId(blogId);</div><div class="line">           po.setIpAddress(request.getRemoteAddr());</div><div class="line">           po.setGmtCreate(new Date());</div><div class="line">           po.setDeleteFlag(Enable.YES.getValue());</div><div class="line">           itCritiquerecordInfoService.insert(po);</div><div class="line">           TBlogInfo blogInfo = itBlogInfoService.selectById(blogId);</div><div class="line">           int hasReadCount = blogInfo.getVisitorHasread();</div><div class="line">           blogInfo.setVisitorHasread(++hasReadCount);</div><div class="line">           itBlogInfoService.updateById(blogInfo);</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       // 4.评论数据</div><div class="line">       Page page = new Page(currentPage, Constants.DEFAULT_EVERY_PAGE);</div><div class="line">       PageModal pg = itCommentInfoService.queryListbyPage(page, new ResultMap("blogId", blogId).toMap());</div><div class="line">       long total = itCommentInfoService.queryTotal(new ResultMap("blogId", blogId).toMap());</div><div class="line">       new PageListUtil().pageModelList(total, mv, pg);</div><div class="line">       mv.addObject("blogInfo", articleDto);</div><div class="line">       mv.addObject("Floor", floorDtos);</div><div class="line">       </div><div class="line">       mv.setViewName("article/articleContent");</div><div class="line">       return mv;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="首页设计"><a href="#首页设计" class="headerlink" title="首页设计"></a>首页设计</h4><p>旧版本这里的设计是对应模块，比如友情链接，关于吧主模块等等，都是在设计一张表，然后通过一个监听器，初始化（initxx）,放在session里，然后定时更新session。<br>目前简化了，直接提供接口，实时改变。比如友情连接<br><img src="/images/xblog/2_7.jpg" alt="Alt text"><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("portal")</div><div class="line">  public String getDoorView(Model model) &#123;</div><div class="line">      </div><div class="line">      // 1.加载链接栏信息</div><div class="line">      List&lt;TLinkInfo&gt; linkList = itLinkInfoService.selectList(new EntityWrapper&lt;TLinkInfo&gt;());</div><div class="line">      model.addAttribute("linkList", linkList);</div><div class="line"></div><div class="line">      // 2.加载热门贴</div><div class="line">      List&lt;ArticleDto&gt; hotDtos = itBlogInfoService.listHotDtos();</div><div class="line">      model.addAttribute("hotBlog", hotDtos);</div><div class="line"></div><div class="line">      return "portal/index";</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p>由于个人经验和能力的不足以及前端比较短板，目前该模块有许多不足之处，请谅解！<br>比如，楼中楼的前端分页显示，自己做不出来~，有能力的在校生或者大佬如果添加，将及时更新</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果放在一张表里，控制起来很复杂，所以干脆设置成三张表&lt;br&gt;t_blog_info(帖子表)、t_comment_info（评论表)、t_
    
    </summary>
    
      <category term="x-blog" scheme="http://www.myzwl.win/categories/x-blog/"/>
    
    
      <category term="x-blog" scheme="http://www.myzwl.win/source/tags/x-blog/"/>
    
  </entry>
  
  <entry>
    <title>x-blog之权限模块简单说明</title>
    <link href="http://www.myzwl.win/2019/07/05/xblog_7/"/>
    <id>http://www.myzwl.win/2019/07/05/xblog_7/</id>
    <published>2019-07-05T13:48:51.000Z</published>
    <updated>2019-07-14T09:08:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前该模块仍然沿袭旧版本的设计，由于个人经验和能力的不足，所以存在很多隐患和漏洞，请谅解。<br>权限模块总共五张表，用户-角色-权限，并且为了方便，系统是基于角色控制用户操作权限的。<br>而真实的情况应该是很多张权限表，并且用户个人信息与用户权限信息应该是独立的，比如tuser不涉及用户的个人信息的，而core_user_base(表名随意)记录用户信息，而其中的用户有哪些信息应该在记录在一张表cfg_user_base_info中，目前登录是系统内单独注册的，应该有第三方登录，如qq，微信等，目前为涉及，请谅解，后续有能力在搞。<br>另外权限是由shiro控制，并且每次都需要从数据库进行验证，合理的应该是初始化到redis。</p>
<h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>t_user（用户表）<br><img src="/images/xblog/3_1.jpg" alt="Alt text"><br>其中user_state是用户拉黑状态，eCode是用户最后注册成功的邮箱激活码</p>
<p>t_role(角色表)<br><img src="/images/xblog/3_2.jpg" alt="Alt text"></p>
<p>t_user_role(用户-角色关系表)<br><img src="/images/xblog/3_3.jpg" alt="Alt text"></p>
<p>t_permisssion（权限表）<br><img src="/images/xblog/3_4.jpg" alt="Alt text"></p>
<p>t_role_permisssion（角色-权限关系表)<br><img src="/images/xblog/3_5.jpg" alt="Alt text"></p>
<p>t_email_code(邮箱记录表)<br><img src="/images/xblog/3_6.jpg" alt="Alt text"><br>该表主要用于验证邮箱是否已被注册和记录最后一次邮箱的激活码</p>
<h4 id="用户注册简单说明"><a href="#用户注册简单说明" class="headerlink" title="用户注册简单说明"></a>用户注册简单说明</h4><p>该实现方法仅作为本项目娱乐使用，用户点击注册，第一个页面包含用户名和邮箱，首先对用户名进行重名校验，邮箱是否已被注册，第二个页面点击发送验证码，如果成功发送出去（一般在垃圾箱），然后在邮箱记录表中进行记录，然后前端判断激活码是否正确。<br>旧版本这里将邮箱发送做成微服务，利用activeMq进行一对一发送，同时，这里邮箱激活码可以改成链接带上激活码参数更优<br>最后一步填写相关信息，注册成功后跳转至个人信息控制页</p>
<h4 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h4><p>旧版本做的很不合理，应该利用redis做成单点登录。目前就是单击通过用户名，密码登录。<br>利用shiro控制权限认证，在进行权限认证的时候，需要进行黑名单过滤和登录日志统计<br>1.黑名单 即利用用户状态判定该用户状态是否被锁定，这里有一个bug未解决，就是用户输入不存在的用户名称时，这里 String nickName = request.getParameter(“nickName”);为空，直接返回fasle，前端通过ajax无法判断，所以无任何改变<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">  /**</div><div class="line"> * &lt;p&gt;</div><div class="line"> * 过滤黑名单用户</div><div class="line"> * &lt;/p&gt;</div><div class="line"> *</div><div class="line"> * @author slycmiaoxi</div><div class="line"> * @since 2019-06-27</div><div class="line"> */</div><div class="line">public class LockUserFilter extends AccessControlFilter &#123;</div><div class="line">    @Autowired</div><div class="line">    private ITUserService itUserService;</div><div class="line">    </div><div class="line">    private String loginUrl = "/unauthorized.jsp";</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)</div><div class="line">        throws Exception &#123;</div><div class="line">        String nickName = request.getParameter("nickName");</div><div class="line">        TUser user = itUserService.getUserByName(nickName);</div><div class="line">        if (null == user || user.getUserState() == 0) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected boolean onAccessDenied(ServletRequest request, ServletResponse response)</div><div class="line">        throws Exception &#123;</div><div class="line">        WebUtils.issueRedirect(request, response, loginUrl);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.登录日志统计<br><img src="/images/xblog/3_7.jpg" alt="Alt text"><br>主要利用一个过滤器继续aop拦截<br>这里有一个地方需要考虑，如果用户未成功登录或其他都不做日志记录，所以需要在用户登录成功时设置一个flag用于标记用户登录成功<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</div><div class="line">     throws IOException, ServletException &#123;</div><div class="line">     request.setCharacterEncoding("UTF-8");</div><div class="line">     response.setCharacterEncoding("UTF-8");</div><div class="line">     HttpServletRequest httpRequest = (HttpServletRequest)request;</div><div class="line">     Date time_begin = new Date();</div><div class="line">     chain.doFilter(request, response);</div><div class="line">     Date time_end = new Date();</div><div class="line">     // 成功登录</div><div class="line">     if (request.getAttribute("flag") != null) &#123;</div><div class="line">         // 请求耗时</div><div class="line">         long i = (long)((time_end.getTime() - time_begin.getTime()));</div><div class="line">         TLoginLog tLoginLog = generatorLogger(httpRequest, i);</div><div class="line">         iTLoginLogService.insert(tLoginLog);</div><div class="line">     &#125;</div><div class="line">     else &#123;</div><div class="line">         log.error("login fail !");</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h4 id="xss防御"><a href="#xss防御" class="headerlink" title="xss防御"></a>xss防御</h4><p>说到安全不得不吐槽下被攻击过的过往<br>利用nat123将本机作为服务器，成为肉鸡，出现一个新用户-&gt;利用富文本编辑漏洞，攻击力数据库-&gt;利用redis默认6379又未设置密码，key被删光-&gt;未做反爬虫处理，被当做请求实验，造成服务器压力大，最后挂掉-&gt;利用es默认配置，数据直接被黑，留下黑客邮箱交钱给数据-&gt;经常被xss攻击，植入脚本。<br>幸亏是个人的，没有多大损失，由此可见。系统的安全性也是必须要考虑的。<br>目前采取了两种方式，直接利用 XssFilter（具体见xss包下类）过滤所有请求，是内容安全，但是这样做会把富文本的表情也给过滤掉。<br>采取了另一种方案，在前端利用开源的xss防御过滤文本类容，然后在后端通过jsoup进行xss防御</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前该模块仍然沿袭旧版本的设计，由于个人经验和能力的不足，所以存在很多隐患和漏洞，请谅解。&lt;br&gt;权限模块总共五张表，用户-角色-权限，并且
    
    </summary>
    
      <category term="x-blog" scheme="http://www.myzwl.win/categories/x-blog/"/>
    
    
      <category term="x-blog" scheme="http://www.myzwl.win/source/tags/x-blog/"/>
    
  </entry>
  
  <entry>
    <title>学习面经一</title>
    <link href="http://www.myzwl.win/2018/04/05/dream_17/"/>
    <id>http://www.myzwl.win/2018/04/05/dream_17/</id>
    <published>2018-04-05T13:48:51.000Z</published>
    <updated>2018-04-14T08:12:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>失败并不可怕，可怕的是不能从失败的阴影中走出来。以下主要来自牛客网别人分享或者有些自己面试记得的题目</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>从三月中旬到四月初，前前后后大概有些在线笔试机会。给自己帮助最大的就是算法了，自己也是非常喜欢算法的，之前也是准备好久的，很多都是leetcode或者剑指offer的题，有些则是结合各公司实际的题，当然做的效果很一般（自己太渣），不得不说算法是程序的灵魂</p>
<h4 id="部分一"><a href="#部分一" class="headerlink" title="部分一"></a>部分一</h4><p>加密解密了解么？几种算法，讲一下你了解的<br>多线程了解么？什么是线程安全？<br>说一个你最熟悉的设计模式<br>讲一下你项目中用到了哪些设计模式<br>Java的hashmap的原理<br>Hashmap的线程安全性，什么是线程安全的？如何实现线程安全<br>Mysql的数据库引擎，区别特点<br>写一个单例模式，用双检查锁单例<br>单例模式在你项目里哪些应用？<br>数据连接池<br>说一说高并发<br>项目介绍，最复杂的表<br>Hashmap的原理<br>Hashmap为什么大小是2的幂次<br>介绍一下红黑树<br>Arraylist的原理<br>堆排序的原理<br>抽象工厂和工厂方法模式的区别<br>工厂模式的思想<br>object类你知道的方法<br>哪里用到了工厂模式<br>Forward和redirect的区别<br>线程池的使用时的注意事项<br>Spring中autowire和resourse关键字的区别<br>Hashmap的原理<br>Hashmap的大小为什么指定为2的幂次<br>简单说一说消息队列和分布式<br>Redis的应用场景<br>Hashmap的原理<br>Hashmap中jdk1.8之后做了哪些优化<br>垃圾回收的过程<br>Jvm的参数设置<br>项目中的优化<br>快排的思想</p>
<h4 id="部分二"><a href="#部分二" class="headerlink" title="部分二"></a>部分二</h4><p>Tcp怎么保证可靠传输<br>Tcp的拥塞控制<br>让你设计一个即时聊天的系统<br>支付宝转账，是如何实现，几个小时通知转账成功的<br>解释一下长连接<br>对面向对象的理解<br>介绍多态<br>Java新建线程有哪几种方式<br>线程池的作用<br>一棵二叉排序树，给定一个数，找到与给定数差值最小的数<br>设计一个系统，解决抢购时所需要的大量的短链接的功能，如何保证高并发，如何设计短链接<br>设计一个系统，记录qq用户前一天的登录状态，提供16g内存和2tb的硬盘，要做到查询指定qq号的前一天的登录状态<br>两个排序的数组A和B分别含有m和n个数，找到两个排序数组的中位数<br>数据库的索引原理<br>索引使用的注意事项<br>数据库的引擎<br>Java垃圾回收机制<br>Java的finalize，finally，final三个关键字的区别和应用场景<br>String类可以被继承么<br>给一个整数数组，找到两个数使得他们的和等于一个给定的数 target<br>红黑树<br>Redis的应用<br>自己写一个tomcat服务器，你会怎么写<br>分布式服务器会出现哪些问题<br>怎么解决session一致性缓存的问题<br>Redis的优势和特点<br>一千万用户并发抢购，怎么设计<br>如果成功的用户有10万，redis存不下怎么处理<br>Redis和mysql的区别<br>Redis的持久化有哪些方式，具体原理<br>Java collection类，集合<br>多线程并发包<br>countDownLatch<br>Hashmap的原理<br>hashmap容量为什么是2的幂次<br>hashset的源码<br>object类你知道的方法<br>hashcode和equals<br>Redis的持久化？有哪些方式，原理是什么？<br>稳定的排序算法和不稳定的排序算法<br>快速排序的思想</p>
<h4 id="部分三"><a href="#部分三" class="headerlink" title="部分三"></a>部分三</h4><p>Java的内存模型，垃圾回收<br>Nio和IO有什么区别<br>Nio和aio的区别<br>Spring的aop怎么实现<br>Spring的aop有哪些实现方式<br>动态代理的实现方式和区别<br>Linux，查找磁盘上最大的文件的命令<br>Linux，如何查看系统日志文件<br>Java中的多态<br>Object类下的方法<br>Finalize的作用和使用场景<br>Hashcode和equals<br>为什么要同时重写hashcode和equals<br>不同时重写会出现哪些问题<br>Hashmap的原理<br>Hashmap如何变线程安全，每种方式的优缺点<br>垃圾回收机制<br>反转单链表<br>实现类似微博子结构的数据结构，输入一系列父子关系，输出一个类似微博评论的父子结构图<br>手写java多线程<br>手写java的soeket编程，服务端和客户端<br>进程间的通信方式<br>Mysql的容灾备份<br>Redis和memcache 的区别<br>Java的full gc<br>Full gc会导致什么问题<br>两个有序链表合并成一个有序链表<br>死锁是什么呢<br>怎么解决死锁</p>
<h4 id="部分四"><a href="#部分四" class="headerlink" title="部分四"></a>部分四</h4><p>http请求流程<br>为什么负载均衡<br>数据库挂了怎么办？除了热备份还有什么方法<br>找出两个数组相等的数，不能用其他数据结构<br>给定一个数字，一个数组，找出数组中相加等于这两个数的和，不能用数据结构<br>如何判断一个树是不是另一颗树的子树<br>I++操作怎么保证线程安全<br>设计一个下单系统，下单成功后可以给用户发优惠券<br>接上面场景题：服务器挂了，优惠券还没发怎么办<br>数据库挂了怎么怎么办<br>怎么保证一致性<br>Nio的原理<br>Channel和buffer<br>directBuffer和buffer的区别<br>nio和aio的区别<br>锁的实现原理<br>怎么解决缓存和主存的一致性问题<br>缓存还没更新到主存，服务器挂了怎么办<br>数据库挂了怎么办<br>读写锁<br>什么时候用读锁<br>什么时候用写锁<br>Cas的原理，使用场景<br>数据库的瓶颈<br>序列化的底层怎么实现的<br>synchronized 的底层怎么实现的<br>乐观锁vs 悲观锁<br>gc<br>concurrenthashmap 分段锁的细节<br>设计模式怎么分类，每一类都有哪些<br>并发包里了解哪些<br>b 树，b+树，b*树</p>
<h4 id="部分五"><a href="#部分五" class="headerlink" title="部分五"></a>部分五</h4><p>jdk 动态代理vscglib 动态代理，他们底层分别怎么实现的<br>synchronizedMap 知道吗？他和concurrenthashmap 分别使用于什么场景？<br>https 过程?公钥能用公钥解吗<br>描述一下java 线程池。<br>怎么保证redis 和db 中的数据一致<br>设计模式怎么用到项目中<br>类加载<br>jvm 分区<br>spring ioc，aop 以及其优点<br>浏览器访问一个网址的时候都有哪些过程（还要了解DNS 查找的过程）<br>tcp 三次握手，四次分手<br>线程池<br>java 同步机制有哪些<br>进程和线程</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;失败并不可怕，可怕的是不能从失败的阴影中走出来。以下主要来自牛客网别人分享或者有些自己面试记得的题目&lt;/p&gt;
&lt;h4 id=&quot;算法&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="从头开始" scheme="http://www.myzwl.win/categories/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
    
      <category term="从头开始" scheme="http://www.myzwl.win/source/tags/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>学习面经一</title>
    <link href="http://www.myzwl.win/2018/04/05/dream_16/"/>
    <id>http://www.myzwl.win/2018/04/05/dream_16/</id>
    <published>2018-04-05T13:48:51.000Z</published>
    <updated>2018-04-14T08:12:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>失败并不可怕，可怕的是不能从失败的阴影中走出来。以下主要来自牛客网别人分享或者有些自己记得的题目</p>
<h4 id="部分一"><a href="#部分一" class="headerlink" title="部分一"></a>部分一</h4><p>1.自我介绍。主要介绍以前做的项目<br>2.如何找出数组中数量最多的数（要求时间复杂度最佳）？<br>public static int maxNumber(int[] a){<br>        Map<integer,integer> map=new HashMap<integer,integer>();<br>       for(int i=0;i<a.length;i++){ if(map.get(a[i])="=null){" map.put(a[i],="" 1);="" }else{="" map.get(a[i])+1);="" }="" int="" max="0;" num="0;" for="" (entry<integer,integer=""> entry :map.entrySet()){</a.length;i++){></integer,integer></integer,integer></p>
<pre><code>        if(entry.getValue()&gt;max){
           max=(Integer)entry.getValue();
           num=(Integer)entry.getKey();
       }
   }
return num;
}
</code></pre><p>3.如何找出数组中数量超过一半的数（要求时间复杂度最佳）？<br>    public static int searchOver(int[] a){<br>        if(a==null)return -1;<br>        int count=0;<br>        int temp=0;<br>        for(int j=0;j<a.length 2;j++){="" temp="a[j];" for(int="" i="j+1;i<a.length;i++){" if(temp="=a[i]){" count++;="" }="" if(count="">a.length/2)<br>                    return temp;<br>            }<br>            count=0;<br>        }<br>        return -1;<br>    }</a.length></p>
<p>4.如何实现轮询？<br>应用:tomcat集群中默认dns轮询，如果有tomcat挂掉了，必须等到dns重新解析或者重启<br>Nginx，轮询（默认）按照时间请求，同时还有个加权<br>spring task定时器，根据相关表达式，设置一定时间轮询<br>循环队列和计数器</p>
<p>5.针对项目提问<br>6.数据库索引为何要用B+树？<br>首先有其他树结构<br>AVL树左孩子毕根节点小，右孩子大，插入O（1）,删除和查找lon（n）<br>红黑树，改进删除O（n）；<br>trim（字典树）但是存储的是字符串，avl删除不行，红黑树<br>磁盘io读取次数过于频繁<br>而数据库中文件过大，不可能全部存在内存中<br>在查找过程中要减少磁盘io读取次数<br>b+数结构，结点值对应最左边第一个，然后叶子结点记录数据，非叶子结点记录索引，一次携带关键字多，减少磁盘io，<br>另一方扫描范围大和稳定（局部性原理)</p>
<p>7.为什么用B+树就会快（硬盘底层问题）<br>8..http状态码<br>主要由三个十进制组成，第一个代表状态<br>1<strong> 信息，服务器收到请求，需要请求者继续执行<br>2</strong> 成功200<br>3<strong>重定向<br>4</strong>客户端 403跨越、401权限404<br>5** 服务器500</p>
<p>9.如何使用数据库索引？<br>聚簇索引（拼音排序好）张查到a-z，知道结果（正文本身就是一个目录<br>非聚簇索引（拼旁部首），不同字上下页跳动大（先找到目录的结果，在翻到所需的页码</p>
<h4 id="部分二"><a href="#部分二" class="headerlink" title="部分二"></a>部分二</h4><p>1.项目中遇到的问题，如何解决？<br>2。一个无序数组，其中一个数字出现的次数大于其他数字之和，求这个数字<br>public static int searchOver(int[] a){<br>        if(a==null)return -1;<br>        int count=0;<br>        int temp=0;<br>        for(int j=0;j<a.length 2;j++){="" temp="a[j];" for(int="" i="j+1;i<a.length;i++){" if(temp="=a[i]){" count++;="" }="" if(count="">a.length/2)<br>                    return temp;<br>            }<br>            count=0;<br>        }<br>        return -1;<br>    }</a.length></p>
<p>3.一个数组，有正有负，不改变顺序的情况下，求和最大的最长子序列<br>public static ArrayList<integer> maxSum(int[] a){<br>        ArrayList<integer> list=new ArrayList<integer>();<br>        if(a==null)return null;<br>        int max=0;<br>        for(int i=0;i&lt;a.length;i++){<br>           max+=a[i];<br>           if(max&lt;0){<br>               max=a[i];<br>               list.clear();<br>               list.add(a[i]);<br>           }else{<br>               list.add(a[i]);<br>           }<br>        }<br>        return list;<br>    }</integer></integer></integer></p>
<p>4.volatile和synchronized？<br>内存模型: 线程、变量、本地内存、主内存<br>v:1.保证变量可见性(死循环，main，isrung线程)本地方法私有栈读取，不强制到主内存刷新，共享变量<br>2.不保证原子可见性，线程不安全，（100个线程，i++，脏读）<br>3.保证有序性（禁止指令重排，比如配置文件加载，happen-before；1.一个操作必须在另一个操作之前，一个操作必须对下一个操作可见）<br>synchronize：同步锁，类锁，对象锁，加载方法和变量，修饰的变量必须拥有锁，才能到临界区执行方法<br>比较:v轻量级，只能修饰变量，s重量级不仅变量还可以是方法<br>v：只能保证变量可见性，不能保证同步性，所以多个线程并发访问不会阻塞，s可以，多个线程竞争锁，会出现阻塞</p>
<p>5.项目用到什么数据库？隔离级别？索引？<br>mysql<br>首先事务并发执行需要解决四个问题<br>1.更新丢失（谁快就覆盖谁）<br>2.脏读（事务未提交，就读了）<br>3.不可重复读（事物之间修改了，读到了未修改前的）<br>4.幻读（事务之间有插入和删除）</p>
<p>事务隔离级别<br>1.默认的一个 不支持事务<br>2.innodb 支持事务 ，灾难恢复，行级锁、索引等等<br>3.memory 内存<br>4.多个默认的隔离级别在一起</p>
<p>innodb b+树索引<br>索引提高查询速度的数据库对象<br>比如主键，索引可以避免全表查询，有些数据项不需要查询、和避免排序</p>
<p>6.垃圾回收算法？<br>主要是分代算法（堆内存中)<br>按照对象的生命周期将内存进行划分<br>分为年轻代和老年代<br>年轻代分为eden、from、to<br>首先对象会在eden、中，但满了之后会将还在使用的放到from中，出发gc，清理eden、然后eden满了，将eden和from中正在使用的放在to中，一次类推，直到一定次数，将还在使用的对象放到老年区，经过一些列折腾后，出发full GC影响性能</p>
<p>7.垃圾收集器?<br>serial(单线程，暂停)<br>prnew（多线程版）<br>serial old<br>parnew old<br>cms（老年代收集器，实现一边清理一边工作，大大提高性能，需要配合使用）<br>G1收集器（将java堆分成大小相等的独立区域，进行年轻代和老年代的回收）</p>
<p>8.怎样进入老年代？<br>1.新生代每经过一次gc，年龄加1，当达到阙值，默认15就会进入老年代<br>2.大对象直接进入老年代<br>3.在复制算法中，s轮换区无法容纳的对象直接进入老年区</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;失败并不可怕，可怕的是不能从失败的阴影中走出来。以下主要来自牛客网别人分享或者有些自己记得的题目&lt;/p&gt;
&lt;h4 id=&quot;部分一&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="从头开始" scheme="http://www.myzwl.win/categories/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
    
      <category term="从头开始" scheme="http://www.myzwl.win/source/tags/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>学习面经</title>
    <link href="http://www.myzwl.win/2018/03/24/dream_15/"/>
    <id>http://www.myzwl.win/2018/03/24/dream_15/</id>
    <published>2018-03-24T13:48:51.000Z</published>
    <updated>2018-03-26T08:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>以下题目均来自牛客网大佬分享</p>
<h4 id="酷家乐实习一面"><a href="#酷家乐实习一面" class="headerlink" title="酷家乐实习一面"></a>酷家乐实习一面</h4><p>1.自我介绍<br>自信展示自我，重点突出与职位相吻合的优势，同时注意自身素质和礼貌</p>
<p>2.做了哪些功能，为什么这么设计，提出新功能，如何做出来 ?<br>以最熟悉的项目为例（按照深度方式询问)<br>主要有留言版、实时显示在线登录人数、在线编程、算法建模、细粒度控制url加密，解耦业务逻辑，论坛核心表、黑名单和日志统计、email和消息推送、自定义访问量统计<br>为什么这么设计?<br>回答思路，困难-怎样做的-有其他方法或改进的<br>比如：留言版，正常思路三张表，文章表、评论表和楼中楼表，表与表之间有关系，控制起来感觉很多<br>三范式:一字段不能再分，二完全依赖主键，三无传递关系<br>很多表设计时都是有传递，如头像，姓名，解决办法，继承父类，放一些字段记录值或者直接sql多表查询<br>尽量放在一张表上，<br>数据结构B树符合，<br>B树是什么?<br>一种多路查找树,每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素，所有元素之间存在某种特定的排序的关系，比如退化到2-2树，二叉排序树，2-3树，2-3-4树，B树、B+树分页面<br>形式最左边记录结点数<br>这里仿照B树<br>节点数固定三个，父节点、当前结点、回复者结点。省略结点记录个数。然后分成两块，最顶层评论和楼中评论，通过父节点是否为0区分，这些父节点构造成一个链表，然后每个结点下，非0，楼中按照父节点id得到一组链表，按照时间顺序放入栈。<br>取出的时候就是由于记录的是用户id’作为结点，所以遍历用户表，id，用户名放入hash表，转换，然后栈-放入集合<br>什么是hash表?<br>它是针对查找效率接近O（1）而专门设计的,散列函数和处理冲突<br>除留余数法<br>该散列函数定义为hash（k）=k%p<br>通过开放定址法、链地址法解决冲突<br>map扩容为什么是2^n，原因位运算比取模运算效率高</p>
<p>3.在线登录人数<br>需要解决五个问题<br>用户主动退出登录，长时间不点击和主动关闭浏览器都会导致会话失效，另外并发登录人数限制和管理员在线踢出用户都会影响登录人数<br>什么是会话?<br>从计算机网络角度来说<br>三次握手，简单来说客户端发送包到服务器，等待服务器确认，第一次握手，<br>服务器收到包，先确认，在发送SYN包，进入SYN——RECV状态第二次握手<br>客户端收到SYN+ACK包，像服务器发送确认包，客户端和服务器端进入监听状态，完成三次握手<br>客户端与服务器开始传送数据<br>四次握手：向主机发送一个带有FIN附加标记的报文段<br>主机先发送确认号ACK，然后通知程序防止重传，客户再发送fin，q确认关闭连接<br>两次握手: 报文发送滞留时间过长失效，服务器发送链接，不理睬</p>
<p>从tomcat角度<br>http 都是无状态的协议，web 服务器不能识别出哪些请求是同一个浏览器发的，浏览器的每一次请求都是完全独立的<br>Cookie 放在浏览器端，浏览器第一次范围服务器时创建，以后每次都带上这个，保持http 状态信息的方案，会话跟踪<br>session通过cokkie携带的JSession_id返回session标识用<br>默认session cookie，关闭浏览器只是使存储在浏览器内存中的session cookie 失效，不会使服务器端的<br>session 对象失效</p>
<p>写个servlet会话监听器去监听登录，当有会话建立时并且已经成功登录和先判断该用户是否已经正在线，统计相关信息，然后就是退出浏览器只能等会话失效才算离线，统计内容和效果不好<br>session是用shiro管理的，大部分应用离不开shiro，而且shiro的sessionId每次是不一样的，也就是说，同一用户登录，在缓存中通过用户名产生的会话id不一样，造成同一用户登录重新登录会变成不同用户而在线人数不对<br>用shiro的缓存来统计，得解决这个并发登录人数控制。Shiro是这样做的，规定同一账号最大会话数，实际上是放在一个缓存队列中，如果其大小超过该会话数，就踢出头或尾会话，在加入该会话，然后就是这个缓存队列是通过ehcache中命名用户名设置的，然后将其放在shiro拦截器，放在登录请求中<br>如何解决缓存同步<br>需要个监听器根据那个用户名得到sessionId然后踢掉<br>还有一个就是强制用户退出，就是根据sessionId让session失效，logout就行了<br>最后就是实时统计在线列表了，这里比较棘手的就是的就是那个强制退出的会话怎么清除，如果不清除，缓存中会得到空指针，最头疼的是服务器崩溃，利用缓存中的方法可以得到所有活跃的会话，包括失效的，然后就是通过异常<br>得到失效的会话，然后就是通过sessionid判断，更新缓存，删掉那个失效的会话，最后就是活跃的会话了，而关闭浏览器通过缩短会话存活时间保证，主动退出和会话正常死亡通过监听器解决</p>
<p>更好的方法,利用redis缓存信息,现在redis中放两组key，根据需求一组存放登陆用户的SessionId与ClientUser的Json数据，另一组存放存放登录用户的UID与SessionId对于的数据，然后利用该监听器，，只要一有会话差生，就从redis登记表（封装各类实时统计的方法）中查看，以一定规则查看是否登录，这里可以判断是游客还是会员，然后记录相关登记信息等等，放在session中</p>
<p>其他同理</p>
<h4 id="项目的并发量"><a href="#项目的并发量" class="headerlink" title="项目的并发量"></a>项目的并发量</h4><p>支持比较小的高并发，压测（Load Impact）50个并发量，5分钟<br>回答思路：项目架构-功能分析<br>部分构成拆成微服务，算法建模+在线编程主要为dubbo+zookeeper，邮箱注册+在线推送，activeMQ+websocket，<br>zookeeper集群，activeMq集群，tomcat集群，nginx根据权重负载均衡和反向代理，redis缓存算法建模和主从复制，elasticsearch搜索查询，mysql数据库分库<br>在线编程尝试多线程并发，返回结果随机，失败</p>
<h4 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h4><p>连接关联<br>A 的id 和b 的parent_id 关联<br>Select a,b from a inner join b on a.id=b.parent_id<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>左外链接（左表all 元素都有）<br>Select a.,b.from a left join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>3 王五null<br>3）右外链接（右表all 元素都有）<br>Select a.,b.from a right join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>Null 3 34 2<br>4）完全链接（返回左边和右表中所有行，若某行在另外一个表中无匹配，则另一表的<br>选择列表列包含空值）<br>Select a.,b.from a full join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>Null 3 34 2<br>3 王五null<br>Not in 的例子：<br>Select emp_no from emplyees where emp_no not in (select emp_no from dept_manager)<br>mysql实现分页的优化sql语句<br>select from table order by id limit 1000000,10(数据1达到百万级贼慢)<br>优化一:<br>select from table where id&gt;=(select id from table limit 100000,1) limit 10<br>速度提升0.x倍<br>优化二:<br>select from table where id between 10000000 and 10000010<br>比上面提升5到10倍<br>另外，如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询<br>SELECT FROM table WHERE id IN(10000, 100000, 1000000…);<br>sql优化原则<br>1.对查询进行优化，要尽量避免全表扫描，在where或order的列上加索引<br>2.尽量避免在where子语句中有where num is null但可用0<br>代替<br>3.尽量避免在where 中用or，因为若一个字段有索引，一个没有，则要全表扫描<br>4.like %abc%全表扫描<br>5.避免在where子语句中对子语句中进行函数操作，因为要全表扫描<br>6使用复合索引时，必须用到该索引的第一个字段，否则索引不被使用</p>
<p>悲观锁和乐观锁<br>面试思路：什么是锁，用来干什么&gt;悲观锁乐观锁各自特点&gt;优缺点比较和各自应用场景<br>数据库管理系统并发控制任务是确保在多个事务同时存取数据库中同一数据时不破坏事务隔离以及统一性以及数据库的统一性<br>悲观锁<br>什么操作都可以改变数据，所以在该数据时就锁住<br>select 。。。for update<br>乐观锁<br>修改数据库后锁住（一般在数据库中加上一个字段区别历史版本和当前版本）<br>update t_goods<br>set status=2,version=version+1<br>where id=#{id} and version=#{version}</p>
<h4 id="有序数组排成二叉搜索树"><a href="#有序数组排成二叉搜索树" class="headerlink" title="有序数组排成二叉搜索树"></a>有序数组排成二叉搜索树</h4><p>思路，对于有序数组还是链表，其中间的数就是根结点，而中间的左边数就是左子树，中间右边就是右子树，依次递归即可<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static TreeNode sortedArrayToBST(int[] nums)&#123;</div><div class="line">		if(nums.length&lt;=0)return null;</div><div class="line">		return buildTree(nums,0,nums.length-1);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static TreeNode buildTree(int[] nums,int start,int end)&#123;</div><div class="line">		if(start&lt;=end)&#123;</div><div class="line">			int mid=(start+end)/2;</div><div class="line">			TreeNode&lt;Integer&gt; tree=new TreeNode&lt;Integer&gt;(nums[mid]);</div><div class="line">			tree.left=buildTree(nums,start,mid-1);</div><div class="line">			tree.right=buildTree(nums,mid+1,end);</div><div class="line">			return tree;</div><div class="line">		&#125;else&#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h4 id="索引，B-树"><a href="#索引，B-树" class="headerlink" title="索引，B+树"></a>索引，B+树</h4><p>mysql索引使用的是B+的数据结构<br>索引: 用于提高数据访问速度的数据库对象<br>有点：避免全表扫描、有些查询甚至可以不访问数据项、索引可以避免排序<br>缺点，性能性能下降，大部分数据更新时需要更新索引<br>哈希索引<br>在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题</p>
<h4 id="CAS与读写锁"><a href="#CAS与读写锁" class="headerlink" title="CAS与读写锁"></a>CAS与读写锁</h4><p>CAS（Compare and Swap）有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。<br>死锁 :哲学家进餐问题，每个哲学家都在等右边哲学家方上筷子，处于僵持等待状态，称为死锁<br>synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁<br>synchronized（S）VS lock（L）<br>）L 是接口，S 是关键字<br>2）S 在发生异常时，会自动释放线程占有的锁，不会发生死锁。L 在发生异常时，若没<br>有主动通过unlock（）释放锁，则很有可能造成死锁。所以用lock 时要在finally 中释放锁。<br>3)L 可以当等待锁的线程响应中断，而S 不行，使用S 时，等待的线程将会一直等下去，<br>不能响应中断。<br>4）通过L 可以知道是否成功获得锁，S 不可以。<br>5）L 可以提高多个线程进行读写操作的效率。<br>继承thread或者Runnable，调用run方法，start启动<br>sleep：暂时停止线程当前的操作<br>wait-把线程放入休息室<br>notify方法-从休息区拿出线程<br>notifyAll从线程区中拿出所有线程<br>Lock lock=new ReentrantLock();读写锁<br>ReadWriteLock rwLock=new ReentrantReadWriteLock()；读-读不互斥，读-写互斥，写-写互斥，并发性提高<br>CountDownLatch: 倒数计时器<br>ReenTrantLock ：公平锁：线程先来，先得到锁，可在构造函数中设置<br>join方法。该方法主要作用是在该线程中的run方法结束后，才往下执行<br>yield方法。这个是线程本身的调度方法，使用时你可以在run方法执行完毕时，调用该方法，告知你已可以出让内存资源。<br>关键字volatile 是轻量级的同步机制。<br>Volatile 变量对于all 线程的可见性，指当一条线程修改了这个变量的值，新值对于其他<br>线程来说是可见的、立即得知的。</p>
<h4 id="锁-可重入锁"><a href="#锁-可重入锁" class="headerlink" title="锁,可重入锁"></a>锁,可重入锁</h4><p>ReentrantLock支持两种获取锁的方式，一种是公平模型，一种是非公平模型</p>
<h4 id="tomcat集群"><a href="#tomcat集群" class="headerlink" title="tomcat集群"></a>tomcat集群</h4><p>集群配置session共享<br>tomcat本身有三种集群方式<br>DNS轮询：当集群中某台服务器停止之后，用户由于dns缓存的缘故，便无法访问服务，必须等到dns解析更新，或者这台服务器重新启动<br>Apache R-proxy<br>Apache mod_jk<br>主要采用nginx的负载均衡<br>五种方式upstream<br>1）轮询（默认），每个请求按时间顺序逐一分配到不同的后端服务器，如果后端<br>服务器down 掉，能自动剔除<br>2）指定权重，指定轮询几率。权重越大，轮询几率越大，用于后端服务器性能不均的情况<br>3）ip 绑定ip_path，每个请求按访问ip 的哈希结果分配，这样每个客户固定访问一个服务器，可以解决session 问题<br>4）fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配<br>5）url_hash 按访问的url 结果来分配请求，使每个url 定位到同一个后端服务器。后端服务器为缓存时比较有效<br>nginx还可以做<br>反向代理<br>文件服务器<br>静态资源<br>ssl配置</p>
<h4 id="Tomcat同步"><a href="#Tomcat同步" class="headerlink" title="Tomcat同步"></a>Tomcat同步</h4><p>集群增量会话管理器<br>这是一种全节点复制模式，全节点复制指的是集群中一个节点发生改变后会同步到其余全部节点，会在一个请求被响应之前同步到其余节点上</p>
<p>集群备份会话管理器<br>全节点复制模式存在的一个很大的问题就是用于备份的网络流量会随着节点数的增加而急速增加，这也就是无法构建较大规模集群的原因，每个会话只有一个备份。这样就可构建大规模的集群</p>
<h4 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h4><p>redis和普通缓存区别<br>cached：本质是一个内存key-value 数据库，但<br>不支持数据持久化，服务器关闭后，数据全丢失。只支持key-value 结构<br>Redis：将大部分数据放在内存中，支持的数据类型有：字符串、hash 表、链表、集合、<br>有序集合以及基于这些数据类型的相关操作。Redis 内部使用一个redisobject 对象来表示all<br>key 和value。<br>redis 支持数据备份，即master-slave 模式的备份<br>redis 支持数据的持久化，可以将内存中的数据保存在磁盘上，重启的时候可以再次加载进内存使用。<br>cached 挂掉后，数据不可以恢复，redis数据丢失后可通过AOF 恢复（灾难恢复）。<br>为什么需要NoSQL<br>1.对数据库高并发读写的需求<br>2.高负载-对海量数据的高效率存储和访问的需求<br>3.高扩展-对数据库的高可扩展性和高可用性的需求<br>主要应用在如下场景<br>1.缓存（数据查询、商品内容等等）<br>2.聊天室的在线好友列表<br>3.任务队列（秒杀、抢购等等）<br>4.应用排行榜<br>5.网站访问统计<br>6.数据过期处理<br>7.分布式集群架构中的session分离<br>redis持久化机制<br>快照（默认方式）<br>将内存中以快照的方式写入到二进制文件中，默认为dump.rdb，redis在n秒内如果超过m个key则修改就自动做快照<br>2.aof（日志方式）<br>由于快照方式是在一定时间间隔做一次，所以可能发生redis意外down的情况就会丢失最后一次快照后的所有修改的数据<br>三种修改方式<br>收到命令就立即写入到磁盘<br>每秒钟写入磁盘一次<br>完全依赖os性能<br>回收策略<br>1.最近最少使用<br>2.将要过期<br>3.任意选择数据<br>4.禁止驱逐数据<br>分布式锁<br>基本原理 : 用一个状态值表示锁，对锁的占用和释放通过状态值来标识。<br>redis+setnx实现?<br>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放<br>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？<br>同时把setnx和expire合成一条指令来用的<br>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？<br>使用keys指令可以扫出指定模式的key列表<br>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。<br>如果有大量的key需要设置同一时间过期，一般需要注意什么？<br>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。<br>redis其他功能<br>数据分片、分库<br>发布订阅<br>集群</p>
<h4 id="密码加密MD5"><a href="#密码加密MD5" class="headerlink" title="密码加密MD5"></a>密码加密MD5</h4><p>散列算法<br>该算法是一种不可逆的算法，如MD5，SHA等，一般该算法最好需要提供一个salt（盐）来增加破解难度，一般情况下的盐被设置为 密码+用户名+盐，这样只有系统知道盐值，更难被破解<br>md5有迭代次数<br>对称加解密base64和16进制字符串编码/解码<br>AES、Blowfish需要key<br>https<br>https 其实是由两部分组成：http+ssl/tls，也就是在http 上又加了一层处理加密信息的<br>模块，服务端和客户端的信息传输都会通过tls 加密，传输的数据都是加密后的数据<br>加解<br>密过程：<br>1）客户端发起https 请求（就是用户在浏览器里输入一个https 网址，然后连接到server<br>的443 端口）<br>2）服务端的配置（采用https 协议的服务器必须要有一塔数字证书，可以自己制作，<br>也可以向组织申请，这套证书就是一对公钥和私钥）。<br>3）传输证书（这个证书就是公钥，只是包含了很多信息）<br>4）客户端解析证书（由客户端tls 完成，首先验证公钥是否有效，若发现异常，则弹出<br>一个警示框，提示证书存在问题，若无问题，则生成一个随机值，然后用证书对随机值进行<br>加密）<br>5）传输加密信息（这里传输的是加密后的随机值，目的是让服务端得到这个随机值，<br>以后客户端和服务端的通信就可以通过这个随机值来进行加密了）<br>6）服务端解密信息（服务端用私钥解密后得到了客户端传来的随机值，then 把内容通<br>过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混在一起，这样除非<br>知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法<br>够彪悍，私钥够复杂，数据就够安全）<br>7）传输加密的信息<br>8）客户端解密信息，用随机数来解。</p>
<h4 id="酷家乐实习二面："><a href="#酷家乐实习二面：" class="headerlink" title="酷家乐实习二面："></a>酷家乐实习二面：</h4><p>1.自我介绍 </p>
<ol>
<li>N个红白蓝三种小球，乱序排在一起，两两交换，要求从左至右排序成红白蓝<br>这是经典的荷兰国旗问题，最经典的解法就是模拟快排，利用三个指针，begin，current，end解决，具体思路如下<br>1.当current为0时，交换current与begin对应的值，current、begin后移一位<br>2.当current为1时，begin不动，只是current后移一位<br>3.当current为2时，交换end与current对应的值，end前移一位<br>手撕代码<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private static void swap(int[] a,int i,int j)&#123;</div><div class="line">		int temp=a[i];</div><div class="line">		a[i]=a[j];</div><div class="line">		a[j]=temp;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void paritionYellowArray(int[] a)&#123;</div><div class="line">		int current=0;</div><div class="line">		int begin=0;</div><div class="line">		int end=a.length-1;</div><div class="line">		while(current&lt;end)&#123;</div><div class="line">			if(a[current]==1)&#123;</div><div class="line">				current++;</div><div class="line">			&#125;</div><div class="line">			else if(a[current]==0)&#123;</div><div class="line">				swap(a,begin,current);</div><div class="line">				begin++;</div><div class="line">				current++;</div><div class="line">			&#125;else&#123;</div><div class="line">				swap(a,current,end);</div><div class="line">				end--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>3.二维数组，行递增从左至右，列从上到下递增，给一个数，求出该数的位置<br>根据条件很容易知道要先选出一个角作为比较点，比如第一行最后一个，然后依次与值比较，比它小，在左边行，比它大，在下边列，依次类推<br>手撕代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public String Find(int target, int [][] array) &#123;</div><div class="line">       int rows=array.length;</div><div class="line">       int columns=array[0].length;</div><div class="line">       int row=0;</div><div class="line">       int column=columns-1;</div><div class="line">       while(row&lt;rows&amp;&amp;column&gt;=0)&#123;</div><div class="line">           if(array[row][column]==target)&#123;</div><div class="line">            break;</div><div class="line">           &#125;else if(array[row][column]&lt;=target)&#123;</div><div class="line">               row++;</div><div class="line">           &#125;else&#123;</div><div class="line">               column--;</div><div class="line">           &#125;</div><div class="line">           </div><div class="line">       &#125;</div><div class="line">       return row+""+","+column+"";</div><div class="line">       </div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h4 id="酷家乐实习终面"><a href="#酷家乐实习终面" class="headerlink" title="酷家乐实习终面"></a>酷家乐实习终面</h4><p>1.spring IOC<br>控制程序对象之间的关系，all类的创建，销毁都由spring来控制，也就是控制对象生命周期的不是引用他的对象，而是spring。对于某个对象而言，以前是他控制其他对象，现在是all对象都被spring控制，控制反转<br>依赖注入都过反射机制实现，在实例化一个类时，它通过反射反射调用类中的set方法将事先保存在hashmap中的类属性注入到类中</p>
<p>2.spring AOP<br>将那些与业务无关，却为业务模块所公用，称其为aspect，便于减少系统的重复代码<br>aop把软件系统分为两个部分<br>核心关注点和横切关注点<br>实现aop 的两大技术：1）采用动态代理，利用截取消息的方式，对该消息进行装饰，<br>以获取原有对象行为的执行。2）采用静态织入，引入特定的语法创建切面，从而可以使编<br>译器可在编译期间织入有关切面的代码。<br>JDK 动态代理，cglib 动态代理。<br>JDK 动态代理：其代理对象必须是某个接口的实现，他是通过在运行期间创建一个接口<br>的实现类来完成对目标对象的代理。核心类有：InnovactionHandler，Proxy。<br>Cgib 动态代理：实现原理类似于jdk 动态代理，只是他在运行期间生成的代理对象是针<br>对目标类扩展的子类。MethodInterceptor</p>
<p>3.hashmap<br>Map(映射)：集合中的每一个元素都包含一对键对象和值对象（key-value），集合中的键对象是不能重复的,它的一些实现类能对集合中的键对象进行排序。<br>不能重复与比较hashcode和equals有关<br>HashMap<br>底层实现是基于哈希表依赖于hashCode（）和equals（）方法，线程不安全，允许key和value为NULL，效率高<br> 有3个关键参数：<br>capacity：容量，就是数组大小<br>loadFactor：比例，用于扩容<br>threshold:=capacity*loadFactor   最多容纳的Entry数，如果当前元素个数多于这个就要扩容（capacity扩大为原来的2倍）</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>分段锁<br>把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。<br>在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;以下题目均来自牛客网大佬分享&lt;/p&gt;
&lt;h4 id=&quot;酷家乐实习一面&quot;&gt;&lt;a href=&quot;#酷家乐实习一面&quot; class=&quot;headerli
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>JVM总结</title>
    <link href="http://www.myzwl.win/2018/03/14/dream_1/"/>
    <id>http://www.myzwl.win/2018/03/14/dream_1/</id>
    <published>2018-03-14T07:48:51.000Z</published>
    <updated>2018-03-18T15:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="jvm有哪些分区"><a href="#jvm有哪些分区" class="headerlink" title="jvm有哪些分区"></a><a href="https://www.myzwl.win/2017/10/23/jvm_1/">jvm有哪些分区</a></h4><p>类加载子系统、方法区、java堆、java虚拟机栈、本地方法栈、程序计数器、执行引擎</p>
<h4 id="对象如何创建"><a href="#对象如何创建" class="headerlink" title="对象如何创建"></a>对象如何创建</h4><p>常量池中类符号引用<br>指针碰撞<br>把Java堆中的内存一分为二，一边是所有用过的内存（这部分内存不能被分配了），一边是空闲的内存，是可以被分配的，这样的话，在可用于不可用的内存之间会有一个分割点指示器，那么为对象分配内存实际上就是从这个分界点指示器往空闲内存的一边拨动一段空间就可以了</p>
<p>空闲列表<br>已使用的内存与空闲内存可能是交叉在一起的，那么使用指针碰撞的方式分配内存就会产生问题，但是虚拟机维护着一张列表，这张列表记录了哪些区域的内存是可用的，那么在分配内存的时候就从选择可以容纳对象要求大小的内存区域分配给这个对象</p>
<p>对象头设置一些必要信息，从虚拟机的角度看，一个对象已经构造完成，但是从开发人员的角度看，还需要进行new对象之后初始化，接着执行init方法，到这里一个对象才算真正创建完毕</p>
<h4 id="jvm的内存布局"><a href="#jvm的内存布局" class="headerlink" title="jvm的内存布局"></a>jvm的内存布局</h4><p>对象头、实例数据和对齐填充<br>对象头又包括两部分信息，第一部分用于存储对象自身的运行时数据，比如哈希码、GC分代年龄，第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</p>
<p>实例数据部分是对象真真好存储的有效信息，也是程序代码中所定义的各种类型的字段内容</p>
<p>第三部分不是必然存在的，只是起到占位符的作用，因为HotspotVM规定对象的起始地址必须是8字节的整数倍。所以很有可能以上两部分的大小不够8字节的整数倍，那么这个字段就可以发挥作用了。</p>
<h4 id="java如何进行对象访问"><a href="#java如何进行对象访问" class="headerlink" title="java如何进行对象访问"></a>java如何进行对象访问</h4><p>主要是通过Java栈中的reference数据，通过这个reference数据只是一个指向对象的引用，<br>目前主流的对象访问方式主要由句柄和直接指针两种<br>通过句柄访问的话，会在Java堆中划分出一块句柄池，句柄池中句柄存放了对象的实例数据和类型指针，而reference数据则存放了句柄的地址引用。使用直接指针访问对象，那么reference数据存放的就是对象的地址<br>使用句柄访问的最大好处是reference中存储的稳定的句柄地址，当对象的地址发生了改变可以不用去关心。而直接指针的最大好处是速度更快，在于节省了一次指针定位的时间</p>
<h4 id="OOM是啥，分析及解决"><a href="#OOM是啥，分析及解决" class="headerlink" title="OOM是啥，分析及解决"></a>OOM是啥，分析及解决</h4><p>内存泄露：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。<br>内存溢出：申请的内存超出了JVM能提供的内存大小，此时称之为溢出</p>
<p>java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，堆大小可以通过虚拟机参数-Xms,-Xmx等修改</p>
<p>java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</p>
<p>java.lang.StackOverflowError：一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小</p>
<h4 id="jvm堆内存情况"><a href="#jvm堆内存情况" class="headerlink" title="jvm堆内存情况"></a><a href="https://www.myzwl.win/2017/10/23/jvm_2/">jvm堆内存情况</a></h4><p>堆内存中主要分为年轻代和老年代,主要分为Eden（对象都会在该区域内创建）同时也会在s0或s1中随机一个进行创建，经过一次GC后在s0和s1中使用复制算法保留存活下来的对象<br>流程：年轻代:通过标记-复制-清除（15次GC，老年代）<br>老年区:通过标记-清除-整理进行垃圾回收，如果老年代内存不足就会触发FULL GC.默认是占用了68%后收集（可通过-XX:CMSInitiatingOccupancyFraction=68设置），该GC非常影响性能</p>
<h4 id="什么是可达性分析"><a href="#什么是可达性分析" class="headerlink" title="什么是可达性分析"></a>什么是可达性分析</h4><p>是通过一系列的称为“GC Roots”的对象作为起始点，从这些起始点开始向下搜索，所走过的路径称为引用链，如果一个对象到GC Roots没有任何引用链，那么这个对象是不可用的，就是说，程序中没有谁引用了这个对象，所以可以说从根节点到叶子结点是不可达的<br>虚拟机栈（栈帧中本地变量表）中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中JNI（也就是native本地方法）引用的对象</p>
<h4 id="为什么需要两次标记"><a href="#为什么需要两次标记" class="headerlink" title="为什么需要两次标记"></a>为什么需要两次标记</h4><p>原因是如果一个对象没有与GC Roots结点相连，就会被第一次标记，而如果对象覆盖了finalize方法，并且在finalize方法中与某个对象建立了引用关系，那么第二次标记会失败，那么这个对象就会被移出“即将回收”的对象列表，移出之后这个对象就“活”了下来，如果在finalize方法中这个对相关仍然没有与一个对象建立引用关系，那么这个对象就真正死亡了</p>
<h4 id="方法区中的什么对象可以被回收"><a href="#方法区中的什么对象可以被回收" class="headerlink" title="方法区中的什么对象可以被回收"></a>方法区中的什么对象可以被回收</h4><p>方法区中的永久代的垃圾回收主要为两部分： 废弃常量和无用的类<br>废弃常量是指没有任何对象引用常量池中的某个对象，那么这个对象就会被回收，而对于常量池中的垃圾回收只要进行一次标记就可以进行判断<br>无用的类需要满足以下三个条件才可以宣判一个类的“死刑”：<br>1.该类的所有实例都已经被回收，也就是Java堆中不存在该类的实例<br>2.加载该类的ClassLoader已经被回收<br>3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p>
<h4 id="jvm堆参数简单说明"><a href="#jvm堆参数简单说明" class="headerlink" title="jvm堆参数简单说明"></a>jvm堆参数简单说明</h4><p>-XX 对于系统级别的jvm配置 配置日志信息 垃圾回收器类型<br>非 -XX的 基本都是对 应用层面上的配置<br>    启用 - 禁用<br>    -XX :PrintGC 使用这个参数，虚拟机启动后，只要遇到GC就会打印日志<br>    -XX: +UserSerialGC 配置串行回收器<br>    -XX:+PrintGCDetails：可以查看详细信息，包括各个区的情况<br>    -Xms: 设置java程序启动时初始堆大小<br>    -Xmx: 设置java程序能获得的最大堆大小<br>    -Xloggc:路径 ：将打印出来的日志信息保存至指定的路径<br>    -Xmn：设置堆的内存大小<br>    -XX:SurvivorRatio=m:n调整Eden和Survivor的比例为m:n</p>
<h4 id="有哪些垃圾收集器"><a href="#有哪些垃圾收集器" class="headerlink" title="有哪些垃圾收集器"></a>有哪些垃圾收集器</h4><p>Serial收集器: 它是一种单线程垃圾收集器，这就意味着在其进行垃圾收集的时候需要暂停其他的线程</p>
<p>ParNew收集器: 为Serial收集器的多线程版本,能够与CMS收集器配合工作</p>
<p>Parallel Scavenge收集器:<br>其使用的算法是复制算法，也是并行的多线程收集器（所谓”并行”，就是指多条垃圾收集线程同时工作，但是用户仍处于等待状态)<br>更关注可控制的吞吐量，吞吐量等于运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)。</p>
<p>Serial Old收集器:<br>Parallel Old收集器<br>CMS收集器:获取最短回收停顿时间。在注重服务器的响应速度，希望停顿时间最短<br>G1收集器: G1收集器将Java堆划分为多个大小相等的Region（独立区域），新生代与老年代都是一部分Region的集合，G1的收集范围则是这一个个Region</p>
<h4 id="java类加载机制如何"><a href="#java类加载机制如何" class="headerlink" title="java类加载机制如何"></a><a href="https://www.myzwl.win/2017/07/31/reflaction_1/">java类加载机制如何</a></h4><p>1.并非一次性加载<br>2.需要的时候加载（运行期动态加载）<br>3.static语句块在加载后执行一次<br>4.dynamic语句块每次new新的对象都会执行（等同于构造方法中语句）</p>
<p>jdk中有各种各样的ClassLoad将类加载进内存<br>一：bootstrap class loader<br>它是最核心的类用于加载java中核心的类<br>二:extesion class loader<br>三:application class loader<br>也就是说它是java的核心类用于加载用户自定义的类和其他类<br>四:other class loaders<br>SecureClassLoader、URLClassLoader等等，该类是其他加载类加载其它类</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;jvm有哪些分区&quot;&gt;&lt;a href=&quot;#jvm有哪些分区&quot; class=&quot;headerlink&quot; title=&quot;jvm有哪些分区&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.myzwl.win/2017/10/23/jvm_1/&quot;&gt;jvm有哪些分区&lt;/a&gt;
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>Java并发总结</title>
    <link href="http://www.myzwl.win/2018/03/14/dream_2/"/>
    <id>http://www.myzwl.win/2018/03/14/dream_2/</id>
    <published>2018-03-14T04:48:51.000Z</published>
    <updated>2018-03-18T15:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="描述一下线程池ThreadPoolExecutor"><a href="#描述一下线程池ThreadPoolExecutor" class="headerlink" title="描述一下线程池ThreadPoolExecutor"></a>描述一下线程池ThreadPoolExecutor</h4><p>corepoolsize：核心池的大小，默认情况下，在创建了线程池之后，线程池中线程数为0，<br>当有任务来之后，就会创建一个线程去执行任务，当线程池中线程数达到corepoolsize 后，<br>就把任务放在任务缓存队列中。<br>Maximumpoolsize:线程池中最多创建多少个线程。<br>Keeplivetime：线程没有任务执行时，最多保存多久的时间会终止，默认情况下，当线程<br>池中线程数&gt;corepoolsize 时，Keeplivetime 才起作用，直到线程数不大于corepoolsize。<br>workQueue:阻塞队列，用来存放等待被执行的任务<br>threadFactory:线程工厂，用来创建线程。</p>
<p>继承关系<br>Executor 接口<br>ExecutoServicer 接口<br>AbstractExecutoServicer 抽象类<br>ThreadPoolExecutor</p>
<p>线程池的状态<br>1.当线程池创建后，初始为running 状态<br>2.调用shutdown 方法后，处shutdown 状态，此时不再接受新的任务，等待已有的任务执<br>行完毕<br>3.调用shutdownnow 方法后，进入stop 状态，不再接受新的任务，并且会尝试终止正在<br>执行的任务。<br>4.当处于shotdown 或stop 状态，并且所有工作线程已经销毁，任务缓存队列已清空，线<br>程池被设为terminated 状态</p>
<p>当有任务提交到线程池之后的一些操作：<br>1.若当前线程池中线程数&lt;corepoolsize，则每来一个任务就创建一个线程去执行。</p>
<ol>
<li>若当前线程池中线程数&gt;=corepoolsize，会尝试将任务添加到任务缓存队列中去，若添<br>加成功，则任务会等待空闲线程将其取出执行，若添加失败，则尝试创建线程去执行这个任<br>务。</li>
<li>若当前线程池中线程数&gt;= Maximumpoolsize，则采取拒绝策略（有4 种，1）abortpolicy 丢<br>弃任务，抛出RejectedExecutionException 2 ）discardpolicy 拒绝执行，不抛异常3 ）<br>discardoldestpolicy 丢弃任务缓存队列中最老的任务，并且尝试重新提交新的任务4）<br>callerrunspolicy 有反馈机制，使任务提交的速度变慢）。</li>
</ol>
<h4 id="什么是死锁，手撕代码模拟"><a href="#什么是死锁，手撕代码模拟" class="headerlink" title="什么是死锁，手撕代码模拟"></a>什么是死锁，手撕代码模拟</h4><p>如哲学家进餐问题，每个哲学家都在等右边哲学家方上筷子，处于僵持等待状态，称为死锁。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class LockTest implements Runnable&#123;</div><div class="line">	public int flag=1;</div><div class="line">	 static Object o1=new Object(),o2=new Object();</div><div class="line">	   </div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println("flag="+flag);</div><div class="line">		 if(flag==1)&#123;</div><div class="line">		 synchronized (o1) &#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(5000);</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			synchronized (o2) &#123;</div><div class="line">				System.out.println("1");</div><div class="line">			&#125;</div><div class="line">		 &#125;	 </div><div class="line">		&#125;</div><div class="line">		if(flag==0)&#123;</div><div class="line">			 synchronized (o2) &#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(5000);</div><div class="line">					&#125; catch (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					synchronized (o1) &#123;</div><div class="line">						System.out.println("0");</div><div class="line">					&#125;</div><div class="line">				 &#125;	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LockTest lt1=new LockTest();</div><div class="line">		LockTest lt2=new LockTest();</div><div class="line">		 lt1.flag=1;</div><div class="line">		 lt2.flag=0;</div><div class="line">		  Thread t1=new Thread(lt1);</div><div class="line">		  Thread t2=new Thread(lt2);</div><div class="line">		  t1.start();</div><div class="line">		  t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="手撕模拟生产者"><a href="#手撕模拟生产者" class="headerlink" title="手撕模拟生产者"></a>手撕模拟生产者</h4><p>模拟一个生产者利用生产食物放到篮子里，而一个消费者从篮子里消费食物<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">public class Food &#123; //食物类</div><div class="line"> int id;</div><div class="line"> public Food(int id)&#123;</div><div class="line">	 this.id=id;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">public class UtilStack &#123;//工具，用来放食物</div><div class="line">	int index=0; //食物计数变量</div><div class="line">	Food[] arrFD=new Food[4]; //最多工具能放食物容量</div><div class="line">	</div><div class="line">	public synchronized void push(Food fd)&#123; //生产食物，必须加锁，保证生产过程不被打断</div><div class="line">		while(index==arrFD.length)</div><div class="line">		&#123;</div><div class="line">			try &#123;</div><div class="line">				System.out.println("full");</div><div class="line">				this.wait();  //生产满了，就去休息区休息，等待被唤醒</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		this.notify();//唤醒当前在休息区的线程</div><div class="line">		arrFD[index]=fd;</div><div class="line">		index++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public synchronized Food pop()&#123; //消费</div><div class="line">		while(index==0) //消费完了，进休息区</div><div class="line">			try &#123;</div><div class="line">				System.out.println("empty");</div><div class="line">				this.wait();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		this.notify();</div><div class="line">		index--;</div><div class="line">		return arrFD[index];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Producer implements Runnable&#123;//生产者</div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Producer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=new Food(i);</div><div class="line">			ss.push(fd);</div><div class="line">			System.out.println("生产了"+fd.id);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(1000);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Consumer implements Runnable&#123;//消费者</div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Consumer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=ss.pop();</div><div class="line">			System.out.println("消费了"+fd.id);</div><div class="line">		 try &#123;</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="线程的状态是什么"><a href="#线程的状态是什么" class="headerlink" title="线程的状态是什么"></a>线程的状态是什么</h4><p>在任意一个时间点，一个线程只能有且只有其中的一种状态<br>1）新建：创建后尚未启动的线程处于这种状态。<br>2）运行：包括了OS 中Running 和Ready 状态，也就是处于次状态的线程可能正在运行，<br>也可能正在等待cpu 为他分配执行时间。<br>3）无限期等待:处于这种状态的线程不会被分配cpu 执行时间，要等待其他线程显示唤<br>醒。以下方法会让线程进入无限期等待：1.没有设置timeout 的object.wait()方法2.没有设<br>置timeout 参数的Thread.join()方法3.LockSupport.park();<br>4）有限期的等待：处于这种状态的线程也不会被分配cpu 执行时间，不过无需等待被<br>其他线程显示唤醒，而是在一定时间后，他们会由os 自动唤醒1.设置了timeout 的<br>object.wait() 方法2. 设置了timeout 参数的Thread.join() 3.LockSupport.parkNanos()<br>4.LockSupport.parkUnit()<br>5）阻塞：线程被阻塞了与“等待状态”的区别是：阻塞状态在等待获取一个排它锁，<br>这个事件将在另外一个线程放弃这个锁的时候发生。等待状态在等待一段时间或者唤醒动<br>作。<br>6）结束：已终止线程的线程状态，线程已经结束执行</p>
<h4 id="synchronized（S）VS-lock（L）"><a href="#synchronized（S）VS-lock（L）" class="headerlink" title="synchronized（S）VS lock（L）"></a>synchronized（S）VS lock（L）</h4><p>1）L 是接口，S 是关键字<br>2）S 在发生异常时，会自动释放线程占有的锁，不会发生死锁。L 在发生异常时，若没<br>有主动通过unlock（）释放锁，则很有可能造成死锁。所以用lock 时要在finally 中释放锁。<br>3)L 可以当等待锁的线程响应中断，而S 不行，使用S 时，等待的线程将会一直等下去，<br>不能响应中断。<br>4）通过L 可以知道是否成功获得锁，S 不可以。<br>5）L 可以提高多个线程进行读写操作的效率。</p>
<h4 id="简单并发中方法总结"><a href="#简单并发中方法总结" class="headerlink" title="简单并发中方法总结"></a>简单并发中方法总结</h4><p>继承thread或者Runnable，调用run方法，start启动<br>sleep：暂时停止线程当前的操作<br>wait-把线程放入休息室<br>notify方法-从休息区拿出线程<br>notifyAll从线程区中拿出所有线程<br>Lock lock=new ReentrantLock();读写锁<br>ReadWriteLock rwLock=new ReentrantReadWriteLock()；读-读不互斥，读-写互斥，写-写互斥，并发性提高<br>CountDownLatch: 倒数计时器<br>ReenTrantLock ：公平锁：线程先来，先得到锁，可在构造函数中设置<br>join方法。该方法主要作用是在该线程中的run方法结束后，才往下执行<br>yield方法。这个是线程本身的调度方法，使用时你可以在run方法执行完毕时，调用该方法，告知你已可以出让内存资源。<br>关键字volatile 是轻量级的同步机制。<br>Volatile 变量对于all 线程的可见性，指当一条线程修改了这个变量的值，新值对于其他<br>线程来说是可见的、立即得知的。</p>
<h4 id="什么是同步与公平锁"><a href="#什么是同步与公平锁" class="headerlink" title="什么是同步与公平锁"></a>什么是同步与公平锁</h4><p>同步：多个线程并发访问共享数据时，保证共享数据在同一个时刻，只被一个（or 一<br>些，使用信号量）线程使用，而互斥是实现同步的一种手段，临界区，互斥量，信号量都是<br>主要的互斥实现方式。互斥是因，同步是果；互斥是方法，同步是目的</p>
<p>公平锁：（先申请先得到）多个线程在等待同一个锁时，必须按照申请锁的时间顺序<br>来依次获取，而非公平锁则不保证这一点。Synchronized 不是公平锁，reetrantlock 默认下也<br>是非公平的，但是在构造函数中，可以设置为公平的。</p>
<h4 id="描述一下java自带的锁机制"><a href="#描述一下java自带的锁机制" class="headerlink" title="描述一下java自带的锁机制"></a>描述一下java自带的锁机制</h4><p>在java 设计中，每一个对象自打娘胎里出来就带了一把看不见的锁，即monitor 锁,有一张记录表记录线程锁住状况，<br>锁主要有4 中状态：无锁状态、偏向状态、轻量级状态、重量级状态。他们会随着竞争<br>的激烈而逐渐升级，锁可以升级但不可以降级<br>轻量级锁：传统的锁是重量级锁，他是用系统的互斥量来实现。轻量级锁的本意是在没<br>有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗<br>Synchronized 用的锁时存在java 对象头里。对象头包含标记字段和类型指针<br>JVM 可以通过对象的元数据信息确定对象的大小，但是无法从数组的元数据来确定数组<br>的大小</p>
<h4 id="乐观锁VS-悲观锁"><a href="#乐观锁VS-悲观锁" class="headerlink" title="乐观锁VS 悲观锁"></a>乐观锁VS 悲观锁</h4><p>悲观锁：就是很悲观，每次去拿数据的时候都认为别人会修改，<br>所以每次在拿数据的时候都会上锁。这样别人想拿这个数据就会block 直到它拿到锁。传统<br>的关系型数据库就用到了很多这种机制，比如行锁，写锁等，都是在操作之前上锁<br>2）乐观锁：就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新<br>的时候会判断一下在此期间别人有没有去更新这个数据。适用于多读</p>
<h4 id="解释一下同步阻塞，异步等"><a href="#解释一下同步阻塞，异步等" class="headerlink" title="解释一下同步阻塞，异步等"></a>解释一下同步阻塞，异步等</h4><p>同步阻塞，用户空间的应用程序执行一个系统调用，这意味着应用程序会一直阻塞，直<br>到系统调用完成为止（数据传输完成或者发生错误）<br>同步非阻塞，设备以非阻塞形式打开，这意味着io 操作不会立刻完成，需要应用程序<br>调用多次来等待完成<br>同步和异步1）同步：发出一个调用时，在没有得到结果前，该调用就不返回，一旦返<br>回就有结果。2）异步：调用在发出之后就直接返回，所以没有返回结果，换句话说，当一<br>个异步调用发生后，调用者不会立即得到结果，而是在调用发生后，被调用者通过状态通知<br>来通知调用者，或者通过回调函数来处理这个调用<br>阻塞和非阻塞1）阻塞：调用结果返回之前，当前线程会被挂起，调用线程只有在得到<br>结果之后才会返回。2）非阻塞：不能立刻得到结果之前，该调用不会阻塞当前线程</p>
<p>BIO：同步并阻塞，一个连接一个线程，适用于链接数量小且固定的架构。<br>NIO：同步非阻塞：一个请求一个线程，客户端发送的链接请求都会注册到多路复用器<br>上，多路复用器轮训到链接有io 请求时才启动一个线程进行处理，适用于链接比较多，比<br>较短<br>AIO：异步非阻塞，一个有效请求一个线程，适用于链接数目多且长。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;描述一下线程池ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#描述一下线程池ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;描述一下线程池ThreadPoolExecutor&quot;&gt;&lt;/a&gt;描述一下线程池Thre
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>设计模式总结</title>
    <link href="http://www.myzwl.win/2018/03/14/dream_3/"/>
    <id>http://www.myzwl.win/2018/03/14/dream_3/</id>
    <published>2018-03-14T02:48:51.000Z</published>
    <updated>2018-03-18T15:48:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说说ioc与aop"><a href="#说说ioc与aop" class="headerlink" title="说说ioc与aop"></a>说说ioc与aop</h4><p>IOC 控制反转容器控制程序对象之间的关系，而不是传统实现中，有程序代码之间控制，<br>又名依赖注入。All 类的创建，销毁都由Spring 来控制，也就是说控制对象生命周期的不是<br>引用他的对象，而是Spring。对于某个对象而言，以前是他控制其他对象，现在是all 对象<br>都被spring 控制，这就叫控制反转<br>依赖注入的思想时通过反射机制实现的。在实例化一个类时，它通过反射调用类中的set<br>方法将事先保存在hashmap 中的类属性注入到类中<br>Spring 实现aop：<br>将那些与业务无关，却为业务模块所公共调用的逻辑或责任封装起来，称其<br>为aspect，便于减少系统的重复代码。使用模块技术，aop 把软件系统分为两个部分：核心<br>关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注<br>点。实现aop 的两大技术：1）采用动态代理，利用截取消息的方式，对该消息进行装饰，<br>以获取原有对象行为的执行。2）采用静态织入，引入特定的语法创建切面，从而可以使编<br>译器可在编译期间织入有关切面的代码。<br>JDK 动态代理，cglib 动态代理。<br>JDK 动态代理：其代理对象必须是某个接口的实现，他是通过在运行期间创建一个接口<br>的实现类来完成对目标对象的代理。核心类有：InnovactionHandler，Proxy。<br>Cgib 动态代理：实现原理类似于jdk 动态代理，只是他在运行期间生成的代理对象是针<br>对目标类扩展的子类。MethodInterceptor</p>
<h4 id="说说代理模式"><a href="#说说代理模式" class="headerlink" title="说说代理模式"></a><a href="https://www.myzwl.win/2017/03/14/dyproxy3/">说说代理模式</a></h4><p>静态代理与继承代理<br>动态代理，javac和反射取出动态类<br>反射<br>1）proxy 类：<br>类的静态方法用来生成动态代理的实例<br>2）innovationhandler 接口有一个invoke 方法，用来<br>集中处理在动态代理类对象的方法调用，通常在该方法中实现对委托类的代理访问，每次生<br>成动态代理对象时都要指定一个对应的调用处理器<br>CGlib 动态代理：jdk 代理机制只能代理<br>实现了接口的类，而没有实现接口的类不能用jdk 动态代理。CGlib 是针对类来实现代理，<br>他的原理是对指定的目标类生成一个子类，并且覆盖其中方法实现增强，因为采用的是继承，<br>所以不能对final 修饰的类进行代理，methodinterceptor </p>
<h4 id="代理模式和装饰模式的区别？"><a href="#代理模式和装饰模式的区别？" class="headerlink" title="代理模式和装饰模式的区别？"></a>代理模式和装饰模式的区别？</h4><p>代理是<br>在内部生成一个代理对象，构造函数参数为空。装饰的构造函数参数有一个对象，就是对这<br>个对象进行装饰。</p>
<h4 id="jdk-中的设计模式："><a href="#jdk-中的设计模式：" class="headerlink" title="jdk 中的设计模式："></a>jdk 中的设计模式：</h4><p>1）单例，比如Runtime 类；<br>2）静态工厂Interger a=Integer.valueOf(intor String);<br>3) 迭代器模式Collection.interator();<br>4) 原型设计模式,clone 方法；<br>5 ）适配器 inputStreamReader 和outputStreamWriter；<br>6）桥接模式，jdbc，抽象部分与实现相分离；<br>7）装饰模式Reader 和bufferedBeader；<br>8）代理，jdk 动态代理；<br>9）观察者observable 和observer；<br>10）责任链，classloader 的双亲委派模型；<br>11 ）组合，某个类型的方法同时也接收自身类型作为参数<br>java.util.list.addall(collection);<br>12)抽象工厂，一个创建新对象的方法，返回的是接口或抽象类<br>Connection c=DriverManager.getConnection();<br>13) 工厂方法，返回一个具体对象的方法Proxy.newProxyInstance;<br>14)解释器模式，该模式通常定义了一个语言的语法,java.util.pattern</p>
<h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a><a href="https://www.myzwl.win/2017/02/23/danli/">单例设计模式</a></h4><p>饿汉式、懒汉式<br>双锁机制<br>public static Singleton getInstance()<br> {<br>     if(singleton==null)<br>     {<br>         synchronized(Singleton.class)<br>         {<br>     if(singleton==null){<br>         singleton=new Singleton();<br>     }<br>         }<br>     }<br>     return singleton;<br> }</p>
<h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><a href="https://www.myzwl.win/2017/03/08/simplefactory/">简单工厂</a></h4><p> 数据库模型</p>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><a href="https://www.myzwl.win/2017/03/09/factory/">工厂方法</a></h4><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><a href="https://www.myzwl.win/2017/03/10/abstractfactory/">抽象工厂</a></h4><h4 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a><a href="https://www.myzwl.win/2017/03/10/observer/">观察者设计模式</a></h4><p> 推模型，也就是被观察者根据状态发生改变时将所有信息都主动通知观察者<br> 拉模型，即观察者主动向被观察者索要信息<br> 观察者模式应用场景<br>1、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变<br>2、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节</p>
<h4 id="职责链设计模式"><a href="#职责链设计模式" class="headerlink" title="职责链设计模式 "></a><a href="https://www.myzwl.win/2017/03/07/filter/">职责链设计模式 </a></h4><p>模拟过滤器</p>
<h4 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a><a href="https://www.myzwl.win/2017/03/06/iterator/">迭代器设计模式</a></h4><p>模拟集合Iterator</p>
<h4 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h4><p>开闭原则：一个软件实体应当对开展开放，对修改关闭（玉帝招安美猴王）<br>面向对象解释： 不予以更改的是抽象层，但是可以扩展的是实现层<br>对可变性的封装原则： 找到一个系统的可变因素，将之封装起来<br>里氏代换原则： 任何基类可以出现的地方，子类一定可以出现<br>依赖倒转原则： 要依赖于抽象，不要依赖于实现<br>接口隔离原则： 应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说说ioc与aop&quot;&gt;&lt;a href=&quot;#说说ioc与aop&quot; class=&quot;headerlink&quot; title=&quot;说说ioc与aop&quot;&gt;&lt;/a&gt;说说ioc与aop&lt;/h4&gt;&lt;p&gt;IOC 控制反转容器控制程序对象之间的关系，而不是传统实现中，有程序代码之间控制，&lt;
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>数据库总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_4/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_4/</id>
    <published>2018-03-13T11:48:51.000Z</published>
    <updated>2018-03-21T08:17:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="mysql-使用的引擎"><a href="#mysql-使用的引擎" class="headerlink" title="mysql 使用的引擎"></a>mysql 使用的引擎</h4><p>A:1)MyIsam 不支持事务，适用于选择密集型，插入密集型，mysql 默认的引擎<br>2)innodb 使用于更新密集型，支持事务，自动灾难恢复，行级锁，外键约束<br>3）memory 出发点是速度采用的逻辑存储介质是内存<br>4）merge 一组myisam 表的组合</p>
<h4 id="mysql-索引使用的是B-的数据结构"><a href="#mysql-索引使用的是B-的数据结构" class="headerlink" title="mysql 索引使用的是B+的数据结构"></a>mysql 索引使用的是B+的数据结构</h4><p>索引：用于提高数据访问速度的数据库对象。<br>优点：1）索引可以避免全表扫描；<br>2）对于非聚集索引，有些查询甚至可以不访问数据项；<br>3）聚集索引可以避免数据插入操作集中于表的最后一个数据页；<br>4）一些情况下，索引还可以避免排序。<br>虽然索引可以提高查询速度，但是他们也会导致数据库更新数据的性能下降，因为大部<br>分数据更新时需要同时更新索引。</p>
<h4 id="连接关联"><a href="#连接关联" class="headerlink" title="连接关联"></a>连接关联</h4><p>A 的id 和b 的parent_id 关联<br>1）内连接<br>Select a.<em>,b.</em>from a inner join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>2）左外链接（左表all 元素都有）<br>Select a.<em>,b.</em>from a left join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>3 王五null<br>3）右外链接（右表all 元素都有）<br>Select a.<em>,b.</em>from a right join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>Null 3 34 2<br>4）完全链接（返回左边和右表中所有行，若某行在另外一个表中无匹配，则另一表的<br>选择列表列包含空值）<br>Select a.<em>,b.</em>from a full join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>Null 3 34 2<br>3 王五null<br>Not in 的例子：<br>Select emp_no from emplyees where emp_no not in (select emp_no from dept_manager)</p>
<h4 id="共享锁VS-排他锁"><a href="#共享锁VS-排他锁" class="headerlink" title="共享锁VS 排他锁"></a>共享锁VS 排他锁</h4><p>1）共享锁，<br>又称读锁，若事务T 对数据对象A 加了S 锁，则是事务T 可以读A 但不能修改A，其它事务只能再对他加S 锁，而不能加X 锁，直到T 释放A 上的S 锁。这保证了其他事务可以读A，但在事务T 释放S 锁之前，不能对A 做任何操作<br>2）排他锁，<br>又称写锁，若事务T 对数据对象加X 锁，事务T 可以读A 也可以修改A，其他事务<br>不能对A 加任何锁，直到T 释放A 上的锁。这保证了，其他事务在T 释放A 上的锁之前不<br>能再读取和修改A。</p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>Serializable(串行化)：一个事务在执行过程中完全看不到其他事务对数据库所做的更新。<br>Repeatable Read(可重复读)：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务对已有记录的更新。<br>Read Commited（读已提交数据）：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的对已有记录的更新<br>Read Uncomitted（读未提交数据）：一个事务在执行过程中可以拷打其他事务没有提交的新插入的记录，而且能看到其他事务没有提交的对已有记录的更新。</p>
<h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>回答思路：事务是干什么的&gt;事务的ACID特性&gt;事务的隔离级别<br>事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取。事务的正确执行使得数据库从一种状态转换成另一种状态<br>原子性、隔离性、持久性<br>脏读：一个事务读到另一个事务为提交的更新数据。<br>虚读：一个事务读到另一个事务已提交的新插入的数据。<br>不可重复读：一个事务读到另一个事务已提交的更新数据</p>
<h4 id="数据库设计三范式是什么"><a href="#数据库设计三范式是什么" class="headerlink" title="数据库设计三范式是什么"></a>数据库设计三范式是什么</h4><p>第一范式：字段还可以再分吗？如过不能，则是符合1NF的设计。<br>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>也就是说主键列与非主键列遵循完全函数依赖关系<br>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。<br>也就是说非主键列之间没有传递函数依赖关系<br>打个比方，比如评论表，如果你将用户ID，用户头像都放在这留言表中，就是不合适的了。用户头像是依赖于用户ID，而不依赖该评论。</p>
<h4 id="悲观锁和乐观锁的比较"><a href="#悲观锁和乐观锁的比较" class="headerlink" title="悲观锁和乐观锁的比较"></a>悲观锁和乐观锁的比较</h4><p>面试思路：什么是锁，用来干什么&gt;悲观锁乐观锁各自特点&gt;优缺点比较和各自应用场景<br>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。<br>悲观锁:<br>简单来说悲观锁认什么操作都可以改变数据，所以在改数据就锁住（在sql语句中加上for update就可以了）<br>乐观锁：<br>简单来说乐观锁很乐观 所以修改数据库后锁住 （一般在数据库中加上一个字段区别历史版本和当前版本）<br>update t_goods<br>set status=2,version=version+1<br>where id=#{id} and version=#{version};<br>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<h4 id="mysql实现分页的优化sql语句"><a href="#mysql实现分页的优化sql语句" class="headerlink" title="mysql实现分页的优化sql语句"></a>mysql实现分页的优化sql语句</h4><p>面试思路：数据库分页的简单实现&gt;数据量变大时的优化方案<br>sql语句是LIMIT m,n其中m是当前页，n是从当前页数n个记录，如果参数为一个就是数n个记录<br>一般我们都会这样写:当数据达到百万级的时候会慢死<br>    SELECT FROM table ORDER BY id LIMIT 1000000, 10;<br>    优化一：<br>    SELECT FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10;<br>    速度可以提升到0.x秒了<br>    优化二：<br>    SELECT FROM table WHERE id BETWEEN 1000000 AND 1000010;<br>    比上面提升5到10倍<br>    另外，如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询<br>    SELECT FROM table WHERE id IN(10000, 100000, 1000000…);</p>
<h4 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h4><p>1)对查询进行优化，要尽量避免全表扫描。在where 或order by 的列上加索<br>引。<br>2）尽量避免在where 子语句中有where num is null，这样不用索引，要全表扫描，可<br>用0 代替null。<br>3）避免在where 中用&lt;&gt;or!=,因为要全表扫描。<br>4）尽量避免在where 中用or，因为若一个字段有索引，一个没有，则要全表扫描。<br>5）like”%abc%”，全表扫描。<br>6）避免在where 子语句中对字段进行函数操作，因为要全表扫描。<br>7）使用复合索引时，必须用到该索引的第一个字段，否则索引不被使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;mysql-使用的引擎&quot;&gt;&lt;a href=&quot;#mysql-使用的引擎&quot; class=&quot;headerlink&quot; title=&quot;mysql 使用的引擎&quot;&gt;&lt;/a&gt;mysql 使用的引擎&lt;/h4&gt;&lt;p&gt;A:1)MyIsam 不支持事务，适用于选择密集型，插入密集型，my
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_5/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_5/</id>
    <published>2018-03-13T08:48:51.000Z</published>
    <updated>2018-03-21T08:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线性表之顺序表"><a href="#线性表之顺序表" class="headerlink" title="线性表之顺序表"></a><a href="https://www.myzwl.win/2017/07/08/sjjg_1/">线性表之顺序表</a></h4><p>数组是顺序存储的随机存取结构，占用一组连续的存储单元，通过下标识别元素，元素地址是下标的线性函数，一个下标能唯一确定一个元素<br>模拟ArrayList</p>
<h4 id="线性表之单链表"><a href="#线性表之单链表" class="headerlink" title="线性表之单链表 "></a><a href="https://www.myzwl.win/2017/07/08/sjjg_2/">线性表之单链表 </a></h4><p>线性表的链式存储是用若干地址分散的存储单元存储数据元素，逻辑上相连的数据元素在物理位置上不一定相连，必须采用附加信息表示数据元素之间的关系，并且存储单元至少包含两部分-数据域和地址域<br>单链表中结点只有一个地址并且指向后继结点<br>模拟SinglyLinkenList</p>
<h4 id="线性表之双链表"><a href="#线性表之双链表" class="headerlink" title="线性表之双链表"></a><a href="https://www.myzwl.win/2017/07/08/sjjg_3/">线性表之双链表</a></h4><p>双链表的每个结点有两个地址域，分别指向它的前驱结点和后继结点</p>
<h4 id="串之字符串"><a href="#串之字符串" class="headerlink" title="串之字符串 "></a><a href="https://www.myzwl.win/2017/07/09/sjjg_4/">串之字符串 </a></h4><p>串是由n(n&gt;=0)个字符组成的有限序列，它是一种特殊的线性表。而子串是指串s中任意连续字符组成的一个子序列组成的串。同时，串的比较通常由其字符编码的相关规则比较</p>
<p>常量字符串String<br>字符串采用字符数组作为存储结构，并且采用顺序存储结构，不过String类一次性申请了固定的空间，同时由于其存储结构为最终型，所以string不提供删除，插入子串<br>变量字符串StringBuffer<br>该字符数组的容量总是大于串长，并且能够修改</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a><a href="https://www.myzwl.win/2017/07/10/sjjg_5/">栈</a></h4><p>栈是一种特殊的线性表，其特殊之处在于插入和删除操作的位置受到限制，而且插入和删除只允许在线性表的一端进行，特点是后进先出<br>顺序栈、链式栈</p>
<h4 id="顺序与链式队列"><a href="#顺序与链式队列" class="headerlink" title="顺序与链式队列"></a><a href="https://www.myzwl.win/2017/07/11/sjjg_6/">顺序与链式队列</a></h4><p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行。特点是先进先出。<br>顺序队列使用数组存储数据元素<br>1.当队列空时，设置队头、队尾下标front=rear=-1，<br>2.当第一个元素入队时，front=rear=0，同时改变两个下标<br>3.进行入队、出队操作，front、rear随之变化<br>4.当入队的元素个数（包括已出队元素）超出数组容量时，rear下标越界，数据溢出，但是，由于之前已有若干元素出队，数组前部以空出许多存储单元，所以这种溢出并不是因为存储空间不够而产生的，称为假溢出<br>所以顺序队列有两个缺点：假溢出和存储单元没有重复使用机制<br>顺序循环队列<br>相比较顺序队列，有如下不同<br>1.队头、队尾元素按照如下循环规律变化，其中length表示数组长度<br>front=（front+1)%length;<br>rear=(rear+1)%length;<br>所以可以看出front和rear的取值范围为0~length-1<br>链式队列</p>
<h4 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a><a href="https://www.myzwl.win/2017/07/14/sjjg_8/">树和二叉树</a></h4><p>基本术语<br>孩子优先遍历<br>兄弟优先遍历<br>完全二叉树和满二叉树<br>顺序与链式存储<br>模拟二叉树类</p>
<h4 id="hash散列表"><a href="#hash散列表" class="headerlink" title="hash散列表 "></a><a href="https://www.myzwl.win/2017/07/14/sjjg_9/">hash散列表 </a></h4><p>散列（hash）表是一种支持高效的查找、插入和删除操作的数据结构，它是针对查找效率接近O（1）而专门设计的。它根据元素的关键字确定元素的存储位置，而其中主要解决两个问题，设计散列函数和处理冲突<br>散列函数实质上是关键字集合到地址集合的映射，如果这种映射是一一对应的，则查找效率是O（1），但是由于散列表是一个压缩映射，即存储容量有限，即映射关系是多对一的映射，所以会产生冲突<br>除留余数法<br>该散列函数定义为hash（k）=k%p，函数结果范围为0~p-1，图示就是采用这种方法，而p取值为小于散列表长度的最大素数，如散列表长度分别为8,16,128，则对应的p（最大素数）分别为7,13,127<br>开放定址法<br>链地址法<br>模拟HashSet类</p>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a><a href="https://www.myzwl.win/2017/07/27/BSTSort_1/">二叉排序树</a></h4><p>原理<br>AVL树</p>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a><a href="https://www.myzwl.win/2017/07/30/huffman_1/">哈夫曼树</a></h4><p>基本术语<br>哈弗曼编码<br>压缩与解压原理</p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a><a href="https://www.myzwl.win/2017/08/01/graph_2/">图</a></h4><p>基本术语<br>邻接矩阵<br>深度（先序）<br>广度（层序）</p>
<h4 id="集合简单总结"><a href="#集合简单总结" class="headerlink" title="集合简单总结"></a>集合简单总结</h4><p>java集合主要分为以下三种类型：<br>Set(集)：集合中的对象不按特定方式排序，且没有重复对象。它的有些实现类能对集合中的对象按照特地方式排序。<br>List(列表)：集合中的对象按照索引位置排序，可以有重复对象，允许使用索引检索对象。<br>Map(映射)：集合中的每一个元素都包含一对键对象和值对象（key-value），集合中的键对象是不能重复的,它的一些实现类能对集合中的键对象进行排序。<br>注意这里的不能重复与比较hashcode和equals有关</p>
<p>Collection接口<br>Collection接口是Set、List、Queue接口的父接口，提供了多数集合常用的方法声明，包括 add()、remove()、contains() 、size() 、iterator() 等</p>
<p>List接口<br>它的特点是有序可重复，使用此接口能够精确的控制每个元素插入的位置用户能够使用索引来访问List中的元素并且允许有可重复的元素</p>
<p>ArrayList<br>底层实现是一个动态的数组，查询快，增删慢，线程不安全，效率高</p>
<p>LinkedList<br>底层实现是一个双向循环链表，查询慢，增删快，线程不安全，效率较高</p>
<p>Vector<br>是ArrlyList的线程安全版，底层同它基本一致，但是效率低，现在基本很少</p>
<p>Set接口<br>它的特点就是唯一性并且不允许出现重复元素和是无序的</p>
<p>hashSet<br>底层是基于哈希表实现的，而其核心就是先比较hashCode（）值是否相同（相当于索引），然后在用equals比较是否相同，从而确定元素是否重复，所以当不希望集合中有重复值，并且不关心元素之间的顺序时可以使用此类</p>
<p>LinkedHashSet<br>底层实现是使用链表和哈希表，它由链表保证元素有序，哈希表保证元素唯一，因此当不希望集合中有重复值，并且希望按照元素的插入顺序进行迭代遍历时可采用此类</p>
<p>TreeSet<br>底层实现是红黑树，也就是一种平衡AVL树，通过比较返回值是否是0来保证元素唯一性，并且通过自然排序来保证元素的排序（自然排序也就是让元素所属的类实现Comparable接口，比如abc排在abd前面，总之就是和插入顺序无关，只和元素本身的内容和特质有关）</p>
<p>Queue接口<br>它的特点就是队列，即用于保存将要执行的任务列表</p>
<p>LinkedList<br>实现了该接口，可以实现先进先出的队列</p>
<p>PriorityQueue<br>底层采用某种排序的单链表存储队列元素，用来创建自然排序的优先级队列</p>
<p>Map接口<br>Map关心的是唯一的标识符，也就是将唯一的键映射到某个元素，以键值对形式存储，键唯一，值可重复</p>
<p>HashMap<br>底层实现是基于哈希表依赖于hashCode（）和equals（）方法，线程不安全，允许key和value为NULL，效率高</p>
<p>Hashtable<br>HashMap的线程安全版，效率低，不允许key和value为NULL</p>
<p>LinkedHashMap<br>底层是由链表和哈希表组成，链表保证元素有序，哈希表保证元素唯一，所以当需要键值对，并且关心插入顺序时可采用它</p>
<p>TreeMap<br>底层是由红黑树实现，当需要键值对，并关心元素的自然排序时可采用它</p>
<p>Collections<br>内置了一些常见的集合算法，像排序，查找算法等</p>
<p>13.并发集合类是什么？<br>Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。</p>
<h4 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h4><p>每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素<br>2-3树、2-3-4树<br>B树、B+树、</p>
<h4 id="说说红黑树"><a href="#说说红黑树" class="headerlink" title="说说红黑树"></a>说说红黑树</h4><p>红黑树—使二叉搜索树更加平衡：他是一种二叉搜索树，但在每个节点上增加一个存储<br>位表示节点的颜色，可是red 或black，红黑树的查找、插入、删除的时间复杂度最坏为O(lgn)。<br>因为由n 个节点随机生成的二叉搜索树的高度为lgn，所以二叉搜索树的一般操作的执行时<br>间为O(lgn)。如何保证一颗n 个节点的红黑树的高度始终为lgn，因为红黑树的5 个性质：<br>1）每个节点，要么红的，要么黑的<br>2）根节点是黑的<br>3）叶节点都是黑的，指的是NIL 指针<br>4）若一个节点时红的，则它的两个儿子都是黑的。<br>5）对于任意节点而言，其到叶节点数尾端NIL 指针的每条路径都包含相同数目的叶节点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;线性表之顺序表&quot;&gt;&lt;a href=&quot;#线性表之顺序表&quot; class=&quot;headerlink&quot; title=&quot;线性表之顺序表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.myzwl.win/2017/07/08/sjjg_1/&quot;&gt;线性表之顺序表&lt;/a&gt;&lt;/h
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>java基础总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_6/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_6/</id>
    <published>2018-03-13T06:48:51.000Z</published>
    <updated>2018-03-18T15:44:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><a href="https://www.myzwl.win/2017/07/16/yc_1/">异常处理</a></h4><p>从大的角度说主要分成两类：Error类代表了编译和系统的错误，不允许捕获，也就是我们自己无法主动去处理它；Exception类代表了我们可捕获并且可自己可处理异常，而Exception有包括两类，一个是你必须要处理的异常，如某个类有throws异常了，在未进入运行期就必须处理，另一类就是Runtime Exception（运行期异常），就是只有在运行时（也就是编译成class文件）时才知道，这个异常可处理或不处理</p>
<p>try-catch-finally 规则<br>1）在finally语句块中发生了异常。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）关闭CPU。</p>
<h4 id="java-IO简单总结"><a href="#java-IO简单总结" class="headerlink" title="java IO简单总结 "></a><a href="https://www.myzwl.win/2017/07/23/IO_1/">java IO简单总结 </a></h4><p>流：数据在数据源（文件）和程序（内存）之间经历的路径<br>输入流：数据从数据源到内存的路径<br>输出流：数据从内存到数据源的路径<br>字节流：可以用于读写二进制文件及任何类型的byte，也就是一个字节一个的读<br>字符流：可以用于读写文本文件，不能操作二进制文件，也就是两个字节两个字节的读<br>2.根据数据流向不同分为：输入流和输出流<br>3。节点流和处理流<br>节点流：直接与数据源相连，读入或读出，可以发现使用该流过于频繁操作硬件，从而使读写很不方便<br>处理流：处理流和节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。<br>Object流的意思将是像一根节点流插入一根Object流管道，专门操作Object，而它必须实现Serializable接口，该接口的意思是可序列化，就是说将一个对象流序列化成子节流写进网络或者文件，比如说游戏存盘，有各个游戏的记录，如果以面向对象来写进管道，它的各个成员变量，会在内存中被序列化成二进制写进去，而Serializable接口无方法，它只是个标记接口，编译器看到实现该接口的类就知道它应该被序列化，同样有一个transient关键字，是使可序列化的某个属性变成透明，也就是它不能变成字节写进去，那个属性只能为默认属性写进去</p>
<h4 id="反射机制简单"><a href="#反射机制简单" class="headerlink" title="反射机制简单"></a>反射机制简单</h4><p>classLoad、Class、Methods</p>
<h4 id="java基本数据类型"><a href="#java基本数据类型" class="headerlink" title="java基本数据类型"></a>java基本数据类型</h4><p>byte、short、int、long、float、double、char、boolean</p>
<h4 id="能否重写构造方法"><a href="#能否重写构造方法" class="headerlink" title="能否重写构造方法"></a>能否重写构造方法</h4><p>重载构造方法是可以的。<br>但是重写则不可以，因为被重写的前提是被继承，而构造方法根本就不能被继承，所以谈不上被重写。只能调用父类的构造方法</p>
<h4 id="构造代码块和构造方法的执行顺序"><a href="#构造代码块和构造方法的执行顺序" class="headerlink" title="构造代码块和构造方法的执行顺序"></a>构造代码块和构造方法的执行顺序</h4><p>父类静态块-自身静态块-父类块-父类构造器-自身块-自身构造器</p>
<h4 id="说说-amp-与-amp-amp-的区别"><a href="#说说-amp-与-amp-amp-的区别" class="headerlink" title="说说&amp;与&amp;&amp;的区别"></a>说说&amp;与&amp;&amp;的区别</h4><p>&amp;与&amp;&amp;都可以用作逻辑与（and）的运算符<br>&amp;&amp;具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。而&amp;则会同时计算<br>&amp;可以作为位运算符，当&amp;两边表达式不是boolean时，&amp;表示按位与操作，通常使用Ox0f来与一个整数&amp;运算，来取该整数的最低4个bit位</p>
<h4 id="Overload与Override的区别？Overload的方法是否可以改变返回值的类型？"><a href="#Overload与Override的区别？Overload的方法是否可以改变返回值的类型？" class="headerlink" title="Overload与Override的区别？Overload的方法是否可以改变返回值的类型？"></a>Overload与Override的区别？Overload的方法是否可以改变返回值的类型？</h4><p>重载表示方法名相同，但是参数个数或类型不同）<br>重写表示子类中的方法可以与父亲中某个方法的名称和参数完全相同，通过子类创建实例调用父类这个方法，也就是相当于覆盖了父类的这个方法，但是当父类是private时相当于子类增加了一个全新的方法，就不存在覆盖了。并且子类应该比父类抛出更少的异常或者拥有更大的权限<br>如果参数名不同会改变返回类型，但是如果都一样肯定不会改变返回类型</p>
<h4 id="abstractclass和interface语法上有什么区别？"><a href="#abstractclass和interface语法上有什么区别？" class="headerlink" title="abstractclass和interface语法上有什么区别？"></a>abstractclass和interface语法上有什么区别？</h4><p>1.抽象类可以有构造方法，接口不能有构造方法<br>2.抽象类中可以有普通成员方法，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。<br>4.抽象类中的抽象方法访问类型可以是public、protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型<br>5.抽象类中可以包含静态方法，接口中不能包含静态方法<br>6.抽象类和接口类中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以是任意，但是接口中定义的变量只能是public static final类型<br>7一个类可以实现多个接口，但只能继承一个抽象类</p>
<h4 id="什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？"><a href="#什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？" class="headerlink" title="什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？"></a>什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？</h4><p>将一个对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如将一个java对象存储到硬盘或者送给网络上的其他计算机，可以用代码把一个java对象变成某个格式的字节流在传输<br>如果要让java自动帮我们做，就需要实现serializable接口，编译的类才被writeObject方法操作，例如，在web中，如果对象被保存在了session中，tomcat在重启时要把session对象序列化到硬盘</p>
<h4 id="hashcode与equals"><a href="#hashcode与equals" class="headerlink" title="hashcode与equals"></a><a href="https://www.cnblogs.com/jesonjason/p/5492208.html" target="_blank" rel="external">hashcode与equals</a></h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;异常处理&quot;&gt;&lt;a href=&quot;#异常处理&quot; class=&quot;headerlink&quot; title=&quot;异常处理&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.myzwl.win/2017/07/16/yc_1/&quot;&gt;异常处理&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;从大的角度说主要分
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_7/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_7/</id>
    <published>2018-03-13T04:48:51.000Z</published>
    <updated>2018-03-18T15:46:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1"><a href="#网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1" class="headerlink" title="网络编程简单总结(https://www.myzwl.win/2017/07/29/socket_1/)"></a>网络编程简单总结(<a href="https://www.myzwl.win/2017/07/29/socket_1/">https://www.myzwl.win/2017/07/29/socket_1/</a>)</h4><p>tcp/ip分层<br>链接层（ARP欺诈）-网络层（ip、icmp（ping））-传送层（tcp、udp）-应用层（POP3、Http、FTP，SSH、SMTP）<br>ip协议<br>ip层就是唯一确定了一台机器，就像我们住的房间地址一样，唯一确定了我们的住处<br>这里需要注意的是，ip地址由四位字节组成，每个字节由8位二进制组成，同时有a，b，c三类地址，如图由网络号和主机号组成，当然这是公网，如果是局域网的话，就需要配网关和子网掩码了，如192.168.1.1和255.255.0.0那么255.255就是确定了ip地址哪几位字节是网络号，如192.168就是网络号<br>TCP与UDP协议<br>tcp协议<br>有65536个端口 0号是保留端口<br>1-1024是固定端口<br>又叫有名端口，即被某些程序固定使用，一般程序员不使用。<br>22：SSH远程登录协议 23：telnet使用 21：ftp使用<br>25：smtp服务使用 80：iis使用 7：echo服务<br>1025-65535是动态端口<br>UDP协议<br>UDP向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接。<br>简单来说，就是只发一次数据，不管对方有没有接收到都不会再发了，但是有时候效率会很高，像网络拥堵时</p>
<p>url<br>统一资源定义符也被称为网页地址。Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL地址，这种地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是Internet上的站点，简单地说，URL就是Web地址，俗称“网址”，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法，如：<br><a href="http://www.sina.com:8080/index.html" target="_blank" rel="external">http://www.sina.com:8080/index.html</a><br>1、协议；2、ip地址(32位)；3、端口号(16位)0-65535；4、资源名称。</p>
<p>单工、半双工和全双工<br>Socket编程（模拟socket编程）</p>
<h4 id="tcp-如何保证传输的可靠性"><a href="#tcp-如何保证传输的可靠性" class="headerlink" title="tcp 如何保证传输的可靠性"></a>tcp 如何保证传输的可靠性</h4><p>tcp 是面向连接，可靠的字节流服务<br>面向连接意味着两个使用tcp 的应用（通常是一个客户端和一个服务器）在彼此交换数<br>据之前必须先建立一个tcp 连接。在一个tcp 连接中，仅有两方进行彼此通信，广播和多播<br>不能用于tcp。<br>Tcp 通过下列方式提供可靠性：<br>1）将应用数据分割为tcp 认为最合适发送的数据块；<br>2）超时重传：当tcp 发出一个段后，他启动一个定时器，等待目的端确认收到这个报<br>文段。若不能及时收到一个确认，将重发这个报文段。<br>3）当tcp 收到发自tcp 链接另一端的数据时，它将发送一个确认（对于收到的请求，给<br>出确认响应）。这个确认不是立即发送，通常将推迟几分之一秒（之所以推迟，可能是要对<br>包做完校验）；<br>4）若tcp 收到包，校验出包有错，丢弃报文段，不给出响应，tcp 发送端会超时重传；<br>5）对于失序数据进行重新排序，然后交给应用层（tcp 报文段作为ip 数据报进行传输，<br>而ip 数据报的到达会失序，因此tcp 报文段的到达也可能失序。若必要，tcp 将对收到的数<br>据进行重新排列，以正确的顺序交给应用层）。<br>6）对于重复数据，直接丢弃。<br>7）tcp 可以进行流量控制，防止较快主机致使较慢主机的缓冲区溢出<br>字节流服务：两个应用程序通过tcp 连接，tcp 不在字节中插入记录标识符，我们将这<br>种为字节流服务。<br>Tcp 对字节流的内容不做任何解释，tcp 不知道传输的字节流数据是二进制数据还是ascii<br>字符或其他类型数据，对字节流的解释由tcp 连接双方的应用层。</p>
<h4 id="简单描述一下https"><a href="#简单描述一下https" class="headerlink" title="简单描述一下https"></a>简单描述一下https</h4><p>https 其实是由两部分组成：http+ssl/tls，也就是在http 上又加了一层处理加密信息的<br>模块，服务端和客户端的信息传输都会通过tls 加密，传输的数据都是加密后的数据。加解<br>密过程：<br>1）客户端发起https 请求（就是用户在浏览器里输入一个https 网址，然后连接到server<br>的443 端口）<br>2）服务端的配置（采用https 协议的服务器必须要有一塔数字证书，可以自己制作，<br>也可以向组织申请，这套证书就是一对公钥和私钥）。<br>3）传输证书（这个证书就是公钥，只是包含了很多信息）<br>4）客户端解析证书（由客户端tls 完成，首先验证公钥是否有效，若发现异常，则弹出<br>一个警示框，提示证书存在问题，若无问题，则生成一个随机值，然后用证书对随机值进行<br>加密）<br>5）传输加密信息（这里传输的是加密后的随机值，目的是让服务端得到这个随机值，<br>以后客户端和服务端的通信就可以通过这个随机值来进行加密了）<br>6）服务端解密信息（服务端用私钥解密后得到了客户端传来的随机值，then 把内容通<br>过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混在一起，这样除非<br>知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法<br>够彪悍，私钥够复杂，数据就够安全）<br>7）传输加密的信息<br>8）客户端解密信息，用随机数来解。</p>
<p>短链接一般只会在client/server 间传递一次读写操作。<br>Tcp 保活功能，主要为服务器应用程序提供，服务器应用程序需要知道客户主机是否崩<br>溃，从而可以代表客户使用资源.<br>tcp 保护功能是探测长连接存活状况。<br>Tcp 的keep-alive 是检查当前tcp 是否还活着；http 的keep-alive 是让一个tcp 连接活多<br>久，他们是不同层次的概念。</p>
<p>a 发送给b 一个信息，但是a 不承认他发送了，防止这个可用数字签名<br>DNS 即使用tcp，又使用udp<br>https 若在浏览器端抓包，是可以看到数据的，并没有加密，抓到的是加密之前的</p>
<h4 id="http-请求过程——当我们在浏览器输入www-baidu-com，然后回车之后的详解"><a href="#http-请求过程——当我们在浏览器输入www-baidu-com，然后回车之后的详解" class="headerlink" title="http 请求过程——当我们在浏览器输入www.baidu.com，然后回车之后的详解"></a>http 请求过程——当我们在浏览器输入www.baidu.com，然后回车之后的详解</h4><p>1）域名解析（域名www.baidu.com 变为ip 地址）。<br>2）发起tcp 的三次握手，建立tcp 连接。浏<br>览器会以一个随机端口（1024-65535）向服务端的web 程序80 端口发起tcp 的连接.这个请<br>求（原始的http 请求，经过原始的tcp/ip 四层模型层层封装），到达服务器端后，进入网<br>卡，然后进入内核的协议栈（一层一层拨开），然后到达web 应用程序，最终建立了tcp/ip<br>链接。<br>3）建立tcp 连接后发起http 请求。<br>4）服务器响应http 请求，客户端得到html 代码。<br>服务器web 应用程序收到http 请求后，就开始处理请求，处理之后就返回给浏览器html<br>文件。<br>5）浏览器解析html 代码，并请求html 中的资源。<br>6）浏览器对页面进行渲染，并呈现给用户。</p>
<h4 id="什么是正向代理和反向代理"><a href="#什么是正向代理和反向代理" class="headerlink" title="什么是正向代理和反向代理"></a>什么是正向代理和反向代理</h4><p>正向代理：我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代<br>理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要哪<br>个无法访问的网站的内容，代理服务器取回来给我。server 不知道client。<br>反向代理：client 不知道server，并不是URL 中请求的那个资源，而是不知道从什么地方来<br>的。以代理服务器来接收internet 上的请求，然后将请求转发给内部网络的服务器，并将从<br>服务器上得到的结果返回给internet 上请求的客户，此时代理服务器对外就表现为一个服务<br>器。1）保证内网安全、2）负载均衡，nginx 通过proxy-pass-http 配置代理站点，upstream<br>实现负载均衡。</p>
<h4 id="怎么用udp-实现tcp"><a href="#怎么用udp-实现tcp" class="headerlink" title="怎么用udp 实现tcp"></a>怎么用udp 实现tcp</h4><p>由于在传输层udp 已经是不可靠的，那就要在应用层自己实现一<br>些保证可靠传输的机制，简单来说，要使用udp 来构建可靠的面向连接的数据传输，就要<br>实现类似于tcp 的超时重传（定时器），拥塞控制（滑动窗口），有序接收（添加包序号），<br>应答确认（ack 和seq）。目前已经有了实现udp 可靠运输的机制——udt：主要目的高速广<br>域网海量数据传输，他是应用层协议</p>
<p>Tcp：<br>1）流量控制：防止较快主机使较慢主机缓冲区溢出，是点对点；<br>2）拥塞控制：全局性，防止过多的数据注入网络。<br>tcp 采用滑动窗口进行流量控制，滑动窗口大小可变，窗口大小的单位是字节。</p>
<h4 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h4><p>在分布式集群中，对机器的添加和删除或机器故障后自动脱离集群，这些操作是分布式<br>集群管理最基本的功能，若采用常用的hash(object)%N 算法，那么在有机器添加或删除以后，<br>很多原有的数据就无法找到，所以出现一致性哈希算法——<br>1）环形hash 空间：按照常用的<br>hash 算法来将对应的key 哈希到一个具有232 个桶的空间，即（0-232 -1）的数字空间中，现<br>在我们将这些数字头尾相连，想象成一个闭合的环形。<br>2）把数据通过一定的hash 算法映射到环上。<br>3）将机器通过一定的hash 算法映射到环上。<br>4）节点按顺时针转动，遇到的第一个机器，就把数据放在该机器上</p>
<h4 id="Nginx负载均衡五种配置"><a href="#Nginx负载均衡五种配置" class="headerlink" title="Nginx负载均衡五种配置"></a>Nginx负载均衡五种配置</h4><p>1）轮询（默认），每个请求按时间顺序逐一分配到不同的后端服务器，如果后端<br>服务器down 掉，能自动剔除；<br>2）指定权重，指定轮询几率。权重越大，轮询几率越大，<br>用于后端服务器性能不均的情况。<br>3）ip 绑定ip_path，每个请求按访问ip 的哈希结果分配，<br>这样每个客户固定访问一个服务器，可以解决session 问题。<br>4）fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>5）url_hash 按访问的url 结果来分配请<br>求，使每个url 定位到同一个后端服务器。后端服务器为缓存时比较有效</p>
<h4 id="三次握手-手动画出图解"><a href="#三次握手-手动画出图解" class="headerlink" title="三次握手(手动画出图解)"></a>三次握手(手动画出图解)</h4><p> 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p>完成三次握手，客户端与服务器开始传送数据</p>
<p> 关闭TCP连接：改进的三次握手</p>
<p>对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：</p>
<p>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p>
<p>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p>
<p>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p>
<p>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放</p>
<h4 id="两次握手不行吗"><a href="#两次握手不行吗" class="headerlink" title="两次握手不行吗"></a>两次握手不行吗</h4><p>A发送报文滞留过长导致失效，然后b发送链接请求，A不理睬</p>
<h4 id="TIME-WAIT为什么是2MSL"><a href="#TIME-WAIT为什么是2MSL" class="headerlink" title="TIME-WAIT为什么是2MSL"></a>TIME-WAIT为什么是2MSL</h4><p>确保最后一个报文发到b，没有则重传<br>防止已失效的报文链接出现在本链接中</p>
<h4 id="为什么TCP释放连接需要四次"><a href="#为什么TCP释放连接需要四次" class="headerlink" title="为什么TCP释放连接需要四次"></a>为什么TCP释放连接需要四次</h4><p>  TCP建立连接要进行三次握手，而断开连接要进行四次。这是由于TCP的半关闭造成的。因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个方向的连接</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1&quot;&gt;&lt;a href=&quot;#网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>javaweb基础总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_8/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_8/</id>
    <published>2018-03-13T02:48:51.000Z</published>
    <updated>2018-03-21T08:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说一说servlet的生命周期"><a href="#说一说servlet的生命周期" class="headerlink" title="说一说servlet的生命周期"></a>说一说servlet的生命周期</h4><p>1）构造函数：<br>只有第一次请求servlet 时，创建servlet 实例，调用构造器，这说明servlet 是单例的，所以又线程安全<br>问题，只被调用一次<br>2）init：<br>只被调用一次，在创建好实例后，立即被调用，用来初始化servlet<br>3）service：<br>被多次调用，每次请求都会调用service，实际响应请求。<br>4）destory：<br>只被调用一次，在当前servlet 所在的web 应用被卸载前调用，用于释放当前servlet 所占用的资源。</p>
<h4 id="servlet-API中forward（）与redirect（）区别"><a href="#servlet-API中forward（）与redirect（）区别" class="headerlink" title="servlet API中forward（）与redirect（）区别"></a>servlet API中forward（）与redirect（）区别</h4><p>从地址栏显示来说：<br>forward是服务器请求的地址资源，通过内部转发方式最后只返回一次内容，而redirect是重新转发，也就是需要经过两次请求与响应<br>从数据共享来说<br>forward可以共享request里的数据，而redirect不行，forward是服务器内部的一种操作，而redirect是服务器通知客户端，然后客户端重新发起请求<br>从运用地方<br>forward一般用于用户登录的时候，根据角色转发到相应的模块<br>redirect一般用于用户注销登录时返回主页和跳转到其它的网站<br>从效率上<br>forward高，redirect低</p>
<h4 id="request-getAttribute-和request-getParameter-有什么区别"><a href="#request-getAttribute-和request-getParameter-有什么区别" class="headerlink" title="request.getAttribute()和request.getParameter()有什么区别"></a>request.getAttribute()和request.getParameter()有什么区别</h4><p>后者取得通过容器的实现来取得通过类似post，get等方式传入的数据<br>前者返回对象，后者返回字符串</p>
<h4 id="Http中get和post方法区别"><a href="#Http中get和post方法区别" class="headerlink" title="Http中get和post方法区别"></a>Http中get和post方法区别</h4><p>1.get请求的数据会被浏览器缓存起来，并以明文方式出现在url中，不太安全而post则更安全<br>2get传输数据有大小限制get请求的参数会跟在url后进行传递</p>
<h4 id="说说Cookie"><a href="#说说Cookie" class="headerlink" title="说说Cookie"></a>说说Cookie</h4><p>http 都是无状态的协议，web 服务器不能识别出哪些请求是同一个浏览器发的，浏览器的每一次请求都是完全独立的<br>Cookie 放在浏览器端，浏览器第一次范围服务器时，没有cookie，then 服务器给浏览<br>器一个cookie，以后每次浏览器访问服务器都要带上这个cookie。Jsp 是服务端<br>&lt;% 1.创建一个cookie 对象Cookie cookie =new Cookie(“name”,”jhb”);<br>2.调用response 的一个方法把cookie 传输给客户端<br>Response.addCookie（cookie）;%&gt;<br>默认情况下cookie 是会话级别，存储在浏览器内存中，用户退出浏览器之后被删除，<br>若希望浏览器将cookie 存在磁盘上，则要使用maxage，并给一个以秒为单位的时间，表示<br>cookie 的存活时间。<br>Cookie 作用范围：可以作用当前目录和当前目录的子目录，但不能作用与当前目录的上<br>一级。<br>Cookie:在客户端保持http 状态信息的方案，会话跟踪。</p>
<h4 id="说说session"><a href="#说说session" class="headerlink" title="说说session"></a>说说session</h4><p>在服务器端保持http 状态信息<br>当浏览器第一次范围服务器时，没有cookie，服务器也就得不到JSession_id，then 服<br>务器创建一个session 对象，并返回一个JSession_id 给浏览器，通过cookie 返回，下次浏览<br>器再访问服务器时就带上cookie（其中有JSession_id），服务器就能找到对应的session 对<br>象。JSession_id 可以通过cookie 传输，也可以通过url 传送。</p>
<p>一个session，对应一个sessionID</p>
<p>Session：浏览器和服务器的一次会话，若浏览器不关，至始至终都是一个session，因<br>为用cookie 传送。<br>当程序需要为某给客户端的请求创建session 时，服务器首先检查这个客户端的请<br>求是否包含一个session 标识，即JSession_id，如果包含，则说明以前已经为此客户创建过<br>JSession_id，服务器就按照这个JSession_id 检索出来（若检索不到，可能会新建一个，这种<br>情况下可能会出现在服务器已经删除了该用户对应的session 对象。但用户人为的在请求的<br>URL 上附加衣蛾JSession_id 的参数。）如不包含则创建一个session，并生成与这个session<br>有关的JSession_id，这个JSession_id 将在本次响应中返回给客户端。<br>默认session 用cookie</p>
<p>若第一次访问某web 应用程序的一个jsp 页面，且该jsp 页面的page 指定session=true，<br>服务器会创建一个httpsession 对象。<br>注：关闭浏览器只是使存储在浏览器内存中的session cookie 失效，不会使服务器端的<br>session 对象失效</p>
<h4 id="xml-解析技术"><a href="#xml-解析技术" class="headerlink" title="xml 解析技术"></a>xml 解析技术</h4><p>1）dom：必须在解析之前把整个文档装入内存，处理大型文件时，性能低，适合xml 随机访问。<br>2）sax：事件驱动，它顺序读取xml 文件，不需要一次全部载入整个文件。当遇到文件开头，文档结束or 标签开头or 标签结束时，他会触发一个事件，用户通过在其回调事件中写入处理代码来处理xml 文件，适合顺序访问</p>
<h4 id="多个请求映射到同一个jsp-页面"><a href="#多个请求映射到同一个jsp-页面" class="headerlink" title="多个请求映射到同一个jsp 页面"></a>多个请求映射到同一个jsp 页面</h4><p>1）这几个请求的名字都为xxx.do,all 以.do 结尾的都映射到同一个servlet。<br>2）用request 获得path，即/xxx.do。<br>3）去掉后面的.do 和前面的”/”，得到方法名,即xxx。<br>4）利用反射调用相关方法</p>
<h4 id="Httpsession-生命周期"><a href="#Httpsession-生命周期" class="headerlink" title="Httpsession 生命周期"></a>Httpsession 生命周期</h4><p>1）什么时候创建httpsession？<br>答案：1.是否浏览器访问服务器<br>的任何一个jsp 或者servlet，服务器都会创建一个httpsession？不一定，设置session=false，<br>若当前jsp 是客户端访问的当前web 应用的第一个资源，且page 指定的session=false，则服<br>务器不会为jsp 创建session 对象。若当前jsp 不是客户端访问的当前web 应用的第一个资源，<br>且其他页面已经创建了其他httpsession 对象，则返回一个和当前会话相关的httpsession 对<br>象，不创建一个新对象。</p>
<p>2.session=false 是什么意思<br>当前jsp 页面禁用session 隐含变量，但可以使用其他的显示的httpsession 的对象</p>
<p>3.对于servlet，若servlet 是客户端访问的第<br>一个web 应用资源，只有调用request.getSession（）或除了1 和2 以外，只要访问jsp，则<br>要创建session 对象。</p>
<p>4.什么时候销毁session 对象<br>1.直接调用httpsession 的invalidate 方法，该方法使httpsession 失效。<br>2.当前web 应用被卸载。<br>3.超出httpsession 的过期时间。</p>
<h4 id="JavaWeb-servlet-监听器"><a href="#JavaWeb-servlet-监听器" class="headerlink" title="JavaWeb-servlet 监听器"></a>JavaWeb-servlet 监听器</h4><p>监听器：专门用与对其他对象身上发生的事件或状态的改变进行监听or 相应处理的对象。<br>当被监视的对象发生情况时，立即采取相应的行动<br>Servlet 监听器：一种特殊的类，用于ServletContext，httpsession，Servletrequest 等域<br>对象的创建与销毁事情，以及监听这些对象中的属性发生修改的事件<br>监听域对象的创建和销毁<br>    创建时间                            销毁时间<br>ServletContext（application）  web 应用被加载web 应用被销毁<br>Httpsession（session）<br>Servletrequest（request）   每次请求开始时创建每次访问结束后销毁</p>
<p>ServletContextListener 最为常用，监听ServletContext 对象创建or 销毁的Servlet 监听器，可以在当前web 应用被加载时对当前web 应用的相关资源进行初始化，比如：创建数据库连接池<br>HttpsessionListener：sessioncreated 在session 被创建后调用，sessionDestoryed 在session被销毁前调用。</p>
<h4 id="域对象生命周期"><a href="#域对象生命周期" class="headerlink" title="域对象生命周期"></a>域对象生命周期</h4><p>1）request：是一个请求，当一个相应返回时被销毁，发一个请求时被创建<br>1.forword 只有一个请求，只有一个request<br>2.response 有两个request<br>2）session：当第<br>一次访问web 应用的一个jsp 或Servlet 时，且该jsp 和Servlet 中还需要创建session 对象，<br>此时服务器会创建一个session 对象<br>3）application：ServletContext 对象。当前web 应用被<br>加载时创建，web 应用被卸载时销毁。</p>
<h4 id="说说Filter"><a href="#说说Filter" class="headerlink" title="说说Filter"></a>说说Filter</h4><p>1）目的：调用目标资源前让一段代码执行，是否允许用户调用目标资源，调<br>用目标资源之后让一段代码执行<br>2）编写java 类，实现filter 接口，配置filter-mapping，<br>说明对哪些资源进行拦截。<br>3）每次拦截时，都调用filter 的dofilter 方法<br>4）filter 创建和销毁由servlet 容器，在web 应用启动时，创建实例，并调用init 方法，filter 对象只创建一<br>次，init 只执行一次。Destory，容器卸载filter 对象前被调用。<br>5）用户在配置filter 时，可<br>以使用<init-param>为filter 配置一些初始化参数，当web 容器实例化filter 对象时，调用其<br>init 方法，会把封装了filter 初始化参数的filter config 对象初始化，所以开发人员在写filter<br>时，可以用filter config 对象的方法来获得初始化对象。<br>6）应用：统一全站的字符编码；禁止浏览器缓存；实现url 级别的权限认证</init-param></p>
<h4 id="说说拦截器"><a href="#说说拦截器" class="headerlink" title="说说拦截器"></a>说说拦截器</h4><p>拦截器，在AOP中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作<br>启动顺序 :监听器 &gt; 过滤器 &gt; 拦截器<br>拦截器与过滤器的区别：<br>过滤器Filter依赖于Servlet容器，基于回调函数，过滤范围大。<br>拦截器Interceptor依赖于框架容器，基于反射机制，只过滤请求</p>
<h4 id="说说集群"><a href="#说说集群" class="headerlink" title="说说集群"></a>说说集群</h4><p>1）伸缩性：系统适应不断增长的用户数的能力。<br>2)高可用性:避免单一服务器的单点失效<br>3)负载均衡:把请求发给不同服务器<br>4）失效转移：当一个节点失效后，通过选择集<br>群中的另一个节点，处理将会继续而不会终止。httpssession 失效转移，用来保证当某台服<br>务器失效以后，会话状态不会丢失，为了支持会话转移，web 服务器将在一定的时候把会话<br>对象备份到其他地方，以防丢失。这个其他地方有jdbc 数据库、其他所有服务器、任意选<br>择其他一台web server、中央server</p>
<h4 id="Ajax的实现流程是主怎样的"><a href="#Ajax的实现流程是主怎样的" class="headerlink" title="Ajax的实现流程是主怎样的"></a>Ajax的实现流程是主怎样的</h4><p>1创建XMLHttpRequest对象，也就是创建一个异步调用对象<br>2.创建一个新的HTTp请求，并指定该HTTP请求的方法，url及验证信息<br>3设置http请求状态变化的函数<br>4.发送HTTp请求<br>5获取异步调用返回的数据<br>6.使用javascript和DOM实现局部刷新</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说一说servlet的生命周期&quot;&gt;&lt;a href=&quot;#说一说servlet的生命周期&quot; class=&quot;headerlink&quot; title=&quot;说一说servlet的生命周期&quot;&gt;&lt;/a&gt;说一说servlet的生命周期&lt;/h4&gt;&lt;p&gt;1）构造函数：&lt;br&gt;只有第一次请求
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
</feed>
