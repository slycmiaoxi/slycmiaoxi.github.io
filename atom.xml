<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2017-07-26T14:02:36.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优先队列与递归</title>
    <link href="http://www.myzwl.win/2017/07/12/sjjg_7/"/>
    <id>http://www.myzwl.win/2017/07/12/sjjg_7/</id>
    <published>2017-07-12T05:48:51.000Z</published>
    <updated>2017-07-26T14:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果按照队列的特点，即先来先服务原则，在很多情况下不能实现相关设计，比如操作系统中的进程调度管理，就是按照优先级大小来进行调度</p>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>若一个队列中的每个元素都有一个优先级，每次出队的是具有优先级最高的元素，则称该队列为优先队列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class PriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; implements QQueue&#123;</div><div class="line"></div><div class="line">	private SortedSinglyLinkedList&lt;T&gt; list; //使用排序单链表存储队列元素</div><div class="line">	</div><div class="line">	public PriorityQueue()&#123;   //构造空队列</div><div class="line">		this.list=new SortedSinglyLinkedList&lt;T&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123; //判断队列是否为空</div><div class="line">		return list.isEmpty();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(Object x) &#123; //元素x入队，根据元素大小插入在单链表适当位置</div><div class="line">		list.insert(x);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object dequeue() &#123;//出队，返回对头元素</div><div class="line"></div><div class="line">		return list.remove(0);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String toString()&#123;</div><div class="line">		return list.toString();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进程按优先级调度管理<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Process implements Comparable&lt;Process&gt;&#123;</div><div class="line"></div><div class="line">	private String name;   //进程名</div><div class="line">	private int priority;  //优先级</div><div class="line"></div><div class="line"></div><div class="line">	public Process(String name, int priority) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.priority = priority;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	public int compareTo(Process o) &#123;//比较两个进程的大小，约定进程排队次序的规则</div><div class="line"></div><div class="line">		return this.priority-o.priority;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>从形式上，递归的定义可如下所示<br><img src="/images/imgs4/6.jpg" alt="Alt text"><br>同时递归定义必须满足以下两个条件<br>1.边界条件：至少有一条初始定义是非递归的。<br>2.递归通式： 由已知函数值逐步递推计算出未知函数值</p>
<p>递归算法是指直接或者间接调用自身的算法<br>如用递归算法求fibonacci数列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Factorial &#123;</div><div class="line"></div><div class="line">	public static int factorial(int n)</div><div class="line">	&#123;</div><div class="line">		if(n&lt;0)</div><div class="line">			throw new IllegalArgumentException("n="+n);</div><div class="line">		if(n==0||n==1)</div><div class="line">			return n;</div><div class="line">		return factorial(n-1)+factorial(n-2);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String args[])&#123;</div><div class="line">		for(int i=0;i&lt;=24;i++)</div><div class="line">			System.out.print(factorial(i)+" ");</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<blockquote>
<p>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 </p>
</blockquote>
<p>再如将之前的SinglyLinkenList类增加一个复制方法，采用递归法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private Node&lt;T&gt; copy(Node&lt;T&gt; p)&#123;</div><div class="line">	Node&lt;T&gt; q=null; //新结点</div><div class="line">	if(p!=null)  //要复制的结点非空</div><div class="line">	&#123;</div><div class="line">		q=new Node&lt;T&gt;(p.data,null); //相当于q.data=p.data，q.next=null</div><div class="line">		q.next=copy(p.next);//递归，q1.data=p.next.data，q1.next=null，先返回q1，q.next=q1</div><div class="line">		//可以看成一棵二叉树</div><div class="line">	&#125;</div><div class="line">	return q;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果按照队列的特点，即先来先服务原则，在很多情况下不能实现相关设计，比如操作系统中的进程调度管理，就是按照优先级大小来进行调度&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>顺序与链式队列</title>
    <link href="http://www.myzwl.win/2017/07/11/sjjg_6/"/>
    <id>http://www.myzwl.win/2017/07/11/sjjg_6/</id>
    <published>2017-07-11T05:48:51.000Z</published>
    <updated>2017-07-26T07:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行。特点是先进先出。</p>
<h4 id="队列抽象数据类型"><a href="#队列抽象数据类型" class="headerlink" title="队列抽象数据类型"></a>队列抽象数据类型</h4><p><img src="/images/imgs4/5.jpg" alt="Alt text"><br>其中，像队列中插入元素的过程称为入队（enqueue），删除元素的过程称为出队（dequeue），允许入队的一端称为队尾（rear），允许出队的一头称为对头（front），没有元素的队列称为空队列<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface QQueue&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	boolean isEmpty();          //判断队列是否为空</div><div class="line">	void enqueue(T x);          //元素x入队</div><div class="line">	T dequeue();                //出队，返回对头元素</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>顺序队列使用数组存储数据元素<br>1.当队列空时，设置队头、队尾下标front=rear=-1，<br>2.当第一个元素入队时，front=rear=0，同时改变两个下标<br>3.进行入队、出队操作，front、rear随之变化<br>4.当入队的元素个数（包括已出队元素）超出数组容量时，rear下标越界，数据溢出，但是，由于之前已有若干元素出队，数组前部以空出许多存储单元，所以这种溢出并不是因为存储空间不够而产生的，称为假溢出</p>
<p>所以顺序队列有两个缺点：假溢出和存储单元没有重复使用机制</p>
<h4 id="顺序循环队列"><a href="#顺序循环队列" class="headerlink" title="顺序循环队列"></a>顺序循环队列</h4><p>相比较顺序队列，有如下不同<br>1.队头、队尾元素按照如下循环规律变化，其中length表示数组长度<br>front=（front+1)%length;<br>rear=(rear+1)%length;<br>所以可以看出front和rear的取值范围为0~length-1；</p>
<p>2.约定rear是下一个入队元素位置，队列空条件是front==rear，即入队只改变rear，出队只改变front<br>3.约定队列满条件是队列中仍然有一个空位置，即front==（rear+1）%length，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class SeqQueue&lt;T&gt; implements QQueue&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Object element[];  //存储队列数据元素的数组</div><div class="line">	private int front,rear;    //分别为对头和队尾元素</div><div class="line">	</div><div class="line">	public SeqQueue(int length)&#123;        //构造容量为length的空队列</div><div class="line">		if(length&lt;64)</div><div class="line">			length=64;</div><div class="line">		this.element=new Object[Math.abs(length)];</div><div class="line">		this.front=this.rear=0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public SeqQueue()&#123;       //构造默认容量空队列</div><div class="line">		this(64);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;     //判断队列是否为空</div><div class="line">		return this.front==this.rear;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(T x) &#123;   //元素x入队，空对象不能入队</div><div class="line">	if(x==null)</div><div class="line">		return;</div><div class="line">	if(this.front==(this.rear+1)%this.element.length) //当队满时，扩充容量</div><div class="line">	&#123;</div><div class="line">		Object[] temp=this.element;</div><div class="line">		this.element=new Object[temp.length*2];</div><div class="line">		int i=this.front,j=0;</div><div class="line">		while(i!=this.rear)&#123;        //按照队列元素次序复制数组元素</div><div class="line">			this.element[j]=temp[i];</div><div class="line">			i=(i+1)%temp.length;</div><div class="line">			j++;</div><div class="line">		&#125;</div><div class="line">		this.front=0;</div><div class="line">		this.rear=j;</div><div class="line">	&#125;</div><div class="line">		this.element[this.rear]=x;</div><div class="line">		this.rear=(this.rear+1)%this.element.length;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T dequeue() &#123;         //出队，返回队头元素，若队列空则返回null</div><div class="line">   if(isEmpty())</div><div class="line">		return null;</div><div class="line">    T temp=(T)this.element[this.front];</div><div class="line">      this.front=(this.front+1)%this.element.length;  //取得队头元素</div><div class="line">     return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p>以不带头结点的单链表实现链式队列，设指针front和rear分别指向队头和队尾结点，初始空队列的状态设置为front=rear=null；队列空条件是front==null&amp;&amp;rear==null</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class LinkedQueue&lt;T&gt; implements QQueue&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Node&lt;T&gt; front,rear;        //分别指向队头和队尾</div><div class="line">	</div><div class="line">	public LinkedQueue()&#123;             //构造空队列</div><div class="line">		this.front=this.rear=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;        //判断队列是否为空</div><div class="line">		return this.front==null&amp;&amp;this.rear==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void enqueue(T x) &#123;       //元素x入队，空对象入队</div><div class="line">		if(x==null)  </div><div class="line">			return;</div><div class="line">		Node&lt;T&gt; q=new Node&lt;T&gt;(x,null);  </div><div class="line">		 if(this.front==null)</div><div class="line">			 this.front=q;   //空队入队</div><div class="line">		 else</div><div class="line">			 this.rear.next=q; //插入在队尾之后</div><div class="line">		 this.rear=q;		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T dequeue() &#123;  //出队，返回对头元素，若队列元素为空，返回null</div><div class="line">		if(isEmpty())</div><div class="line">			return null;</div><div class="line">		T temp=this.front.data;    //取得队头元素</div><div class="line">		this.front=this.front.next;    //删除队头结点</div><div class="line">		if(this.front==null)</div><div class="line">			this.rear=null;</div><div class="line">		return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行。特点是先进先出。&lt;/p&gt;
&lt;h4 id=&quot;队列抽象数据类型&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://www.myzwl.win/2017/07/10/sjjg_5/"/>
    <id>http://www.myzwl.win/2017/07/10/sjjg_5/</id>
    <published>2017-07-10T05:48:51.000Z</published>
    <updated>2017-07-26T05:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈是一种特殊的线性表，其特殊之处在于插入和删除操作的位置受到限制，而且插入和删除只允许在线性表的一端进行，特点是后进先出</p>
<h4 id="栈抽象数据类型"><a href="#栈抽象数据类型" class="headerlink" title="栈抽象数据类型"></a>栈抽象数据类型</h4><p><img src="/images/imgs4/8.gif" alt="Alt text"><br>其中允许操作的一端为栈顶（top），不允许操作的一端为栈底（bottom），栈中插入元素的操作称为入栈（push），删除元素的操作为出栈（pop），没有元素的栈称为空栈</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface SStack&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	boolean isEmpty();  //判断是否为空栈</div><div class="line">	void push(T x);     //元素x入栈</div><div class="line">	T pop();            //出栈，返回当前栈顶元素</div><div class="line">	T get();            //取栈顶元素，未出栈</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>采用顺序存储结构的栈称为顺序栈<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class SeqStack&lt;T&gt; implements SStack&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Object element[];    //存取栈数据元素的数组</div><div class="line">	private int top;             //栈顶元素下标</div><div class="line">	</div><div class="line">	public SeqStack(int size)&#123;    //构造容量为size的空栈</div><div class="line">		this.element=new Object[Math.abs(size)];</div><div class="line">		this.top=-1;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public SeqStack()&#123;         //构造默认容量的空栈</div><div class="line">		this(64);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123; //判断栈是否为空</div><div class="line">		</div><div class="line">		return this.top==-1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void push(T x) &#123;    //元素x入栈，空对象不能入栈</div><div class="line">		if(x==null)</div><div class="line">			return;</div><div class="line">		if(this.top==element.length-1)   //栈满，扩充栈容量</div><div class="line">		&#123;</div><div class="line">			Object[] temp=this.element;</div><div class="line">			this.element=new Object[temp.length*2];</div><div class="line">			for(int i=0;i&lt;temp.length;i++)</div><div class="line">				this.element[i]=temp[i];</div><div class="line">		&#125;</div><div class="line">		this.top++;</div><div class="line">		this.element[this.top]=x;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T pop() &#123;  //出栈</div><div class="line">		</div><div class="line">		return this.top==-1?null:(T)this.element[this.top--];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get() &#123;		//取栈顶元素</div><div class="line">		return this.top==-1?null:(T)this.element[this.top];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上，push（），pop（），get（）方法的时间复杂度为O（1），而需要扩充容量时，复杂度为O（n）；</p>
<h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>采用链式存储结构的栈称为链式栈，这里采用单链表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class LinkedStack&lt;T&gt; implements SStack&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Node&lt;T&gt; top;         //栈顶结点</div><div class="line">	</div><div class="line">	public LinkedStack()&#123;        //构造空栈</div><div class="line">		this.top=null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;     //判断栈是否为空</div><div class="line">		return this.top==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void push(T x) &#123;</div><div class="line">		if(x!=null)</div><div class="line">			this.top=new Node(x, this.top);  //头插入，x结点作为新的栈顶结点</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T pop() &#123;         //出栈，返回栈顶元素</div><div class="line">		if(this.top==null)</div><div class="line">			return null;</div><div class="line">		T temp=this.top.data;</div><div class="line">		this.top=this.top.next;</div><div class="line">		return temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get() &#123;</div><div class="line">		return this.top==null?null:this.top.data;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;栈是一种特殊的线性表，其特殊之处在于插入和删除操作的位置受到限制，而且插入和删除只允许在线性表的一端进行，特点是后进先出&lt;/p&gt;
&lt;h4 i
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>串之字符串</title>
    <link href="http://www.myzwl.win/2017/07/09/sjjg_4/"/>
    <id>http://www.myzwl.win/2017/07/09/sjjg_4/</id>
    <published>2017-07-09T05:48:51.000Z</published>
    <updated>2017-07-23T15:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>串是由n(n&gt;=0)个字符组成的有限序列，它是一种特殊的线性表。而子串是指串s中任意连续字符组成的一个子序列组成的串。同时，串的比较通常由其字符编码的相关规则比较</p>
<h4 id="常量字符串String"><a href="#常量字符串String" class="headerlink" title="常量字符串String"></a>常量字符串String</h4><p>字符串采用字符数组作为存储结构，并且采用顺序存储结构，不过String类一次性申请了固定的空间，同时由于其存储结构为最终型，所以string不提供删除，插入子串<br>如下是模仿String类的部分<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public final class MyString implements Comparable&lt;MyString&gt;,Serializable&#123;</div><div class="line"></div><div class="line">	private final char[] value;         //字符数组，只能赋值一次</div><div class="line">	</div><div class="line">	public MyString()&#123;  //构造一个空串</div><div class="line">		this.value=new char[0];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyString(String original)&#123; //将字符串常量变成字符数组</div><div class="line">		this.value=original.toCharArray();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//以value数组中构造从begin开始的count个字符的字符串对象</div><div class="line">	public MyString(char[] value,int begin,int count)&#123;</div><div class="line">		this.value=new char[count];</div><div class="line">		 for(int i=begin;i&lt;begin+count;i++)</div><div class="line">			 this.value[i]=value[i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//以value数组中字符构造字符串</div><div class="line">	public MyString(char[] value)&#123;</div><div class="line">		this(value,0,value.length);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public MyString(MyString str)&#123;//复制对象</div><div class="line">		this(str.value);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int length()&#123;  //返回字符串长度</div><div class="line">		return this.value.length;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public char charAt(int i)&#123; //返回第i个字符</div><div class="line">		if(i&lt;0||i&gt;=this.value.length)</div><div class="line">			 throw new StringIndexOutOfBoundsException(i);</div><div class="line">		return this.value[i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String toString()&#123;</div><div class="line">		return new String(this.value);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">		public MyString concat(MyString str)&#123; //返回当前串与指定串str连接生成的新串</div><div class="line">		if(str==null||str.length()==0)     //要连接的串为空时，返回当前串</div><div class="line">			return this;</div><div class="line">		  char[] buffer=new char[this.value.length+str.length()];</div><div class="line">		   int i;</div><div class="line">		    for(i=0;i&lt;this.value.length;i++)  //复制当前串</div><div class="line">		    buffer[i]=this.value[i];</div><div class="line">		     for(int j=0;j&lt;str.value.length;j++)  //复制指定串</div><div class="line">		    	 buffer[i+j]=str.value[j];</div><div class="line">		       return new MyString(buffer); //以字符数组构造串</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int compareTo(MyString o) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由上述模拟过程知道，有四种构造方法构造串对象</p>
<blockquote>
<p>MyString s1=new MyString();<br> MyString s2=new MyString(“abc”);<br> char[] letters={a,b,c,d}<br> MyString s3=new MyString(“letters);<br> MyString s4=new MyString(s3);</p>
</blockquote>
<p> 此外在数组复制时，java提供了两种方法</p>
<blockquote>
<p>java.lang.System.arraycopy(value,0,this.value,0,value.length);<br> this.value=java.util.Arrays.copyOf(value,value.length)</p>
</blockquote>
<h4 id="求字串"><a href="#求字串" class="headerlink" title="求字串"></a>求字串</h4> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public MyString substring(int begin,int end)&#123;//返回传中从begin到end-1的子串</div><div class="line">	if(begin&lt;0)</div><div class="line">		begin=0;</div><div class="line">	if(end&gt;this.value.length)</div><div class="line">		end=this.value.length;</div><div class="line">	if(begin&gt;end)</div><div class="line">		throw new StringIndexOutOfBoundsException(end-begin);</div><div class="line">	if(begin==0&amp;&amp;end==this.value.length)</div><div class="line">		return this;</div><div class="line">	char[] buffer=new char[end-begin];</div><div class="line">	 for(int i=0;i&lt;buffer.length;i++)</div><div class="line">		 buffer[i]=this.value[i+begin];</div><div class="line">	   return new MyString(buffer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyString substring (int begin)&#123;//返回串中序号从begin到末尾的子串</div><div class="line">	return substring(begin,this.value.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="比较串相等与大小"><a href="#比较串相等与大小" class="headerlink" title="比较串相等与大小"></a>比较串相等与大小</h4> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object obj)&#123;</div><div class="line">	if(this==obj)</div><div class="line">		return true;</div><div class="line">	if(obj instanceof MyString)</div><div class="line">		&#123;MyString str=(MyString)obj;</div><div class="line">	if(this.value.length==str.value.length)&#123;</div><div class="line">		for(int i=0;i&lt;this.value.length;i++)</div><div class="line">			if(this.value[i]!=str.value[i])</div><div class="line">				return false;</div><div class="line">	      return true;&#125;</div><div class="line">&#125;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//返回两个字符串之间的差值，返回0表示相等</div><div class="line">public int compareTo(MyString o) &#123;</div><div class="line">	for(int i=0;i&lt;this.value.length&amp;&amp;i&lt;o.value.length;i++)</div><div class="line">		if(this.value[i]!=o.value[i])</div><div class="line">			 return this.value[i]-o.value[i]; //返回两串第一个不同字符的差值</div><div class="line">	return this.value.length-o.value.length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="变量字符串StringBuffer"><a href="#变量字符串StringBuffer" class="headerlink" title="变量字符串StringBuffer"></a>变量字符串StringBuffer</h4><p>该字符数组的容量总是大于串长，并且能够修改<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public class MyStringBuffer implements Serializable&#123;</div><div class="line">    </div><div class="line">	   private char[] value;     //字符数组</div><div class="line">	    private int len;         //串长度</div><div class="line">	     </div><div class="line">	    public MyStringBuffer(int size)&#123;    //构造指定容量的空串</div><div class="line">	    	this.value=new char[size&lt;16?16:size];</div><div class="line">	    	this.len=0;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public MyStringBuffer()&#123;      //以默认容量构造空串</div><div class="line">	    	this(16);</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public MyStringBuffer(String str)&#123;  //以字符串常量构造对象</div><div class="line">	    	this(str.length()+16);</div><div class="line">	    	 </div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public int length()&#123;</div><div class="line">	    	return this.len;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public synchronized char charAt(int i)&#123;</div><div class="line">	    	if(i&lt;0||i&gt;=this.len)</div><div class="line">	    		throw new StringIndexOutOfBoundsException(i);</div><div class="line">	    	return this.value[i];</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public void setCharAt(int i,char ch)&#123;</div><div class="line">	    	if(i&lt;0||i&gt;=this.len)</div><div class="line">	    		throw new StringIndexOutOfBoundsException(i);</div><div class="line">	    	this.value[i]=ch;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public synchronized MyStringBuffer insert(int i,MyStringBuffer str)&#123;</div><div class="line">	    	if(i&lt;0) i=0;</div><div class="line">	    	if(i&gt;this.len) i=this.len;</div><div class="line">	    	if(str==null) return this;</div><div class="line">	    	char temp[]=this.value;</div><div class="line">	    	if(this.value.length-this.len&lt;str.len) //当前容量不足，自动扩充</div><div class="line">	    	&#123;</div><div class="line">	    		this.value=new char[this.value.length+str.len*2];</div><div class="line">	    		for(int j=0;j&lt;i;j++)  //复制当前串前i-1个字符</div><div class="line">	    			this.value[j]=temp[j];</div><div class="line">	    	&#125;</div><div class="line">	    		for(int j=i;j&lt;this.len;j++)</div><div class="line">	    			this.value[str.len+j]=temp[j];//从i开始向后移动j个字符</div><div class="line">	    		for(int j=0;j&lt;str.len;j++)     //复制字符串str</div><div class="line">	    			this.value[i+j]=str.value[j];</div><div class="line">	    		this.len+=str.len;</div><div class="line">	    		return this;</div><div class="line">	    	&#125;</div><div class="line">	   </div><div class="line">	    public synchronized MyStringBuffer delete(int begin,int end)&#123;</div><div class="line">	    	if(begin&gt;0)</div><div class="line">	    		begin=0;</div><div class="line">	    	if(end&gt;this.len)</div><div class="line">	    		end=this.len;</div><div class="line">	    	if(begin&gt;end)</div><div class="line">	    		throw new StringIndexOutOfBoundsException(end-begin);</div><div class="line">	    	for(int i=0;i&lt;this.len-end;i++) //从end开始至串尾的子串向前移动</div><div class="line">	    		this.value[begin+1]=this.value[end+i];</div><div class="line">	    	this.len=end-begin;</div><div class="line">	    	return this;</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    public synchronized String toString()&#123;</div><div class="line">	    	return new String(this.value,0,this.len);</div><div class="line">	    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;串是由n(n&amp;gt;=0)个字符组成的有限序列，它是一种特殊的线性表。而子串是指串s中任意连续字符组成的一个子序列组成的串。同时，串的比较通
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性表之双链表</title>
    <link href="http://www.myzwl.win/2017/07/08/sjjg_3/"/>
    <id>http://www.myzwl.win/2017/07/08/sjjg_3/</id>
    <published>2017-07-08T05:48:51.000Z</published>
    <updated>2017-07-22T07:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>双链表的每个结点有两个地址域，分别指向它的前驱结点和后继结点<br><img src="/images/imgs4/4.jpg" alt="Alt text"></p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>双链表的结点声明如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class DLinkNode&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	public T data;  //数据元素</div><div class="line">	public DLinkNode&lt;T&gt; prev,next; //prev指向前驱结点，next指向后继结点</div><div class="line">	</div><div class="line">	public DLinkNode(T data, DLinkNode&lt;T&gt; prev, DLinkNode&lt;T&gt; next) &#123;</div><div class="line">		super();</div><div class="line">		this.data = data;</div><div class="line">		this.prev = prev;</div><div class="line">		this.next = next;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public DLinkNode()&#123;</div><div class="line">		this(null,null,null);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若带头结点的双链表为空双链表，则有head.next=null&amp;&amp;head.prev=null;</p>
<p>若p指向双链表中非两端的某个结点，则有p=p.next.prev=p.prev.next;</p>
<h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>如果双链表的最后一个结点的next链指向头结点，头结点的prev链指向最后一个结点，则称为循环双链表，<br>对于空双链表有head.next=head&amp;&amp;head.prev=head<br>下面是循环双链表CirDoublyLinkedList的实现类<br>只有插入和删除和单链表不一样<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class CirDoublyLinkedList&lt;T&gt; implements LList&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	public DLinkNode&lt;T&gt; head;</div><div class="line">	</div><div class="line">	public CirDoublyLinkedList()&#123;</div><div class="line">		this.head=new DLinkNode&lt;T&gt;();</div><div class="line">		this.head.prev=head;</div><div class="line">		this.head.next=head;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void insert(int i, T x) &#123;//将x对象插入在序号为i的结点</div><div class="line">	if(x==null)</div><div class="line">		return;</div><div class="line">	DLinkNode&lt;T&gt; p=this.head;</div><div class="line">	for(int j=0;p.next!=this.head&amp;&amp;j&lt;i;j++) //寻找插入位置</div><div class="line">		p=p.next;                           //循环停止时，p指向第i-1个结点</div><div class="line">	 DLinkNode&lt;T&gt; q=new DLinkNode&lt;T&gt;(x,p,p.next);//插入在p结点之后</div><div class="line">	 p.next.prev=q;</div><div class="line">	 p.next=q;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void append(T x) &#123;</div><div class="line">	 if(x==null)</div><div class="line">		 return;</div><div class="line">	 DLinkNode&lt;T&gt; q=new DLinkNode&lt;T&gt;(x,head.prev,head);</div><div class="line">	 head.prev.next=q; //插入在头结点之前，相当于尾插入</div><div class="line">	 head.prev=q;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T remove(int i) &#123;</div><div class="line">	if(i&gt;0)</div><div class="line">	&#123;</div><div class="line">		DLinkNode&lt;T&gt; p=this.head.next;</div><div class="line">		for(int j=0;p!=head&amp;&amp;j&lt;i;j++)  //定位到待删除结点</div><div class="line">			p=p.next;</div><div class="line">		if(p!=head)</div><div class="line">		&#123; </div><div class="line">			T old=p.data;     //获得原对象</div><div class="line">			p.prev.next=p.next;  //删除p结点自己</div><div class="line">			p.next.prev=p.prev;</div><div class="line">			return old;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">		this.head.prev=head;</div><div class="line">		this.head.next=head;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	。。。其余方法和单链表一样</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;双链表的每个结点有两个地址域，分别指向它的前驱结点和后继结点&lt;br&gt;&lt;img src=&quot;/images/imgs4/4.jpg&quot; alt=&quot;
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性表之单链表</title>
    <link href="http://www.myzwl.win/2017/07/07/sjjg_2/"/>
    <id>http://www.myzwl.win/2017/07/07/sjjg_2/</id>
    <published>2017-07-07T05:48:51.000Z</published>
    <updated>2017-07-22T07:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线性表的链式存储是用若干地址分散的存储单元存储数据元素，逻辑上相连的数据元素在物理位置上不一定相连，必须采用附加信息表示数据元素之间的关系，并且存储单元至少包含两部分-数据域和地址域<br><img src="/images/imgs4/2.jpg" alt="Alt text"></p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表中结点只有一个地址并且指向后继结点<br><img src="/images/imgs4/3.jpg" alt="Alt text"></p>
<p>单链表结点类Node声明如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Node&lt;T&gt; &#123;  //单链表结点类</div><div class="line"></div><div class="line">	public T data;            //数据域，保存数据元素</div><div class="line">	public Node&lt;T&gt; next;      //地址域，引用后继结点</div><div class="line">	</div><div class="line">	public Node(T data,Node&lt;T&gt; next)&#123;</div><div class="line">		this.data=data;</div><div class="line">		this.next=next;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Node()&#123;</div><div class="line">		this(null,null);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于java不支持指针类型，但提供引用方式保存包括地址在内的结构化信息<br>通常通过node结点建立两个结点之间的链接，如p结点的下一个结点是q结点</p>
<blockquote>
<p>Node<string> p=new Node<string>(‘A’,null);<br>  Node<string> q=new Node<string>(‘B’,null);<br>  p.next=q;</string></string></string></string></p>
</blockquote>
<p>  单链表的头指针head也是一个结点引用</p>
<blockquote>
<p>Node<t> head=null;</t></p>
</blockquote>
<p>  当head==null时，为空单链表</p>
<p><strong>单链表的遍历操作 </strong><br>  遍历单链表是指从第一个结点开始，沿着结点的next链，依次访问单链表中的每个结点，并且每个结点只访问一次</p>
<blockquote>
<p>Node<t> p=head;<br>while(p!=null){<br>    p=p.next;<br>}</t></p>
</blockquote>
<p><strong>单链表的插入操作 </strong><br>对单链表进行插入操作，只要该表节点间的链接关系，不需要移动数据元素<br><strong>空表插入/头插入 </strong></p>
<blockquote>
<p>if(head==null)<br> head=new Node<t>(x,null);  //空表插入<br> else{<br> Node<t> q=new Node<t>(x,null); //头插入<br> q.next=head;<br> }</t></t></t></p>
</blockquote>
<p><strong>中间插入 </strong><br>若p指向非空单链表的某个结点，在p结点之后插入q结点</p>
<p>&lt; Node<t> q=new Node<t>(x,null);<br>q.next=p.next;             //q的后继结点应是p的原后继结点<br>p.next=q;                  //q作为p的后继结点</t></t></p>
<p><strong>尾插入 </strong></p>
<p><strong>单链表的删除操作 </strong><br>删除单链表的指定结点，只需改变结点的next域</p>
<p><strong>头删除 </strong></p>
<blockquote>
<p>head=head.next;</p>
</blockquote>
<p><strong>中间/尾删除 </strong></p>
<blockquote>
<p>if(p.next!=null)<br> p.next=p.next.next;</p>
</blockquote>
<h4 id="单链表实现类"><a href="#单链表实现类" class="headerlink" title="单链表实现类"></a>单链表实现类</h4> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line">public class SinglyLinkenList&lt;T&gt; implements LList&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	public Node&lt;T&gt; head;  //头指针</div><div class="line">	</div><div class="line">	public SinglyLinkenList()&#123; //构造空链表</div><div class="line">		this.head=new Node&lt;T&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public SinglyLinkenList(T[] element)&#123;//尾插入构造单链表</div><div class="line">		this();</div><div class="line">		Node&lt;T&gt; rear=this.head; //指向单链表最后一个结点</div><div class="line">		for(int i=0;i&lt;element.length;i++)&#123;</div><div class="line">			rear.next=new Node&lt;T&gt;(element[i],null); //尾插入</div><div class="line">			rear=rear.next;     //指向新的链尾结点</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;</div><div class="line">		</div><div class="line">		return this.head.next==null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int length() &#123;</div><div class="line">		</div><div class="line">		int i=0;</div><div class="line">		Node&lt;T&gt; p=this.head.next;  //p从单链表第一个结点开始</div><div class="line">		while(p!=null)&#123;            //若单链表未结束</div><div class="line">			i++;</div><div class="line">			p=p.next;             //p的后继结点</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		return i;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String toString()&#123;</div><div class="line">		String str="(";</div><div class="line">		Node&lt;T&gt; p=this.head.next;</div><div class="line">		while(p!=null)&#123;</div><div class="line">			str+=p.data.toString();</div><div class="line">			if(p.next!=null)</div><div class="line">				str+=",";  //不是最后一个结点时加分隔符</div><div class="line">			p=p.next;</div><div class="line">		&#125;</div><div class="line">		return str+")";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get(int i) &#123;  //返回第i个元素，若i指定序号无效，则返回null</div><div class="line">	  if(i&gt;=0)</div><div class="line">	  &#123;</div><div class="line">		  Node&lt;T&gt; p=this.head.next;</div><div class="line">		   for(int j=0;p!=null&amp;&amp;j&lt;i;j++)</div><div class="line">			   p=p.next;</div><div class="line">		    if(p!=null)</div><div class="line">		    	return p.data;</div><div class="line">	  &#125;</div><div class="line">		</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//设置第i个元素值为x，若i指定序号无效则抛出序号越界异常</div><div class="line">	public void set(int i, T x) &#123;</div><div class="line">		if(x==null)</div><div class="line">			return;            //不能设置空对象</div><div class="line">		if(i&gt;=0)</div><div class="line">		&#123;</div><div class="line">			Node&lt;T&gt; p=this.head.next;</div><div class="line">			 for(int j=0;p!=null&amp;&amp;j&lt;i;j++)</div><div class="line">				 p=p.next;</div><div class="line">			 if(p!=null)</div><div class="line">				 p.data=x;        //p指向第i个节点</div><div class="line">		&#125;</div><div class="line">		else throw new IndexOutOfBoundsException(i+"");</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void insert(int i, T x) &#123;//将x对象插入在序号为i的结点前</div><div class="line"></div><div class="line">		if(x==null)</div><div class="line">			return;</div><div class="line">		Node&lt;T&gt; p=this.head;  //p指向头结点</div><div class="line">		for(int j=0;p.next!=null&amp;&amp;j&lt;i;j++) //寻找插入位置</div><div class="line">			p=p.next;  //循环停止时，p指向第i-1结点或最后一个结点</div><div class="line">		p.next=new Node&lt;T&gt;(x,p.next);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//单链表最后添加对象</div><div class="line">	public void append(T x) &#123;</div><div class="line">		insert(Integer.MAX_VALUE,x);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	public T remove(int i) &#123;</div><div class="line">		if(i&gt;=0)</div><div class="line">		&#123;</div><div class="line">			Node&lt;T&gt; p=this.head;</div><div class="line">			 for(int j=0;p.next!=null&amp;&amp;j&lt;i;j++)//找到待删除的结点i的前驱结点i-1</div><div class="line">				 p=p.next;</div><div class="line">			 if(p.next!=null)</div><div class="line">			 &#123;</div><div class="line">				 T old=p.next.data;     //获取原对象</div><div class="line">				  p.next=p.next.next;    //删除p的后继结点</div><div class="line">				   return old;</div><div class="line">			 &#125;</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">	this.head.next=null;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int indexOf(T key) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public boolean contain(T key) &#123;</div><div class="line">		</div><div class="line">		return this.search(key)!=null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T search(T key) &#123;</div><div class="line">	 if(key==null)</div><div class="line">		 return null;</div><div class="line">	 Node&lt;T&gt; p=this.head.next;</div><div class="line">	 while(p!=null)</div><div class="line">	 &#123;</div><div class="line">		 if(p.data.equals(key))</div><div class="line">			 return p.data;</div><div class="line">		 p=p.next;</div><div class="line">	 &#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单链表求解约瑟夫环"><a href="#单链表求解约瑟夫环" class="headerlink" title="单链表求解约瑟夫环"></a>单链表求解约瑟夫环</h4><p>只需更改一处</p>
<blockquote>
<p>//LList<string> list=new seqList<string>(number);<br>  LList<string> list=new SinglyLinkenList<string>();</string></string></string></string></p>
</blockquote>
<p> 得到如下结果</p>
<blockquote>
<p>初始化约瑟夫环:(5,0,2)<br>删除B(A,C,D,E)<br>删除D(A,C,E)<br>删除A(C,E)<br>删除E(C)<br>最后的被赦免者是:C</p>
</blockquote>
<p>此外单链表相比较于顺序表在插入和删除时只要改变少量结点的链，不需要移动数据元素，也避免了顺序表因存在空间不足扩充空间和复制元素的过程，提高了运行效率和空间利用率</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;线性表的链式存储是用若干地址分散的存储单元存储数据元素，逻辑上相连的数据元素在物理位置上不一定相连，必须采用附加信息表示数据元素之间的关系，
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性表之顺序表</title>
    <link href="http://www.myzwl.win/2017/07/06/sjjg_1/"/>
    <id>http://www.myzwl.win/2017/07/06/sjjg_1/</id>
    <published>2017-07-06T05:48:51.000Z</published>
    <updated>2017-07-22T07:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据结构是指数据间存在的关系，通常包含三个方面。数据的逻辑结构（线性结构、树、图），数据的存储结构（顺序存储和链式存储），数据操作（对数据结构中的元素进行各种运算和处理），而通常所说的算法是建立在数据结构之上，读数据结构的操作需要用算法来描述。而算法的分析又主要包括时间代价和空间代价两方面</p>
<h4 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h4><p><img src="/images/imgs4/1.jpg" alt="Alt text"></p>
<p>数组是顺序存储的随机存取结构，占用一组连续的存储单元，通过下标识别元素，元素地址是下标的线性函数，一个下标能唯一确定一个元素<br> 不妨构造一个顺序表接口类来模仿顺序表<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface LList&lt;T&gt; &#123;</div><div class="line">	boolean isEmpty();       //判断线性表是否为空</div><div class="line">	int length();            //返回线性表长度</div><div class="line">	T get(int i);            //返回第i(i&gt;=0)个元素</div><div class="line">	void set(int i,T x);     //设置第i个元素值为x</div><div class="line">	void insert(int i,T x);  //插入x作为第i个元素</div><div class="line">	void append(T x);        //在线性表最后插入第i个元素</div><div class="line">	T remove(int i);         //删除第i个元素并返回被删除对象</div><div class="line">	void removeAll();        //删除线性表所有元素</div><div class="line">	int indexOf(T key);      //顺序查找关键字为key的元素，返回首次出现的位置</div><div class="line">	boolean contain(T key);  //是否包含关键字</div><div class="line">	T search(T key);         //顺序查找关键字为key的元素，返回首次出现的元素</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是其实现类<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">public class seqList&lt;T&gt; implements LList&lt;T&gt;&#123;</div><div class="line"></div><div class="line">	private Object[] element; //存放线性表元素的一维数组</div><div class="line">	private int len;       //顺序表长度，记载元素个数</div><div class="line">	</div><div class="line">	public seqList(int size)&#123;            //创建容量为size的空表</div><div class="line">		//若size&lt;0，java将抛出负数组长度异常</div><div class="line">		this.element=new Object[size];</div><div class="line">		this.len=0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public seqList()&#123;     //创建默认容量的空表，这里是64</div><div class="line">		this(64);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public boolean isEmpty() &#123;</div><div class="line">		</div><div class="line">		return this.len==0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int length() &#123;</div><div class="line">	</div><div class="line">		return this.len;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public T get(int i) &#123; //返回第i个元素（i&gt;=0),若i指定元素无效，则返回null</div><div class="line">	if(i&gt;=0&amp;&amp;i&lt;this.len)</div><div class="line">		return (T)this.element[i];</div><div class="line">    return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//设置第i(i&gt;=0)个元素的值为x，若i指定序号无效则抛出序号越界异常</div><div class="line">	public void set(int i, T x) &#123;</div><div class="line">		if(x==null)</div><div class="line">			return;</div><div class="line">		if(i&gt;=0&amp;&amp;i&lt;this.len)</div><div class="line">			this.element[i]=x;</div><div class="line">		else</div><div class="line">			throw new IndexOutOfBoundsException(i+"");</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">/**</div><div class="line"> * 在顺序表元素ai位置插入元素x，首选必须将i到n个元素后移，空出一个位置，然后插入元素x</div><div class="line"> */</div><div class="line">	public void insert(int i, T x) &#123;</div><div class="line">		if(x==null)</div><div class="line">			return ;           //不能添加null</div><div class="line">		if(this.len==element.length)	 //若数组满，则扩充顺序表容量</div><div class="line">		&#123; </div><div class="line">			Object[] temp=this.element;</div><div class="line">			this.element=new Object[temp.length*2]; //容量扩充2倍</div><div class="line">			for(int j=0;j&lt;temp.length;j++)&#123; </div><div class="line">				this.element[i]=temp[i];  //复制数组元素</div><div class="line">			&#125;</div><div class="line">			if(i&lt;0)                      //下标容错</div><div class="line">				i=0;</div><div class="line">			if(i&gt;this.len)</div><div class="line">				i=this.len;</div><div class="line">			for(int j=this.len-1;j&gt;=i;j--)       //元素后移，平均移动len/2</div><div class="line">				this.element[j+1]=this.element[j];</div><div class="line">			this.element[i]=x;</div><div class="line">			this.len++;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void append(T x) &#123;</div><div class="line">		insert(this.len,x);	   //在顺序表最后插入x对象</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 删除元素ai，必须将元素i+1到n向前移动</div><div class="line">	 */</div><div class="line">	public T remove(int i) &#123; //删除成功返回被删除对象，否则返回null</div><div class="line">		if(this.len==0||i&lt;0||i&gt;this.len)</div><div class="line">			return null;</div><div class="line">		T old=(T)this.element[i];</div><div class="line">		 for(int j=i;j&lt;this.len-1;j++)     //元素前移，平均移动len/2</div><div class="line">			 this.element[j]=this.element[j+1];</div><div class="line">		 this.element[this.len-1]=null;</div><div class="line">		 this.len--;</div><div class="line">		return old;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void removeAll() &#123;</div><div class="line">		</div><div class="line">		this.len=0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//顺序查找关键字为key的元素，返回首次出现的位置，若查找不成功返回-1</div><div class="line">	public int indexOf(T key) &#123;</div><div class="line">		if(key!=null)</div><div class="line">			for(int i=0;i&lt;this.len;i++)</div><div class="line">				if(this.element[i].equals(key))</div><div class="line">					return i;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//判断线性表是否包含关键字为key元素</div><div class="line">	public boolean contain(T key) &#123;</div><div class="line">		</div><div class="line">		return this.indexOf(key)&gt;=0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//查找，返回首次出现的关键字为key的元素</div><div class="line">	public T search(T key) &#123;</div><div class="line">	 int find=this.indexOf(key);</div><div class="line">		return find==-1?null:(T)this.element[find];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h4><p> 问题描述：古代某法官要判决n个犯人的死刑，他有一条荒唐的法律：将犯人站成一个圆圈，从第s个人开始数起，每数到第d个犯人，就拉出来处决，在从下一个开始数d个，数到的人在处决。。。直到数到最后一个人就开始赦免</p>
<p><img src="/images/imgs4/7.gif" alt="Alt text"><br>上面是假设n=5，s=1，d=2，并且起始位置是从第一个人开始数起，因为该圆圈可以看成顺序表进行模拟<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Josephus &#123;</div><div class="line"></div><div class="line">	public Josephus(int number,int start,int distance)&#123;</div><div class="line">		seqList&lt;String&gt; list=new seqList&lt;String&gt;(number); //初始化顺序表</div><div class="line">		for(int i=0;i&lt;number;i++)                      </div><div class="line">		//依次添加犯人，这里记为A,B.C,D,E</div><div class="line">			list.append((char)('A'+i)+"");</div><div class="line">		System.out.println("初始化约瑟夫环:"+'('+number+','+start+','+distance+')');</div><div class="line">		int i=start;            //起始数起的人</div><div class="line">		while(list.length()&gt;1)&#123;        //多于一个犯人时数起</div><div class="line">			i=(i+distance-1)%list.length(); </div><div class="line">			System.out.print("删除"+list.remove(i).toString()+"");</div><div class="line">			System.out.println(list.toString());</div><div class="line">		&#125;</div><div class="line">		System.out.println("最后的被赦免者是:"+list.get(0).toString());	</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String args[])&#123;</div><div class="line">		new Josephus(5,0,2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果</p>
<blockquote>
<p>初始化约瑟夫环:(5,0,2)<br>删除B(A,C,D,E)<br>删除D(A,C,E)<br>删除A(C,E)<br>删除E(C)<br>最后的被赦免者是:C</p>
</blockquote>
<h4 id="顺序表的效率分析"><a href="#顺序表的效率分析" class="headerlink" title="顺序表的效率分析"></a>顺序表的效率分析</h4><p>由之前的源码易看出，存取任何一个元素，即set（）、get（）方法的时间复杂度为O（1），而插入或者删除很耗时，不妨假设在第i个位置插入元素，并且概率为p<em>{i},表长度为n；则平均移动次数为\sum</em>{i=0}^n{(n-i)}*{p_i};<br>如果插入元素的概率相同，即都是1/(n+1);最后求得时间复杂度为O(n);同理删除的时间复杂度也为O(n);<br>所以得出一个结论:顺序表的动态操作效率极低</p>
<h4 id="顺序表比较相等"><a href="#顺序表比较相等" class="headerlink" title="顺序表比较相等"></a>顺序表比较相等</h4><p>首先简单说一下深拷贝和浅拷贝，浅拷贝类似于只引用某个对象，和原对象指向相同的空间，而深拷贝是开辟了新空间并且复制原来对象的数据<br>而两个顺序表的相等是指，他们对应的元素相等并且长度也相同<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object obj)&#123;</div><div class="line">		if(this==obj)</div><div class="line">			return true;</div><div class="line">		if(obj instanceof seqList)&#123;</div><div class="line">			seqList&lt;T&gt; list=(seqList&lt;T&gt;)obj;</div><div class="line">			if(this.length()==list.length())&#123;</div><div class="line">				for(int i=0;i&lt;this.length();i++)</div><div class="line">					if(!(this.get(i).equals(list.get(i))))</div><div class="line">						return false;</div><div class="line">				return true;</div><div class="line">			&#125;</div><div class="line">				</div><div class="line">		&#125;</div><div class="line">			return true;</div><div class="line">	</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;数据结构是指数据间存在的关系，通常包含三个方面。数据的逻辑结构（线性结构、树、图），数据的存储结构（顺序存储和链式存储），数据操作（对数据结
    
    </summary>
    
      <category term="数据结构" scheme="http://www.myzwl.win/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.myzwl.win/source/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>shiro之会话管理</title>
    <link href="http://www.myzwl.win/2017/07/05/shiro_5/"/>
    <id>http://www.myzwl.win/2017/07/05/shiro_5/</id>
    <published>2017-07-05T05:48:51.000Z</published>
    <updated>2017-07-16T01:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shiro提供了完整的会话功能，不依赖于底层容器，即直接使用shiro的会话管理可以直接替换掉web容器的会话管理</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。</p>
<p><strong>获取会话</strong></p>
<blockquote>
<p>Subject subject = SecurityUtils.getSubject();<br>Session session = subject.getSession();  </p>
</blockquote>
<p><strong>获取当前会话的唯一标识</strong></p>
<blockquote>
<p>session.getId(); </p>
</blockquote>
<p><strong>获取当前Subject的主机地址</strong></p>
<blockquote>
<p>session.getHost();</p>
</blockquote>
<p><strong>获取/设置当前Session的过期时间</strong></p>
<blockquote>
<p>session.getTimeout();<br>session.setTimeout(毫秒); </p>
</blockquote>
<p><strong>获取会话的启动时间及最后访问时间</strong></p>
<blockquote>
<p>session.getStartTimestamp();<br>session.getLastAccessTime();</p>
</blockquote>
<p><strong>更新会话最后访问时间及销毁会话</strong></p>
<blockquote>
<p>session.touch();<br>session.stop();</p>
</blockquote>
<p>当Subject.logout()时会自动调用stop方法来销毁会话</p>
<p><strong>设置/获取/删除会话属性</strong></p>
<blockquote>
<p>session.setAttribute(“key”, “WORD”);<br>session.getAttribute(“key”);<br>session.removeAttribute(“key”); </p>
</blockquote>
<h4 id="会话管理器"><a href="#会话管理器" class="headerlink" title="会话管理器"></a>会话管理器</h4><p>会话管理器管理着应用中所有subject的会话的创建、维护、删除、失效、验证等工作。它是shiro的核心，顶层组件SecurityManager直接继承了SessionManager，且提供了SessionsSecurityManager实现直接把会话管理委托给相应的SessionManager，DefaultSecurityManager及DefaultWebSecurityManager默认SecurityManager都继承了SessionsSecurityManager。</p>
<p><strong>SecurityManager</strong></p>
<blockquote>
<p>Session start(SessionContext context); //启动会话<br>Session getSession(SessionKey key) throws SessionException; //根据会话Key获取会话 </p>
</blockquote>
<p><strong>WebSessionManager</strong></p>
<blockquote>
<p>boolean isServletContainerSessions();//是否使用Servlet容器的会话  </p>
</blockquote>
<p><strong>ValidatingSessionManager</strong></p>
<blockquote>
<p>void validateSessions();//验证所有会话是否过期 </p>
</blockquote>
<p><img src="/images/imgs4/5.gif" alt="Alt text"></p>
<p>Shiro提供了三个默认实现：</p>
<p>DefaultSessionManager：DefaultSecurityManager使用的默认实现，用于JavaSE环境；</p>
<p>ServletContainerSessionManager：DefaultWebSecurityManager使用的默认实现，用于Web环境，其直接使用Servlet容器的会话；</p>
<p>DefaultWebSessionManager：用于Web环境的实现，可以替代ServletContainerSessionManager，自己维护着会话，直接废弃了Servlet容器的会话管理。</p>
<p><strong>全局会话时间</strong><br>在web.xml中设置(单位：分钟)</p>
<blockquote>
<p><session-config><br>  <session-timeout>30</session-timeout><br></session-config> </p>
</blockquote>
<h4 id="会话监听器"><a href="#会话监听器" class="headerlink" title="会话监听器"></a>会话监听器</h4><p>会话监听器用于监听会话创建、过期及停止事件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MySessionListener1 implements SessionListener &#123;  </div><div class="line">     @Override  </div><div class="line">     public void onStart(Session session) &#123;//会话创建时触发  </div><div class="line">         System.out.println("会话创建：" + session.getId());  </div><div class="line">     &#125;  </div><div class="line">     @Override  </div><div class="line">     public void onExpiration(Session session) &#123;//会话过期时触发  </div><div class="line">         System.out.println("会话过期：" + session.getId());  </div><div class="line">     &#125;  </div><div class="line">     @Override  </div><div class="line">     public void onStop(Session session) &#123;//退出/会话过期时触发  </div><div class="line">         System.out.println("会话停止：" + session.getId());  </div><div class="line">     &#125;    </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>如果只想监听某一个事件，可以继承SessionListenerAdapter实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class MySessionListener2 extends SessionListenerAdapter &#123;  </div><div class="line">    @Override  </div><div class="line">    public void onStart(Session session) &#123;  </div><div class="line">        System.out.println("会话创建：" + session.getId());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="会话存储-持久化"><a href="#会话存储-持久化" class="headerlink" title="会话存储/持久化"></a>会话存储/持久化</h4><p>Shiro提供SessionDAO用于会话的CRUD</p>
<blockquote>
<pre><code>//如DefaultSessionManager在创建完session后会调用该方法；如保存到关系数据库/文件系统/NoSQL数据库；即可以实现会话的持久化；返回会话ID；主要此处返回的ID.equals(session.getId())；  
Serializable create(Session session);  
//根据会话ID获取会话  
Session readSession(Serializable sessionId) throws UnknownSessionException;  
//更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用  
void update(Session session) throws UnknownSessionException;  
//删除会话；当会话过期/会话停止（如用户退出时）会调用  
void delete(Session session);  
//获取当前所有活跃用户，如果用户量多此方法影响性能  
Collection&lt;Session&gt; getActiveSessions();   
</code></pre></blockquote>
<p><img src="/images/imgs4/6.gif" alt="Alt text"></p>
<p>AbstractSessionDAO提供了SessionDAO的基础实现，如生成会话ID等；CachingSessionDAO提供了对开发者透明的会话缓存的功能，只需要设置相应的CacheManager即可；MemorySessionDAO直接在内存中进行会话维护；而EnterpriseCacheSessionDAO提供了缓存功能的会话维护，默认情况下使用MapCache实现，内部使用ConcurrentHashMap保存缓存的会话。</p>
<pre><code>如果自定义实现SessionDAO，继承CachingSessionDAO即可
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class MySessionDAO extends CachingSessionDAO &#123;  </div><div class="line">    private JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate();  </div><div class="line">     protected Serializable doCreate(Session session) &#123;  </div><div class="line">        Serializable sessionId = generateSessionId(session);  </div><div class="line">        assignSessionId(session, sessionId);  </div><div class="line">        String sql = "insert into sessions(id, session) values(?,?)";  </div><div class="line">        jdbcTemplate.update(sql, sessionId, SerializableUtils.serialize(session));  </div><div class="line">        return session.getId();  </div><div class="line">    &#125;  </div><div class="line">protected void doUpdate(Session session) &#123;  </div><div class="line">    if(session instanceof ValidatingSession &amp;&amp; !((ValidatingSession)session).isValid()) &#123;  </div><div class="line">        return; //如果会话过期/停止 没必要再更新了  </div><div class="line">    &#125;  </div><div class="line">        String sql = "update sessions set session=? where id=?";  </div><div class="line">        jdbcTemplate.update(sql, SerializableUtils.serialize(session), session.getId());  </div><div class="line">    &#125;  </div><div class="line">    protected void doDelete(Session session) &#123;  </div><div class="line">        String sql = "delete from sessions where id=?";  </div><div class="line">        jdbcTemplate.update(sql, session.getId());  </div><div class="line">    &#125;  </div><div class="line">    protected Session doReadSession(Serializable sessionId) &#123;  </div><div class="line">        String sql = "select session from sessions where id=?";  </div><div class="line">        List&lt;String&gt; sessionStrList = jdbcTemplate.queryForList(sql, String.class, sessionId);  </div><div class="line">        if(sessionStrList.size() == 0) return null;  </div><div class="line">        return SerializableUtils.deserialize(sessionStrList.get(0));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h4><p>Shiro提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话，Shiro提供了会话验证调度器SessionValidationScheduler来验证</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//分页获取会话并验证  </div><div class="line">String sql = "select session from sessions limit ?,?";  </div><div class="line">int start = 0; //起始记录  </div><div class="line">int size = 20; //每页大小  </div><div class="line">List&lt;String&gt; sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);  </div><div class="line">while(sessionList.size() &gt; 0) &#123;  </div><div class="line">  for(String sessionStr : sessionList) &#123;  </div><div class="line">    try &#123;  </div><div class="line">      Session session = SerializableUtils.deserialize(sessionStr);  </div><div class="line">      Method validateMethod =   </div><div class="line">        ReflectionUtils.findMethod(AbstractValidatingSessionManager.class,   </div><div class="line">            "validate", Session.class, SessionKey.class);  </div><div class="line">      validateMethod.setAccessible(true);  </div><div class="line">      ReflectionUtils.invokeMethod(validateMethod,   </div><div class="line">        sessionManager, session, new DefaultSessionKey(session.getId()));  </div><div class="line">    &#125; catch (Exception e) &#123;  </div><div class="line">        //ignore  </div><div class="line">    &#125;  </div><div class="line">  &#125;  </div><div class="line"> start = start + size;  </div><div class="line">  sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>sessionFactory</strong><br>sessionFactory是创建会话的工厂，根据相应的Subject上下文信息来创建会话；默认提供了SimpleSessionFactory用来创建SimpleSession会话。<br>自定义一个session</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class OnlineSession extends SimpleSession &#123;  </div><div class="line">    public static enum OnlineStatus &#123;  </div><div class="line">        on_line("在线"), hidden("隐身"), force_logout("强制退出");  </div><div class="line">        private final String info;  </div><div class="line">        private OnlineStatus(String info) &#123;  </div><div class="line">            this.info = info;  </div><div class="line">        &#125;  </div><div class="line">        public String getInfo() &#123;  </div><div class="line">            return info;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    private String userAgent; //用户浏览器类型  </div><div class="line">    private OnlineStatus status = OnlineStatus.on_line; //在线状态  </div><div class="line">    private String systemHost; //用户登录时系统IP   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义SessionFactory<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class OnlineSessionFactory implements SessionFactory &#123;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public Session createSession(SessionContext initData) &#123;  </div><div class="line">        OnlineSession session = new OnlineSession();  </div><div class="line">        if (initData != null &amp;&amp; initData instanceof WebSessionContext) &#123;  </div><div class="line">            WebSessionContext sessionContext = (WebSessionContext) initData;  </div><div class="line">            HttpServletRequest request = (HttpServletRequest) sessionContext.getServletRequest();  </div><div class="line">            if (request != null) &#123;  </div><div class="line">                session.setHost(IpUtils.getIpAddr(request));  </div><div class="line">                session.setUserAgent(request.getHeader("User-Agent"));  </div><div class="line">                session.setSystemHost(request.getLocalAddr() + ":" + request.getLocalPort());  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return session;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;shiro提供了完整的会话功能，不依赖于底层容器，即直接使用shiro的会话管理可以直接替换掉web容器的会话管理&lt;/p&gt;
&lt;h4 id=&quot;
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro之jstl标签</title>
    <link href="http://www.myzwl.win/2017/07/04/shiro_4/"/>
    <id>http://www.myzwl.win/2017/07/04/shiro_4/</id>
    <published>2017-07-04T05:48:51.000Z</published>
    <updated>2017-07-15T12:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shiro提供了JSTL标签用于在页面进行权限控制</p>
<h4 id="导入标签库"><a href="#导入标签库" class="headerlink" title="导入标签库"></a>导入标签库</h4><blockquote>
<p>&lt;%@taglib prefix=”shiro” uri=”<a href="http://shiro.apache.org/tags" target="_blank" rel="external">http://shiro.apache.org/tags</a>“ %&gt; </p>
</blockquote>
<h4 id="各类标签"><a href="#各类标签" class="headerlink" title="各类标签"></a>各类标签</h4><p><strong>guest标签</strong></p>
<blockquote>
<p><shiro:guest><br>欢迎游客访问，<br></shiro:guest></p>
</blockquote>
<p>用户没有身份验证时显示相应信息，即游客访问信息</p>
<p><strong>user标签 </strong></p>
<blockquote>
<p>   <shiro:user><br>    欢迎[<shiro:principal>]登录<br>    </shiro:principal></shiro:user>   </p>
</blockquote>
<p>用户已经身份验证/记住我登录后显示相应的信息。</p>
<p><strong>authenticated标签 </strong></p>
<blockquote>
<p> shiro:authenticated&gt;<br>     </p>
</blockquote>
<p> 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。</p>
<p><strong>notAuthenticated标签</strong></p>
<blockquote>
<p>  <shiro:notauthenticated><br>     </shiro:notauthenticated></p>
</blockquote>
<p> 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证</p>
<p><strong>principal标签</strong></p>
<blockquote>
<shiro: principal="">

</shiro:></blockquote>
<p> 显示用户身份信息，默认调用Subject.getPrincipal()获取，即Primary Principal。</p>
<p><strong>hasRole标签</strong></p>
<blockquote>
<p> <shiro:hasrole name="admin"><br>    用户[<shiro:principal>]拥有角色admin<br><br>    </shiro:principal></shiro:hasrole></p>
</blockquote>
<p> 如果当前Subject有角色将显示body体内容</p>
<p><strong>hasAnyRoles标签</strong></p>
<blockquote>
<pre><code>&lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;    
   &lt;/shiro:hasAnyRoles&gt;   
</code></pre></blockquote>
<p> 如果当前Subject有任意一个角色（或的关系）将显示body体内容</p>
<p><strong>lacksRole标签</strong></p>
<blockquote>
<p>  <shiro:lacksrole name="abc"><br>     </shiro:lacksrole></p>
</blockquote>
<p> 如果当前Subject没有角色将显示body体内容</p>
<p><strong>hasPermission标签</strong></p>
<blockquote>
<p><shiro:haspermission name="user:create"><br>    </shiro:haspermission></p>
</blockquote>
<p> 如果当前Subject有权限将显示body体内容。</p>
<p><strong>lacksPermission标签</strong></p>
<blockquote>
<p> <shiro:lackspermission name="sss:create"><br>     </shiro:lackspermission> </p>
</blockquote>
<p> 如果当前Subject没有权限将显示body体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;shiro提供了JSTL标签用于在页面进行权限控制&lt;/p&gt;
&lt;h4 id=&quot;导入标签库&quot;&gt;&lt;a href=&quot;#导入标签库&quot; class=&quot;h
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro之拦截器机制</title>
    <link href="http://www.myzwl.win/2017/07/03/shiro_3/"/>
    <id>http://www.myzwl.win/2017/07/03/shiro_3/</id>
    <published>2017-07-03T05:48:51.000Z</published>
    <updated>2017-07-15T11:44:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Shiro使用了与Servlet一样的Filter接口进行扩展，还有拦截器是基于java的反射机制，如利用动态代理实现，而平时说的过滤器是基于回调函数的实现，在实现原理上有着本质的区别<br><img src="/images/imgs4/2.gif" alt="Alt text"></p>
<h4 id="拦截器介绍"><a href="#拦截器介绍" class="headerlink" title="拦截器介绍"></a>拦截器介绍</h4><p><strong>NameableFilter</strong><br>顾名思义，就是根据相应拦截器链组装拦截器的名字找到相应的拦截器实例</p>
<p><strong>OncePerRequestFilter</strong><br>该拦截器用于控制一次请求只能走一次拦截器链，默认是开启拦截的</p>
<p><strong>ShiroFilter</strong><br>是整个shiro的入口点，用于拦截需要安全控制的请求进行处理</p>
<p><strong>AdviceFilter</strong><br>该拦截器非常类似于struct中拦截器，同时支持AOP拦截</p>
<blockquote>
<p>boolean preHandle(ServletRequest request, ServletResponse response) throws Exception<br>void postHandle(ServletRequest request, ServletResponse response) throws Exception<br>void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception;  </p>
</blockquote>
<p>preHandler：类似于AOP中的前置增强；在拦截器链执行之前执行；如果返回true则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权）</p>
<p>postHandle：类似于AOP中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）；</p>
<p>afterCompletion：类似于AOP中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源（如解除Subject与线程的绑定之类的）；</p>
<p><strong>PathMatchingFilter</strong><br>提供了基于Ant风格的请求路径匹配功能及拦截器参数解析的功能，如“roles[admin,user]”自动根据“，”分割解析到一个路径参数配置并绑定到相应的路径：</p>
<blockquote>
<p>boolean pathsMatch(String path, ServletRequest request)<br>boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception </p>
</blockquote>
<p>pathsMatch：该方法用于path与请求路径进行匹配的方法；如果匹配返回true；</p>
<p>onPreHandle：在preHandle中，当pathsMatch匹配一个路径后，会调用opPreHandler方法并将路径绑定参数配置传给mappedValue；然后可以在这个方法中进行一些验证（如角色授权），如果验证失败可以返回false中断流程；默认返回true；也就是说子类可以只实现onPreHandle即可，无须实现preHandle。如果没有path与请求路径匹配，默认是通过的（即preHandle返回true）。</p>
<p><strong>AccessControlFilter</strong><br>提供了访问控制的基础功能</p>
<blockquote>
<pre><code>abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;  
boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;  
abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception;   
</code></pre></blockquote>
<pre><code>isAccessAllowed：表示是否允许访问；mappedValue就是[urls]配置中拦截器参数部分，如果允许访问返回true，否则false；
</code></pre><p>onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；如果返回false表示该拦截器实例已经处理了，将直接返回即可。</p>
<p>同时它还有一些扩展的功能</p>
<blockquote>
<p>void setLoginUrl(String loginUrl) //身份验证时使用，默认/login.jsp<br>String getLoginUrl()<br>Subject getSubject(ServletRequest request, ServletResponse response) //获取Subject实例<br>boolean isLoginRequest(ServletRequest request, ServletResponse response)//当前请求是否是登录请求<br>void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException //将当前请求保存起来并重定向到登录页面<br>void saveRequest(ServletRequest request) //将请求保存起来，如登录成功后再重定向回该请求<br>void redirectToLogin(ServletRequest request, ServletResponse response) //重定向到登录页面 </p>
</blockquote>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h4><p>在web容器中，先执行shiro的filter链，再执行servlet容器的filter链，同时shiro的ProxiedFilterChain对Servlet容器的FilterChain进行了代理</p>
<blockquote>
<p>FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain);</p>
</blockquote>
<h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><p>通过自定义拦截器可以扩展一些功能，如动态url-角色/权限访问控制，根据Subject身份信息获取用户信息绑定到Request（即设置通用数据）、验证码验证、在线用户信息的保存等等</p>
<p><strong>扩展OncePerRequestFilter</strong><br>OncePerRequestFilter保证一次请求只调用一次doFilterInternal<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MyOncePerRequestFilter extends OncePerRequestFilter&#123;</div><div class="line">	@Override</div><div class="line">	protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)</div><div class="line">			throws ServletException, IOException &#123;	</div><div class="line">		  System.out.println("once");</div><div class="line">		  chain.doFilter(request, response);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的ini配置文件中</p>
<blockquote>
<p>[filters]<br>myFilter1=com.shiro.web.MyOncePerRequestFilter<br>[urls]<br>/**=myFilter1</p>
</blockquote>
<p>其中[filters]声明拦截器，[urls]执行拦截器</p>
<p><strong>扩展AdviceFilter</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MyAdviceFilter extends AdviceFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">		System.out.println("pre");</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void postHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">	  System.out.println("postHandle");</div><div class="line">		super.postHandle(request, response);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception)</div><div class="line">			throws Exception &#123;</div><div class="line">		System.out.println("afterCompletion");</div><div class="line">		super.afterCompletion(request, response, exception);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>preHandle：进行请求的预处理，然后根据返回值决定是否继续处理（true：继续过滤器链）；可以通过它实现权限控制；</p>
<p>postHandle：执行完拦截器链之后正常返回后执行；</p>
<p>afterCompletion：不管最后有没有异常，afterCompletion都会执行，完成如清理资源功能。</p>
<p><strong>扩展PathMatchingFilter</strong><br>提供了url模式过滤的功能<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyPathMatchingFilter extends PathMatchingFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue)</div><div class="line">			throws Exception &#123;</div><div class="line">		</div><div class="line">		   System.out.println("url matches,config is " + Arrays.toString((String[])mappedValue));  </div><div class="line">	       return true;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>preHandle：会进行url模式与请求url进行匹配，如果匹配会调用onPreHandle；如果没有配置url模式/没有url模式匹配，默认直接返回true；</p>
<p>onPreHandle：如果url模式与请求url匹配，那么会执行onPreHandle，并把该拦截器配置的参数传入。默认什么不处理直接返回true。</p>
<p><strong>扩展AccessControlFilter</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MyAccessControlFilter extends AccessControlFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)</div><div class="line">			throws Exception &#123;</div><div class="line">		System.out.println("isAccessAllowed");  </div><div class="line">        return false;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">		 System.out.println("访问拒绝也不自己处理，继续拦截器链的执行");  </div><div class="line">	        return true;  </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>isAccessAllowed：即是否允许访问，返回true表示允许；</p>
<p>onAccessDenied：表示访问拒绝时是否自己处理，如果返回true表示自己不处理且继续拦截器链执行，返回false表示自己已经处理了（比如重定向到另一个页面）</p>
<p>其中如果isAccessAllowed返回true，onAccessDenied将不执行，反之执行</p>
<h4 id="默认拦截器"><a href="#默认拦截器" class="headerlink" title="默认拦截器"></a>默认拦截器</h4><p>Shiro内置了很多默认的拦截器，比如身份验证、授权等相关的<br><img src="/images/imgs4/3.gif" alt="Alt text"><br><img src="/images/imgs4/4.gif" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Shiro使用了与Servlet一样的Filter接口进行扩展，还有拦截器是基于java的反射机制，如利用动态代理实现，而平时说的过滤器是基
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro之编码加密</title>
    <link href="http://www.myzwl.win/2017/07/02/shiro_2/"/>
    <id>http://www.myzwl.win/2017/07/02/shiro_2/</id>
    <published>2017-07-02T05:48:51.000Z</published>
    <updated>2017-07-14T12:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在涉及数据在网络上的传输时，都要将明文数据加密传输，并且通常情况下的加密都是不可逆的</p>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>shiro内部提供了base64和16进制字符串编码/解码的API支持，如下<br><strong>base64编码/解码</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     String str="123456";	</div><div class="line">String base64Encoded=Base64.encodeToString(str.getBytes());//加密</div><div class="line"> System.out.println(base64Encoded);</div><div class="line">  String str2=Base64.decodeToString(base64Encoded); //解密</div><div class="line">   System.out.println(str2);</div><div class="line">    System.out.println(str.equals(str2));</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>MTIzNDU2<br>123456<br>true</p>
</blockquote>
<p><strong>16进制字符串编码/解码</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     String str="123456";	</div><div class="line">String base64Encoded = Hex.encodeToString(str.getBytes());//加密</div><div class="line"> System.out.println(base64Encoded);</div><div class="line"> String str2 = new String(Hex.decode(base64Encoded.getBytes())); //解密</div><div class="line">   System.out.println(str2);</div><div class="line">    System.out.println(str.equals(str2));</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>313233343536<br>123456<br>true</p>
</blockquote>
<p><strong>byte与string编码/解码</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     String str="123456";</div><div class="line">     byte[] str3=CodecSupport.toBytes(str, "utf-8");  //变成byte数组</div><div class="line">System.out.println(str3);</div><div class="line">String str4=CodecSupport.toString(str3, "utf-8"); //编程String</div><div class="line">System.out.println(str4);</div></pre></td></tr></table></figure></p>
<p>输出结果</p>
<blockquote>
<p>[B@cd51c3<br>123456</p>
</blockquote>
<h4 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h4><p>该算法是一种不可逆的算法，如MD5，SHA等，一般该算法最好需要提供一个salt（盐）来增加破解难度，一般情况下的盐被设置为 密码+用户名+盐，这样只有系统知道盐值，更难被破解</p>
<p><strong>MD5散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  String str = "hello";  </div><div class="line">String salt = "world";  </div><div class="line">String md5 = new Md5Hash(str, salt,2).toString();</div><div class="line">System.out.println(md5);</div></pre></td></tr></table></figure></p>
<p>这里的2是散列次数，即迭代多少次，这里是2次</p>
<blockquote>
<p>556b1a232d4d63a2f3ab87c9535abe25</p>
</blockquote>
<p><strong>其它散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    String str = "hello";  </div><div class="line">String salt = "world";  </div><div class="line">String sha1 = new Sha256Hash(str, salt).toString(); </div><div class="line">String SHA1=new Sha1Hash(str, salt).toString();</div><div class="line">String SHA512=new Sha512Hash(str, salt).toString();</div><div class="line">System.out.println(sha1);</div><div class="line">System.out.println(SHA1);</div><div class="line">System.out.println(SHA512);</div></pre></td></tr></table></figure></p>
<p>相应的输入结果：</p>
<blockquote>
<p>5715790a892990382d98858c4aa38d0617151575<br>3e64afa1cb7d643aa36f63b8d092ad76b1f04ff557abbb3d05f5b9037abf68a6606a8885d51bec8f6f39ee7d0badd504241c3704e777a51c21a9723e285fb9b8</p>
</blockquote>
<p><strong>通用散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String simpleHash = new SimpleHash("SHA-1", str, salt).toString();</div></pre></td></tr></table></figure></p>
<p>其中第一个参数指定采用哪种算法<br>输出结果：</p>
<blockquote>
<p>5715790a892990382d98858c4aa38d0617151575</p>
</blockquote>
<p><strong>默认匹配</strong><br>Shiro提供了HashService，默认提供了DefaultHashService实现。<br>先来看下它的构造函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public DefaultHashService() &#123;</div><div class="line">        this.algorithmName = "SHA-512";//默认算法SHA-512</div><div class="line">        this.iterations = 1; //生成Hash值的迭代次数，默认1</div><div class="line">        this.generatePublicSalt = false; //是否生成公盐，默认false</div><div class="line">        this.rng = new SecureRandomNumberGenerator();//用于生成公盐</div><div class="line">    &#125;</div><div class="line">    String hex = randomNumberGenerator.nextBytes().toHex();//随机生成一个盐</div></pre></td></tr></table></figure></p>
<h4 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h4><p>Shiro还提供对称式加密/解密算法的支持，如AES、Blowfish等<br><strong>AES算法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">AesCipherService aesCipherService = new AesCipherService();</div><div class="line">      aesCipherService.setKeySize(128);//设置key长度</div><div class="line">      //生成key</div><div class="line">      Key key = aesCipherService.generateNewKey();</div><div class="line">      String text = "zwl";</div><div class="line">      //加密</div><div class="line">      String encrptText = aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();</div><div class="line">      //解密</div><div class="line">      String text2 = new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());</div><div class="line">        System.out.println(key.toString());</div><div class="line">      System.out.println(encrptText);</div><div class="line">    System.out.println(text2);</div></pre></td></tr></table></figure></p>
<p>而上面的key就相当于一把钥匙，只有了这把钥匙，就能解密<br>输出结果：</p>
<blockquote>
<p>javax.crypto.spec.SecretKeySpec@176a4<br>a316645482dff96d9c86c64adabc51dee5170232365a3c15dab941dc6b73c2ec<br>zwl</p>
</blockquote>
<p><strong>Blowfish算法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BlowfishCipherService blowfishCipherService = new BlowfishCipherService();</div><div class="line">        blowfishCipherService.setKeySize(128);</div><div class="line">        //生成key</div><div class="line">        Key key = blowfishCipherService.generateNewKey();</div><div class="line">        String text = "zwl";</div><div class="line">        //加密</div><div class="line">        String encrptText = blowfishCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();</div><div class="line">        //解密</div><div class="line">        String text2 = new String(blowfishCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes()); </div><div class="line">        System.out.println(key.toString());</div><div class="line">       System.out.println(encrptText);</div><div class="line">      System.out.println(text2);</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>javax.crypto.spec.SecretKeySpec@d97afa5c<br>8e7f6626884b7b429a1000286f4990a4<br>zwl</p>
</blockquote>
<h4 id="PasswordService-CredentialsMatcher"><a href="#PasswordService-CredentialsMatcher" class="headerlink" title="PasswordService/CredentialsMatcher"></a>PasswordService/CredentialsMatcher</h4><p>在用户输入明文密码时，shiro默认的实现方式如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public interface PasswordService &#123;  </div><div class="line">    //输入明文密码得到密文密码  </div><div class="line">    String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">    public interface CredentialsMatcher &#123;  </div><div class="line">    //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）  </div><div class="line">    boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Shiro默认提供了PasswordService实现DefaultPasswordService；CredentialsMatcher实现PasswordMatcher及HashedCredentialsMatcher</p>
<p>关于shiro的编码\加密是在是丰富多多彩，一般是学习中遇到采取查询相关的</p>
<h4 id="一个对称加密的算法"><a href="#一个对称加密的算法" class="headerlink" title="一个对称加密的算法"></a>一个对称加密的算法</h4><p>下面是在一个项目中使用到的工具类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div></pre></td><td class="code"><pre><div class="line">public class DesUtils &#123;</div><div class="line">	/** 字符串默认键值     */</div><div class="line">	  private static String strDefaultKey = "national";</div><div class="line"></div><div class="line">	  /** 加密工具     */</div><div class="line">	  private Cipher encryptCipher = null;</div><div class="line"></div><div class="line">	  /** 解密工具     */</div><div class="line">	  private Cipher decryptCipher = null;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 将byte数组转换为表示16进制值的字符串， 如：byte[]&#123;8,18&#125;转换为：0813， 和public static byte[]  </div><div class="line">	   * hexStr2ByteArr(String strIn) 互为可逆的转换过程  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需要转换的byte数组  </div><div class="line">	   * @return 转换后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   *             本方法不处理任何异常，所有异常全部抛出  </div><div class="line">	   */</div><div class="line">	  public static String byteArr2HexStr(byte[] arrB) throws Exception &#123;</div><div class="line">	    int iLen = arrB.length;</div><div class="line">	    // 每个byte用两个字符才能表示，所以字符串的长度是数组长度的两倍   </div><div class="line">	    StringBuffer sb = new StringBuffer(iLen * 2);</div><div class="line">	    for (int i = 0; i &lt; iLen; i++) &#123;</div><div class="line">	      int intTmp = arrB[i];</div><div class="line">	      // 把负数转换为正数   </div><div class="line">	      while (intTmp &lt; 0) &#123;</div><div class="line">	        intTmp = intTmp + 256;</div><div class="line">	      &#125;</div><div class="line">	      // 小于0F的数需要在前面补0   </div><div class="line">	      if (intTmp &lt; 16) &#123;</div><div class="line">	        sb.append("0");</div><div class="line">	      &#125;</div><div class="line">	      sb.append(Integer.toString(intTmp, 16));</div><div class="line">	    &#125;</div><div class="line">	    return sb.toString();</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 将表示16进制值的字符串转换为byte数组， 和public static String byteArr2HexStr(byte[] arrB)  </div><div class="line">	   * 互为可逆的转换过程  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需要转换的字符串  </div><div class="line">	   * @return 转换后的byte数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   *             本方法不处理任何异常，所有异常全部抛出  </div><div class="line">	   *  </div><div class="line">	   */</div><div class="line">	  public static byte[] hexStr2ByteArr(String strIn) throws Exception &#123;</div><div class="line">	    byte[] arrB = strIn.getBytes();</div><div class="line">	    int iLen = arrB.length;</div><div class="line"></div><div class="line">	    // 两个字符表示一个字节，所以字节数组长度是字符串长度除以2   </div><div class="line">	    byte[] arrOut = new byte[iLen / 2];</div><div class="line">	    for (int i = 0; i &lt; iLen; i = i + 2) &#123;</div><div class="line">	      String strTmp = new String(arrB, i, 2);</div><div class="line">	      arrOut[i / 2] = (byte) Integer.parseInt(strTmp, 16);</div><div class="line">	    &#125;</div><div class="line">	    return arrOut;</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 默认构造方法，使用默认密钥  </div><div class="line">	   *   </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public DesUtils() throws Exception &#123;</div><div class="line">	    this(strDefaultKey);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 指定密钥构造方法  </div><div class="line">	   *   </div><div class="line">	   * @param strKey  </div><div class="line">	   *            指定的密钥  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public DesUtils(String strKey) throws Exception &#123;</div><div class="line">	    //Security.addProvider(new com.sun.crypto.provider.SunJCE());</div><div class="line">	    Key key = getKey(strKey.getBytes());</div><div class="line"></div><div class="line">	    encryptCipher = Cipher.getInstance("DES");</div><div class="line">	    encryptCipher.init(Cipher.ENCRYPT_MODE, key);</div><div class="line"></div><div class="line">	    decryptCipher = Cipher.getInstance("DES");</div><div class="line">	    decryptCipher.init(Cipher.DECRYPT_MODE, key);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 加密字节数组  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需加密的字节数组  </div><div class="line">	   * @return 加密后的字节数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public byte[] encrypt(byte[] arrB) throws Exception &#123;</div><div class="line">	    return encryptCipher.doFinal(arrB);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 加密字符串  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需加密的字符串  </div><div class="line">	   * @return 加密后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public String encrypt(String strIn) throws Exception &#123;</div><div class="line">	    return byteArr2HexStr(encrypt(strIn.getBytes()));</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 解密字节数组  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需解密的字节数组  </div><div class="line">	   * @return 解密后的字节数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public byte[] decrypt(byte[] arrB) throws Exception &#123;</div><div class="line">	    return decryptCipher.doFinal(arrB);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 解密字符串  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需解密的字符串  </div><div class="line">	   * @return 解密后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public String decrypt(String strIn) throws Exception &#123;</div><div class="line">	    return new String(decrypt(hexStr2ByteArr(strIn)));</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 从指定字符串生成密钥，密钥所需的字节数组长度为8位 不足8位时后面补0，超出8位只取前8位  </div><div class="line">	   *   </div><div class="line">	   * @param arrBTmp  </div><div class="line">	   *            构成该字符串的字节数组  </div><div class="line">	   * @return 生成的密钥  </div><div class="line">	   * @throws java.lang.Exception  </div><div class="line">	   */</div><div class="line">	  private Key getKey(byte[] arrBTmp) throws Exception &#123;</div><div class="line">	    // 创建一个空的8位字节数组（默认值为0）   </div><div class="line">	    byte[] arrB = new byte[8];</div><div class="line"></div><div class="line">	    // 将原始字节数组转换为8位   </div><div class="line">	    for (int i = 0; i &lt; arrBTmp.length &amp;&amp; i &lt; arrB.length; i++) &#123;</div><div class="line">	      arrB[i] = arrBTmp[i];</div><div class="line">	    &#125;</div><div class="line"></div><div class="line">	    // 生成密钥   </div><div class="line">	    Key key = new javax.crypto.spec.SecretKeySpec(arrB, "DES");</div><div class="line"></div><div class="line">	    return key;</div><div class="line">	  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在涉及数据在网络上的传输时，都要将明文数据加密传输，并且通常情况下的加密都是不可逆的&lt;/p&gt;
&lt;h2 id=&quot;编码与解码&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>初识shiro</title>
    <link href="http://www.myzwl.win/2017/07/01/shiro_1/"/>
    <id>http://www.myzwl.win/2017/07/01/shiro_1/</id>
    <published>2017-07-01T05:48:51.000Z</published>
    <updated>2017-07-14T09:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考百度上说的<a href="http://shiro.apache.org/download.html" target="_blank" rel="external">Apache Shiro</a>是一个强大易用的java安全框架，提供了认证、授权、加密和会话管理功能，可以为任何应用提供安全保障，而其主要为解决以下四个问题：<br>1、 认证-用户身份识别，常被称为用户登录<br>2、 授权-访问控制<br>3、 密码加密-保护或隐藏数据防止被偷窥<br>4、 会话管理-每用户相关的时间敏感的状态</p>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>以下是从其官网上截取的原理图<br><img src="/images/imgs3/14.gif" alt="Alt text"></p>
<p>可以看出shiro的设计非常精妙，同时它不依赖于任何容器，即在java se和java ee中都可以使用，如果把shiro看做一个不透明的黑盒的话，即认证主体subject提供认证给security manager，其内部封装一些列细节方法去执行认证，这里的验证数据源可以是数据库的或者其他</p>
<p>下面将以用户的登录过程来模拟shiro的执行过程</p>
<p><img src="/images/imgs4/1.gif" alt="Alt text"></p>
<h4 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h4><p><strong>token令牌</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">   @RequestMapping("login")</div><div class="line">public ModelAndView login(@RequestParam("username") String username, @RequestParam("password") String password) &#123;</div><div class="line">	 UsernamePasswordToken token = new UsernamePasswordToken(username, password);</div><div class="line">        Subject subject = SecurityUtils.getSubject();</div><div class="line">        try &#123;</div><div class="line">            subject.login(token);</div><div class="line">        &#125; catch (IncorrectCredentialsException ice) &#123;</div><div class="line">            // 捕获密码错误异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "password error!");</div><div class="line">            return mv;</div><div class="line">        &#125; catch (UnknownAccountException uae) &#123;</div><div class="line">            // 捕获未知用户名异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "username error!");</div><div class="line">            return mv;</div><div class="line">        &#125; catch (ExcessiveAttemptsException eae) &#123;</div><div class="line">            // 捕获错误登录过多的异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "times error");</div><div class="line">            return mv;</div><div class="line">        &#125;</div><div class="line">        catch (AuthenticationException eae) &#123;</div><div class="line">            // 捕获错误登录过多的异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "times error");</div><div class="line">            return mv;</div><div class="line">        &#125;</div><div class="line">        TUserEntity user=tUserService.queryObject(username);</div><div class="line">        subject.getSession().setAttribute("user", user);   </div><div class="line">         return new ModelAndView("index");	 </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这里该方法接收到前台传递过来的username和password信息，类比身份证，姓名是认证，但是身份证号码是作为认证的唯一凭证，只有身份证号码正确了，这个认证也就通过了，而这里的token可以理解为用户登录的令牌，里面记录着认证信息，然后交给shiro去验证<br> 接下来就是执行登录动作了</p>
<blockquote>
<p>SecurityUtils.setSecurityManager(securityManager); // 注入SecurityManager<br>Subject subject = SecurityUtils.getSubject(); // 获取Subject单例对象<br>subject.login(token); // 登陆</p>
</blockquote>
<p>其中SecurityManager是一个单例对象，即全局变量，接着SecurityUtils会自动绑定当前线程，获得subject主体，关于subject可以这样理解其包含两个信息:<br>Principals： 身份，可以是用户名，邮件，手机号码等等，用来标识一个登陆主体身份；<br>Credentials： 凭证，常见有密码，数字证书等等；<br>最后就是登陆了，最后通过验证token是否合法返回不同结果</p>
<h4 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h4><p>根据流程图，接下来security manager开始执行一系列的认证手段了，其中最主要的就是<br>AuthorizationInfo（角色权限认证），AuthenticationInfo（身份认证），可以简单这样理解，身份认证只是验证了这个subject的存在性，如果约定subject有某些权限，如管理员有删除或者访问某些url地址权限，而这个管理员就可以抽象为角色，也就是说权限是访问资源的权利集合，而角色是权限的集合</p>
<p>最后的realm域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色，权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源</p>
<p>一般情况下realm需要我们自定义去实现，因为shiro不知道哪些token是合法的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">  public class OAuth2Realm extends AuthorizingRealm&#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	private TUserService tUserService;</div><div class="line">	</div><div class="line">	/**</div><div class="line">     * 提供用户信息返回权限信息</div><div class="line">     */</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</div><div class="line">	</div><div class="line">		String username = (String) principals.getPrimaryPrincipal();</div><div class="line">		 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();</div><div class="line">		   TUserEntity user=tUserService.queryObject(username);</div><div class="line">	        // 根据id查询当前用户拥有的角色</div><div class="line">		  List&lt;TUserRoleEntity&gt; ture=tUserService.queryRole(user.getId());</div><div class="line">		   Set&lt;TRoleEntity&gt; roles=new HashSet&lt;TRoleEntity&gt;();</div><div class="line">		        for(TUserRoleEntity Tures:ture)&#123;</div><div class="line">		        	roles.add(tUserService.queryObject(Tures.getRoleId()));</div><div class="line">		        &#125;</div><div class="line">		        Set&lt;String&gt; roleNames=new HashSet&lt;String&gt;();</div><div class="line">		         for(TRoleEntity rolename : roles)&#123;</div><div class="line">		    	   roleNames.add(rolename.getRolename());</div><div class="line">		         &#125;</div><div class="line">		      // 将角色名称提供给info</div><div class="line">		      authorizationInfo.setRoles(roleNames);</div><div class="line">		return authorizationInfo;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">     * 提供账户信息返回认证信息</div><div class="line">     */</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</div><div class="line">		</div><div class="line">		String username=(String)token.getPrincipal();   // 获取用户名</div><div class="line">// String password = new String((char[])token.getCredentials()); 得到密码</div><div class="line"></div><div class="line">	UsernamePasswordToken t = (UsernamePasswordToken) token; //得到密码</div><div class="line">		String newPassword=new String(t.getPassword());</div><div class="line">		//根据用户名从数据库取出用户完整信息</div><div class="line">		 TUserEntity tuserEntity=tUserService.queryObject(username);</div><div class="line">		  if(tuserEntity!=null)&#123;</div><div class="line">			  //若存在，将此用户存放到登录认证info中    </div><div class="line">	            return new SimpleAuthenticationInfo(tuserEntity.getUsername(),tuserEntity.getPassword(), ByteSource.Util.bytes("zwl"), getName());  </div><div class="line">		  &#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>该realm类的结果就是根据token的合法性验证返回不同结果给相应的controller，目前只是从宏观上看了一个全过程，shiro是非常强大的，它的功能远不止如此</p>
<h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>缓存的本质就是将原本只能存储在内存中的数据通过算法保存到硬盘上，再根据需求依次取出。可以把缓存理解为一个Map对象，通过put保存对象，再通过get取回对象。这里使用的是Ehcache缓存框架。具体代码如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;ehcache name="es"&gt;</div><div class="line"></div><div class="line">    &lt;diskStore path="java.io.tmpdir"/&gt;</div><div class="line"></div><div class="line">    &lt;!--</div><div class="line">       name:缓存名称。</div><div class="line">       maxElementsInMemory：缓存最大个数。</div><div class="line">       eternal:对象是否永久有效，一但设置了，timeout将不起作用。</div><div class="line">       timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</div><div class="line">       timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</div><div class="line">       overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。</div><div class="line">       diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</div><div class="line">       maxElementsOnDisk：硬盘最大缓存个数。</div><div class="line">       diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</div><div class="line">       diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</div><div class="line">       memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</div><div class="line">       clearOnFlush：内存数量最大时是否清除。</div><div class="line">    --&gt;</div><div class="line"></div><div class="line">    &lt;defaultCache</div><div class="line">            maxEntriesLocalHeap="1000"</div><div class="line">            eternal="false"</div><div class="line">            timeToIdleSeconds="3600"</div><div class="line">            timeToLiveSeconds="3600"</div><div class="line">            overflowToDisk="false"&gt;</div><div class="line">    &lt;/defaultCache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-authenticationCache"</div><div class="line">           maxEntriesLocalHeap="1000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-authorizationCache"</div><div class="line">           maxEntriesLocalHeap="2000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-userCache"</div><div class="line">           maxEntriesLocalHeap="2000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">&lt;/ehcache&gt;</div></pre></td></tr></table></figure></p>
<p>其中<diskstore path="java.io.tmpdir">可以指定缓存的路径，这里是临时路径</diskstore></p>
<h4 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h4><p>通常情况下散列和加密本质上都是一样的，即将一个Object变成一串无意义的字符串，不同点是经过散列的对象无法复原，是一个单向的过程，而加密是可以双向的，即加密与解密，所以如果忘记密码，只能进行修改密码操作，下面是在项目中用到的散列算法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private RandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator();</div><div class="line">private String algorithmName = "md5";</div><div class="line">private final int hashIterations = 2;</div><div class="line"></div><div class="line">public void encryptPassword(TUserEntity user) &#123;</div><div class="line">    // User对象包含最基本的字段Username和Password</div><div class="line">	String salt="zwl";</div><div class="line">    // 将用户的注册密码经过散列算法替换成一个不可逆的新密码保存进数据，散列过程使用了盐</div><div class="line">    String newPassword = new SimpleHash(algorithmName, user.getPassword(),</div><div class="line">            ByteSource.Util.bytes("zwl"), hashIterations).toHex();</div><div class="line">    user.setPassword(newPassword);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中algorithmName为指定运用何种算法，hashIterations为散列次数，也就是数学中的迭代，将前一个结果作为参数在运算一次，salt盐可以理解为有了盐，并且每个盐唯一确定一个散列值，最后产生的newPassword是经过如下类</p>
<blockquote>
<p>public SimpleHash(String algorithmName, Object source, Object salt, int hashIterations) </p>
</blockquote>
<p>四个参数分别标识算法名称，散列对象，散列使用的salt值，散列次数。</p>
<h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>匹配的功能就是用来匹配用户登录使用的令牌和数据库中保存的用户信息是否匹配。它的原始接口是CredentialsMatcher，一般情况下如果不自定义的话就会使用默认的实现类HashedCredentialsMatcher，如下是自定义的匹配<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher&#123;</div><div class="line"></div><div class="line">	// 声明一个缓存接口，这个接口是Shiro缓存管理的一部分，它的具体实现可以通过外部容器注入</div><div class="line">	 private Cache&lt;String, AtomicInteger&gt; passwordRetryCache;</div><div class="line">	 </div><div class="line">	 public RetryLimitHashedCredentialsMatcher(CacheManager cacheManager) &#123;</div><div class="line">	        passwordRetryCache = cacheManager.getCache("passwordRetryCache");</div><div class="line">	    &#125;</div><div class="line">	 </div><div class="line">	 @Override</div><div class="line">	    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123;</div><div class="line">		 String username = (String) token.getPrincipal();</div><div class="line">	        AtomicInteger retryCount = passwordRetryCache.get(username);</div><div class="line">	        if (retryCount == null) &#123;</div><div class="line">	            retryCount = new AtomicInteger(0);</div><div class="line">	            passwordRetryCache.put(username, retryCount);</div><div class="line">	        &#125;</div><div class="line">	        // 自定义一个验证过程：当用户连续输入密码错误5次以上禁止用户登录一段时间</div><div class="line">	        if (retryCount.incrementAndGet() &gt; 5) &#123;</div><div class="line">	            throw new ExcessiveAttemptsException();</div><div class="line">	        &#125;</div><div class="line">	        boolean match = super.doCredentialsMatch(token, info);</div><div class="line">	        if (match) &#123;</div><div class="line">	            passwordRetryCache.remove(username);</div><div class="line">	        &#125;</div><div class="line">	        return match;</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般情况下，匹配的异常的结果都会抛出相应的异常，如 DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等</p>
<p>而针对获得realm数据源的情况，会设置五张表，分别是用户表（存储用户名，密码，盐等）、角色表（角色名称，相关描述等）、权限表（权限名称，相关描述等）、用户-角色对应中间表（以用户ID和角色ID作为联合主键）、角色-权限对应中间表（以角色ID和权限ID作为联合主键），其中用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>用户的一次登录即为一次会话，即session，Shiro也可以代替Tomcat等容器管理会话。而针对会话，可以处理的情况太多了，如记录用户信息和行为等等，比如保存用户信息</p>
<blockquote>
<p>TUserEntity user=tUserService.queryObject(username);<br>    subject.getSession().setAttribute(“user”, user); </p>
</blockquote>
<h4 id="ssm-shiro集成"><a href="#ssm-shiro集成" class="headerlink" title="ssm+shiro集成"></a>ssm+shiro集成</h4><p>web.xml中的配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"</div><div class="line">         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee</div><div class="line">                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</div><div class="line">         version="3.0"&gt;</div><div class="line"></div><div class="line">    &lt;!-- 修改 Servlet 版本--&gt;</div><div class="line">    &lt;!-- 配置 DispatcherServlet--&gt;</div><div class="line">    &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</div><div class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">        &lt;init-param&gt;</div><div class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">            &lt;param-value&gt;</div><div class="line">                classpath:spring/spring-web.xml</div><div class="line">            &lt;/param-value&gt;</div><div class="line">        &lt;/init-param&gt;</div><div class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">        &lt;async-supported&gt;true&lt;/async-supported&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">    &lt;context-param&gt;</div><div class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;</div><div class="line">            classpath:spring/spring-service.xml,</div><div class="line">            classpath:spring/spring-dao.xml,</div><div class="line">            classpath:spring/spring-shiro.xml</div><div class="line">        &lt;/param-value&gt;</div><div class="line">    &lt;/context-param&gt;</div><div class="line"></div><div class="line">    &lt;listener&gt;</div><div class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</div><div class="line">    &lt;/listener&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;!-- 添加 Shiro 相关配置(应该去官网查询相应的配置信息) --&gt;</div><div class="line"></div><div class="line">    &lt;!-- The filter-name matches name of a 'shiroFilter' bean inside applicationContext.xml --&gt;</div><div class="line">    &lt;filter&gt;</div><div class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</div><div class="line">        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</div><div class="line">        &lt;init-param&gt;</div><div class="line">            &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;</div><div class="line">            &lt;param-value&gt;true&lt;/param-value&gt;</div><div class="line">        &lt;/init-param&gt;</div><div class="line">    &lt;/filter&gt;</div><div class="line"></div><div class="line">    &lt;filter-mapping&gt;</div><div class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</div><div class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">    &lt;/filter-mapping&gt;</div><div class="line"></div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>其中主要关心的是web容器将将Shiro的配置文件交给Spring监听器初始化以及配置了shiro的过滤等<br>这里shiro的配置都在spring-shiro.xml中配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">       xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">       xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">       xsi:schemaLocation="</div><div class="line">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</div><div class="line">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</div><div class="line">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;!-- 声明一个密码匹配器 --&gt;</div><div class="line">    &lt;bean id="credentialsMatcher" class="com.hfsf.sys.oauth2.RetryLimitHashedCredentialsMatcher"&gt;</div><div class="line">        &lt;!-- 设置该密码匹配器使用的算法是 md5 --&gt;</div><div class="line">      &lt;property name="hashAlgorithmName" value="md5"/&gt;</div><div class="line">     &lt;property name="hashIterations" value="2" /&gt;</div><div class="line">      &lt;property name="storedCredentialsHexEncoded" value="true" /&gt; </div><div class="line">      &lt;constructor-arg ref="ehCacheManager" /&gt; </div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 声明一个自定义的 Realm --&gt;</div><div class="line">    &lt;bean id="myRealm" class="com.hfsf.sys.oauth2.OAuth2Realm"&gt;</div><div class="line">        &lt;!-- 将上面声明的密码匹配器注入到自定义 Realm 的属性中去 --&gt;</div><div class="line">        &lt;property name="credentialsMatcher" ref="credentialsMatcher"/&gt;</div><div class="line">        &lt;!-- 将自定义的权限匹配器注入到自定义 Realm 中 --&gt;</div><div class="line">        &lt;property name="permissionResolver" ref="permissionResolver"/&gt;</div><div class="line"></div><div class="line">        &lt;!-- 配置缓存相关 --&gt;</div><div class="line">        &lt;!-- 启用缓存 --&gt;</div><div class="line">        &lt;property name="cachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 开启认证缓存--&gt;</div><div class="line">        &lt;property name="authenticationCachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 指定认证缓存的名字(与 ehcache.xml 中声明的相同) --&gt;</div><div class="line">        &lt;property name="authenticationCacheName" value="shiro-authenticationCache"/&gt;</div><div class="line">        &lt;!--开启授权缓存--&gt;</div><div class="line">        &lt;property name="authorizationCachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 指定授权缓存的名字(与 ehcache.xml 中声明的相同) --&gt;</div><div class="line">        &lt;property name="authorizationCacheName" value="shiro-authorizationCache"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 自定义一个权限匹配器 --&gt;</div><div class="line">    &lt;bean id="permissionResolver" class="com.hfsf.sys.oauth2.UrlPermissionResolver"/&gt;</div><div class="line"></div><div class="line">    &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt;</div><div class="line">        &lt;property name="securityManager" ref="securityManager"/&gt;</div><div class="line">        &lt;!-- 如果认证不通过,浏览器通过 Get 方式请求到 /login 上 --&gt;</div><div class="line">        &lt;property name="loginUrl" value="/login.jsp"/&gt;</div><div class="line"></div><div class="line">        &lt;!-- override these for application-specific URLs if you like:</div><div class="line"></div><div class="line">        &lt;property name="successUrl" value="/home.jsp"/&gt;</div><div class="line">        &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; --&gt;</div><div class="line"> </div><div class="line">        &lt;!-- defined will be automatically acquired and available via its beanName in chain        --&gt;</div><div class="line">       </div><div class="line">        &lt;property name="filterChainDefinitions"&gt;</div><div class="line">            &lt;value&gt;</div><div class="line"></div><div class="line">               /authc/admin = roles[admin]</div><div class="line">                /authc/** = authc</div><div class="line">                /** = anon</div><div class="line">            &lt;/value&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 声明一个自定义的过滤器 --&gt;</div><div class="line">    &lt;bean id="resourceCheckFilter" class="com.hfsf.common.xss.ResourceCheckFilter"&gt;</div><div class="line">        &lt;!-- 为上面声明的自定义过滤器注入属性值 --&gt;</div><div class="line">        &lt;property name="errorUrl" value="/unAuthorization"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt;</div><div class="line">        &lt;!-- Single realm app.  If you have multiple realms, use the 'realms' property instead. --&gt;</div><div class="line">        &lt;!-- 设置安全管理器的安全数据源为自定义的 Realm --&gt;</div><div class="line">        &lt;property name="realm" ref="myRealm"/&gt;</div><div class="line">        &lt;!-- By default the servlet container sessions will be used.  Uncomment this line</div><div class="line">             to use shiro's native sessions (see the JavaDoc for more): --&gt;</div><div class="line">        &lt;!-- &lt;property name="sessionMode" value="native"/&gt; --&gt;</div><div class="line">        &lt;property name="cacheManager" ref="ehCacheManager"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    </div><div class="line">  </div><div class="line">   </div><div class="line">    &lt;!-- 配置 shiro 的 ehcache 缓存相关,这个缓存只和 Realm 相关 --&gt;</div><div class="line">    &lt;bean id="ehCacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 配置 Spring 的 EhCacheManagerFactoryBean ,须要 spring-context-support 的支持 --&gt;</div><div class="line">    &lt;bean id="ehCacheManagerFactoryBean" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt;</div><div class="line">        &lt;property name="configLocation" value="classpath:ehcache.xml"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 配置 Spring 的 EhCacheCacheManager,须要 spring-context-support 的支持 --&gt;</div><div class="line">    &lt;bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager"&gt;</div><div class="line">        &lt;property name="cacheManager" ref="ehCacheManagerFactoryBean"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>其中最主要的是filterChainDefinitions，这里声明了权限控制用户访问哪些url，而且访问是有顺序的，即执行了前者后者将不再执行，其中anon为匿名访问，authc为需要身份认证通过才可以访问，这里的内容较多，具体参考官方文档</p>
<p>最后只要通过前台页面提交数据，经过一系列流程，最终就可以完成权限控制了，事实上shiro的内容很多，而且很丰富，只有不断在实践中踩坑，学习，总结才能更好的认识和运用它</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考百度上说的&lt;a href=&quot;http://shiro.apache.org/download.html&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>设计模式原则笔记</title>
    <link href="http://www.myzwl.win/2017/05/11/jd1/"/>
    <id>http://www.myzwl.win/2017/05/11/jd1/</id>
    <published>2017-05-11T05:48:51.000Z</published>
    <updated>2017-06-30T02:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在编程语言中除了各种不同的设计模式外，它们也可以被抽出一些共性</p>
<p>开闭原则：一个软件实体应当对开展开放，对修改关闭（玉帝招安美猴王）</p>
<p>面向对象解释： 不予以更改的是抽象层，但是可以扩展的是实现层</p>
<p>对可变性的封装原则： 找到一个系统的可变因素，将之封装起来</p>
<p>继承应当是看做封装的方法，而不应该被认为是从一般对象方法到特殊对象的生成方法</p>
<p>里氏代换原则： 任何基类可以出现的地方，子类一定可以出现</p>
<p>两个类共同行为抽象到一个c类<br>B继承A改为聚合B（白马与黑马，正方形与长方形）</p>
<p>依赖倒转原则： 要依赖于抽象，不要依赖于实现<br>抽象类仅提供一个类型的部分实现，可以同时有抽象方法和具体方法<br>具体类不是用来继承的<br>如果两个具体类存在继承关系，要引入第三个类作为他们的共同的接口<br>抽象类应该拥有尽可能多共同代码<br>抽象类应当拥有尽可能少的数据</p>
<p>接口隔离原则： 应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</p>
<p>角色的合理划分<br>定制服务<br>接口污染</p>
<p>合成/聚合复用原则： 要尽量使用合成/聚合，而不是继承关系达到复用的目的<br>合成是值得聚合，聚合是引用的聚合<br>Is-A 代表一个类是另一个类的一种，Has-A代表一个类是另一个类的角色，而不是另一个类的特殊类（人与角色）</p>
<p>迪米特法则： 一个软件实体应当尽可能少的与其他实体发生相互作用</p>
<p>java接口： 一些方法特征的集合<br>没有接口会造成硬代码问题直接导致可插入性没有保证<br>java接口用来声明一个新的类型<br>单方法接口（如Runnable）<br>标识接口（serialzable）<br>常量接口</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编程语言中除了各种不同的设计模式外，它们也可以被抽出一些共性&lt;/p&gt;
&lt;p&gt;开闭原则：一个软件实体应当对开展开放，对修改关闭（玉帝招安美猴王）&lt;/p&gt;
&lt;p&gt;面向对象解释： 不予以更改的是抽象层，但是可以扩展的是实现层&lt;/p&gt;
&lt;p&gt;对可变性的封装原则： 找到一个系统的可
    
    </summary>
    
      <category term="java与设计" scheme="http://www.myzwl.win/categories/java%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java与设计" scheme="http://www.myzwl.win/source/tags/java%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Shiro之通过数据库验证身份</title>
    <link href="http://www.myzwl.win/2017/04/14/shiro1/"/>
    <id>http://www.myzwl.win/2017/04/14/shiro1/</id>
    <published>2017-04-14T05:48:51.000Z</published>
    <updated>2017-07-14T11:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考百度上说的<a href="http://shiro.apache.org/download.html" target="_blank" rel="external">Apache Shiro</a>是一个强大易用的java安全框架，提供了认证、授权、加密和会话管理功能，可以为任何应用提供安全保障，而其主要为解决以下四个问题：<br>1、 认证-用户身份识别，常被称为用户登录<br>2、 授权-访问控制<br>3、 密码加密-保护或隐藏数据防止被偷窥<br>4、 会话管理-每用户相关的时间敏感的状态</p>
<h4 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h4><p>以下是从其官网上截取的原理图<br><img src="/images/imgs3/14.gif" alt="Alt text"></p>
<h4 id="Subject认证主体"><a href="#Subject认证主体" class="headerlink" title="Subject认证主体"></a>Subject认证主体</h4><p>其中认证主体包含两个信息:<br>Principals： 身份，可以是用户名，邮件，手机号码等等，用来标识一个登陆主体身份；<br>Credentials： 凭证，常见有密码，数字证书等等；</p>
<h4 id="Realm-amp-JDBC-amp-Reaml"><a href="#Realm-amp-JDBC-amp-Reaml" class="headerlink" title="Realm&amp;JDBC&amp;Reaml"></a>Realm&amp;JDBC&amp;Reaml</h4><p>Realm：意思是域，Shiro从Reaml中获取验证数据；<br>Realm有很多种类，例如常见的jdbc realm</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>1.在eclipse中新建一个maven工程，并且配置pom.xml<br>主要配置如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;dependencies&gt;</div><div class="line"></div><div class="line">  	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span>&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">1.2</span>.<span class="number">4</span>&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    </div><div class="line">    &lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">1.7</span>.<span class="number">12</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;c3p0&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;c3p0&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">0.9</span>.<span class="number">1.2</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;commons-logging&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">1.2</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">5.1</span>.<span class="number">37</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line"></div><div class="line">  &lt;/dependencies&gt;</div></pre></td></tr></table></figure></p>
<p>主要有shiro的核心包、日志包，数据源及数据库连接包</p>
<ol>
<li>在resource包下新建jdbc_realm.ini用于配置从数据库中获取验证数据<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[main]   <span class="comment">//声明以下是代码片段</span></div><div class="line"><span class="comment">//相当于new了一个jdbcRealm类</span></div><div class="line">jdbcRealm=org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.realm</span><span class="selector-class">.jdbc</span><span class="selector-class">.JdbcRealm</span></div><div class="line"><span class="comment">//声明一个数据源，这里用了c3p0</span></div><div class="line">dataSource=com<span class="selector-class">.mchange</span><span class="selector-class">.v2</span><span class="selector-class">.c3p0</span><span class="selector-class">.ComboPooledDataSource</span></div><div class="line"><span class="comment">//声明驱动</span></div><div class="line">dataSource.driverClass=com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span></div><div class="line"><span class="comment">//声明url，其中localhost可更改为ip地址</span></div><div class="line">dataSource.jdbcUrl=jdbc:mysql:<span class="comment">//localhost:9806/db_shiro</span></div><div class="line"><span class="comment">//配置数据库用户名、密码</span></div><div class="line">dataSource.user=root</div><div class="line">dataSource.password=root</div><div class="line"><span class="comment">//添加数据源</span></div><div class="line">jdbcRealm.dataSource=<span class="variable">$dataSource</span></div><div class="line"><span class="comment">//添加数据域</span></div><div class="line">securityManager.realms=<span class="variable">$jdbcRealm</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里数据库中需要注意的是，数据库中的表名必须为users，并且字段必须为userName和password</p>
<ol>
<li>在src/main/java文件下新建一个HelloWorld类，目前数据这里手动构造一个<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package com.zwl.shiro;</div><div class="line"></div><div class="line">import org.apache.shiro.SecurityUtils;</div><div class="line">import org.apache.shiro.authc.AuthenticationException;</div><div class="line">import org.apache.shiro.authc.UsernamePasswordToken;</div><div class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</div><div class="line">import org.apache.shiro.mgt.SecurityManager;</div><div class="line">import org.apache.shiro.subject.Subject;</div><div class="line">import org.apache.shiro.util.Factory;</div><div class="line"></div><div class="line">public class HelloWorld &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//读取配置文件，初始化SecurityManager工厂</div><div class="line">	   Factory&lt;SecurityManager&gt; factory=new IniSecurityManagerFactory("classpath:jdbc_realm.ini");</div><div class="line">	    //获取SecurityManager实例</div><div class="line">	   SecurityManager securityManager=factory.getInstance();</div><div class="line">	   //把SecurityManager实例绑定到SecurityUtils</div><div class="line">	   SecurityUtils.setSecurityManager(securityManager);</div><div class="line">	   //得到当前执行的用户</div><div class="line">	   Subject currentUser=SecurityUtils.getSubject();</div><div class="line">	   //创建token令牌，用户名/密码</div><div class="line">	   UsernamePasswordToken token=new UsernamePasswordToken("admin", "123456");</div><div class="line">	   try &#123;</div><div class="line">		//身份认证</div><div class="line">		  currentUser.login(token);</div><div class="line">		  System.out.println("身份认证成功！");</div><div class="line">	&#125; catch (AuthenticationException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		System.out.println("身份认证失败！");</div><div class="line">	&#125;</div><div class="line">	        // 退出</div><div class="line">			currentUser.logout();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里通过更改token来模拟验证数据是否正确</p>
<p>相关源代码，已放在<a href="https://github.com/slycmiaoxi/slycmx.github.io/tree/b" target="_blank" rel="external">github</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考百度上说的&lt;a href=&quot;http://shiro.apache.org/download.html&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>并发系列之四Guarded Suspension</title>
    <link href="http://www.myzwl.win/2017/04/13/thrd4/"/>
    <id>http://www.myzwl.win/2017/04/13/thrd4/</id>
    <published>2017-04-13T05:48:51.000Z</published>
    <updated>2017-04-20T11:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Guarded Suspension是指当现在并不适合马上执行某个操作时，就要求想要执行该操作的线程等待</p>
<h4 id="Guarded-Suspension"><a href="#Guarded-Suspension" class="headerlink" title="Guarded Suspension"></a>Guarded Suspension</h4><p>首先模拟一个案例<br>首先是表示请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public class Request &#123;</div><div class="line">private final String name;</div><div class="line"></div><div class="line">public Request(String name)&#123;</div><div class="line">	this.name=name;</div><div class="line">&#125;</div><div class="line">public String getName()&#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String toString()&#123;</div><div class="line">	return "[ Request"+name+"]";</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一次存放请求以待使用的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.LinkedList;</div><div class="line"></div><div class="line">public class RequestQueue &#123;</div><div class="line"></div><div class="line">  //构造链表，用来保存请求</div><div class="line">	private final LinkedList queue=new LinkedList&lt;&gt;();</div><div class="line">//有请求将最早的请求取出，没有则等待</div><div class="line">	public synchronized Request getRequest()&#123;</div><div class="line">		while(queue.size()&lt;=0)&#123;</div><div class="line">			try&#123;</div><div class="line">				wait();</div><div class="line">			&#125;catch(Exception e)&#123;</div><div class="line">				</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return (Request) queue.removeFirst();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//增加一个请求</div><div class="line">	public synchronized void putRequest(Request request)&#123;</div><div class="line">		queue.addLast(request);</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>送出请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class ClientThread extends Thread &#123;</div><div class="line">  //构造随机数，用来线程等待时间</div><div class="line">	private Random random;</div><div class="line">	//存放请求</div><div class="line">	private RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	public ClientThread(RequestQueue requestQueue,String name,long seed)&#123;</div><div class="line">		super(name);</div><div class="line">		this.requestQueue=requestQueue;</div><div class="line">		this.random=new Random(seed);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">//不断调用putrequest（），并且打印相关信息</div><div class="line">		for(int i=0;i&lt;10000;i++)&#123;</div><div class="line">			Request request=new Request("No ."+i);</div><div class="line">			System.out.println(Thread.currentThread().getName()+" Request:"+request);</div><div class="line">			requestQueue.putRequest(request);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(random.nextInt(1000));</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO: handle exception</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接收请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class ServerThread extends Thread &#123;</div><div class="line">	private Random random;</div><div class="line">	private RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	public ServerThread(RequestQueue requestQueue,String name,long seed)&#123;</div><div class="line">		super(name);</div><div class="line">		this.requestQueue=requestQueue;</div><div class="line">		this.random=new Random(seed);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">	//不断调用getrequest（）</div><div class="line">		for(int i=0;i&lt;10000;i++)&#123;</div><div class="line">			Request request=requestQueue.getRequest();</div><div class="line">			System.out.println(Thread.currentThread().getName()+" Handlet:"+request);</div><div class="line">			</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(random.nextInt(1000));</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO: handle exception</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后是测试<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RequestQueue requestQueue=new RequestQueue();</div><div class="line">		new ClientThread(requestQueue, "A", 1314520l).start();</div><div class="line">		new ServerThread(requestQueue, "B", 5201314l).start();</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>A Request:[ RequestNo .0]<br>B Handlet:[ RequestNo .0]<br>A Request:[ RequestNo .1]<br>B Handlet:[ RequestNo .1]<br>A Request:[ RequestNo .2]<br>B Handlet:[ RequestNo .2]<br>……</p>
</blockquote>
<p>从测试结果可以看出，当发送请求时，接受并处理<br>而其中的关键方法是getRequest（）中，当满足while里条件时，则调用wait，处于等待，直到收到通知，才从休息区出来，而这种一定要满足的条件，就称为Guarded Suspension的警戒条件</p>
<p>所以可将该模式抽象为如下<br>GuardedObject（被防伪的对象）参与者：当线程执行guardMethod时，只要满足警戒条件，就马上执行，当不成立时，就开始等待，而条件的成立与否，是与参与者的状态变化有关<br>guardMethod：防伪的方法<br>stateChangingMethod：状态改变的方法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Guarded Suspension是指当现在并不适合马上执行某个操作时，就要求想要执行该操作的线程等待&lt;/p&gt;
&lt;h4 id=&quot;Guard
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发系列之三Immutable</title>
    <link href="http://www.myzwl.win/2017/04/12/thrd3/"/>
    <id>http://www.myzwl.win/2017/04/12/thrd3/</id>
    <published>2017-04-12T05:48:51.000Z</published>
    <updated>2017-07-14T07:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>immutable是指永恒，不会改变的意思，就像java.lang.String类中，并没有提供任何改变字符串属性的方法</p>
<h4 id="immutable-Pattern"><a href="#immutable-Pattern" class="headerlink" title="immutable Pattern"></a>immutable Pattern</h4><p>首先模拟一个案例<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public final class Person &#123;</div><div class="line">//不允许修改的地址</div><div class="line">private final String address;</div><div class="line">//不允许修改的姓名</div><div class="line">private final String name;</div><div class="line">public Person(String name, String address) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.address = address;</div><div class="line">&#125;</div><div class="line">//有final就不会有set方法，控制外部对其的修改</div><div class="line">public String getAddress() &#123;</div><div class="line">	return address;</div><div class="line">&#125;</div><div class="line">public String getName() &#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String toString()&#123;</div><div class="line">	return "[ Person: name="+name+ ",address="+address+"]";</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是人的线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public class PersonThread extends Thread &#123;</div><div class="line"></div><div class="line">	private Person person;</div><div class="line"></div><div class="line">	public PersonThread(Person person) &#123;</div><div class="line">		this.person = person;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">		while(true)&#123;</div><div class="line">		//得到线程的名并打印出人的信息</div><div class="line">			System.out.println(Thread.currentThread().getName()+"prints"+person);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person person=new Person("A1","AA");</div><div class="line">	new PersonThread(person).start();</div><div class="line">	new PersonThread(person).start();</div><div class="line">	new PersonThread(person).start();</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>以下一直重复</p>
</blockquote>
<p>可以发现上面的字段都是final并且没有修改该字段的方法<br>正因为如此，所以就不需要使用synchronized来限制，这在性能上就大大提高了</p>
<h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><p>1.当实例产生后，状态不再变化时<br>2.实例需要共享，而且访问很频繁时</p>
<p>当然，有时也需要变与不变的转换，就像StringBuffer是一个线程不安全的类，在它的构造器中有String作为参数，而在String类中也有StringBuffer作为参数<br>另外像java中的基本类型boolean、int、long等都是immutable模式<br>该模式最大的优点就是实例的状态不会改变，所以没必要进行保护</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;immutable是指永恒，不会改变的意思，就像java.lang.String类中，并没有提供任何改变字符串属性的方法&lt;/p&gt;
&lt;h4 i
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发系列之二Single Threaded Execution</title>
    <link href="http://www.myzwl.win/2017/04/11/thrd2/"/>
    <id>http://www.myzwl.win/2017/04/11/thrd2/</id>
    <published>2017-04-11T03:48:51.000Z</published>
    <updated>2017-04-20T04:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Single Threaded Execution是指以一个线程执行，简单来说就是在多线程中限制同时只让一个线程运行</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>首先来模拟一个线程不安全的例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class Gate &#123;</div><div class="line"></div><div class="line">    //记录走过门的人数，默认为0</div><div class="line">	private int count=0;</div><div class="line">	//记录通过门的人的名字</div><div class="line">	private String name="nobody";</div><div class="line">	//记录通过门的人的地址</div><div class="line">	private String address="noplace";</div><div class="line">	</div><div class="line">	//穿越这道门使用的方法</div><div class="line">	public  void pass(String name,String address)&#123;</div><div class="line">		this.name=name;</div><div class="line">		this.address=address;</div><div class="line">		count++;</div><div class="line">		check();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//检查通过门的人的合法性，即人的名字和地址首字母是否相同</div><div class="line">	public void check()&#123;</div><div class="line">		if(name.charAt(0)!=address.charAt(0))&#123;</div><div class="line">			System.out.println("***broken***"+this.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//打印出人数、姓名、地址</div><div class="line">	public  String toString()&#123;</div><div class="line">		return "No."+count+":"+name+" ,"+address;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>目前上面的Gate类是线程不安全的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">//不断穿越门的行人</div><div class="line">public class UserThread extends Thread &#123;</div><div class="line">//用final限制门，姓名，地址不能重复</div><div class="line">private final Gate gate;</div><div class="line">private final String myaddress;</div><div class="line">private final String myname;</div><div class="line">public UserThread(Gate gate, String myname, String myaddress) &#123;</div><div class="line">	super();</div><div class="line">	this.gate = gate;</div><div class="line">	this.myname = myname;</div><div class="line">	this.myaddress = myaddress;</div><div class="line">&#125;</div><div class="line">//发生错误，即行人不合法，则处于死循环，并且执行toString方法</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">	System.out.println(myname+" BEGIN");</div><div class="line">while(true)&#123;</div><div class="line">	gate.pass(myname, myaddress);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">System.out.println("test begin:");</div><div class="line">	Gate gate=new Gate();</div><div class="line">	//构造三个行人</div><div class="line">	new UserThread(gate, "A1", "A2").start();</div><div class="line">	new UserThread(gate, "B1", "B2").start();</div><div class="line">	new UserThread(gate, "C1", "C2").start();</div></pre></td></tr></table></figure></p>
<p>测试结果（截取部分）</p>
<blockquote>
<p>test begin:<br>B1 BEGIN<br>A1 BEGIN<br><strong><em>broken</em></strong>No.1305356:A1 ,A2<br><strong><em>broken</em></strong>No.1347999:B1 ,B2<br><strong><em>broken</em></strong>No.1357011:A1 ,A2<br><strong><em>broken</em></strong>No.1370176:B1 ,B2<br><strong><em>broken</em></strong>No.1377075:B1 ,B2</p>
</blockquote>
<p>从结果来看，明显发生了错误，即出现了线程不安全，但是也有点不对劲</p>
<h4 id="为什么会出错了"><a href="#为什么会出错了" class="headerlink" title="为什么会出错了"></a>为什么会出错了</h4><blockquote>
<p>问题的出错地方就在Gate类中，因为其是线程不安全的，打个比方<br>    线程A1                  线程A2           this.name值            this.address值<br>   count++                  count++            之前的值                  之前的值<br> this.name=name                                  A1                     之前的值<br>                           this.name=name        A2                     之前的值<br>                           this.address=address  A2                       B2<br> this.address=address                            A1                       B2<br>  check（）                  check（）           A1                        B2</p>
</blockquote>
<p>  发生错误</p>
<p>  以上只是发生错误的一种情况，事实上只有当数据量非常大时，极有可能发生错误，所以才会出现错误的结果，并且是在count达到大数量的时候出现的<br>  那么如何修改了？<br>  因为发生在Gate类的pass和toString方法中，所以只要把这个两个方法声明为同步就可以了</p>
<blockquote>
<p>public synchronized void pass(String name,String address){}<br>  public synchronized String toString(){}</p>
</blockquote>
<p>  对应的测试结果</p>
<blockquote>
<p>test begin:<br>A1 BEGIN<br>B1 BEGIN<br>C1 BEGIN</p>
</blockquote>
<h4 id="归纳single-Threaded"><a href="#归纳single-Threaded" class="headerlink" title="归纳single Threaded"></a>归纳single Threaded</h4><p>上面例子的解决方案就是该模式的一种应用，可以将其抽象为以下几个参与者<br>SharedResource（共享资源）参与者：可有多个线程访问的类，如Gate<br>SafeMethod：从多个线程同时调用也不会发生问题<br>UnsafeMethod：从多个线程同时调用会发生问题，需要防范的方法<br>所以必须将上述不安全的方法加以同步锁，当时如果通过其他方法改变不安全方法中数据也会发生错误，就像大门上锁，但是窗户开着一样，所以有时也是一个隐患的问题</p>
<p>那么此种模式何时适用了？<br>多线程时、数据可被多个线程访问的时候、状态可能变化的时候、需要确保安全性的时候</p>
<h4 id="生命线与死锁"><a href="#生命线与死锁" class="headerlink" title="生命线与死锁"></a>生命线与死锁</h4><p>使用该模式，可能会发生死锁的危险<br>而死锁是指：两个线程分别获取了锁定，互相等待另一个线程解除锁定的线程。发生死锁时，哪个线程都无法继续执行下去，所以程序会失去生命线<br>最经典的死锁问题就是汤勺与叉子模型，问题大概是这样的<br>假设A与B同吃一碗面，盘子旁有一支汤勺与一支叉子，而吃面必须同时需要汤勺和叉子<br>而现在叉子被其中一人假设是A拿走，而汤勺被B拿走，就会造成如下现象：<br>A和B一直等待对方放下叉子（或者汤勺），即一直处于等待，僵持阶段，从而程序无法继续运行，故称为死锁现象</p>
<p>而只要上述模式达到下面的条件，就会出现死锁<br>1.具有多个SharedResource参与者<br>2.线程锁定一个SharedResource时，还没接触前就去锁定另一个SharedResource<br>3.获取SharedResource参与者的顺序不固定</p>
<p>当然只要破坏上述三个条件之一就可以避免死锁的发生</p>
<p>下面就开始模拟死锁<br>首先是表示餐具的类(这里只有叉子和汤勺)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class Tool &#123;</div><div class="line"></div><div class="line">	private final String name;</div><div class="line">	public Tool(String  name)&#123;</div><div class="line">		this.name=name;</div><div class="line">	&#125;</div><div class="line">	public String toString()&#123;</div><div class="line">		return "["+name+"]";</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>开始用餐的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class EaterThread extends Thread &#123;</div><div class="line">    </div><div class="line">    //用餐者名字</div><div class="line">	private String name;</div><div class="line">	//左手拿餐具</div><div class="line">	private final Tool lefthand;</div><div class="line">	//右手拿餐具</div><div class="line">	private final Tool righthand;</div><div class="line">	public EaterThread(String name, Tool lefthand, Tool righthand) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.lefthand = lefthand;</div><div class="line">		this.righthand = righthand;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">	  //不断吃</div><div class="line">		while(true)&#123;</div><div class="line">			eat();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void eat()&#123;</div><div class="line">		 //锁定左手获取餐具</div><div class="line">		synchronized (lefthand) &#123;</div><div class="line">		 //左手拿餐具</div><div class="line">			System.out.println(name+"takes up"+lefthand+"left.");</div><div class="line">		 //锁定右手拿餐具</div><div class="line">			synchronized (righthand) &#123;</div><div class="line">		 //右手拿餐具</div><div class="line">				System.out.println(name+" takes up"+righthand+"right.");</div><div class="line">		 //开吃</div><div class="line">				System.out.println(name+" is eating");</div><div class="line">		 //右手放下餐具</div><div class="line">				System.out.println(name+" puts down"+righthand+"right.");</div><div class="line">			&#125;</div><div class="line">		 //解除右手锁定锁，并且左手放下餐具</div><div class="line">			System.out.println(name+"puts down"+lefthand+"left.");</div><div class="line">		&#125;</div><div class="line">		//解除左手餐具的锁定</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   System.out.println("test begin:");</div><div class="line">Tool spoon=new Tool("Spoon");</div><div class="line">Tool fork=new Tool("Fork");</div><div class="line">new EaterThread("A", spoon, fork).start();</div><div class="line">new EaterThread("B", fork, spoon).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>test begin:<br>Atakes up[Spoon]left.<br>A takes up[Fork]right.<br>A is eating<br>A puts down[Fork]right.<br>Aputs down[Spoon]left.<br>Atakes up[Spoon]left.<br>A takes up[Fork]right.<br>A is eating<br>A puts down[Fork]right.<br>Aputs down[Spoon]left.<br>重复。。直到<br>Atakes up[Spoon]left.<br>Btakes up[Fork]left.<br>该处程序停止不动了，也就是a和b分别拿着汤勺和叉子，即处于死锁状态了。</p>
</blockquote>
<p>一种最简单的方法就是改变顺序，即以相同顺序拿餐具<br>即：</p>
<blockquote>
<p>Tool spoon=new Tool(“Spoon”);<br>    Tool fork=new Tool(“Fork”);<br>    new EaterThread(“A”, spoon, fork).start();<br>    new EaterThread(“B”, spoon,fork).start();</p>
</blockquote>
<p>最后程序就会一直进行下去，不过这样的话，前面的共享资源就不存在了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Single Threaded Execution是指以一个线程执行，简单来说就是在多线程中限制同时只让一个线程运行&lt;/p&gt;
&lt;h4 id=
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发系列一之初识java线程</title>
    <link href="http://www.myzwl.win/2017/04/10/thrd1/"/>
    <id>http://www.myzwl.win/2017/04/10/thrd1/</id>
    <published>2017-04-10T13:48:51.000Z</published>
    <updated>2017-04-18T15:47:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>曾在论坛中看过这样一句话，如果连多线程都不懂，别说自己学过java，可见多线程的重要性！</p>
<h4 id="何谓线程"><a href="#何谓线程" class="headerlink" title="何谓线程"></a>何谓线程</h4><p>简单来说，就像我们在执行一个程序时，他总按照顺序执行，如果从头到尾都没有分叉，也就是说总是一个流程，那么就可以看做单线程，并且程序执行的主体只有一个，所以，我们把正在执行程序的主体称为线程</p>
<p>当然，平时我们说的最多的就是多线程，顾名思义就是由一个以上的线程所构成的程序，比如文件处理，io请求处理及网络客户端发出的请求等等都可以看做多线程</p>
<h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>先看一个简单的例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest1;</div><div class="line"></div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">public class Mythread extends Thread &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;700;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mythread m=new Mythread();</div><div class="line">	  m.start();</div><div class="line">	  for(int i=0;i&lt;900;i++)&#123;</div><div class="line">	  System.out.print("lol!");</div><div class="line">	  &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>lol!lol!lol!lol!lol!lol!。。hello!hello!hello!hello!hello!。。lol!lol!lol!lol!lol!lol!</p>
</blockquote>
<p>然后在去认识上面程序，其中start方法会启动新的线程，然后再由这个新线程调用run方法，<br>当然也可以直接调用run方法</p>
<p>那么两者有什么区别了？<br>调用start方法会出现字符串交错，也就是并发，而run方法，就是等run方法执行完，在执行其它，显然不会出现交错现象<br>当然数据量小的话，出现的结果很难有说服力，所以并发模拟尽量使用大数量</p>
<h4 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h4><ol>
<li>利用thread的子类的实例，启动线程<br>正如前面模拟的程序，不过下面测试用两个线程<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new Mythread().start（）;</div><div class="line">new Mythread().start（）;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>显然两个线程操作两个对象，所以thread是线程安全的</p>
<ol>
<li>利用Runnable接口<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Mythread implements Runnable</div><div class="line">&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;700;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      Mythread m=new Mythread();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>这里主要向Runnable接口实现的实例作为参数传递给Thread，再启动线程，这里就有一个问题，因为不同线程操作一个对象，所以会造成线程不安全的问题，也就是脏数据</p>
<h4 id="线程的暂时停止"><a href="#线程的暂时停止" class="headerlink" title="线程的暂时停止"></a>线程的暂时停止</h4><p>利用Thread的sleep方法可暂时停止线程当前的操作，如<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">      public class Mythread implements Runnable</div><div class="line">&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;5;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>这里的参数是ms，所以1000就是1s了</p>
<h4 id="线程的共享互斥"><a href="#线程的共享互斥" class="headerlink" title="线程的共享互斥"></a>线程的共享互斥</h4><p>在程序里，多个线程可自由操作，就会造成一个线程还在执行，另一个线程就插进来执行，就会造成一些脏数据的产生<br>如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">       private int count=1000;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">	for(int i=0;i&lt;100;i++)&#123;</div><div class="line">		count--;</div><div class="line">		System.out.println("mythread"+(count));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     Mythread m=new Mythread();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：（取部分）</p>
<blockquote>
<p>mythread999<br>mythread997<br>mythread996<br>mythread995<br>mythread994</p>
</blockquote>
<p>显然出现了脏数据<br>要想使数据正确，一种方法是加同步锁，即一个线程在执行该操作时，其余线程无锁，则必须等待，直到该线程执行结束或者被挂起，才释放锁，然后在门外等待的线程依次执行，加锁，重复上述步骤<br>显然，就不会出现多个线程操作同一个对象了</p>
<p>java中通过声明synchronized关键字实现同步锁<br>如：</p>
<blockquote>
<p>public synchronized void run()</p>
</blockquote>
<p>则在执行run方法前加同步锁，控制线程，当然该关键字可以声明在任何方法前，包括静态方法<br>另外，它还有另外一种声明方式</p>
<blockquote>
<p>public  void run() {<br>        synchronized (xx.class) {<br>        }</p>
</blockquote>
<p>注意这里xx.class是操作该方法的那个类实现同步比如这里可以将</p>
<blockquote>
<p>synchronized (this) {}</p>
</blockquote>
<p>就是对本身这个类加锁控制了等同于上述的另一种写法</p>
<h4 id="线程的协调"><a href="#线程的协调" class="headerlink" title="线程的协调"></a>线程的协调</h4><p>如果有一个线程正在执行同步锁，而其他线程则要等待，这是典型的线程互斥现象<br>假如当该空间有空余时则写入数据，无空闲时间则等待（等待）<br>当该空间有空闲时，则通知等待的线程（通知）</p>
<p>这里是根据空间是否空闲为条件进行线程处理，java中通过wait（让线程等待），notify与notifyAll（启动等候中的线程）</p>
<p>我们可以把线程处于等待的地方形象的看做wait set（线程的休息室）</p>
<h4 id="wait-把线程放入休息室"><a href="#wait-把线程放入休息室" class="headerlink" title="wait-把线程放入休息室"></a>wait-把线程放入休息室</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">	private static int count=90;</div><div class="line">	</div><div class="line">public synchronized int s() throws InterruptedException&#123;</div><div class="line">	count--;</div><div class="line">	System.out.println("ok:"+count);</div><div class="line">	this.wait();</div><div class="line">	System.out.println("lockover");</div><div class="line">	return count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">	public  void run() &#123;	</div><div class="line">				try &#123;</div><div class="line">					s();</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>然后在测试中启动几个线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     Count m=new Count();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>ok:89<br>ok:88<br>ok:87</p>
</blockquote>
<p>一般为obj.wait（），而obj是某个对象的实例，也就是说该线程在obj的休息区<br>之后会自动释放锁，等待的线程开始执行</p>
<p>当然也有obj.wait（1000）；也可以设置在休息区等待的秒数，然后继续执行</p>
<p>测试结果：</p>
<blockquote>
<p>ok:89<br>ok:88<br>ok:87<br>lockover<br>lockover<br>lockover</p>
</blockquote>
<h4 id="notify方法-从休息区拿出线程"><a href="#notify方法-从休息区拿出线程" class="headerlink" title="notify方法-从休息区拿出线程"></a>notify方法-从休息区拿出线程</h4><p>一般为obj.notify（），即从obj的wait set里的线程中挑选一个，唤醒一个线程并退出该休息区<br>当然，这里有一个顺序，召唤该线程的那个线程执行完，释放锁后，那个在休息区的线程在执行</p>
<p>obj.notifyAll（），即从线程区中拿出所有线程</p>
<p>最后需要说一下的是wait、notify、notifyAll是Object的类方法，也就是所有类都能使用</p>
<p>由此可看出多线程的确是一个复杂而且很重要的东西！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;曾在论坛中看过这样一句话，如果连多线程都不懂，别说自己学过java，可见多线程的重要性！&lt;/p&gt;
&lt;h4 id=&quot;何谓线程&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>集合中的线程安全问题</title>
    <link href="http://www.myzwl.win/2017/04/07/thread2/"/>
    <id>http://www.myzwl.win/2017/04/07/thread2/</id>
    <published>2017-04-07T13:48:51.000Z</published>
    <updated>2017-04-08T15:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早在刚开始学习java se的时候，就遇到过这样问题，xxx是线程安全的，xxxx是线程不安全的，当时也是一脸蒙，只记住了结论。后来接触了单例才有一点了解</p>
<p>线程安全的：<br>vector、hashtable、stringbuffer等</p>
<p>非线程安全的：<br>arraylist、linkedlist、hashmap、StringBuilder等等</p>
<p>首先来模拟一个案例</p>
<p>测试集合类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static void test()  &#123;</div><div class="line">// 用来测试的List  </div><div class="line">   List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();  </div><div class="line">   </div><div class="line">   // 线程数量(1000)  </div><div class="line">   int threadCount = 1000;  </div><div class="line">   </div><div class="line">// 用来让主线程等待threadCount个子线程执行完毕  </div><div class="line">   CountDownLatch countDownLatch = new CountDownLatch(threadCount);  </div><div class="line">   </div><div class="line">    // 启动threadCount个子线程  </div><div class="line">   for(int i = 0; i &lt; threadCount; i++)  </div><div class="line">   &#123;  </div><div class="line">       Thread thread = new Thread(new Mythread(list,countDownLatch));  </div><div class="line">       thread.start();  </div><div class="line">   &#125;  </div><div class="line">   try  </div><div class="line">   &#123;  </div><div class="line">       // 主线程等待所有子线程执行完成，再向下执行  </div><div class="line">       countDownLatch.await();  </div><div class="line">   &#125;  </div><div class="line">   catch (InterruptedException e)  </div><div class="line">   &#123;  </div><div class="line">       e.printStackTrace();  </div><div class="line">   &#125;  </div><div class="line">   // List的size  </div><div class="line">   System.out.println(list.size());  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>自定义线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line">import java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line">public class Mythread implements Runnable &#123;</div><div class="line">	private List&lt;Object&gt; list;  </div><div class="line">	</div><div class="line">	private CountDownLatch countDownLatch; </div><div class="line">	public Mythread(List&lt;Object&gt; list,CountDownLatch countDownLatch)&#123;</div><div class="line">		  this.list = list; </div><div class="line">		  this.countDownLatch = countDownLatch;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		// 每个线程向List中添加100个元素  </div><div class="line">        for(int i = 0; i &lt; 100; i++)  </div><div class="line">        &#123;  </div><div class="line">            list.add(new Object());  </div><div class="line">        &#125;  </div><div class="line">     // 完成一个子线程  </div><div class="line">        countDownLatch.countDown();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">	 </div><div class="line">	 // 进行10次测试  </div><div class="line">        for(int i = 0; i &lt; 10; i++)  </div><div class="line">        &#123;  </div><div class="line">            test();  </div><div class="line">        &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>99873<br>99968<br>99955<br>100000<br>100000<br>100000<br>100000<br>Exception in thread “Thread-7516” java.lang.ArrayIndexOutOfBoundsException: 76327<br>    at java.util.ArrayList.add(ArrayList.java:441)<br>    at com.zwl.test.Mythread.run(Mythread.java:20)<br>    at java.lang.Thread.run(Thread.java:744)</p>
</blockquote>
<p>有时不会出现异常，但是list的长度不是最终期望的那样，显然是线程不安全的，<br>这里是arraylist，同样将其换成linkedlist，也可以改变list，变成其它，得到同样线程不安全结果</p>
<p>测试结果：</p>
<blockquote>
<p>100000<br>99783<br>100000<br>99945<br>99897<br>99996<br>99879<br>99971<br>100000<br>99899</p>
</blockquote>
<p>将其换成线程安全的，如</p>
<blockquote>
<p>List<object> list = new Vector<object>(); </object></object></p>
</blockquote>
<p>测试结果：</p>
<blockquote>
<p>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000</p>
</blockquote>
<p>当然集合中的线程不安全是多线程同时操作同一个对象，如果是不同类，就不存在线程安全问题</p>
<p>对于线程安全，一般通过线程同步来实现，即通过申明synchronized关键字</p>
<p>如，改一下之前的线程安全的例子number类</p>
<p>修改后的number类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class number &#123;</div><div class="line"></div><div class="line">	private int num=0; </div><div class="line"></div><div class="line">	public  void count()&#123;</div><div class="line">	</div><div class="line">		num++;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int getnumber()&#123;</div><div class="line">		return num;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是自定义线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Mythread implements Runnable &#123;</div><div class="line">	private number num;</div><div class="line">	</div><div class="line">	private CountDownLatch countDownLatch; </div><div class="line">	public Mythread(number num,CountDownLatch countDownLatch)&#123;</div><div class="line">		  this.num = num; </div><div class="line">		  this.countDownLatch = countDownLatch;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123; </div><div class="line">        for(int i = 0; i &lt; 100; i++)  </div><div class="line">        &#123;  </div><div class="line"> </div><div class="line">        	num.count();</div><div class="line">        	</div><div class="line">        &#125;  </div><div class="line">     // 完成一个子线程  </div><div class="line">        countDownLatch.countDown();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> public static void test()  &#123;</div><div class="line"></div><div class="line">   </div><div class="line">   number num=new number();</div><div class="line">   // 线程数量(1000)  </div><div class="line">   int threadCount = 1000;  </div><div class="line">   </div><div class="line">// 用来让主线程等待threadCount个子线程执行完毕  </div><div class="line">   CountDownLatch countDownLatch = new CountDownLatch(threadCount);  </div><div class="line">   </div><div class="line">   for(int i = 0; i &lt; threadCount; i++)  </div><div class="line">   &#123;  </div><div class="line">       Thread thread = new Thread(new Mythread(num,countDownLatch));  </div><div class="line">       thread.start();  </div><div class="line">   &#125;  </div><div class="line">   try  </div><div class="line">   &#123;  </div><div class="line">       // 主线程等待所有子线程执行完成，再向下执行  </div><div class="line">       countDownLatch.await();  </div><div class="line">   &#125;  </div><div class="line">   catch (InterruptedException e)  </div><div class="line">   &#123;  </div><div class="line">       e.printStackTrace();  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line">   System.out.println(num.getnumber());  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		 </div><div class="line">		 // 进行10次测试  </div><div class="line">	        for(int i = 0; i &lt; 10; i++)  </div><div class="line">	        &#123;  </div><div class="line">	            test();  </div><div class="line">	        &#125;  </div><div class="line">	 &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>100000<br>100000<br>100000<br>100000<br>99940<br>99300<br>100000<br>100000<br>100000<br>100000</p>
</blockquote>
<p>出现了线程不安全<br>可以通过对方法声明同步</p>
<blockquote>
<p>public synchronized void count(){}</p>
</blockquote>
<p>最后输出的书都是同一个数</p>
<p>最后不得不说，线程安全是一个很复杂的问题，有时候不注意就会出现数据上的各种问题！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;早在刚开始学习java se的时候，就遇到过这样问题，xxx是线程安全的，xxxx是线程不安全的，当时也是一脸蒙，只记住了结论。后来接触了单
    
    </summary>
    
      <category term="学习进阶" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="java集合" scheme="http://www.myzwl.win/source/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>初识线程安全与线程不安全</title>
    <link href="http://www.myzwl.win/2017/04/06/thread1/"/>
    <id>http://www.myzwl.win/2017/04/06/thread1/</id>
    <published>2017-04-06T13:48:51.000Z</published>
    <updated>2017-04-08T15:58:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于线程问题基本上贯穿学习的整个过程，像集合，servlet，structs，hibernate，spring等等，其都涉及到线程问题</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>什么是线程安全？<br>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>线程安全问题都是由全局变量及静态变量引起的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全</p>
<p>不妨来一个实例<br>首先是number类，里面有一个计数的全局和静态变量<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class number &#123;</div><div class="line"></div><div class="line">	private int num;</div><div class="line">	private static int count;</div><div class="line">	</div><div class="line">	public void count()&#123;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			num+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+num);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void countstatic()&#123;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			count+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+count);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然我们希望每个线程都能输出的结果是55就是线程安全</p>
<p>线面是测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class test &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	</div><div class="line">		Runnable runner=new Runnable() &#123;</div><div class="line">			number num=new number();</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				num.count();</div><div class="line">				System.out.println("statis:");</div><div class="line">				num.countstatic();</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			new Thread(runner).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里启动十个线程，依次通过run方法输出全局和静态变量的累加和，如果是线程安全的，则应该都是55</p>
<p>结果如下所示</p>
<blockquote>
<p>Thread-0:55<br>statis:<br>Thread-0:55<br>Thread-1:110<br>statis:<br>Thread-1:110<br>Thread-2:165<br>statis:<br>Thread-2:165<br>Thread-6:275<br>statis:<br>Thread-6:220<br>Thread-3:385<br>statis:<br>Thread-4:220<br>statis:<br>Thread-3:275<br>Thread-8:385<br>statis:<br>Thread-8:385<br>Thread-4:330<br>Thread-5:440<br>statis:<br>Thread-5:440<br>Thread-7:495<br>statis:<br>Thread-7:495<br>Thread-9:550<br>statis:<br>Thread-9:550</p>
</blockquote>
<p>发现不是线程安全的</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
<p>对于上面的线程不安全可以进行如下修改</p>
<p>解决方法：将全局变量变成局部变量（静态变量暂时不讨论）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void count()&#123;</div><div class="line">		int num = 0;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			num+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+num);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>最后所有的线程都输出了55</p>
<p>或者将new 的number放到run里面，变成局部的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">			public void run() &#123;</div><div class="line">				number num=new number();</div><div class="line">				num.count();</div><div class="line">				System.out.println("statis:");</div><div class="line">				num.countstatic();</div><div class="line">			&#125;</div><div class="line">		&#125;;</div></pre></td></tr></table></figure></p>
<p>最后也能保证了线程安全了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于线程问题基本上贯穿学习的整个过程，像集合，servlet，structs，hibernate，spring等等，其都涉及到线程问题&lt;/p
    
    </summary>
    
      <category term="学习进阶" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="java集合" scheme="http://www.myzwl.win/source/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
