<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2017-04-02T15:32:34.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mybatis 之四:mybatis整合spring</title>
    <link href="http://www.myzwl.win/2017/04/02/mybatis4/"/>
    <id>http://www.myzwl.win/2017/04/02/mybatis4/</id>
    <published>2017-04-02T07:48:51.000Z</published>
    <updated>2017-04-02T15:32:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整合思路：<br>    1、数据源信息交给spring管理<br>2、sqlsessionfactory交给spring进行单例管理<br>3、由spring来管理mapper代理的代理类</p>
<p>下面以根据用户id查询用户信息案例来搭建工程<br>步骤一：建立java工程</p>
<p>步骤二：添加整合包（这里需要的jar包过多）<br>Mysql的驱动包<br>Mybatis的核心包和依赖包<br>Mybatis和spring的整合包<br>Spring的包<br>dbcp数据库连接池包<br>等等</p>
<p>步骤三：在src目录下建立sqlmapconfig.xml配置文件，里面暂时只有一个dtd文件声明<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE configuration</div><div class="line">PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</div><div class="line">"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>步骤四：在src目录下建立applicationcontext.xml配置文件<br>里面目前只配置一些重要连接数据库的信息，后面步骤将加入重要信息<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt;</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line">	&lt;!-- 创建数据源 --&gt;</div><div class="line">	&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;</div><div class="line">		&lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt;</div><div class="line">		&lt;property name="url" value="jdbc:mysql://localhost:9806/sshe" /&gt;</div><div class="line">		&lt;property name="username" value="root" /&gt;</div><div class="line">		&lt;property name="password" value="root" /&gt;</div><div class="line">		&lt;property name="maxActive" value="10" /&gt;</div><div class="line">		&lt;property name="maxIdle" value="5" /&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">	&lt;!-- SqlSessionFactory --&gt;</div><div class="line">	&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;</div><div class="line">		&lt;!-- 指定mybatis的全局配置文件的路径 --&gt;</div><div class="line">		&lt;property name="configLocation" value="SqlMapConfig.xml"&gt;&lt;/property&gt;</div><div class="line">		&lt;!-- 数据源 --&gt;</div><div class="line">		&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>步骤五：创建pojo类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">private int age;</div><div class="line">private int id;</div><div class="line">private String name;</div><div class="line">此处省略set与get方法。。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤六：创建mapper代理<br>首先是UserMapper.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE mapper    </div><div class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    </div><div class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line">&lt;mapper namespace="com.zwl.mapper.UserMapper"&gt;</div><div class="line">	&lt;!-- 根据用户ID查询用户信息 --&gt;</div><div class="line">	&lt;select id="findUserById" parameterType="int" resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT</div><div class="line">		* FROM user WHERE id =#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure></p>
<p>接下来是mapper接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(int id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在sqlmapconfig.xml文件中声明代理文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">	&lt;!-- 加载映射文件 --&gt;</div><div class="line">	&lt;mappers&gt;</div><div class="line">		&lt;mapper resource=<span class="string">"com/zwl/mapper/UserMapper.xml"</span> /&gt;</div><div class="line">	&lt;/mappers&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>步骤七：spring中注入<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"UserMapper"</span> class=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</div><div class="line">		&lt;!-- 设置代理类的接口 --&gt;</div><div class="line">		&lt;property name=<span class="string">"mapperInterface"</span> value=<span class="string">"com.zwl.mapper.UserMapper"</span>&gt;&lt;/property&gt;</div><div class="line">		&lt;!-- 依赖注入SqlSessionFactory --&gt;</div><div class="line">		&lt;property name=<span class="string">"sqlSessionFactory"</span> ref=<span class="string">"sqlSessionFactory"</span>&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>步骤八：测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class test &#123;</div><div class="line">	private ApplicationContext ctx;</div><div class="line"></div><div class="line">//在测试之前自动加载</div><div class="line">	@Before</div><div class="line">	public void setUp() throws Exception &#123;</div><div class="line">		ctx = new ClassPathXmlApplicationContext(</div><div class="line">				"applicationContext.xml");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Test</div><div class="line">	public void testFindUserById() throws Exception &#123;</div><div class="line">		</div><div class="line">		UserMapper dao = (UserMapper) ctx.getBean("userMapper");</div><div class="line">		</div><div class="line">		User user = dao.findUserById(1);</div><div class="line">		</div><div class="line">		System.out.println(user.getName());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：取出数据库中的helloworld<br>至此mybatis整合spring完成</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;整合思路：&lt;br&gt;    1、数据源信息交给spring管理&lt;br&gt;2、sqlsessionfactory交给spring进行单例管理&lt;br
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>mybatis 之三:映射文件</title>
    <link href="http://www.myzwl.win/2017/04/02/mybatis3/"/>
    <id>http://www.myzwl.win/2017/04/02/mybatis3/</id>
    <published>2017-04-02T03:48:51.000Z</published>
    <updated>2017-04-02T15:32:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基本上我们对数据库的操作都在映射文件中编写，通过mapper代理方式简化配置，同时依据不同的参数和返回类型完成相关需求</p>
<h5 id="一：parameterType输入参数"><a href="#一：parameterType输入参数" class="headerlink" title="一：parameterType输入参数"></a>一：parameterType输入参数</h5><p>简单类型：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id="findUserById" parameterType="int"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>参数是基本类型，在之前已演示</p>
<p>Pojo类型<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;insert id=<span class="string">"insertuser"</span> parameterType=<span class="string">"com.zwl.pojo.User"</span>&gt;</div><div class="line">&lt;selectKey keyProperty=<span class="string">"id"</span> resultType=<span class="string">"int"</span> <span class="attribute">order</span>=<span class="string">"AFTER"</span>&gt;</div><div class="line">select LAST_INSERT_ID()</div><div class="line">&lt;/selectKey&gt;</div><div class="line">insert into user values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</div><div class="line">&lt;/insert&gt;</div></pre></td></tr></table></figure></p>
<p>即参数类型是一个对象，如之前的添加操作</p>
<p>包装pojo类型<br>即在类中包含另一个对象，如<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class Uservo &#123;</div><div class="line">private User user;</div><div class="line">此处省略set。。get方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件中<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id="findUserById" parameterType="com.zwl.pojo.Uservo"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;user.id&#125;</div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>参数是包装类，注意参数是包装类的属性</p>
<p>Map<br>  同传递pojo对象一样，map的key相当于pojo的属性<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id="findUserById" parameterType="hashmap"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;id&#125; and name=#&#123;name&#125;</div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>显然，参数是hashmap，其中#{id}与#{name}都是hashmap的key</p>
<p>接口文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(HashMap&lt;String, Object&gt; id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">UserMapper mapper=sqlSession.getMapper(UserMapper.class);</div><div class="line">				</div><div class="line">				HashMap&lt;String, Object&gt; hm=new HashMap&lt;&gt;();</div><div class="line">				hm.put("id", 1);</div><div class="line">				hm.put("name","helloworld");</div><div class="line">				</div><div class="line">				User u=mapper.findUserById(hm);</div><div class="line">				System.out.println(u.getAge());</div><div class="line">				sqlSession.close();</div></pre></td></tr></table></figure></p>
<h4 id="输出映射"><a href="#输出映射" class="headerlink" title="输出映射"></a>输出映射</h4><p>Resulttype：<br>    使用要求：<br>  使用resultType进行结果映射时，需要查询出的列名和映射的对象的属性名一致，才能映射成功。<br>如果查询的列名和对象的属性名全部不一致，那么映射的对象为空。<br>如果查询的列名和对象的属性名有一个一致，那么映射的对象不为空，但是只有映射正确那一个属性才有值。</p>
<p>简单类型：resultType=”int”<br>Pojo对象：resultType=”com.zwl.pojo.User”</p>
<p>如之前的案例<br>Resultmap<br>使用resultMap进行结果映射时，不需要查询的列名和映射的属性名必须一致。但是需要声明一个resultMap，来对列名和属性名进行映射<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;resultMap type=<span class="string">"com.zwl.pojo.User"</span> id=<span class="string">"Userresult"</span>&gt;</div><div class="line">	&lt;id column=<span class="string">"id_"</span> property=<span class="string">"id"</span>/&gt;</div><div class="line">	&lt;result column=<span class="string">"name_"</span> property=<span class="string">"name"</span>/&gt;</div><div class="line">	&lt;result column=<span class="string">"age_"</span> property=<span class="string">"age"</span>/&gt;</div><div class="line">	&lt;/resultMap&gt;</div></pre></td></tr></table></figure></p>
<p>其中id为查询结果中唯一列映射，result标签为映射结果中的普通列</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select id=<span class="string">"findUserById"</span> parameterType=<span class="string">"int"</span></div><div class="line">		resultMap=<span class="string">"Userresult"</span> &gt;</div><div class="line">		SELECT id id_,name name_,age age_ FROM user WHERE id =#&#123;id&#125; </div><div class="line">	&lt;/select&gt;</div></pre></td></tr></table></figure>
<p>其中resultmap必须与声明中的id保持一致，这样才能引用</p>
<p>接口：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(int id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">User u=mapper.findUserById(1);</div><div class="line">				System.out.println(u.getAge());</div><div class="line">				sqlSession.close();</div></pre></td></tr></table></figure>
<p>mybatis与hibernate的区别及各自应用场景<br>Mybatis技术特点：<br>1、    通过直接编写SQL语句，可以直接对SQL进行性能的优化；<br>2、    学习门槛低，学习成本低。只要有SQL基础，就可以学习mybatis，而且很容易上手；<br>3、    由于直接编写SQL语句，所以灵活多变，代码维护性更好。<br>4、    不能支持数据库无关性，即数据库发生变更，要写多套代码进行支持，移植性不好。</p>
<p>Hibernate技术特点：<br>1、    标准的orm框架，程序员不需要编写SQL语句。<br>2、    具有良好的数据库无关性，即数据库发生变化的话，代码无需再次编写。<br>3、    学习门槛高，需要对数据关系模型有良好的基础，而且在设置OR映射的时候，需要考虑好性能和对象模型的权衡。<br>4、    程序员不能自主的去进行SQL性能优化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;基本上我们对数据库的操作都在映射文件中编写，通过mapper代理方式简化配置，同时依据不同的参数和返回类型完成相关需求&lt;/p&gt;
&lt;h5 id
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>mybatis 之二:开发dao的两种方式</title>
    <link href="http://www.myzwl.win/2017/04/01/mybatis2/"/>
    <id>http://www.myzwl.win/2017/04/01/mybatis2/</id>
    <published>2017-04-01T13:48:51.000Z</published>
    <updated>2017-04-02T15:32:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Dao层的开发，在mybatis中可以通过原始dao（一个接口和接口实现类），而在mybatis中可以更方便的通过mapper代理模式，当然需要满足一定的规范性原则</p>
<p>不多说，以一个增加user信息为例</p>
<p>一：首先在映射文件中写一个增加用户配置信息<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 添加用户 --&gt;</div><div class="line">	&lt;!-- selectKey：查询主键，在标签内需要输入查询主键的sql --&gt;</div><div class="line">	&lt;!-- <span class="attribute">order</span>：指定查询主键的sql和insert语句的执行顺序，相当于insert语句来说 --&gt;</div><div class="line">	&lt;!-- LAST_INSERT_ID：该函数是mysql的函数，获取自增主键的ID，它必须配合insert语句一起使用 --&gt;</div><div class="line">	&lt;insert id=<span class="string">"insertuser"</span> parameterType=<span class="string">"com.zwl.pojo.User"</span>&gt;</div><div class="line">	&lt;selectKey keyProperty=<span class="string">"id"</span> resultType=<span class="string">"int"</span> <span class="attribute">order</span>=<span class="string">"AFTER"</span>&gt;select LAST_INSERT_ID()&lt;/selectKey&gt;</div><div class="line">	insert into user values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</div><div class="line">	&lt;/insert&gt;</div></pre></td></tr></table></figure></p>
<p>注意：这里的插入中原表中主键有自增长，所以需要先获得主键，在增加，这是一个插入语句</p>
<p>二：dao接口及其实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public interface userdao &#123;</div><div class="line">//添加user</div><div class="line">	public void insertusers(User user) throws Exception;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Dao接口实现类</div><div class="line">public class userdaoimpl implements userdao &#123;</div><div class="line"></div><div class="line">	private SqlSessionFactory sqlSessionFactory;</div><div class="line">	</div><div class="line">//通过构造函数注入sqlSessionFactory</div><div class="line">	public userdaoimpl(SqlSessionFactory sqlSessionFactory)&#123;</div><div class="line">		this.sqlSessionFactory=sqlSessionFactory;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void insertusers(User user) throws Exception &#123;</div><div class="line">//通过线程安全方式获得sqlsession，实现增删该查操作</div><div class="line">		SqlSession sqlsession=sqlSessionFactory.openSession();</div><div class="line">//注意这里的test是映射文件中的namespace，insertuser是id用于标识</div><div class="line">		sqlsession.insert("test.insertuser", user);</div><div class="line">//添加操作需要提交事务</div><div class="line">		sqlsession.commit();</div><div class="line">		sqlsession.close();</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>编写测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//读取配置文件</div><div class="line">				//全局配置文件的路径</div><div class="line">				String resource = "SqlMapConfig.xml";</div><div class="line">				InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">				</div><div class="line">				//创建SqlSessionFactory</div><div class="line">				SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div><div class="line"></div><div class="line">              //创建user</div><div class="line">	            User u=new User();</div><div class="line">				u.setName("java");</div><div class="line">				u.setAge(18);</div><div class="line">				</div><div class="line">//调用dao层方法，实现添加功能</div><div class="line">				userdao dao=new userdaoimpl(sqlSessionFactory);</div><div class="line">				dao.insertusers(u);</div></pre></td></tr></table></figure></p>
<p>这种原始dao方式，我们很熟悉，也很好理解，到时当方法多的时候，就会存在大量多余的重复编码问题</p>
<p>Mapper代理的开发模式<br>即开发mapper接口（相当于dao接口）<br>Mapper代理使用的是jdk的代理策略</p>
<p>还有一点是mapper代理最重要的，就是必须满足mapper代理的开发规范<br>1 mapper接口的全限定名要和mapper映射文件的namespace值一致<br>2 mapper接口的方法名称要和mapper映射文件的statement的id一致。<br>3 mapper接口的方法参数类型要和mapper映射文件的statement的parameterType的值一致，而且它的参数是一个。<br>4 mapper接口的方法返回值类型要和mapper映射文件的statement的resultType的值一致。</p>
<p>下面以入门程序的通过id查询user为例<br>首先是修改映射文件，改名为UserMapper.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE mapper    </div><div class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    </div><div class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line">&lt;!-- namespace：命名空间，对statement的信息进行分类管理 --&gt;</div><div class="line">&lt;!-- 注意：在mapper代理时，它具有特殊及重要的作用 --&gt;</div><div class="line">&lt;mapper namespace="com.zwl.mapper.UserMapper"&gt;</div><div class="line">	&lt;!-- 根据用户ID查询用户信息 --&gt;</div><div class="line">	&lt;!-- select：表示一个MappedStatement对象 --&gt;</div><div class="line">	&lt;!-- id：statement的唯一标示 --&gt;</div><div class="line">	&lt;!-- #&#123;&#125;：表示一个占位符？ --&gt;</div><div class="line">	&lt;!-- #&#123;id&#125;：里面的id表示输入参数的参数名称，如果该参数是简单类型，那么#&#123;&#125;里面的参数名称可以任意 --&gt;</div><div class="line">	&lt;!-- parameterType：输入参数的java类型 --&gt;</div><div class="line">	&lt;!-- resultType：输出结果的所映射的java类型（单条结果所对应的java类型） --&gt;</div><div class="line">	</div><div class="line"></div><div class="line">	&lt;select id="findUserById" parameterType="int"</div><div class="line">		resultType="com.zwl.pojo.User" &gt;</div><div class="line">		select * from user where id=#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure></p>
<p>上述的namespace需要和mapper接口的全限定名一致<br>然后是mapper接口开发（UserMapper.java）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package com.zwl.mapper;</div><div class="line"></div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public interface UserMapper &#123;</div><div class="line">	public User findUserById(int id) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来是在配置文件中声明映射文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;mappers&gt;</div><div class="line">		&lt;mapper resource=<span class="string">"com/zwl/mapper/UserMapper.xml"</span> /&gt;</div><div class="line">	&lt;/mappers&gt;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">String resource = "SqlMapConfig.xml";</div><div class="line">				InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">				</div><div class="line">				//创建SqlSessionFactory</div><div class="line">				SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div><div class="line">				</div><div class="line">			//创建SqlSession</div><div class="line">				SqlSession sqlSession = sqlSessionFactory.openSession();</div><div class="line">				</div><div class="line">//通过mybatis的sqlsession来创建代理对象</div><div class="line">				UserMapper mapper=sqlSession.getMapper(UserMapper.class);</div><div class="line">				</div><div class="line">				User u=mapper.findUserById(1);</div><div class="line">				System.out.println(u.getName());</div><div class="line">				sqlSession.close();</div></pre></td></tr></table></figure></p>
<p>最后的测试结果是取出数据库中id为1的helloworld</p>
<p>至此mapper代理开发dao完成，这里只给了一个简单的例子，总的来说，只要满足规范，就可以简化配置</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Dao层的开发，在mybatis中可以通过原始dao（一个接口和接口实现类），而在mybatis中可以更方便的通过mapper代理模式，当然
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>mybatis 之一:hello world</title>
    <link href="http://www.myzwl.win/2017/04/01/mybatis1/"/>
    <id>http://www.myzwl.win/2017/04/01/mybatis1/</id>
    <published>2017-04-01T12:48:51.000Z</published>
    <updated>2017-04-02T15:32:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mybatis就是一个封装了jdbc的持久层框架，它和hibernate都属于orm框架，但是具体说，hibernate是一个完全的orm框架，而mybatis是一个不完全的orm框架，mybatis只关注sql本身，而不需要关注如连接的创建，statement的创建等操作。Mybatis会将输入参数、输出结果进行映射。</p>
<p>不多说，先来一个入门程序，意在先从整体了解<br>步骤一：创建一个java工程</p>
<p>步骤二：导入jar包，首先创建一个lib文件夹，在将包导入<br><img src="/images/imgs2/17.gif" alt="Alt text"></p>
<p>步骤三：数据库中的表user<br><img src="/images/imgs2/18.gif" alt="Alt text"></p>
<p>步骤四：创建pojo类，与数据库字段对应<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pojo;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line">	private int age;</div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line">	public int getId() &#123;</div><div class="line">		return id;</div><div class="line">	&#125;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public void setId(int id) &#123;</div><div class="line">		this.id = id;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤五：创建全局配置文件（mybatis核心配置文件SqlMapConfig.xml，放在src目录下）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE configuration</div><div class="line">PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</div><div class="line">"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">	&lt;!-- 配置mybatis的环境信息，与spring整合，该信息由spring来管理 --&gt;</div><div class="line">	&lt;environments default="development"&gt;</div><div class="line">		&lt;environment id="development"&gt;</div><div class="line">			&lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt;</div><div class="line">			&lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;</div><div class="line">			&lt;!-- 配置数据源，采用mybatis连接池 --&gt;</div><div class="line">			&lt;dataSource type="POOLED"&gt;</div><div class="line">				&lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt;</div><div class="line">				&lt;property name="url" value="jdbc:mysql://localhost:9806/sshe" /&gt;</div><div class="line">				&lt;property name="username" value="root" /&gt;</div><div class="line">				&lt;property name="password" value="root" /&gt;</div><div class="line">			&lt;/dataSource&gt;</div><div class="line">		&lt;/environment&gt;</div><div class="line">	&lt;/environments&gt;</div><div class="line"></div><div class="line">	&lt;mappers&gt;</div><div class="line">		还没有映射文件 </div><div class="line">	&lt;/mappers&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>简要说明一下，类似于hibernate核心配置文件，连接数据库，这里暂时还没有映射文件，后面步骤在加上</p>
<p>步骤六：映射文件（User.xml）这里是通过id查询返回对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE mapper    </div><div class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    </div><div class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line">&lt;!-- namespace：命名空间，对statement的信息进行分类管理 --&gt;</div><div class="line">&lt;!-- 注意：在mapper代理时，它具有特殊及重要的作用 --&gt;</div><div class="line">&lt;mapper namespace="test"&gt;</div><div class="line">	&lt;!-- 根据用户ID查询用户信息 --&gt;</div><div class="line">	&lt;!-- select：表示一个MappedStatement对象 --&gt;</div><div class="line">	&lt;!-- id：statement的唯一标示 --&gt;</div><div class="line">	&lt;!-- #&#123;&#125;：表示一个占位符？ --&gt;</div><div class="line">	&lt;!-- #&#123;id&#125;：里面的id表示输入参数的参数名称，如果该参数是简单类型，那么#&#123;&#125;里面的参数名称可以任意 --&gt;</div><div class="line">	&lt;!-- parameterType：输入参数的java类型 --&gt;</div><div class="line">	&lt;!-- resultType：输出结果的所映射的java类型（单条结果所对应的java类型） --&gt;</div><div class="line">	&lt;select id="findUserById" parameterType="int"</div><div class="line">		resultType="com.zwl.pojo.User"&gt;</div><div class="line">		SELECT * FROM user WHERE id =#&#123;id&#125;</div><div class="line">	&lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure></p>
<p>步骤七：在全局配置文件中声明映射文件（User.xml）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;mappers&gt;</div><div class="line">		&lt;mapper resource=<span class="string">"com/zwl/pojo/User.xml"</span> /&gt;</div><div class="line">	&lt;/mappers&gt;</div></pre></td></tr></table></figure></p>
<p>步骤八：测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">import java.io.InputStream;</div><div class="line"></div><div class="line">import org.apache.ibatis.io.Resources;</div><div class="line">import org.apache.ibatis.session.SqlSession;</div><div class="line">import org.apache.ibatis.session.SqlSessionFactory;</div><div class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public class test &#123;</div><div class="line">	@Test</div><div class="line">	public void findUserByIdtest() throws Exception&#123;</div><div class="line">		        //读取配置文件</div><div class="line">				//全局配置文件的路径</div><div class="line">				String resource = "SqlMapConfig.xml";</div><div class="line">				InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">				</div><div class="line">				//创建SqlSessionFactory</div><div class="line">				SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div><div class="line">				</div><div class="line">				//创建SqlSession</div><div class="line">				SqlSession sqlSession = sqlSessionFactory.openSession();</div><div class="line">				</div><div class="line">				//调用SqlSession的增删改查方法</div><div class="line">				//第一个参数：表示statement的唯一标示</div><div class="line">				User u=sqlSession.selectOne("test.findUserById", 1);</div><div class="line">				System.out.println(u.getName());</div><div class="line">				sqlSession.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后可将数据库中id为1的数据取出</p>
<p>至此，入门程序算是完成了，通过上面步骤发现，这里的不完全orm，还是得最后我们自己写sql，这样我们就可以面对复杂表关系时，自己优化了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Mybatis就是一个封装了jdbc的持久层框架，它和hibernate都属于orm框架，但是具体说，hibernate是一个完全的orm框
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>spring mvc之四:数据回显与json</title>
    <link href="http://www.myzwl.win/2017/04/01/springmvc4/"/>
    <id>http://www.myzwl.win/2017/04/01/springmvc4/</id>
    <published>2017-04-01T11:48:51.000Z</published>
    <updated>2017-04-02T15:32:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>比较struts2与spring mvc<br>实现机制：<br>Struts2是基于过滤器实现的。<br>Springmvc基于servlet实现。Servlet比过滤器快。</p>
<p>运行速度：<br>Struts2是多列<br>请求来了以后，struts2创建多少个对象：<br>ActionContext，valuestack，UserAction，ActionSuport，ModelDriven<br>Springmvc是单列</p>
<p>参数封装来分析：<br>Struts基于属性进行封装。<br>Springmvc基于方法封装。</p>
<p>页面回显：<br> 查询所有<br>构造一组list数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("userlist")</div><div class="line">   //model	相当于application域对象</div><div class="line">	public String userlist(Model modal)&#123;</div><div class="line">		List&lt;User&gt; list=new ArrayList&lt;&gt;();</div><div class="line">		User u1=new User();</div><div class="line">		u1.setId(1);</div><div class="line">		u1.setSex("1");</div><div class="line">		u1.setAddress("lol");</div><div class="line">		u1.setUsername("1");</div><div class="line">		u1.setBirthday(new Date());</div><div class="line">		</div><div class="line">		User u2=new User();</div><div class="line">		u2.setId(1);</div><div class="line">		u2.setSex("1");</div><div class="line">		u2.setAddress("lol");</div><div class="line">		u2.setUsername("1");</div><div class="line">		u2.setBirthday(new Date());</div><div class="line">		</div><div class="line">		list.add(u1);</div><div class="line">		list.add(u2);</div><div class="line">		</div><div class="line">		modal.addAttribute("userlist", list);</div><div class="line">		</div><div class="line">		return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>页面回显（利用jstl标签回显）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;//声明此标签</div><div class="line"></div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;table border="1" style="color: blue"&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">&lt;td&gt;姓名&lt;/td&gt;</div><div class="line">&lt;td&gt;生日&lt;/td&gt;</div><div class="line">&lt;td&gt;性别&lt;/td&gt;</div><div class="line">&lt;td&gt;地址&lt;/td&gt;</div><div class="line">&lt;td&gt;操作&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;c:forEach items="$&#123;userlist &#125;" var="user"&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">&lt;td&gt;$&#123;user.username &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;user.birthday &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;user.sex &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;$&#123;user.address &#125;&lt;/td&gt;</div><div class="line">&lt;td&gt;</div><div class="line">&lt;a href="$&#123;pageContext.request.contextPath &#125;/test/update?id=$&#123;user.id &#125;"&gt;delete&lt;/a&gt;</div><div class="line">&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line"></div><div class="line">&lt;/c:forEach&gt;</div><div class="line"></div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>注意此处有个delete</p>
<blockquote>
<p><a href="${pageContext.request.contextPath }/test/update?id=${user.id }">delete</a></p>
</blockquote>
<p>利用？的方法，无疑将值显示的传过去，很不安全</p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc2/test/userlist.do" target="_blank" rel="external">http://localhost:100/springmvc2/test/userlist.do</a></p>
<p>可以取出集合中的数据，同时delete中有显示id=参数传过去了</p>
<h4 id="URL模版映射"><a href="#URL模版映射" class="headerlink" title="URL模版映射"></a>URL模版映射</h4><p>url模版映射是restfull软件架构<br>Web.xml拦截方式：在rest目录下所有请求都被拦截，servlet可以拦截目录<br>配置如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;/rest<span class="comment">/*&lt;/url-pattern&gt;</span></div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
<p>（）:匹配接受页面Url路径参数<br>@Pathariable：（）里面参数注入后面参数里面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("update/&#123;id&#125;")</div><div class="line">	public String update(@PathVariable Integer id)&#123;</div><div class="line">		System.out.println(id);</div><div class="line">		</div><div class="line">		return "redirect:/test/userlist.do";</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>页面修改：</p>
<blockquote>
<p><a href="${pageContext.request.contextPath }/rest/test/update/${user.id }">delete</a></p>
</blockquote>
<p>测试：同样输入相同地址，会发现href代参直接变成/参数</p>
<h4 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h4><p>转发<br>关键字：forward<br>本类进行转发：<br>本类方法与方法之间进行forward<br>转发方式：</p>
<blockquote>
<p>return “forward : /test/userlist.do”;</p>
</blockquote>
<p>跨类进行转发：<br>转发方式：return ”forward：/items/userlist.do“；<br>其中items是类前面的路径声明</p>
<p>重定向<br>关键字：redirect<br>本类进行重定向：<br>本类方法与方法之间进行redirect<br>重定向方式：</p>
<blockquote>
<p>return “redirect:/test/userlist.do”;</p>
</blockquote>
<p>跨类进行重定向：<br>转发方式：return ”redirect：/items/userlist.do“；</p>
<h4 id="responseBody和-RequestBody"><a href="#responseBody和-RequestBody" class="headerlink" title="@responseBody和@RequestBody"></a>@responseBody和@RequestBody</h4><p>@responseBody把后台pojo转换json对象，返回到页面。<br>@RequestBody接受前台json数据，把json数据自动封装javaBean。</p>
<p>下面以一个实例说明<br>这里ajax传递json数据用jquery来模拟</p>
<p>步骤一：导入jar包（jackson-core-asl-1.9.11.jar和jackson-mapper-asl-1.9.11.jar）<br>加入jquery<br>在springmvc.xml文件中声明对json数据的支持<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</div><div class="line">		&lt;property name=<span class="string">"messageConverters"</span>&gt;</div><div class="line">		&lt;bean class=<span class="string">"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"</span>&gt;&lt;/bean&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>页面传递ajax格式<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">function requestjson()&#123;</div><div class="line">	//模拟了一个json格式数据</div><div class="line">			 var jsonobj=JSON.stringify(&#123;"username":"11","sex":"man","address":"ok"&#125;); </div><div class="line">			$.ajax(&#123;</div><div class="line">				type:'POST',</div><div class="line">				url:'&lt;%=path%&gt;/test/requestjson.do',</div><div class="line">	//申明传递的是json格式</div><div class="line">				 contentType:'application/json;charset=utf-8', </div><div class="line">	//传递的数据</div><div class="line">				data:jsonobj,</div><div class="line">	//如果成功，返回数据</div><div class="line">				success:function(data)&#123;</div><div class="line">					</div><div class="line">					alert(data.username);</div><div class="line">				&#125;</div><div class="line">			&#125;)</div><div class="line">			</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	&lt;/script&gt;</div><div class="line"></div><div class="line">	 &lt;body&gt;</div><div class="line">  &lt;form action=""&gt;</div><div class="line">   &lt;input type="text" name="username1" onclick="requestjson();"/&gt;</div><div class="line">   &lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>后台代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("requestjson")</div><div class="line">	public @ResponseBody User requestjson(@RequestBody User user)&#123;</div><div class="line">		System.out.println(user.getSex());</div><div class="line">		</div><div class="line">		return user;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>此处声明了接受的参数和返回的都是json数据格式</p>
<p>测试：在浏览器输入<a href="http://localhost:100/springmvc2/index.jsp" target="_blank" rel="external">http://localhost:100/springmvc2/index.jsp</a><br>通过点击文本，后台会打印参数，同时返回一个user对象给前台，并显示出来</p>
<p>pojo，后台返回json<br>前台请求数据构造：key=value&amp;key=value.<br>首先是页面<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">				type:'POST',</div><div class="line">				url:'&lt;%=path%&gt;/user/requestjson1.do',</div><div class="line">				data:'username=lol&amp;address=zwl',</div><div class="line">				success:function(data)&#123;</div><div class="line">					</div><div class="line">					alert(data.username);</div><div class="line">				&#125;</div><div class="line">			&#125;)</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">后台代码：</div><div class="line">@RequestMapping("requestjson1")</div><div class="line">	public @ResponseBody User requestjson1(User user)&#123;</div><div class="line">		System.out.println(user.getAddress());</div><div class="line">		</div><div class="line">		return user;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>最后在springmvc中配置的前两个设配器，我们可以通过一个注解声明代替</p>
<blockquote>
<p><mvc:annotation-driven></mvc:annotation-driven></p>
</blockquote>
<p>不仅如此，它还自动包括了json数据格式声明等等<br>即默认创建注解处理器映射器，注解处理器适配器。提供json格式支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;比较struts2与spring mvc&lt;br&gt;实现机制：&lt;br&gt;Struts2是基于过滤器实现的。&lt;br&gt;Springmvc基于servl
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>spring mvc之三:注解开发</title>
    <link href="http://www.myzwl.win/2017/03/31/springmvc3/"/>
    <id>http://www.myzwl.win/2017/03/31/springmvc3/</id>
    <published>2017-03-31T11:48:51.000Z</published>
    <updated>2017-04-02T15:32:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我们都是通过xml方式显示配置，会发现配置起来特别麻烦。当使用注解时，有时只需在相关类中做相关的声明，就能完成同样的工作。</p>
<p>不多说：先来一个注解开发例子</p>
<p>步骤一：首先创建一个web工程</p>
<p>步骤二：添加jar包</p>
<p>步骤三：配置web.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt;</div><div class="line">  </div><div class="line">  &lt;filter&gt;</div><div class="line">  &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line">  &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">  &lt;init-param&gt;</div><div class="line">  &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line">  &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line">  &lt;/init-param&gt;</div><div class="line">  &lt;/filter&gt;</div><div class="line">  </div><div class="line">  &lt;filter-mapping&gt;</div><div class="line">  &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">  &lt;/filter-mapping&gt;</div><div class="line">  </div><div class="line">  &lt;servlet&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">  &lt;!-- 默认加载方式</div><div class="line">  	   默认加载必须规范：</div><div class="line">  	   * 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml</div><div class="line">  	   * 路径规范：必须在WEB-INF目录下面</div><div class="line">   --&gt;</div><div class="line"> &lt;/servlet&gt;</div><div class="line">  </div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>步骤四：配置springmvc-servlet.xml文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt;</div><div class="line">		</div><div class="line">		&lt;!--  扫描基本的父包，这样子类包被自动扫到执行 --&gt;</div><div class="line">		&lt;context:component-scan base-package="com.zwl"&gt;&lt;/context:component-scan&gt;</div><div class="line">		</div><div class="line">	&lt;!-- 配置注解处理器映射器 </div><div class="line">			功能：寻找执行类Controller</div><div class="line">		--&gt;</div><div class="line"></div><div class="line">		 &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt;</div><div class="line">		&lt;!-- 配置注解处理器适配器 </div><div class="line">			功能：调用controller方法，执行controller</div><div class="line">		--&gt;</div><div class="line"></div><div class="line">		&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;</div><div class="line">		&lt;/bean&gt;</div><div class="line">		&lt;!-- 配置sprigmvc视图解析器：解析逻辑试图 </div><div class="line">			 后台返回逻辑试图：index</div><div class="line">			视图解析器解析出真正物理视图：前缀+逻辑试图+后缀====/WEB-INF/jsps/index.jsp</div><div class="line">		--&gt;</div><div class="line">		&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;</div><div class="line">		&lt;property name="prefix" value="/"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;		</div><div class="line">		&lt;/bean&gt;</div><div class="line">		&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>这里简要说明一下，以上是注解最基本的配置，有扫描配置，两个基本配置和一个视图配置</p>
<p>步骤五：自定义controller类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import org.springframework.stereotype.Controller;</div><div class="line">import org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"></div><div class="line">@Controller  //相当于&lt;bean class="Usercontrol"/&gt;并且声明这是一个controller</div><div class="line">public class Usercontrol &#123;</div><div class="line"></div><div class="line">	@RequestMapping("hello") //相当于需要访问的路径hello.do</div><div class="line">	public String say()&#123;</div><div class="line">		return "index" ;  //放回到逻辑视图index.jsp</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个最简化的注解配置<br>对应index.jsp<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> &lt;body&gt;</div><div class="line">hello 盲僧</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：浏览器中输入<a href="http://localhost:100/springmvc2/hello.do" target="_blank" rel="external">http://localhost:100/springmvc2/hello.do</a></p>
<p>对应输出结果</p>
<blockquote>
<p>hello 盲僧</p>
</blockquote>
<h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h4><p>它有三种方式，分别为</p>
<blockquote>
<p>requestMapping(“hello”)<br>requestMapping(“/hello.do”)<br>requestMapping(value=”/hello.do”)</p>
</blockquote>
<p>都能达到同样的效果，都是需要访问的路径<br>如果在类前面添加此属性，则相当于映射路径在加一层<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Controller <span class="comment">//&lt;bean class="Usercontrol"/&gt;</span></div><div class="line">@RequestMapping(<span class="string">"/test"</span>)</div><div class="line">public class Usercontrol &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>即<a href="http://localhost:100/springmvc2/test/hello.do" target="_blank" rel="external">http://localhost:100/springmvc2/test/hello.do</a></p>
<p>另外，注意下里面还有个method配置，即按什么模式接受表单</p>
<blockquote>
<p>@RequestMapping(value=”/hello.do”,method=RequestMethod.GET)</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>@RequestMapping(value=”/hello.do”,method=RequestMethod.POST)</p>
</blockquote>
<p>默认是两个都可以的</p>
<blockquote>
<p>requestMapping(value=”/hello.do”,method={RequestMethod.POST, RequestMethod.GET})</p>
</blockquote>
<h4 id="封装参数"><a href="#封装参数" class="headerlink" title="封装参数"></a>封装参数</h4><p>分析接受参数类型：<br>基本类型，int，String等等基本类型。<br>Pojo类型<br>包装类型<br>Springmvc参数封装：基于方法进行封装。</p>
<p>一：基本类型<br> 封装int型参数<br>页面<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  &lt;body&gt;</div><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/ test/recieve.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">id：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"id"</span> id=<span class="string">"id"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>接受参数方法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recieve")</div><div class="line">	public String recieve(Integer id)&#123;</div><div class="line">		System.out.println(id);</div><div class="line">  return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>注意这里的Integer id必须要与页面中的name=”id”一致才能正确接受参数</p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc2/index.jsp" target="_blank" rel="external">http://localhost:100/springmvc2/index.jsp</a></p>
<p>然后输入id，后台即可接收到参数</p>
<p>接受字符转类型<br>页面：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/ test/recievestr.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">id：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"name"</span> id=<span class="string">"name"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>接收参数方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recievestr")</div><div class="line">	public String recievestr(String name)&#123;</div><div class="line">		System.out.println(name);</div><div class="line">		  return "login";&#125;</div></pre></td></tr></table></figure></p>
<p>接受数组：<br>分析：批量：checkbox复选框。Value必须有值<br>页面：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/test/recievearray.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">ID：&lt;<span class="selector-tag">input</span> type=<span class="string">"checkbox"</span> name=<span class="string">"ids"</span> value=<span class="string">"1"</span> id=<span class="string">"ids"</span>&gt;</div><div class="line">ID：&lt;<span class="selector-tag">input</span> type=<span class="string">"checkbox"</span> name=<span class="string">"ids"</span> value=<span class="string">"2"</span> id=<span class="string">"ids"</span>&gt;</div><div class="line">ID：&lt;<span class="selector-tag">input</span> type=<span class="string">"checkbox"</span> name=<span class="string">"ids"</span> value=<span class="string">"3"</span> id=<span class="string">"ids"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>接受参数的方法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recievearray")</div><div class="line">	public String recievearray(Integer []ids)&#123;</div><div class="line">		System.out.println(ids);</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>接受pojo类<br>页面：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/test/recieveUser.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">姓名：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"username"</span> id=<span class="string">"username"</span>&gt;</div><div class="line">生日：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"birthday"</span> id=<span class="string">"birthday"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>Pojo类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">	</div><div class="line">	private String username;</div><div class="line">	private Date birthday;</div><div class="line"></div><div class="line">此处省略set。Get方法&#125;</div></pre></td></tr></table></figure></p>
<p>接受参数的方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping("recieveUser")</div><div class="line">	public String recievearray(User user)&#123;</div><div class="line">		System.out.println(user.getUsername());</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>接受包装类型参数<br> 包装pojo类</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Usercus &#123;</div><div class="line">	private User user;</div><div class="line">此处省略set。Get方法。&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/usercus.do" method="post"&gt;</div><div class="line">姓名：&lt;input type="text" name="user.username" id="username"&gt;</div><div class="line">生日：&lt;input type="text" name="user.birthday" id="birthday"&gt;</div><div class="line">&lt;input type="submit" value="提交"&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">接受参数的方法：</div><div class="line">@RequestMapping("usercus")</div><div class="line">	public String usercus(Usercus user)&#123;</div><div class="line">		System.out.println(user.getUser().getUsername());</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>接受集合类型参数<br> 接受list集合<br>首先在包装类中加入如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private List&lt;User&gt; userlist;</div><div class="line">此处省略set，get方法</div><div class="line"></div><div class="line">然后是页面</div><div class="line">&lt;form action="$&#123;pageContext.request.contextPath &#125;/test/recievelist.do" method="post"&gt;</div><div class="line">姓名：&lt;input type="text" name="userList[0].username" id="username"&gt;</div><div class="line">地址：&lt;input type="text" name="userList[0].address" id="address"&gt;</div><div class="line"></div><div class="line">姓名：&lt;input type="text" name="userList[1].username" id="username"&gt;</div><div class="line">地址：&lt;input type="text" name="userList[1].address" id="address"&gt;</div><div class="line">&lt;input type="submit" value="提交"&gt;</div><div class="line"></div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">接受参数方法：</div><div class="line">@RequestMapping("recievelist")</div><div class="line">	public String recievelist(Usercus userlist)</div><div class="line">	&#123;</div><div class="line">		System.out.println(userlist.getUserlist().get(0).getUsername());</div><div class="line">		 return "login";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前我们都是通过xml方式显示配置，会发现配置起来特别麻烦。当使用注解时，有时只需在相关类中做相关的声明，就能完成同样的工作。&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>spring mvc之二:处理器</title>
    <link href="http://www.myzwl.win/2017/03/31/springmvc2/"/>
    <id>http://www.myzwl.win/2017/03/31/springmvc2/</id>
    <published>2017-03-31T10:48:51.000Z</published>
    <updated>2017-03-31T13:05:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在spring mvc中，使用映射处理器可以把web请求映射到正确的处理器上，spring内置了很多映射器，而且我们也可以自定义处理器，映射处理器都能把请求传递到处理器执行链接上，并且处理器执行链接必须包含能处理该请求的处理器，而且处理器链接也能包含一系列拦截器<br>  接下来就是一些常见的处理映射器</p>
<h4 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h4><p> 功能：寻找Controller<br>        根据url请求去匹配bean的name属性url，从而获取Controller<br>      这里注意：这是默认的映射器，也就是说我们不配置这个，也能自动执行这个<br>     如：入门程序中的案例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置自定义Controler --&gt;</div><div class="line">		&lt;bean id=<span class="string">"mycontrol"</span> name=<span class="string">"/hello.do"</span> class=<span class="string">"com.zwl.control.mycontrol"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p> 即根据自定义的/hello.do，找到对应的mycontrol.java类</p>
<h4 id="SimpleUrlHandlerMaping"><a href="#SimpleUrlHandlerMaping" class="headerlink" title="SimpleUrlHandlerMaping"></a>SimpleUrlHandlerMaping</h4><p> 功能：寻找Controller<br>      根据浏览器url匹配简单url的key，key又Controller的id找到Controller<br>如：在映射文件中配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</div><div class="line">		&lt;property name=<span class="string">"mappings"</span>&gt;</div><div class="line">		&lt;props&gt;</div><div class="line">		&lt;prop key=<span class="string">"zwl.do"</span>&gt;mycontrol&lt;/prop&gt;</div><div class="line">		&lt;prop key=<span class="string">"slycmiaoxi.do"</span>&gt;mycontrol&lt;/prop&gt;</div><div class="line">		&lt;/props&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;/bean&gt;</div><div class="line"></div><div class="line">		   &lt;!-- 配置自定义Controler --&gt;</div><div class="line">		&lt;bean id=<span class="string">"mycontrol"</span>  class=<span class="string">"com.zwl.control.mycontrol"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器输入<a href="http://localhost:100/springmvc1/zwl.do或者http://localhost:100/springmvc1/slycmiaoxi.do" target="_blank" rel="external">http://localhost:100/springmvc1/zwl.do或者http://localhost:100/springmvc1/slycmiaoxi.do</a></p>
<p>输出结果：</p>
<blockquote>
<p>hello world</p>
</blockquote>
<p>此外：这个映射器是把url进行集中配置</p>
<h4 id="ControllerClassNameHandlerMapping"><a href="#ControllerClassNameHandlerMapping" class="headerlink" title="ControllerClassNameHandlerMapping"></a>ControllerClassNameHandlerMapping</h4><p>功能：寻找Controller<br>       根据类名（Mycontrol）类名.do来访问,类名首字母小写<br>在配置文件中增加如下配置</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 定义通过: 类名<span class="selector-class">.do</span> 形式来访问controller --&gt;</div><div class="line">		 &lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>注意，这里并没有声明mycontrol.do和只有一个类mycontrol.java</p>
<p>测试：在浏览器输入<a href="http://localhost:100/springmvc1/mycontrol.do" target="_blank" rel="external">http://localhost:100/springmvc1/mycontrol.do</a><br>结果：</p>
<blockquote>
<p>hello world</p>
</blockquote>
<p>事实上，以上三个映射器都可以同时存在</p>
<p>下面将是处理器适配器</p>
<h4 id="SimpleControllerHandlerAdapter"><a href="#SimpleControllerHandlerAdapter" class="headerlink" title="SimpleControllerHandlerAdapter"></a>SimpleControllerHandlerAdapter</h4><p>功能：执行controller<br>      调用controller里面方法，返回modelAndView。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置处理器适配器执行Controlelr ,springmvc默认的</div><div class="line">		SimpleControllerHandlerAdapter:执行Controller</div><div class="line">		--&gt;</div><div class="line">		&lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h4 id="HttpRequestHandlerAdapter"><a href="#HttpRequestHandlerAdapter" class="headerlink" title="HttpRequestHandlerAdapter"></a>HttpRequestHandlerAdapter</h4><p>功能：执行controller<br>首先新建一个类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import javax.servlet.ServletException;</div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import org.springframework.web.HttpRequestHandler;</div><div class="line"></div><div class="line">public class httpcontrol implements HttpRequestHandler &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void handleRequest(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line">		       request.setCharacterEncoding("utf-8");</div><div class="line">		     //给Request设置值，在页面进行回显</div><div class="line">		       request.setAttribute("hello", "lol");</div><div class="line">		       response.setCharacterEncoding("utf-8");</div><div class="line">		     //跳转页面</div><div class="line">		       request.getRequestDispatcher("/index.jsp").forward(request, response);;</div><div class="line"> </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在配置文件中配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!-- HttpRequestHandlerAdapter负责执行实现接口HttpRequestHandler的后端</div><div class="line">			 控制器。</div><div class="line">		 --&gt;</div><div class="line">		&lt;bean class=<span class="string">"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"</span>&gt;&lt;/bean&gt;</div><div class="line">		</div><div class="line">		&lt;!-- 配置自定义HttpController --&gt;</div><div class="line">		&lt;bean id=<span class="string">"http"</span> class=<span class="string">"com.zwl.control.httpcontrol"</span>&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">		&lt;prop key=<span class="string">"/zwl.do"</span>&gt;http&lt;/prop&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入：<a href="http://localhost:100/springmvc1/zwl.do" target="_blank" rel="external">http://localhost:100/springmvc1/zwl.do</a></p>
<p>输出结果：</p>
<blockquote>
<p>lol</p>
</blockquote>
<p>注意这两个处理器设配器可以共存！</p>
<h4 id="命令控制器"><a href="#命令控制器" class="headerlink" title="命令控制器"></a>命令控制器</h4><p>Spring mvc通过命令设计模式接受页面参数。</p>
<p>自定义命令控制器<br>首先新建一个pojo类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pojo;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line">private int id;</div><div class="line">private String username;</div><div class="line">public int getId() &#123;</div><div class="line">	return id;</div><div class="line">&#125;</div><div class="line">public String getUsername() &#123;</div><div class="line">	return username;</div><div class="line">&#125;</div><div class="line">public void setId(int id) &#123;</div><div class="line">	this.id = id;</div><div class="line">&#125;</div><div class="line">public void setUsername(String username) &#123;</div><div class="line">	this.username = username;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自定义控制器<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import org.springframework.validation.BindException;</div><div class="line">import org.springframework.web.servlet.ModelAndView;</div><div class="line">import org.springframework.web.servlet.config.MvcNamespaceHandler;</div><div class="line">import org.springframework.web.servlet.mvc.AbstractCommandController;</div><div class="line"></div><div class="line">import com.zwl.pojo.User;</div><div class="line"></div><div class="line">public class CommandController extends AbstractCommandController &#123;</div><div class="line"></div><div class="line">	//指定参数绑定哪个pojo类</div><div class="line">		public CommandController()&#123;</div><div class="line">			</div><div class="line">			this.setCommandClass(User.class);</div><div class="line">			</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected ModelAndView handle(HttpServletRequest request,</div><div class="line">			HttpServletResponse response, Object command, BindException error)</div><div class="line">			throws Exception &#123;</div><div class="line">		//将命令对象强转成用户对象</div><div class="line">		User user=(User)command;</div><div class="line">		ModelAndView mv=new ModelAndView();</div><div class="line">		mv.addObject("user",user);</div><div class="line">        mv.setViewName("index");	</div><div class="line">		return mv;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>封装参数页面（这里是login.jsp）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  &lt;body&gt;</div><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/command.do"</span> method=<span class="string">"post"</span>&gt;</div><div class="line">姓名：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"username"</span> id=<span class="string">"username"</span>&gt;</div><div class="line">id：&lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"id"</span> id=<span class="string">"id"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>配置bean<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=<span class="string">"/command.do"</span> class=<span class="string">"com.zwl.control.CommandController"</span>&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>回显数据：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> &lt;body&gt;</div><div class="line"> $&#123;user<span class="selector-class">.username</span> &#125; &lt;br&gt;</div><div class="line">$&#123;user<span class="selector-class">.id</span> &#125; &lt;br&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc1/login.jsp到login.jsp" target="_blank" rel="external">http://localhost:100/springmvc1/login.jsp到login.jsp</a><br>然后分别将name输入中文和非中文，发现出现中文乱码</p>
<p>需要Spring编码过滤器：在web.xml配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line"> &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line"> &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line"> &lt;init-param&gt;</div><div class="line"> &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line"> &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line"> &lt;/init-param&gt;</div><div class="line"> &lt;/filter&gt;</div><div class="line"> </div><div class="line"> &lt;filter-mapping&gt;</div><div class="line"> &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt;</div><div class="line"> &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line"> &lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>然后输入中文，就没有乱码了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在spring mvc中，使用映射处理器可以把web请求映射到正确的处理器上，spring内置了很多映射器，而且我们也可以自定义处理器，映射
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>spring mvc之一:hello world</title>
    <link href="http://www.myzwl.win/2017/03/31/springmvc1/"/>
    <id>http://www.myzwl.win/2017/03/31/springmvc1/</id>
    <published>2017-03-31T09:48:51.000Z</published>
    <updated>2017-03-31T11:44:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MVC模式是Model-View-Control的简写，而spring mvc主要负责c层，主要为封装web请求为一个数据对象、调用业务逻辑层来处理数据对象、返回处理数据结果及相应的视图给用户</p>
<p>简要概述spring mvc：<br>   SpringC层框架的核心是DispatcherServlet，它的作用是将请求分发给不同的后端处理器，springC层框架使用了后端控制器、映射处理器和视图解析器来共同完成c层的主要任务，真正的把业务层处理的数据结果和相应的视图拼成一个对象，即ModelAndView对象</p>
<p>下面以hello world为入门程序搭建环境<br>步骤一：创建一个web工程</p>
<p>步骤二：导入相关jar包<br><img src="/images/imgs2/16.gif" alt="Alt text"></p>
<p>步骤三：编写web.xml配置文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt;</div><div class="line"></div><div class="line">  &lt;servlet&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet</div><div class="line">&lt;/servlet-class&gt;</div><div class="line"> &lt;/servlet&gt;</div><div class="line">  </div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</div><div class="line">  &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>简要说明一下：dispatcherservlet就是一个servlet，也是对请求进行转发的核心servlet。在这里即所有的.do的请求将首先被dispatcherservlet处理，而它要做的工作就是对请求进行分发（即把请求转发给具体的controller），可以简单的认为，他就是一个总控处理器，除此之外，它还能使用spring的其他功能<br>同时注意一下上面的servlet-name<br>默认加载方式<br>         默认加载必须规范：</p>
<pre><code>* 文件命名：servlet-name-servlet.xml====springmvc-servlet.xml
* 路径规范：必须在WEB-INF目录下面
</code></pre><p> 步骤四：配置springmvc-servlet.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/mvc </div><div class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/context </div><div class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/aop </div><div class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </div><div class="line">		http://www.springframework.org/schema/tx </div><div class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt;</div><div class="line">		</div><div class="line">		</div><div class="line">		&lt;!-- 配置处理器映射器,springmvc默认的处理器映射器</div><div class="line">		BeanNameUrlHandlerMapping：根据bean(自定义Controler)的name属性的url去寻找hanler(Action:Controller)</div><div class="line">		 --&gt;</div><div class="line">		&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt;</div><div class="line">	 	</div><div class="line">		&lt;!-- 配置处理器适配器执行Controlelr ,springmvc默认的</div><div class="line">		SimpleControllerHandlerAdapter:执行Controller</div><div class="line">		--&gt;</div><div class="line">		&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt;</div><div class="line">		</div><div class="line">		&lt;!-- 配置自定义Controler --&gt;</div><div class="line">		&lt;bean id="mycontrol" name="/hello.do" class="com.zwl.control.mycontrol"&gt;&lt;/bean&gt;</div><div class="line">		</div><div class="line">	</div><div class="line">		&lt;!-- 配置sprigmvc视图解析器：解析逻辑试图 </div><div class="line">			 后台返回逻辑试图：index</div><div class="line">			视图解析器解析出真正物理视图：前缀+逻辑试图+后缀--&gt;</div><div class="line"></div><div class="line">		&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;</div><div class="line">		&lt;property name="prefix" value="/"&gt;&lt;/property&gt;</div><div class="line">		&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;		</div><div class="line">		&lt;/bean&gt;</div><div class="line">		&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>步骤五：自定义controller<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.zwl.control;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import org.springframework.web.servlet.ModelAndView;</div><div class="line">import org.springframework.web.servlet.mvc.Controller;</div><div class="line"></div><div class="line">public class mycontrol implements Controller &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public ModelAndView handleRequest(HttpServletRequest arg0,</div><div class="line">			HttpServletResponse arg1) throws Exception &#123;</div><div class="line">		//接受请求，参数，验证参数</div><div class="line">		//封装参数，调用业务方法</div><div class="line">		//返回视图</div><div class="line">		ModelAndView mv=new ModelAndView();</div><div class="line">		</div><div class="line">		//设置页面回显数据</div><div class="line">		mv.addObject("hello","hello world");</div><div class="line">		//指定跳转的视图</div><div class="line">		//返回物理视图</div><div class="line">        mv.setViewName("index");	</div><div class="line">		return mv;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤六：定义视图页面<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">   $&#123;hello&#125;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入<a href="http://localhost:100/springmvc1/hello.do" target="_blank" rel="external">http://localhost:100/springmvc1/hello.do</a></p>
<p>结果：</p>
<blockquote>
<p>hello world </p>
</blockquote>
<p>简要分析入门程序的过程<br>1 启动服务器，根据web.xml的配置加载前端控制器dispatcherservlet。在加载时，会完成一系列的初始化动作。</p>
<p>2 根据servlet的映射请求（上面的.do），并参照spingmvc-servlet.xml文件，把具体的请求分发给特定的后端处理器，如上面的mycontrol</p>
<p>3 后端控制器调用相应的逻辑层代码，完成处理并返回视图对象ModelAndView给前端处理器</p>
<p>4 前端处理器根据后端控制器返回的ModelAndView对象，返回一个相应的页面给客户端</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MVC模式是Model-View-Control的简写，而spring mvc主要负责c层，主要为封装web请求为一个数据对象、调用业务逻辑
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>spring之装配bean</title>
    <link href="http://www.myzwl.win/2017/03/30/spring2/"/>
    <id>http://www.myzwl.win/2017/03/30/spring2/</id>
    <published>2017-03-30T09:48:51.000Z</published>
    <updated>2017-04-02T15:32:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在spring中，对象无需自己负责查找或创建与其关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象，例如一个消费系统需要信誉证件，但它不需要自己创建，它只负责自己两手空空，而容器就赋予它一个信用卡认证组件。<br>  通常，我们将创建应用对象间相互协作关系的行为称为装配。这也是依赖注入的本质。</p>
<h4 id="一：声明bean"><a href="#一：声明bean" class="headerlink" title="一：声明bean"></a>一：声明bean</h4><p>  首先我们假想一个选秀场景，该bean为一个表演接口<br>  public interface Performe {<br>    public void perform();<br>}<br>很显然我们需要一些参赛者，而这些参赛者就需要spring帮我们创建了</p>
<h4 id="二：创建spring配置"><a href="#二：创建spring配置" class="headerlink" title="二：创建spring配置"></a>二：创建spring配置</h4><p>   Spring是一个基于容器的框架，但是如果我们不对他进行任何配置，那么它就相当于一个空框架，一般情况下有采用XML或者注解式声明，这里都采用xml形式。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">		xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">		xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<h4 id="三：声明一个简单的bean"><a href="#三：声明一个简单的bean" class="headerlink" title="三：声明一个简单的bean"></a>三：声明一个简单的bean</h4><p>  这次表演者可以使各种各样的人，首先是一个杂技师。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Juggler implements Performe &#123;</div><div class="line"></div><div class="line">	private int bigbang=5;</div><div class="line">	</div><div class="line">	public Juggler()&#123;	</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Juggler(int bigbang)&#123;</div><div class="line">		this.bigbang=bigbang;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void perform() &#123;</div><div class="line">		System.out.println("it is "+bigbang);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要打印出杂技师扔了多少块Bigbang；</p>
<p>接下来在spring中配置bean，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;bean id=<span class="string">"juggle"</span> class=<span class="string">"com.zwl.dao.Juggler"</span>&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>这是一个最简单的声明格式<br>接下来就是加载spring上下文，进行测试</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Juggler hello=(Juggler) ApplicaionContextUtil.getApplicationContext().getBean("juggle");</div><div class="line">		hello.perform();</div></pre></td></tr></table></figure>
<p>ApplicaionContextUtil.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private static ApplicationContext ac=null;</div><div class="line"></div><div class="line">private ApplicaionContextUtil()&#123;		</div><div class="line">&#125;</div><div class="line">static&#123;</div><div class="line">	ac=new ClassPathXmlApplicationContext("applicationContext.xml");</div><div class="line">&#125;</div><div class="line">public static ApplicationContext getApplicationContext()&#123;</div><div class="line">	return ac;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<blockquote>
<p>it is 5</p>
</blockquote>
<h4 id="四：通过构造器注入"><a href="#四：通过构造器注入" class="headerlink" title="四：通过构造器注入"></a>四：通过构造器注入</h4><p> 有时候我们需要通过构造方法进行注入<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"juggle"</span> class=<span class="string">"com.zwl.dao.Juggler"</span>&gt;</div><div class="line">&lt;constructor-arg value=<span class="string">"66"</span>&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>因为Juggle有一个代参和无参构造函数，默认不配置constructor-arg则是默认构造函数，相反则是代参构造函数，</p>
<p>构造器注入对象引用<br> 上面是注入的基本类型，如果是一个对象了？<br> 在Juggler类中增加如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private Helloworld helloworld;</div><div class="line">	</div><div class="line">	public Juggler(Helloworld helloworld)&#123;</div><div class="line">		this.helloworld=helloworld;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">public void perform() &#123;</div><div class="line">		System.out.println("it is "+bigbang);</div><div class="line">		helloworld.sayhello();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>其中helloworld为入门时的程序</p>
<p>接下来就是配置文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.spring.Helloworld"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"name"</span>&gt;</div><div class="line">&lt;value&gt;hello world!&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt; </div><div class="line"></div><div class="line">&lt;bean id=<span class="string">"juggle"</span> class=<span class="string">"com.zwl.dao.Juggler"</span>&gt;</div><div class="line">&lt;constructor-arg ref=<span class="string">"helloworld"</span>&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>其中ref为注入另一个bean的id<br>测试结果：</p>
<blockquote>
<p>it is 5<br>it is hello world</p>
</blockquote>
<h4 id="五：bean的作用域"><a href="#五：bean的作用域" class="headerlink" title="五：bean的作用域"></a>五：bean的作用域</h4><p>  所有的spring bean默认都是单例，即它总是返回同一个bean实例，通过在bean中的scope属性进行设置，一般有如下属性<br>  Singleton 在每一个spring容器中，一个bean定义只对应一个对象实例（默认）<br>  Prototype  允许bean的定义可以被实例化任意次（每次调用都创建一个实例）<br>  另外还有request，session，global-session，一般只用前两者<br>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Helloworld hello=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld");</div><div class="line">		Helloworld hello1=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld");</div><div class="line">		System.out.println(hello==hello1);</div></pre></td></tr></table></figure></p>
<p>当采用默认scope时，测试结果为true</p>
<p>当进行如下修改时<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.spring.Helloworld"</span> scope=<span class="string">"prototype"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>测试结果为false</p>
<p>另外在我们初始化和销毁bean时，需要在bean中配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.spring.Helloworld"</span> scope=<span class="string">"prototype"</span> init-method=<span class="string">"sayhello"</span> destroy-method=<span class="string">"saybyb"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>其中sayhello与saybyb都是该类中方法，当在调用该bean之前，调用init-method，而在该bean销毁前，即生命周期结束前实现destroy-method，</p>
<h4 id="六：注入bean属性"><a href="#六：注入bean属性" class="headerlink" title="六：注入bean属性"></a>六：注入bean属性</h4><p>   通常，javabean的属性时私有的，同时拥有一组set与get方法取出该属性，spring可以借助set配置属性的值<br>   注意，这里和利用构造器的注入差不多<br>   如注入简单值<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"name"</span> value=<span class="string">"hello world"</span>&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>引用其他bean<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"hello"</span> ref=<span class="string">"helloworld"</span>&gt;&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>其中name中的值是该bean中的属性，名字要一致，而ref是该配置文件中的其他bean</p>
<h4 id="七：装配集合"><a href="#七：装配集合" class="headerlink" title="七：装配集合"></a>七：装配集合</h4><p>  前面我们都是介绍单个对象的装配，对于复合类型该如何装配了<br> 不妨模拟一个案例<br>首相是一个Student类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package com.zwl.spring;</div><div class="line"></div><div class="line">public class Student &#123;</div><div class="line"></div><div class="line">	private String name;</div><div class="line"></div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是School类，主要有的属性为集合，首先是list<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class School &#123;</div><div class="line"></div><div class="line">	private List&lt;Student&gt; stulist;</div><div class="line">	</div><div class="line">	public List&lt;Student&gt; getStulist() &#123;</div><div class="line">		return stulist;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setStulist(List&lt;Student&gt; stulist) &#123;</div><div class="line">		this.stulist = stulist;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置的bean<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"stu"</span> class=<span class="string">"com.zwl.spring.Student"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"name"</span> value=<span class="string">"hello"</span>&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id=<span class="string">"stu1"</span> class=<span class="string">"com.zwl.spring.Student"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"name"</span> value=<span class="string">"world"</span>&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>简要说明一下，这里注入同一个类的不同bean，用于装入集合<br>然后是配置school<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"sch"</span> class=<span class="string">"com.zwl.spring.School"</span>&gt;</div><div class="line">&lt;property name=<span class="string">"stulist"</span>&gt;</div><div class="line">&lt;list&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu"</span>/&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu1"</span>/&gt;</div><div class="line">&lt;/list&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>一般格式如下，属性下，配置<list>和要引入的bean</list></p>
<p>测试代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch");</div><div class="line">		String name1=hello.getStulist().get(0).getName();</div><div class="line">		String name=hello.getStulist().get(1).getName();</div><div class="line">		System.out.println(name1+name);</div></pre></td></tr></table></figure></p>
<p>测试结果:</p>
<blockquote>
<p>helloworld</p>
</blockquote>
<p>Set集合装配<br> 首先在school类中加入如下属性<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> private Set&lt;Student&gt; stuset;</div><div class="line">省略set与get方法</div></pre></td></tr></table></figure></p>
<p>配置文件，添加如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"stuset"</span>&gt;</div><div class="line">&lt;set&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu"</span>/&gt;</div><div class="line">&lt;ref bean=<span class="string">"stu1"</span>/&gt;</div><div class="line">&lt;/set&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>对应测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch");</div><div class="line">	Iterator&lt;Student&gt; it=hello.getStuset().iterator();</div><div class="line">	while(it.hasNext())&#123;</div><div class="line">		Student stu=it.next();</div><div class="line">		System.out.println(stu.getName());</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这里通过迭代器取出对象<br>测试结果：</p>
<blockquote>
<p>hello<br>world</p>
</blockquote>
<p>Map集合装配<br> 首先在school中添加如下属性：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private Map&lt;String, Student&gt; stumap;</div><div class="line">省略set与get方法。。</div></pre></td></tr></table></figure></p>
<p>配置文件，添加如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"stumap"</span>&gt;</div><div class="line">&lt;map&gt;</div><div class="line">&lt;entry key=<span class="string">"11"</span> value-ref=<span class="string">"stu"</span>&gt;&lt;/entry&gt;</div><div class="line">&lt;entry key=<span class="string">"22"</span> value-ref=<span class="string">"stu1"</span>&gt;&lt;/entry&gt;</div><div class="line">&lt;/map&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>其中，key为map的索引值，而value-ref为引用的bean<br>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">School hello=(School) ApplicaionContextUtil.getApplicationContext().getBean("sch");</div><div class="line">		String name=hello.getStumap().get("11").getName();</div><div class="line">		String name1=hello.getStumap().get("22").getName();</div><div class="line">		System.out.println(name+name1);</div></pre></td></tr></table></figure></p>
<p>测试结果:</p>
<blockquote>
<p>helloworld</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在spring中，对象无需自己负责查找或创建与其关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象，例如一个消费系统需要信誉
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>spring之hello world</title>
    <link href="http://www.myzwl.win/2017/03/30/spring1/"/>
    <id>http://www.myzwl.win/2017/03/30/spring1/</id>
    <published>2017-03-30T08:48:51.000Z</published>
    <updated>2017-03-31T05:04:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> spring 是容器框架,用于配置bean,并维护bean之间关系的框架，而bean是java中的任何一种对象 javabean/service/action/数据源./dao, ioc(控制反转 inverse of control) di( dependency injection 依赖注入)，而spring的设计思想主要为单例和工厂模式，它能很好的解耦，简化开发，同时贯穿于各层。</p>
<p> 不多说，先来一个入门案例，目的在先具体把握，最后在看细节</p>
<p> 步骤一：创建一个web工程，同时引入两个jar包，一个是spring核心包（spring.jar）和日包（commons-logging.jar）及测试包junit；</p>
<p> 步骤二：新建applicationContent.xml文件，该文件是spring的核心文件，先放在src目录下，里面暂时什么都不写</p>
<p> 步骤三：编写helloworld类：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.zwl.spring;</div><div class="line"></div><div class="line">public class Helloworld &#123;</div><div class="line">private String name;</div><div class="line"></div><div class="line">public String getName() &#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setName(String name) &#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">public void sayhello()&#123;</div><div class="line">	System.out.println("it is "+name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要通过spring自动注入name为helloworld来演示</p>
<p>步骤四：配置applicationContent.xml文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">		xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">		xmlns:tx="http://www.springframework.org/schema/tx"</div><div class="line">		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd</div><div class="line">				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;</div><div class="line"></div><div class="line">&lt;!-- bean元素的作用是，当我们的spring框架加载时候，spring就会自动的创建一个bean对象，并放入内存 ,</div><div class="line">相当于Helloworld helloworld=new Helloworld();</div><div class="line">helloworld.setName("helloworld!"); </div><div class="line">id:用于唯一标识该bean，</div><div class="line">class:相应的bean所处的位置</div><div class="line">--&gt;</div><div class="line">&lt;bean id="helloworld" class="com.zwl.spring.Helloworld"&gt;</div><div class="line">&lt;property name="name"&gt;</div><div class="line">&lt;value&gt;hello world!&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>步骤五：编写工具类<br>因为spring也是初始化加载很耗内存，所以同样采取单例模式初始化<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utils;</div><div class="line"></div><div class="line">import org.springframework.context.ApplicationContext;</div><div class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line">public class ApplicaionContextUtil &#123;</div><div class="line">private static ApplicationContext ac=null;</div><div class="line">	</div><div class="line">	private ApplicaionContextUtil()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	static&#123;</div><div class="line">		//1.得到spring 的applicationContext对象(容器对象)</div><div class="line">		ac=new ClassPathXmlApplicationContext("applicationContext.xml");</div><div class="line">	&#125;</div><div class="line">	public static ApplicationContext getApplicationContext()&#123;</div><div class="line">		return ac;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤六：编写测试类（用junit4）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">	public void test()&#123;</div><div class="line">//得到bean对象</div><div class="line">	 Helloworld hello=(Helloworld) ApplicaionContextUtil.getApplicationContext().getBean("helloworld");</div><div class="line">	 hello.sayhello();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>it is hello world ！</p>
</blockquote>
<p>至此helloworld程序完成，当然这只是一个初步的认识spring是什么，事实上spring的注入远不止如此简单，但至少有一点可以明确，通过spring，可以帮我们管理，特别是结合其他开源框架，达到解耦和高效的作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt; spring 是容器框架,用于配置bean,并维护bean之间关系的框架，而bean是java中的任何一种对象 javabean/serv
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>代理模式（四）之模仿spring Aop及真实jdk的动态代理</title>
    <link href="http://www.myzwl.win/2017/03/29/dyproxy3/"/>
    <id>http://www.myzwl.win/2017/03/29/dyproxy3/</id>
    <published>2017-03-29T12:48:51.000Z</published>
    <updated>2017-03-29T15:06:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式，尤其是动态代理，他从思想上改变了我们对编程的认识，可以想象一个切面我们在其中添加任何控制如事务、日志、权限等，而这也是面向切面编程的核心，更是spring Aop的核心，而设计才是实用的，框架和配置都是虚的，尤其当抛开jdk底层代码设计，才发现其中的来龙去脉和乐趣。</p>
<p>总之，动态代理设计模式的思想太强大了。接下来将用之前模拟的jdk动态代码和jdk本身自带的动态来模拟一个案例</p>
<p>大概物理情景是，添加一个打野信息接口和打野代理，利用InvocationHandler实现代理对具体打野的代理</p>
<p>首先是一个打野接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line"></div><div class="line">public interface JungleInfo &#123;</div><div class="line"></div><div class="line">	public void addJungle();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打野接口实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line"></div><div class="line">public class JungleInfoimpl implements JungleInfo &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void addJungle() &#123;</div><div class="line">		System.out.println("Js is ganking");</div><div class="line">		System.out.println("Leesin is ganking");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打野代理<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line"></div><div class="line">import java.lang.reflect.Method;</div><div class="line"></div><div class="line">public class JungleHandler implements InvocationHandler &#123;</div><div class="line"></div><div class="line">private Object target;</div><div class="line">	</div><div class="line">	public JungleHandler(Object target) &#123;</div><div class="line">		super();</div><div class="line">		this.target = target;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void invoke(Object o, Method m) &#123;</div><div class="line">		//控制之前的业务逻辑</div><div class="line">		System.out.println("JungleHandler is starting");</div><div class="line">		try &#123;</div><div class="line">			m.invoke(target);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		//控制之后的业务逻辑</div><div class="line">		System.out.println("JungleHandler is ending");</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了方便这里只是打印了一个语句<br>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">      //被代理对象</div><div class="line">      JungleInfo jun=new JungleInfoimpl();</div><div class="line">      //代理类</div><div class="line">InvocationHandler invo=new JungleHandler(jun);</div><div class="line">JungleInfo jung=(JungleInfo) Proxy.newProxyInstance(JungleInfo.class, invo);</div><div class="line">jung.addJungle();</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>JungleHandler is starting<br>Js is ganking<br>Leesin is ganking<br>JungleHandler is ending</p>
</blockquote>
<p>至此我们发现如果我们想在这个切面中再加一个控制，好办，再写一个handle类，代理其它handle类，达到切面控制效果。<br>当然，以后只要实现InvocationHandler接口就能达到效果，而proxy底层都不需要知道</p>
<h3 id="jdk的动态代理"><a href="#jdk的动态代理" class="headerlink" title="jdk的动态代理"></a>jdk的动态代理</h3><p>同样是上面的例子，知识代理handler需要改变</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">     package com.zwl.pr;</div><div class="line"></div><div class="line">import java.lang.reflect.InvocationHandler;</div><div class="line">import java.lang.reflect.Method;</div><div class="line"></div><div class="line">public class JungleHandlers implements InvocationHandler &#123;</div><div class="line"></div><div class="line">	</div><div class="line">private Object target;</div><div class="line">	</div><div class="line">	public JungleHandlers(Object target) &#123;</div><div class="line">		super();</div><div class="line">		this.target = target;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public Object invoke(Object proxy, Method method, Object[] args)</div><div class="line">			throws Throwable &#123;</div><div class="line">		System.out.println("Jdk is starting");</div><div class="line">		method.invoke(target, args);</div><div class="line">		System.out.println("Jdk is ending");</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中Object proxy是指代理类，Method method是指被代理的方法，Object[] args为该方法的参数数组</p>
<p>接下来是测试类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">      JungleInfo jun=new JungleInfoimpl();</div><div class="line">JungleHandlers invo=new JungleHandlers(jun);</div><div class="line">JungleInfo jung=(JungleInfo) Proxy.newProxyInstance(JungleInfo.class.getClassLoader(),new Class&lt;?&gt;[]&#123;JungleInfo.class&#125;,  invo);</div><div class="line">jung.addJungle();</div></pre></td></tr></table></figure>
<p>其中jung将返回一个代理类的实例JungleInfo.class.getClassLoader()是类装载器，第二个参数是任何真实类拥有的全部接口的数组，第三个参数就是真实的handles</p>
<p>测试结果：</p>
<blockquote>
<p>Jdk is starting<br>Js is ganking<br>Leesin is ganking<br>Jdk is ending</p>
</blockquote>
<p>至此，我们利用动态代理，就可以在不修改原来代码的基础上，就可以在原来代码的基础上做操作，而这恰恰就是AOP编程的核心</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;代理模式，尤其是动态代理，他从思想上改变了我们对编程的认识，可以想象一个切面我们在其中添加任何控制如事务、日志、权限等，而这也是面向切面编程
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="http://www.myzwl.win/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式（三）之模仿jdk底层动态代理实现</title>
    <link href="http://www.myzwl.win/2017/03/29/dyproxy2/"/>
    <id>http://www.myzwl.win/2017/03/29/dyproxy2/</id>
    <published>2017-03-29T10:48:51.000Z</published>
    <updated>2017-03-29T15:06:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面的基础上在做进一步的改进，前面我们是动态写死了方法，即自己指定了方法名，当然我们可以利用反射帮我们完成函数名的动态指定</p>
<p>首先是一个反射例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//拿到相应的类</div><div class="line">Method[]  methods=com.zwl.pr.Jungle.class.getMethods();</div><div class="line">		for(Method method: methods)&#123;</div><div class="line">		//循环输出该类的函数名，如public void ss();最后只输出ss</div><div class="line">			System.out.println(method.getName());</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>有了这个原理就可以对之前的proxy进行改造</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">public static Object newProxyInstance(Class interfac) throws Exception&#123;</div><div class="line">      </div><div class="line">      //动态拿到方法的代码</div><div class="line">		String methodStr = "";</div><div class="line">		String rt = "\r\n";</div><div class="line">		</div><div class="line">		//将指定的动态接口类名拿到</div><div class="line">		Method[] methods = interfac.getMethods();</div><div class="line"></div><div class="line">		//循环添加方法</div><div class="line">		for(Method m : methods) &#123;</div><div class="line">			methodStr += "@Override" + rt + </div><div class="line">						 "public void " + m.getName() + "() &#123;" + rt +</div><div class="line">						 	"   long start = System.currentTimeMillis();" + rt +</div><div class="line">							"   leesin." + m.getName() + "();" + rt +</div><div class="line">							"   long end = System.currentTimeMillis();" + rt +</div><div class="line">							"   System.out.println(\"time:\" + (end-start));" + rt +</div><div class="line">						 "&#125;";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line"></div><div class="line">				"public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"Jungle leesin;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(Jungle leesin) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.leesin = leesin;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line">          //这里循环动态输出方法</div><div class="line">					methodStr +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line"></div><div class="line">		//这里将动态生成的代理文件放到指定文件夹中，避免与bin里的.class文件冲突</div><div class="line">		String filename=</div><div class="line">				"E:/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div><div class="line"></div><div class="line">		   //compile</div><div class="line">				JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">				StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">				Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">				CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">				t.call();</div><div class="line">				fileMgr.close();</div><div class="line">				</div><div class="line">				//load into memory and create an instance</div><div class="line">				//更改到指定文件夹</div><div class="line">				URL[] urls = new URL[] &#123;new URL("file:/" + "E:/src/")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div><div class="line">				</div><div class="line">				Constructor ctr = c.getConstructor(Jungle.class);</div><div class="line">				</div><div class="line">				//返回任意一个类</div><div class="line">				Object jungle=ctr.newInstance(new LeeSin());</div><div class="line">				</div><div class="line">		</div><div class="line">		return jungle;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<pre><code>注意这里和之前做了几处修改
1.利用反射动态生成方法
2.更改编译后生成文件的目录
3.返回类型为object
4具体在代码里有注释

测试类：
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class);</div><div class="line">		jungle.gank();</div></pre></td></tr></table></figure>
</code></pre><p>输出结果</p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>LeeSin is ganking…<br>gank time:1336<br>time:1336</p>
</blockquote>
<p>这里很明显发现方法都是固定的，如果想要方法都是动态生成的，则要进行进一步修改<br>首先增加一个<br>InvocationHandler动态生成类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface InvocationHandler &#123;</div><div class="line">	public void invoke(Object o, Method m);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是具体的针对所有接口的时间处理类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class TimeHandler implements InvocationHandler &#123;</div><div class="line"></div><div class="line">   //代理类</div><div class="line">	private Object target;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	public TimeHandler(Object target) &#123;</div><div class="line">		super();</div><div class="line">		this.target = target;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void invoke(Object o, Method m) &#123;</div><div class="line">		long start = System.currentTimeMillis();</div><div class="line">		try &#123;</div><div class="line">			//指定代理类的动态方法</div><div class="line">			m.invoke(target);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		long end = System.currentTimeMillis();</div><div class="line">		System.out.println("time:" + (end-start));</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后proxy里也要进行相应修改</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//参数分别为被代理对象与代理对象</div><div class="line">public static Object newProxyInstance(Class interfac,InvocationHandler h) throws Exception&#123;</div><div class="line">		String methodStr = "";</div><div class="line">		String rt = "\r\n";</div><div class="line">		</div><div class="line">		Method[] methods = interfac.getMethods();</div><div class="line">		</div><div class="line">	//动态生成方法，其中this是指代理对象本身，而md是指方法名，这里的h是构造函数传的代理对象</div><div class="line">		for(Method m : methods) &#123;</div><div class="line">			methodStr += "@Override" + rt + </div><div class="line">						 "public void " + m.getName() + "() &#123;" + rt +</div><div class="line">						 "    try &#123;" + rt +</div><div class="line">						 "    Method md = " + interfac.getName() + ".class.getMethod(\"" + m.getName() + "\");" + rt +</div><div class="line">						 "    h.invoke(this, md);" + rt +</div><div class="line">						 "    &#125;catch(Exception e) &#123;e.printStackTrace();&#125;" + rt +</div><div class="line">						</div><div class="line">						 "&#125;";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line">               "import java.lang.reflect.Method;" + rt +</div><div class="line">				"public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"com.zwl.pr.InvocationHandler h;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(InvocationHandler h) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.h = h;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line"></div><div class="line">					methodStr +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line">		String filename=</div><div class="line">				"E:/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div><div class="line"></div><div class="line">		   //compile</div><div class="line">				JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">				StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">				Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">				CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">				t.call();</div><div class="line">				fileMgr.close();</div><div class="line">				</div><div class="line">				//load into memory and create an instance</div><div class="line">				URL[] urls = new URL[] &#123;new URL("file:/" + "E:/src/")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div><div class="line">				</div><div class="line">				//返回代理类</div><div class="line">				Constructor ctr = c.getConstructor(InvocationHandler.class);</div><div class="line">				</div><div class="line">				Object jungle=ctr.newInstance(h);</div><div class="line">				</div><div class="line">		</div><div class="line">		return jungle;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//被代理对象</div><div class="line">LeeSin leesin=new LeeSin();</div><div class="line">//代理对象</div><div class="line">		InvocationHandler ivo=new TimeHandler(leesin);</div><div class="line">		Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class,ivo);</div><div class="line">		jungle.gank();</div></pre></td></tr></table></figure>
<p>对应生成的java文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package com.zwl.pr;</div><div class="line">import java.lang.reflect.Method;</div><div class="line">public class LeeSinTimeProxy implements com.zwl.pr.Jungle&#123;</div><div class="line">com.zwl.pr.InvocationHandler h;</div><div class="line">public LeeSinTimeProxy(InvocationHandler h) &#123;</div><div class="line">super();</div><div class="line">this.h = h;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public void gank() &#123;</div><div class="line">    try &#123;</div><div class="line">    Method md = com.zwl.pr.Jungle.class.getMethod("gank");</div><div class="line">    h.invoke(this, md);</div><div class="line">    &#125;catch(Exception e) &#123;e.printStackTrace();&#125;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>对应的测试结果 </p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>LeeSin is ganking…<br>gank time:2642<br>time:2642</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在前面的基础上在做进一步的改进，前面我们是动态写死了方法，即自己指定了方法名，当然我们可以利用反射帮我们完成函数名的动态指定&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="http://www.myzwl.win/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式（二）之初识动态代理</title>
    <link href="http://www.myzwl.win/2017/03/29/dyproxy1/"/>
    <id>http://www.myzwl.win/2017/03/29/dyproxy1/</id>
    <published>2017-03-29T09:48:51.000Z</published>
    <updated>2017-03-29T10:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我们通过静态代理可以在编译期创建一个代理对象，如果要求我们必须在运行时创建一个代理，如时间代理，如何做了？<br>也就是说，需要写一个代理（proxy），然后我们只需要传入相关接口，它就可以主动生成代理对象</p>
<p>再一次使用之前的情景，即有一个打野对象接口和具体打野盲僧，然后编写一个针对打野的动态代理（proxy），只要传入（打野接口对象），就可以动态自动生成该java文件，并且载入内存并不jvm编译</p>
<p>下面就是其代码实现</p>
<p>Jungle（打野接口）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">  //打野gank方法</div><div class="line">	public void gank();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LeeSin（盲僧）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		//gank开始时间</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		System.out.println("LeeSin is ganking...");</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			//gank进行中</div><div class="line">			Thread.sleep(new Random().nextInt(10000));</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		//gank结束时间</div><div class="line">        long ends=System.currentTimeMillis();</div><div class="line">        System.out.println("gank time:"+(ends-starts));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果想要动态生成一个事件代理（按常理应该新建一个代理类），按照动态思想，我们将该创建该类的所以涉及的代码赋给一个字符串<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">String str=</div><div class="line">		"package com.zwl.pr;" +</div><div class="line"></div><div class="line">		"public class LeeSinTimeProxy implements Jungle &#123;" +</div><div class="line"></div><div class="line">			</div><div class="line">			"Jungle leesin;" +</div><div class="line">			</div><div class="line">			</div><div class="line">			"public LeeSinTimeProxy(Jungle leesin) &#123;" +</div><div class="line">				"super();" +</div><div class="line">				"this.leesin = leesin;" +</div><div class="line">			"&#125;" +</div><div class="line"></div><div class="line"></div><div class="line">			"@Override" +</div><div class="line">			"public void gank() &#123;" +</div><div class="line">				"long starts=System.currentTimeMillis();" +</div><div class="line">				"leesin.gank();" +</div><div class="line">				 "long ends=System.currentTimeMillis();" +</div><div class="line">			      "  System.out.println(\"gank time:\"+(ends-starts));" +</div><div class="line"></div><div class="line">			"&#125;" +</div><div class="line"></div><div class="line">		"&#125;" ;</div></pre></td></tr></table></figure></p>
<p>上面字符串就是创建该代理的代码，然后如果jvm能自动将其编译成.class并且载入内存，就是一个真的类了，按照这种思想，我们可以通过jvm提供的方法完成<br>为了方便先把上述动态创建时间代理放在测试中（也就是main函数中）<br>1.首先将代码格式修整一下，即加个换行，同时将字符写入时间代理文件中<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> //换行，防止所有代码全部挤在一行</div><div class="line">String rt = "\r\n";</div><div class="line"></div><div class="line">//要动态生成的类的代码</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line"></div><div class="line">				"public class LeeSinTimeProxy implements Jungle &#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"Jungle leesin;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(Jungle leesin) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.leesin = leesin;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line"></div><div class="line">					"@Override" + rt +</div><div class="line">					"public void gank() &#123;" + rt +</div><div class="line">						"long starts=System.currentTimeMillis();" + rt +</div><div class="line">						"leesin.gank();" + rt +</div><div class="line">						 "long ends=System.currentTimeMillis();" + rt +</div><div class="line">					      "  System.out.println(\"gank time:\"+(ends-starts));" + rt +</div><div class="line"></div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		//得到该项目的根路径</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line"></div><div class="line">		//该时间代理文件的完整路径，不存在则创建（第一次自动动态创建）</div><div class="line">		String filename=System.getProperty("user.dir")+</div><div class="line">				"/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		//将字符写入该文件</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div></pre></td></tr></table></figure></p>
<p>这里先一小段一小段的加，目前是已经在该包下生成一个LeeSinTimeProxy.java文件，并且里面有被写入的字符，但是纯粹只是一个文件，因为还没被编译和载入内存</p>
<p>2.进行编译<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">            //compile</div><div class="line">            //得到java编译器，也就是javac了，至此我们可以最终将其编译，得到.class（二进制文件）</div><div class="line">JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">           //管理编译文件，默认为空就行</div><div class="line">StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">//所有编译的文件，目前就一个，当然可以传入多个</div><div class="line">Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">//编译任务管理，目前传入上面两个参数，其余默认为空就行</div><div class="line">CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">//执行任务编译</div><div class="line">t.call();</div><div class="line">fileMgr.close();</div></pre></td></tr></table></figure></p>
<p>至此，在包下也动态生成了一个.class文件，而平常我们编译时都会在path路径下，jdk主动生成.class，而此时我们自己指定了位置</p>
<p>3.载入内存<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//指定载入内存的url</div><div class="line">URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir")+"/src")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">//指定class文件载入</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div></pre></td></tr></table></figure></p>
<p>4.利用反射取出实例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//反射取出类</div><div class="line">Constructor ctr = c.getConstructor(Jungle.class);</div><div class="line">				</div><div class="line">		//操作该类相应方法，此处是动态返回类</div><div class="line">				Jungle jubgle= (Jungle) ctr.newInstance(new LeeSin());</div><div class="line">				//调用gank方法</div><div class="line">				jubgle.gank();</div></pre></td></tr></table></figure>
<p>以下是结果：</p>
<blockquote>
<p>class com.zwl.pr.LeeSinTimeProxy<br>LeeSin is ganking…<br>gank time:7557<br>gank time:7563</p>
</blockquote>
<p>至此算是动态生成了时间代理，但是目前是很有局限性的，因为我们指定了一个特定接口，而不是泛指，当然通过这个例子，也算是初识了一把动态模式的魅力，当然它的最大魅力，在于制定任何接口，返回相应的代理类</p>
<p>在这里我们先将测试的类中代码移至Proxy类中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class Proxy &#123;</div><div class="line"> </div><div class="line"> //这里的interfac就是动态指定了任何接口代理，而且必须取它的名字，否则是执行其tostring方法</div><div class="line">	public static Object newProxyInstance(Class interfac) throws Exception&#123;</div><div class="line">		String rt = "\r\n";</div><div class="line">		String str=</div><div class="line">				"package com.zwl.pr;" + rt +</div><div class="line"></div><div class="line">				"public class LeeSinTimeProxy implements "+interfac.getName()+ "&#123;" + rt +</div><div class="line"></div><div class="line">					</div><div class="line">					"Jungle leesin;" + rt +</div><div class="line">					</div><div class="line">					</div><div class="line">					"public LeeSinTimeProxy(Jungle leesin) &#123;" + rt +</div><div class="line">						"super();" + rt +</div><div class="line">						"this.leesin = leesin;" + rt +</div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line"></div><div class="line">					"@Override" + rt +</div><div class="line">					"public void gank() &#123;" + rt +</div><div class="line">						"long starts=System.currentTimeMillis();" + rt +</div><div class="line">						"leesin.gank();" + rt +</div><div class="line">						 "long ends=System.currentTimeMillis();" + rt +</div><div class="line">					      "  System.out.println(\"gank time:\"+(ends-starts));" + rt +</div><div class="line"></div><div class="line">					"&#125;" + rt +</div><div class="line"></div><div class="line">				"&#125;" ;</div><div class="line">		</div><div class="line">		//System.out.println(System.getProperty("user.dir"));</div><div class="line">		String filename=System.getProperty("user.dir")+</div><div class="line">				"/src/com/zwl/pr/LeeSinTimeProxy.java";</div><div class="line">		File f=new File(filename);</div><div class="line">		FileWriter fw=new FileWriter(f);</div><div class="line">		fw.write(str);</div><div class="line">		fw.flush();</div><div class="line">		fw.close();</div><div class="line"></div><div class="line">		   //compile</div><div class="line">				JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">				StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);</div><div class="line">				Iterable units = fileMgr.getJavaFileObjects(filename);</div><div class="line">				CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);</div><div class="line">				t.call();</div><div class="line">				fileMgr.close();</div><div class="line">				</div><div class="line">				//load into memory and create an instance</div><div class="line">				URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir")+"/src")&#125;;</div><div class="line">				URLClassLoader ul = new URLClassLoader(urls);</div><div class="line">				Class c = ul.loadClass("com.zwl.pr.LeeSinTimeProxy");</div><div class="line">				System.out.println(c);</div><div class="line">				</div><div class="line">				Constructor ctr = c.getConstructor(Jungle.class);</div><div class="line">				</div><div class="line">				Jungle jubgle= (Jungle) ctr.newInstance(new LeeSin());</div><div class="line">				jubgle.gank();</div><div class="line">		</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目前先不管错误，在做测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      LeeSin leesin=new LeeSin();</div><div class="line">Jungle jungle=(Jungle) Proxy.newProxyInstance(Jungle.class);</div><div class="line">jungle.gank();</div></pre></td></tr></table></figure></p>
<p>这里参数我们可以设置任何class接口，当然先不管错误，至少动态代理算是成功了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前我们通过静态代理可以在编译期创建一个代理对象，如果要求我们必须在运行时创建一个代理，如时间代理，如何做了？&lt;br&gt;也就是说，需要写一个代
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="http://www.myzwl.win/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式（一）之静态代理</title>
    <link href="http://www.myzwl.win/2017/03/29/stproxy/"/>
    <id>http://www.myzwl.win/2017/03/29/stproxy/</id>
    <published>2017-03-29T08:48:51.000Z</published>
    <updated>2017-03-29T06:21:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式从定义上说就是给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用</p>
<p>一般情况下，我们可以通过继承或者聚合来实现代理，当然继承会造成类爆炸，而聚合则更灵活<br>不多说，模拟一个静态代理的情景<br>假设打野是一个接口，有gank方法，记录打野行为，打野具体对象盲僧，实现其gank的时间并记录下来，然后后续打野盲僧1、盲僧2分别记录打野具体对象的gank时间和gank日志（目前打野对象为LeeSin）</p>
<p>Jungle（打野接口）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">  //打野gank方法</div><div class="line">	public void gank();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LeeSin（盲僧）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		//gank开始时间</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		System.out.println("LeeSin is ganking...");</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			//gank进行中</div><div class="line">			Thread.sleep(new Random().nextInt(10000));</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		//gank结束时间</div><div class="line">        long ends=System.currentTimeMillis();</div><div class="line">        System.out.println("gank time:"+(ends-starts));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是使用代理对象，比如用一个代理记录打野gank方法的时间<br>不妨先用继承（与后面聚合比较会发现继承将造成类爆炸）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//时间代理，记录gank时间</div><div class="line">public class LeeSin1 extends LeeSin &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		super.gank();</div><div class="line">		 long ends=System.currentTimeMillis();</div><div class="line">	        System.out.println("gank time:"+(ends-starts));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这时再有一个log代理，记录gank日志<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class LeeSin2 extends LeeSin &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		System.out.println("LeeSin starts ganking");</div><div class="line">		super.gank();</div><div class="line">		System.out.println("LeeSin ends ganking");		 </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果这时说先记录日志在记录时间或者先记录时间在记录日志，这时就要写两个类<br>列出主体代码（另一个调换位置）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">@Override</div><div class="line">public void gank() &#123;</div><div class="line">	System.out.println("LeeSin starts ganking");</div><div class="line">	long starts=System.currentTimeMillis();</div><div class="line">	super.gank();</div><div class="line">	 long ends=System.currentTimeMillis();</div><div class="line">        System.out.println("gank time:"+(ends-starts));</div><div class="line">        System.out.println("LeeSin ends ganking");	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能目前代理类较少，还没有缺陷，如果是100个甚至更多，只要稍微要求下顺序或者其他，就要增加一个类，显然造成类爆炸，所以继承代理不可取</p>
<p>利用聚合代理（因为被代理类都是继承或者实现Jungle，所以可以用jungle代理，知识子类行为不同而已<br>打野时间代理类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class LeeSinTimeProxy implements Jungle &#123;</div><div class="line"></div><div class="line">	//代理对象</div><div class="line">	Jungle leesin;</div><div class="line">	</div><div class="line">	</div><div class="line">	public LeeSinTimeProxy(Jungle leesin) &#123;</div><div class="line">		super();</div><div class="line">		this.leesin = leesin;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		long starts=System.currentTimeMillis();</div><div class="line">		leesin.gank();</div><div class="line">		 long ends=System.currentTimeMillis();</div><div class="line">	        System.out.println("gank time:"+(ends-starts));</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>日志代理<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSinlogProxy implements Jungle &#123;</div><div class="line"></div><div class="line">	</div><div class="line">	Jungle leesin;</div><div class="line">	</div><div class="line">	</div><div class="line">	public LeeSinlogProxy(Jungle leesin) &#123;</div><div class="line">		super();</div><div class="line">		this.leesin = leesin;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gank() &#123;</div><div class="line">		System.out.println("LeeSin starts ganking");</div><div class="line">		leesin.gank();</div><div class="line">		System.out.println("LeeSin ends ganking");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		LeeSin leesin=new LeeSin();</div><div class="line">		</div><div class="line">		Jungle jungletime=new LeeSinTimeProxy(leesin);</div><div class="line">		Jungle junglelog=new LeeSinlogProxy(jungletime);</div><div class="line">		junglelog.gank();</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>LeeSin starts ganking<br>LeeSin is ganking…<br>gank time:1005<br>gank time:1005<br>LeeSin ends ganking</p>
</blockquote>
<p>注意这里是日志代理时间，时间代理盲僧，如果更改顺序，只需改变被代理对象即可<br><img src="/images/imgs2/15.gif" alt="Alt text"></p>
<p>至此我们可以简单归纳一下静态代理<br>大概有抽象角色：如打野  ，代理角色（被聚合类的引用），以及真实角色</p>
<p>最后不得不提的是静态代理虽然简单，但是有很多局限性，比如它是在编译期由我们主动创建的，也就说在程序运行前已经存在在.class文件中了，如果代理类一旦多的话，代理内容就无法复用，新增方法时，代理对象也要跟着增加方法。</p>
<p>所以代理设计模式真正的魅力和强大之处而是动态代理！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;代理模式从定义上说就是给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用&lt;/p&gt;
&lt;p&gt;一般情况下，我们可以通过继承或者聚合来实现
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="http://www.myzwl.win/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者设计模式</title>
    <link href="http://www.myzwl.win/2017/03/28/observer/"/>
    <id>http://www.myzwl.win/2017/03/28/observer/</id>
    <published>2017-03-28T08:48:51.000Z</published>
    <updated>2017-03-29T05:31:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观察者模式从定义上说就是一种一对多的依赖关系，即当一个对象的状态发生改变时，其它依赖此对象的对象会得到通知并且做出相应的改变。一般有“推”模型和“拉”模型，前者是被观察者将所有信息通知所有人，而后者则是被观察者不主动提供信息，观察者主动索要信息</p>
<p>在这里还是以之前的例子为例</p>
<p><img src="/images/imgs2/14.gif" alt="Alt text"></p>
<p>这是一个推模型，也就是被观察者根据状态发生改变时将所有信息都主动通知观察者<br>其中：Jungle（打野）是被观察者，即如果有一些状态变化，如对方打野有动作则将通知observer（目前假定只有上路和adc）<br>observer：观察者，用来监听被观察者并且根据相应的变化做出变化<br>top：上单  adc：Adc LesSin：打野盲僧<br>以下是相关代码：</p>
<p>Jungle（被观察者）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">     </div><div class="line">     //增加观察者</div><div class="line">	public void addObserve(Observer obs);</div><div class="line">	 //删除观察者</div><div class="line">	public void deleteObserve(Observer obs);</div><div class="line">	 //通知观察者</div><div class="line">	public void notifyObserve(String msg);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>observer（观察者）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Observer &#123;</div><div class="line">   //收到通知后状态变化</div><div class="line">	public void notifybyJungle(String msg);</div><div class="line">&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LeeSin<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line">   //存放所有的观察者</div><div class="line">	List&lt;Observer&gt; list=new ArrayList&lt;Observer&gt;();</div><div class="line">	</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void addObserve(Observer obs) &#123;</div><div class="line">		list.add(obs);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void deleteObserve(Observer obs) &#123;</div><div class="line">		list.remove(obs);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void notifyObserve(String msg) &#123;</div><div class="line">		for(Observer obs : list)&#123;</div><div class="line">			obs.notifybyJungle(msg);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>top<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class top implements Observer &#123;</div><div class="line"> </div><div class="line"> //收到消息</div><div class="line">	public String newmsg;</div><div class="line">	</div><div class="line">	public String getNewmsg() &#123;</div><div class="line">		return newmsg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setNewmsg(String newmsg) &#123;</div><div class="line">		this.newmsg = newmsg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void notifybyJungle(String msg) &#123;</div><div class="line">		newmsg=msg;</div><div class="line">		System.out.println("上单收到:"+newmsg);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Adc<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Adc implements Observer &#123;</div><div class="line"></div><div class="line">public String newmsg;</div><div class="line">	</div><div class="line">	public String getNewmsg() &#123;</div><div class="line">		return newmsg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setNewmsg(String newmsg) &#123;</div><div class="line">		this.newmsg = newmsg;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void notifybyJungle(String msg) &#123;</div><div class="line">		newmsg=msg;</div><div class="line">		System.out.println("adc收到:"+newmsg);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		Jungle jungle=new LeeSin();</div><div class="line">		</div><div class="line">		Observer obs1=new Adc();</div><div class="line">		</div><div class="line">		Observer obs2=new top();</div><div class="line">		</div><div class="line">		jungle.addObserve(obs1);</div><div class="line">		jungle.addObserve(obs2);</div><div class="line">		</div><div class="line">		jungle.notifyObserve("敌方打野正在打小龙");</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下面是输出结果</p>
<blockquote>
<p>adc收到:敌方打野正在打小龙<br>上单收到:敌方打野正在打小龙</p>
</blockquote>
<p>如果我们使用拉模型，即观察者主动向被观察者索要信息，那么上面程序将做部分修改</p>
<p>大体思路就是将Jungle（被观察者）的通知函数改为void即<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line">     </div><div class="line">     //增加观察者</div><div class="line">	public void addObserve(Observer obs);</div><div class="line">	 //删除观察者</div><div class="line">	public void deleteObserve(Observer obs);</div><div class="line">	 //通知观察者</div><div class="line">	public void notifyObserve();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相应的observer将更改为<br>observer（观察者）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Observer &#123;</div><div class="line">   //收到通知后状态变化</div><div class="line">	public void notifybyJungle(Jungle jungle);</div><div class="line">&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于推与拉模型，如果目标角色过于复杂，则优先使用推模式，反之则使用拉模式</p>
<p>观察者模式应用场景<br>1、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变</p>
<p>2、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观察者模式从定义上说就是一种一对多的依赖关系，即当一个对象的状态发生改变时，其它依赖此对象的对象会得到通知并且做出相应的改变。一般有“推”模
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="http://www.myzwl.win/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂设计模式</title>
    <link href="http://www.myzwl.win/2017/03/27/abstractfactory/"/>
    <id>http://www.myzwl.win/2017/03/27/abstractfactory/</id>
    <published>2017-03-27T08:48:51.000Z</published>
    <updated>2017-03-29T05:31:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>抽象工厂方法通俗的讲就是为创建一组相关或相互依赖的对象提供一组接口，无需指定他们的具体类。因此，他们通常为创建一族产品对象，并且该产品由不同等级划分。</p>
<p>这里还是以之前的例子为例，假设有一个产生top（上单）的机器，另一个产生Jungle（打野）的机器，同时top可以有ad（物理上单）和ap(法术上单)，同样，Jungle可以有ad和ap打野，现在需要一个工厂，可以同时产生仅含ad的打野和上单，另一个产生仅含ap的打野和上单，当然可以按照自己的组合<br><img src="/images/imgs2/13.gif" alt="Alt text"><br>打野</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public interface Jungle &#123;</div><div class="line"></div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ad打野</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class AdJungle implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ap打野<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ApJungle implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上单<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface Top &#123;</div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ad上单<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class AdTop implements Top &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ap上单<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ApTop implements Top &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生产打野和上单的工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface AbstractFactory &#123;</div><div class="line">public Top factorytop();</div><div class="line">public Jungle factoryjungle();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生产ad打野和上单的工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class AdFactory implements AbstractFactory &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Top factorytop() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new AdTop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle factoryjungle() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new AdJungle();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生产ap打野和上单的工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ApFactory implements AbstractFactory &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Top factorytop() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new ApTop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle factoryjungle() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new ApJungle();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过上面例子，我们可以发现抽象工厂易于交换产品系列，通过按需改变具体工厂从而使用不同的产品配置，同时它也将创建实例的过程与客户端分类</p>
<p>当然它的缺点就是和简单工厂一样，如果要从sql server切换到mysql，需要重新实例很多次</p>
<p>最后对应工厂系列的设计模式，无论选择哪一个，最终的目的都是为了解耦！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;抽象工厂方法通俗的讲就是为创建一组相关或相互依赖的对象提供一组接口，无需指定他们的具体类。因此，他们通常为创建一族产品对象，并且该产品由不同
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="http://www.myzwl.win/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法设计模式</title>
    <link href="http://www.myzwl.win/2017/03/27/factory/"/>
    <id>http://www.myzwl.win/2017/03/27/factory/</id>
    <published>2017-03-27T06:48:51.000Z</published>
    <updated>2017-03-29T05:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工厂方法模式又被称为多态工厂模式，通俗的讲就是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中，因此，也属于创建型模式</p>
<p><img src="/images/imgs2/12.gif" alt="Alt text"><br>这里Jungle的每个具体类都对应一个具体工厂<br>下面就是以工厂方法创建它们，通过抽象工厂选择不同的具体子工厂，从而产生不同的具体打野类</p>
<p>打野接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//打野英雄</div><div class="line">public interface Jungle &#123;</div><div class="line"></div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>工厂接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface junglefactor &#123;</div><div class="line">//产生打野</div><div class="line">public Jungle createjungle();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>盲僧</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("盲僧正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("盲僧太灵活了");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("盲僧正在打野怪");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剑圣</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Js implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("剑圣正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("js也灵活");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("剑圣正在打野");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>盲僧工厂<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class LeeSinFactory implements junglefactor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle createjungle() &#123;</div><div class="line">		</div><div class="line">		return new LeeSin();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">剑圣工厂</div><div class="line">``` stylus</div><div class="line">public class JsFactory implements junglefactor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Jungle createjungle() &#123;</div><div class="line">		</div><div class="line">		return new Js();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">测试类：</div><div class="line">``` stylus</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		// Jungle jungle= JungleFactory.createJungle("LeeSin");</div><div class="line">		// jungle.gankenemy();</div><div class="line"></div><div class="line">      junglefactor factory=new LeeSinFactory();</div><div class="line">    Jungle jubjle=factory.createjungle();</div><div class="line">    jubjle.flexible();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这里通过多态，产生不同的工厂，从而产生不同的打野</p>
<p>工厂方法比较简单工厂模式</p>
<p>现在我们要是把打野对象由盲僧换成剑圣的话，利用简单工厂，那就要<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Jungle jungle= JungleFactory.createJungle("Js");</div><div class="line">``` </div><div class="line">如果是100或者更多的话，那就要重复上述代码那么多次</div><div class="line"></div><div class="line">但是如果采用工厂方法，只需要改一处</div><div class="line">```stylus</div><div class="line">junglefactor factory=new JsFactory();</div></pre></td></tr></table></figure></p>
<p>显然对外扩展开放，对内修改关闭更好。而简单工厂则违背了该原则</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工厂方法模式又被称为多态工厂模式，通俗的讲就是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中，因此，也属于创建型模式&lt;/p&gt;

    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="http://www.myzwl.win/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单工厂设计模式</title>
    <link href="http://www.myzwl.win/2017/03/27/simplefactory/"/>
    <id>http://www.myzwl.win/2017/03/27/simplefactory/</id>
    <published>2017-03-27T04:48:51.000Z</published>
    <updated>2017-03-27T11:53:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单工厂模式又叫静态工厂设计模式。通俗的讲，就是通过专门定义一个类来负责建立其他类的实例，与此同时被创建的类都必须满足他们有共同的父类，所以，它是一种创建型模式。</p>
<p><img src="/images/imgs2/11.gif" alt="Alt text"><br>这里Leesin（盲僧）与Js（剑圣）继承Jungle（打野），而JungleFactory（打野生产工厂）产生具体打野对象<br>下面将以简单工厂创建他们，满足通过传入打野工厂不同的参数，产生不同的打野对象</p>
<p>打野接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//打野英雄</div><div class="line">public interface Jungle &#123;</div><div class="line"></div><div class="line">	//gank能力强</div><div class="line">	public void gankenemy();</div><div class="line">	</div><div class="line">	//本身足够灵活</div><div class="line">	public void flexible();</div><div class="line">	</div><div class="line">	//打野不太伤</div><div class="line">	public void killbeast();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>盲僧</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class LeeSin implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("盲僧正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("盲僧太灵活了");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("盲僧正在打野怪");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剑圣</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Js implements Jungle &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void gankenemy() &#123;</div><div class="line">		System.out.println("剑圣正在gank");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void flexible() &#123;</div><div class="line">		System.out.println("js也灵活");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void killbeast() &#123;</div><div class="line">		System.out.println("剑圣正在打野");</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打野工厂</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class JungleFactory &#123;</div><div class="line"></div><div class="line">	public static Jungle createJungle(String Junglename)&#123;</div><div class="line">		 Jungle jungle=null;</div><div class="line">		 switch(Junglename)&#123;</div><div class="line">		 case "LeeSin":</div><div class="line">			 jungle=new LeeSin();</div><div class="line">			 break;</div><div class="line">		 case "Js" :</div><div class="line">			 jungle=new Js();</div><div class="line">			 break;</div><div class="line">		 default :</div><div class="line">			  break;</div><div class="line">		 </div><div class="line">		 &#125;</div><div class="line">		return jungle;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是测试类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		Jungle jungle= JungleFactory.createJungle("LeeSin");</div><div class="line">		jungle.gankenemy();</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>当然，我们这里通过不同的参数，获得不同的打野英雄<br>当然这个例子也很好理解简单工厂</p>
<p>事实上，我们知道如果我们一开始用的是sql server数据库，然后我们想换数据库，如果不用工厂模式，那么将替换许多东西，如果这时，使用简单工厂模式，就会使问题变简单许多。</p>
<p>利用简单工厂模式大概思路就是先创建一个抽象数据库(DBobject)，然后是具体实现类sql server与mysql类，然后再来一个生成数据库工厂(DBobjectFactory)通过传入不同的数据库参数，从而连接不同的数据库</p>
<p>至此我们发现，简单工厂的优点在于工厂类中包含了必要的逻辑判断，而且可以根据客户端的选择条件不同而动态的实例化相关的类</p>
<p>当然它的缺点也很明显，当我们创建的抽象实例过多时，显然高内聚就增多了，不利于维护了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;简单工厂模式又叫静态工厂设计模式。通俗的讲，就是通过专门定义一个类来负责建立其他类的实例，与此同时被创建的类都必须满足他们有共同的父类，所以
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="http://www.myzwl.win/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>职责链设计模式</title>
    <link href="http://www.myzwl.win/2017/03/26/filter/"/>
    <id>http://www.myzwl.win/2017/03/26/filter/</id>
    <published>2017-03-26T14:48:51.000Z</published>
    <updated>2017-03-27T09:07:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 职责链，通俗地讲就是把责任处理对象连城一条链，这样当一个处理对象不能及时处理的时候就会交给下一个处理对象直到被处理为止。就好比生活中，我们有事向学校请假，得找班主任签字同意，然后有些时候需要院里签字，甚至教务处，最后将假条交给同学，最后在给相应授课老师，可能这个例子还不太准确，但是总之经过一些列流程，最后才会处理。</p>
<p>当然，在程序中，最常见的就是过滤关键字了，首先模拟一下非web下的责任链</p>
<p><strong>首先定义一个过滤接口</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Filter &#123;</div><div class="line">	String doFilter(String str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>接下来就是各式各样的过滤字</strong><br>敏感字过滤</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SesitiveFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String doFilter(String str) &#123;</div><div class="line">		//第一个参数是非法字符，第二个参数是被替换的字符</div><div class="line">		String r = str.replace("瞎子", "李青")</div><div class="line">			 .replace("小学僧", "盲僧");</div><div class="line">		</div><div class="line">		return r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>过滤html标签</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class HTMLFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String doFilter(String str) &#123;</div><div class="line">	//&lt;&gt;被替换成[]</div><div class="line">		String r = str.replace('&lt;', '[')</div><div class="line">				   .replace('&gt;', ']');</div><div class="line">		return r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>过滤链:将过滤器串成一个链，并保存过滤后的字</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class FilterChain implements Filter &#123;</div><div class="line">     //保存所有的具体过滤器</div><div class="line">	List&lt;Filter&gt; filters=new ArrayList&lt;Filter&gt;();</div><div class="line">	</div><div class="line">    //过滤器串成链</div><div class="line">	public FilterChain addFilter(Filter f)</div><div class="line">	&#123;</div><div class="line">		this.filters.add(f);</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">  //返回过滤后的字符</div><div class="line">	@Override</div><div class="line">	public String doFilter(String str) &#123;</div><div class="line">		String r=str;</div><div class="line">		for(Filter f:filters)&#123;</div><div class="line">			r=f.doFilter(r);</div><div class="line">		&#125;</div><div class="line">		return r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		String msg = "因为一个英雄而爱上了lol，他就是瞎子，虽然我是小学僧，但是我还是只坚信我的&lt;我的信仰&gt;英雄！！";</div><div class="line">		FilterChain fc = new FilterChain();</div><div class="line">		fc.addFilter(new SesitiveFilter())</div><div class="line">		  .addFilter(new HTMLFilter());</div><div class="line">		String result=fc.doFilter(msg);</div><div class="line">		System.out.println(result);</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>输出结果:</p>
<blockquote>
<p>因为一个英雄而爱上了lol，他就是李青，虽然我是盲僧，但是我还是只坚信我的[我的信仰]英雄！！</p>
</blockquote>
<h4 id="Web下责任链"><a href="#Web下责任链" class="headerlink" title="Web下责任链"></a>Web下责任链</h4><p>当然一般情况下，都是过滤web环境下的字符，大概思路跟非web下差不多</p>
<p>首先需要建立request和response对象，即接收和响应</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Request &#123;</div><div class="line">String requestStr;</div><div class="line"></div><div class="line">public String getRequestStr() &#123;</div><div class="line">	return requestStr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setRequestStr(String requestStr) &#123;</div><div class="line">	this.requestStr = requestStr;</div><div class="line">&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Response &#123;</div><div class="line">	 String responseStr;</div><div class="line">	public String getResponseStr() &#123;</div><div class="line">		return responseStr;</div><div class="line">	&#125;</div><div class="line">	public void setResponseStr(String responseStr) &#123;</div><div class="line">		this.responseStr = responseStr;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是Filter接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Filter &#123;</div><div class="line">	void doFilter(Request request, Response response, FilterChain chain);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>紧接着是filterchain类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class FilterChain implements Filter &#123;</div><div class="line">    //存放各种filter</div><div class="line">	List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();</div><div class="line">   </div><div class="line">    //控制filter的索引</div><div class="line">	int index = 0;</div><div class="line"></div><div class="line">    //添加filter</div><div class="line">	public FilterChain addFilter(Filter f) &#123;</div><div class="line">		this.filters.add(f);</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">//filter链，特别注意这里有一个迭代，与具体filter里的迭代相呼应</div><div class="line">//主要是依次先取出request的接受字符过滤，然后在倒叙依次取完response的响应过滤,而这恰恰是struts2框架原理的核心，当然spring mvc(直接基于servlet)也类似，都是基于拦截或者过滤实现的</div><div class="line">	@Override</div><div class="line">	public void doFilter(Request request, Response response, FilterChain chain) &#123;</div><div class="line">		// 过滤器取完退出</div><div class="line">if(index == filters.size()) return ;</div><div class="line">		</div><div class="line">	//依次取出过滤器</div><div class="line">		Filter f = filters.get(index);</div><div class="line">		index ++;</div><div class="line">		f.doFilter(request, response, chain);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就是具体的filter了（这里就是web中的真实拦截顺序了）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SesitiveFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void doFilter(Request request, Response response, FilterChain chain) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		request.requestStr = request.requestStr.replace("瞎子", "李青")</div><div class="line">				 .replace("小学僧", "盲僧") ;</div><div class="line">		chain.doFilter(request, response, chain);</div><div class="line">		response.responseStr += "SesitiveFilterresponse";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一个filter</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class HTMLFilter implements Filter &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void doFilter(Request request, Response response,FilterChain chain) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		request.requestStr = request.requestStr.replace('&lt;', '[')</div><div class="line">				   .replace('&gt;', ']') ;</div><div class="line">		</div><div class="line">		chain.doFilter(request, response, chain);</div><div class="line">		response.responseStr += "HTMLFilterresponse";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先附一张structs2原理图，来对比一下上述过滤过程<br><img src="/images/imgs2/9.gif" alt="Alt text"><br>主要关注action invocation中部分</p>
<p>测试类:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		String msg = "因为一个英雄而爱上了lol，他就是瞎子，虽然我是小学僧，但是我还是只坚信我的&lt;我的信仰&gt;英雄！！";</div><div class="line">		Request request = new Request();</div><div class="line">		request.setRequestStr(msg);</div><div class="line">		Response response = new Response();</div><div class="line">		response.setResponseStr("response");</div><div class="line">		FilterChain fc = new FilterChain();</div><div class="line">		fc.addFilter(new HTMLFilter())</div><div class="line">		  .addFilter(new SesitiveFilter())</div><div class="line">		  ;</div><div class="line">		</div><div class="line">		fc.doFilter(request, response, fc);</div><div class="line">		System.out.println(request.getRequestStr());</div><div class="line">		System.out.println(response.getResponseStr());</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>结果:</p>
<blockquote>
<p>因为一个英雄而爱上了lol，他就是李青，虽然我是盲僧，但是我还是只坚信我的[我的信仰]英雄！！<br>response–SesitiveFilterresponse–HTMLFilterresponse</p>
</blockquote>
<p>最后归纳一下责任链设计模式的一般形式<br><img src="/images/imgs2/10.gif" alt="Alt text"><br>分别为客户端、处理者和具体处理者</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt; 职责链，通俗地讲就是把责任处理对象连城一条链，这样当一个处理对象不能及时处理的时候就会交给下一个处理对象直到被处理为止。就好比生活中，我们
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="http://www.myzwl.win/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器设计模式</title>
    <link href="http://www.myzwl.win/2017/03/26/iterator/"/>
    <id>http://www.myzwl.win/2017/03/26/iterator/</id>
    <published>2017-03-26T13:48:51.000Z</published>
    <updated>2017-03-27T07:18:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 为什么会有迭代器？<br>当我们想要 遍历取出集合一组数据时，一般都是用for里面套着i循环，或者使用for（对象 x :某个集合)的形式取出，不过因为集合类型的不同，取出的形式也不同，但是当我们想要一种统一的方法去遍历集合时，就可以用迭代器去实现，说了那么多，不如来一个直观的例子。</p>
<p><img src="/images/imgs2/7.gif" alt="Alt text"><br>这里模仿Arraylist集合中的迭代器实现过程，其中<br>Iterator:执行递增遍历的接口<br>Collection:一些集合的上层接口<br>Arraylist: 目前只实现了add、size及迭代器<br>ArrayListIterator: 用于Arraylist的迭代器</p>
<p>Iterator接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;</div><div class="line">//取得下一个元素</div><div class="line">Object next();</div><div class="line">//检查有没有下一个元素</div><div class="line">boolean hasNext();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Collection接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Collection &#123;</div><div class="line">public void add(Object o);//增加一个对象</div><div class="line">public int size();//返回长度</div><div class="line">Iterator iterator();//内聚迭代器</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Arraylist类（这里ArrayListIterator是其内部类）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">package com.zwl.iterator;</div><div class="line"></div><div class="line">public class ArrayList implements Collection&#123;</div><div class="line">//默认都是初始化为10的</div><div class="line">Object objects[]=new Object[10];</div><div class="line">//默认集合长度都为0的</div><div class="line">int index=0;</div><div class="line"></div><div class="line">//增加方法</div><div class="line">public void add(Object o)&#123;</div><div class="line">//集合长度动态增长，每次都使其长度增加2倍，并且创建一个增长后的新数组</div><div class="line">//将旧数组先copy给新数组，在指向旧数组的引用</div><div class="line">//同时保证每添加一个对象，集合长度自增长，这样就不会出现越界情况</div><div class="line">	if(index==objects.length)&#123;</div><div class="line">		Object newobjects[]=new Object[objects.length*2];</div><div class="line">		System.arraycopy(objects, 0, newobjects, 0, objects.length);</div><div class="line">		objects=newobjects;</div><div class="line">	&#125;</div><div class="line">	objects[index]=o;</div><div class="line">	index++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回集合长度</div><div class="line">public int size()&#123;</div><div class="line">	return index;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//统一迭代器方法</div><div class="line">@Override</div><div class="line">public Iterator iterator() &#123;</div><div class="line">	// TODO Auto-generated method stub</div><div class="line">	return new ArrayListIterator();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//内部类，返回arraylist的专有迭代器</div><div class="line">private class ArrayListIterator implements Iterator&#123;</div><div class="line">    //取集合中对象的索引</div><div class="line">        private int currentIndex=0;</div><div class="line">    </div><div class="line">   //取出集合中当前索引的一个对象</div><div class="line">	@Override</div><div class="line">	public Object next() &#123;</div><div class="line">		Object o = objects[currentIndex];</div><div class="line">		currentIndex ++;</div><div class="line">		return o;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//判断集合是否含有下一个元素</div><div class="line">	@Override</div><div class="line">	public boolean hasNext() &#123;</div><div class="line">//索引值超出集合长度，集合中元素取完</div><div class="line">		if(currentIndex&gt;=index) return false;</div><div class="line">		else</div><div class="line">			return true;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		Collection al=new ArrayList();</div><div class="line">		</div><div class="line"> for(int i=0;i&lt;15;i++)&#123;</div><div class="line">	 al.add(new Object());</div><div class="line"> &#125;</div><div class="line"> System.out.println(al.size());</div><div class="line"> </div><div class="line"> Iterator it=al.iterator();</div><div class="line"> while(it.hasNext())&#123;</div><div class="line">	 Object o=it.next();</div><div class="line">	 System.out.println(o+"  ");</div><div class="line"> &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>至此，可以归纳一下迭代器设计模式的一般形式<br><img src="/images/imgs2/8.gif" alt="Alt text"></p>
<p>其中：<br>1：Iterator(迭代器) 参与者：<br> 定义访问和遍历元素的接口（如Iterator)</p>
<p>2.ConcreteIterator(具体迭代器)参与者<br>实现迭代器的接口(如ArrayListIterator)</p>
<p>3.Aggregate(聚合)参与者<br>定义建立Iterator参与者的接口(如Collection)</p>
<p>4.ConcreteAggregate（具体聚合）参与者<br>实现Aggregate所定义的接口（如Arraylist）</p>
<p>最后不得不提的是，无论一个集合实现的结果如何，都能使用iterator，此外，我们通过改变iterato，来增加各种iterator，如反向遍历，双向遍历（即，增加一个previous方法），只要注意一下currentInde和index就可以了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt; 为什么会有迭代器？&lt;br&gt;当我们想要 遍历取出集合一组数据时，一般都是用for里面套着i循环，或者使用for（对象 x :某个集合)的形式
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="http://www.myzwl.win/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
