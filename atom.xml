<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2017-07-14T09:54:00.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识shiro</title>
    <link href="http://www.myzwl.win/2017/07/01/shiro_1/"/>
    <id>http://www.myzwl.win/2017/07/01/shiro_1/</id>
    <published>2017-07-01T05:48:51.000Z</published>
    <updated>2017-07-14T09:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考百度上说的<a href="http://shiro.apache.org/download.html" target="_blank" rel="external">Apache Shiro</a>是一个强大易用的java安全框架，提供了认证、授权、加密和会话管理功能，可以为任何应用提供安全保障，而其主要为解决以下四个问题：<br>1、 认证-用户身份识别，常被称为用户登录<br>2、 授权-访问控制<br>3、 密码加密-保护或隐藏数据防止被偷窥<br>4、 会话管理-每用户相关的时间敏感的状态</p>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>以下是从其官网上截取的原理图<br><img src="/images/imgs3/14.gif" alt="Alt text"></p>
<p>可以看出shiro的设计非常精妙，同时它不依赖于任何容器，即在java se和java ee中都可以使用，如果把shiro看做一个不透明的黑盒的话，即认证主体subject提供认证给security manager，其内部封装一些列细节方法去执行认证，这里的验证数据源可以是数据库的或者其他</p>
<p>下面将以用户的登录过程来模拟shiro的执行过程</p>
<p><img src="/images/imgs4/1.gif" alt="Alt text"></p>
<h4 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h4><p><strong>token令牌</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">   @RequestMapping("login")</div><div class="line">public ModelAndView login(@RequestParam("username") String username, @RequestParam("password") String password) &#123;</div><div class="line">	 UsernamePasswordToken token = new UsernamePasswordToken(username, password);</div><div class="line">        Subject subject = SecurityUtils.getSubject();</div><div class="line">        try &#123;</div><div class="line">            subject.login(token);</div><div class="line">        &#125; catch (IncorrectCredentialsException ice) &#123;</div><div class="line">            // 捕获密码错误异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "password error!");</div><div class="line">            return mv;</div><div class="line">        &#125; catch (UnknownAccountException uae) &#123;</div><div class="line">            // 捕获未知用户名异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "username error!");</div><div class="line">            return mv;</div><div class="line">        &#125; catch (ExcessiveAttemptsException eae) &#123;</div><div class="line">            // 捕获错误登录过多的异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "times error");</div><div class="line">            return mv;</div><div class="line">        &#125;</div><div class="line">        catch (AuthenticationException eae) &#123;</div><div class="line">            // 捕获错误登录过多的异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "times error");</div><div class="line">            return mv;</div><div class="line">        &#125;</div><div class="line">        TUserEntity user=tUserService.queryObject(username);</div><div class="line">        subject.getSession().setAttribute("user", user);   </div><div class="line">         return new ModelAndView("index");	 </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这里该方法接收到前台传递过来的username和password信息，类比身份证，姓名是认证，但是身份证号码是作为认证的唯一凭证，只有身份证号码正确了，这个认证也就通过了，而这里的token可以理解为用户登录的令牌，里面记录着认证信息，然后交给shiro去验证<br> 接下来就是执行登录动作了</p>
<blockquote>
<p>SecurityUtils.setSecurityManager(securityManager); // 注入SecurityManager<br>Subject subject = SecurityUtils.getSubject(); // 获取Subject单例对象<br>subject.login(token); // 登陆</p>
</blockquote>
<p>其中SecurityManager是一个单例对象，即全局变量，接着SecurityUtils会自动绑定当前线程，获得subject主体，关于subject可以这样理解其包含两个信息:<br>Principals： 身份，可以是用户名，邮件，手机号码等等，用来标识一个登陆主体身份；<br>Credentials： 凭证，常见有密码，数字证书等等；<br>最后就是登陆了，最后通过验证token是否合法返回不同结果</p>
<h4 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h4><p>根据流程图，接下来security manager开始执行一系列的认证手段了，其中最主要的就是<br>AuthorizationInfo（角色权限认证），AuthenticationInfo（身份认证），可以简单这样理解，身份认证只是验证了这个subject的存在性，如果约定subject有某些权限，如管理员有删除或者访问某些url地址权限，而这个管理员就可以抽象为角色，也就是说权限是访问资源的权利集合，而角色是权限的集合</p>
<p>最后的realm域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色，权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源</p>
<p>一般情况下realm需要我们自定义去实现，因为shiro不知道哪些token是合法的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">  public class OAuth2Realm extends AuthorizingRealm&#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	private TUserService tUserService;</div><div class="line">	</div><div class="line">	/**</div><div class="line">     * 提供用户信息返回权限信息</div><div class="line">     */</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</div><div class="line">	</div><div class="line">		String username = (String) principals.getPrimaryPrincipal();</div><div class="line">		 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();</div><div class="line">		   TUserEntity user=tUserService.queryObject(username);</div><div class="line">	        // 根据id查询当前用户拥有的角色</div><div class="line">		  List&lt;TUserRoleEntity&gt; ture=tUserService.queryRole(user.getId());</div><div class="line">		   Set&lt;TRoleEntity&gt; roles=new HashSet&lt;TRoleEntity&gt;();</div><div class="line">		        for(TUserRoleEntity Tures:ture)&#123;</div><div class="line">		        	roles.add(tUserService.queryObject(Tures.getRoleId()));</div><div class="line">		        &#125;</div><div class="line">		        Set&lt;String&gt; roleNames=new HashSet&lt;String&gt;();</div><div class="line">		         for(TRoleEntity rolename : roles)&#123;</div><div class="line">		    	   roleNames.add(rolename.getRolename());</div><div class="line">		         &#125;</div><div class="line">		      // 将角色名称提供给info</div><div class="line">		      authorizationInfo.setRoles(roleNames);</div><div class="line">		return authorizationInfo;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">     * 提供账户信息返回认证信息</div><div class="line">     */</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</div><div class="line">		</div><div class="line">		String username=(String)token.getPrincipal();   // 获取用户名</div><div class="line">// String password = new String((char[])token.getCredentials()); 得到密码</div><div class="line"></div><div class="line">	UsernamePasswordToken t = (UsernamePasswordToken) token; //得到密码</div><div class="line">		String newPassword=new String(t.getPassword());</div><div class="line">		//根据用户名从数据库取出用户完整信息</div><div class="line">		 TUserEntity tuserEntity=tUserService.queryObject(username);</div><div class="line">		  if(tuserEntity!=null)&#123;</div><div class="line">			  //若存在，将此用户存放到登录认证info中    </div><div class="line">	            return new SimpleAuthenticationInfo(tuserEntity.getUsername(),tuserEntity.getPassword(), ByteSource.Util.bytes("zwl"), getName());  </div><div class="line">		  &#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>该realm类的结果就是根据token的合法性验证返回不同结果给相应的controller，目前只是从宏观上看了一个全过程，shiro是非常强大的，它的功能远不止如此</p>
<h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>缓存的本质就是将原本只能存储在内存中的数据通过算法保存到硬盘上，再根据需求依次取出。可以把缓存理解为一个Map对象，通过put保存对象，再通过get取回对象。这里使用的是Ehcache缓存框架。具体代码如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;ehcache name="es"&gt;</div><div class="line"></div><div class="line">    &lt;diskStore path="java.io.tmpdir"/&gt;</div><div class="line"></div><div class="line">    &lt;!--</div><div class="line">       name:缓存名称。</div><div class="line">       maxElementsInMemory：缓存最大个数。</div><div class="line">       eternal:对象是否永久有效，一但设置了，timeout将不起作用。</div><div class="line">       timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</div><div class="line">       timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</div><div class="line">       overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。</div><div class="line">       diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</div><div class="line">       maxElementsOnDisk：硬盘最大缓存个数。</div><div class="line">       diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</div><div class="line">       diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</div><div class="line">       memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</div><div class="line">       clearOnFlush：内存数量最大时是否清除。</div><div class="line">    --&gt;</div><div class="line"></div><div class="line">    &lt;defaultCache</div><div class="line">            maxEntriesLocalHeap="1000"</div><div class="line">            eternal="false"</div><div class="line">            timeToIdleSeconds="3600"</div><div class="line">            timeToLiveSeconds="3600"</div><div class="line">            overflowToDisk="false"&gt;</div><div class="line">    &lt;/defaultCache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-authenticationCache"</div><div class="line">           maxEntriesLocalHeap="1000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-authorizationCache"</div><div class="line">           maxEntriesLocalHeap="2000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-userCache"</div><div class="line">           maxEntriesLocalHeap="2000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">&lt;/ehcache&gt;</div></pre></td></tr></table></figure></p>
<p>其中<diskstore path="java.io.tmpdir">可以指定缓存的路径，这里是临时路径</diskstore></p>
<h4 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h4><p>通常情况下散列和加密本质上都是一样的，即将一个Object变成一串无意义的字符串，不同点是经过散列的对象无法复原，是一个单向的过程，而加密是可以双向的，即加密与解密，所以如果忘记密码，只能进行修改密码操作，下面是在项目中用到的散列算法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private RandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator();</div><div class="line">private String algorithmName = "md5";</div><div class="line">private final int hashIterations = 2;</div><div class="line"></div><div class="line">public void encryptPassword(TUserEntity user) &#123;</div><div class="line">    // User对象包含最基本的字段Username和Password</div><div class="line">	String salt="zwl";</div><div class="line">    // 将用户的注册密码经过散列算法替换成一个不可逆的新密码保存进数据，散列过程使用了盐</div><div class="line">    String newPassword = new SimpleHash(algorithmName, user.getPassword(),</div><div class="line">            ByteSource.Util.bytes("zwl"), hashIterations).toHex();</div><div class="line">    user.setPassword(newPassword);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中algorithmName为指定运用何种算法，hashIterations为散列次数，也就是数学中的迭代，将前一个结果作为参数在运算一次，salt盐可以理解为有了盐，并且每个盐唯一确定一个散列值，最后产生的newPassword是经过如下类</p>
<blockquote>
<p>public SimpleHash(String algorithmName, Object source, Object salt, int hashIterations) </p>
</blockquote>
<p>四个参数分别标识算法名称，散列对象，散列使用的salt值，散列次数。</p>
<h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>匹配的功能就是用来匹配用户登录使用的令牌和数据库中保存的用户信息是否匹配。它的原始接口是CredentialsMatcher，一般情况下如果不自定义的话就会使用默认的实现类HashedCredentialsMatcher，如下是自定义的匹配<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher&#123;</div><div class="line"></div><div class="line">	// 声明一个缓存接口，这个接口是Shiro缓存管理的一部分，它的具体实现可以通过外部容器注入</div><div class="line">	 private Cache&lt;String, AtomicInteger&gt; passwordRetryCache;</div><div class="line">	 </div><div class="line">	 public RetryLimitHashedCredentialsMatcher(CacheManager cacheManager) &#123;</div><div class="line">	        passwordRetryCache = cacheManager.getCache("passwordRetryCache");</div><div class="line">	    &#125;</div><div class="line">	 </div><div class="line">	 @Override</div><div class="line">	    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123;</div><div class="line">		 String username = (String) token.getPrincipal();</div><div class="line">	        AtomicInteger retryCount = passwordRetryCache.get(username);</div><div class="line">	        if (retryCount == null) &#123;</div><div class="line">	            retryCount = new AtomicInteger(0);</div><div class="line">	            passwordRetryCache.put(username, retryCount);</div><div class="line">	        &#125;</div><div class="line">	        // 自定义一个验证过程：当用户连续输入密码错误5次以上禁止用户登录一段时间</div><div class="line">	        if (retryCount.incrementAndGet() &gt; 5) &#123;</div><div class="line">	            throw new ExcessiveAttemptsException();</div><div class="line">	        &#125;</div><div class="line">	        boolean match = super.doCredentialsMatch(token, info);</div><div class="line">	        if (match) &#123;</div><div class="line">	            passwordRetryCache.remove(username);</div><div class="line">	        &#125;</div><div class="line">	        return match;</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般情况下，匹配的异常的结果都会抛出相应的异常，如 DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等</p>
<p>而针对获得realm数据源的情况，会设置五张表，分别是用户表（存储用户名，密码，盐等）、角色表（角色名称，相关描述等）、权限表（权限名称，相关描述等）、用户-角色对应中间表（以用户ID和角色ID作为联合主键）、角色-权限对应中间表（以角色ID和权限ID作为联合主键），其中用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>用户的一次登录即为一次会话，即session，Shiro也可以代替Tomcat等容器管理会话。而针对会话，可以处理的情况太多了，如记录用户信息和行为等等，比如保存用户信息</p>
<blockquote>
<p>TUserEntity user=tUserService.queryObject(username);<br>    subject.getSession().setAttribute(“user”, user); </p>
</blockquote>
<h4 id="ssm-shiro集成"><a href="#ssm-shiro集成" class="headerlink" title="ssm+shiro集成"></a>ssm+shiro集成</h4><p>web.xml中的配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"</div><div class="line">         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee</div><div class="line">                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</div><div class="line">         version="3.0"&gt;</div><div class="line"></div><div class="line">    &lt;!-- 修改 Servlet 版本--&gt;</div><div class="line">    &lt;!-- 配置 DispatcherServlet--&gt;</div><div class="line">    &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</div><div class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">        &lt;init-param&gt;</div><div class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">            &lt;param-value&gt;</div><div class="line">                classpath:spring/spring-web.xml</div><div class="line">            &lt;/param-value&gt;</div><div class="line">        &lt;/init-param&gt;</div><div class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">        &lt;async-supported&gt;true&lt;/async-supported&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">    &lt;context-param&gt;</div><div class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;</div><div class="line">            classpath:spring/spring-service.xml,</div><div class="line">            classpath:spring/spring-dao.xml,</div><div class="line">            classpath:spring/spring-shiro.xml</div><div class="line">        &lt;/param-value&gt;</div><div class="line">    &lt;/context-param&gt;</div><div class="line"></div><div class="line">    &lt;listener&gt;</div><div class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</div><div class="line">    &lt;/listener&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;!-- 添加 Shiro 相关配置(应该去官网查询相应的配置信息) --&gt;</div><div class="line"></div><div class="line">    &lt;!-- The filter-name matches name of a 'shiroFilter' bean inside applicationContext.xml --&gt;</div><div class="line">    &lt;filter&gt;</div><div class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</div><div class="line">        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</div><div class="line">        &lt;init-param&gt;</div><div class="line">            &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;</div><div class="line">            &lt;param-value&gt;true&lt;/param-value&gt;</div><div class="line">        &lt;/init-param&gt;</div><div class="line">    &lt;/filter&gt;</div><div class="line"></div><div class="line">    &lt;filter-mapping&gt;</div><div class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</div><div class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">    &lt;/filter-mapping&gt;</div><div class="line"></div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>其中主要关心的是web容器将将Shiro的配置文件交给Spring监听器初始化以及配置了shiro的过滤等<br>这里shiro的配置都在spring-shiro.xml中配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">       xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">       xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">       xsi:schemaLocation="</div><div class="line">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</div><div class="line">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</div><div class="line">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;!-- 声明一个密码匹配器 --&gt;</div><div class="line">    &lt;bean id="credentialsMatcher" class="com.hfsf.sys.oauth2.RetryLimitHashedCredentialsMatcher"&gt;</div><div class="line">        &lt;!-- 设置该密码匹配器使用的算法是 md5 --&gt;</div><div class="line">      &lt;property name="hashAlgorithmName" value="md5"/&gt;</div><div class="line">     &lt;property name="hashIterations" value="2" /&gt;</div><div class="line">      &lt;property name="storedCredentialsHexEncoded" value="true" /&gt; </div><div class="line">      &lt;constructor-arg ref="ehCacheManager" /&gt; </div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 声明一个自定义的 Realm --&gt;</div><div class="line">    &lt;bean id="myRealm" class="com.hfsf.sys.oauth2.OAuth2Realm"&gt;</div><div class="line">        &lt;!-- 将上面声明的密码匹配器注入到自定义 Realm 的属性中去 --&gt;</div><div class="line">        &lt;property name="credentialsMatcher" ref="credentialsMatcher"/&gt;</div><div class="line">        &lt;!-- 将自定义的权限匹配器注入到自定义 Realm 中 --&gt;</div><div class="line">        &lt;property name="permissionResolver" ref="permissionResolver"/&gt;</div><div class="line"></div><div class="line">        &lt;!-- 配置缓存相关 --&gt;</div><div class="line">        &lt;!-- 启用缓存 --&gt;</div><div class="line">        &lt;property name="cachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 开启认证缓存--&gt;</div><div class="line">        &lt;property name="authenticationCachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 指定认证缓存的名字(与 ehcache.xml 中声明的相同) --&gt;</div><div class="line">        &lt;property name="authenticationCacheName" value="shiro-authenticationCache"/&gt;</div><div class="line">        &lt;!--开启授权缓存--&gt;</div><div class="line">        &lt;property name="authorizationCachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 指定授权缓存的名字(与 ehcache.xml 中声明的相同) --&gt;</div><div class="line">        &lt;property name="authorizationCacheName" value="shiro-authorizationCache"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 自定义一个权限匹配器 --&gt;</div><div class="line">    &lt;bean id="permissionResolver" class="com.hfsf.sys.oauth2.UrlPermissionResolver"/&gt;</div><div class="line"></div><div class="line">    &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt;</div><div class="line">        &lt;property name="securityManager" ref="securityManager"/&gt;</div><div class="line">        &lt;!-- 如果认证不通过,浏览器通过 Get 方式请求到 /login 上 --&gt;</div><div class="line">        &lt;property name="loginUrl" value="/login.jsp"/&gt;</div><div class="line"></div><div class="line">        &lt;!-- override these for application-specific URLs if you like:</div><div class="line"></div><div class="line">        &lt;property name="successUrl" value="/home.jsp"/&gt;</div><div class="line">        &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; --&gt;</div><div class="line"> </div><div class="line">        &lt;!-- defined will be automatically acquired and available via its beanName in chain        --&gt;</div><div class="line">       </div><div class="line">        &lt;property name="filterChainDefinitions"&gt;</div><div class="line">            &lt;value&gt;</div><div class="line"></div><div class="line">               /authc/admin = roles[admin]</div><div class="line">                /authc/** = authc</div><div class="line">                /** = anon</div><div class="line">            &lt;/value&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 声明一个自定义的过滤器 --&gt;</div><div class="line">    &lt;bean id="resourceCheckFilter" class="com.hfsf.common.xss.ResourceCheckFilter"&gt;</div><div class="line">        &lt;!-- 为上面声明的自定义过滤器注入属性值 --&gt;</div><div class="line">        &lt;property name="errorUrl" value="/unAuthorization"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt;</div><div class="line">        &lt;!-- Single realm app.  If you have multiple realms, use the 'realms' property instead. --&gt;</div><div class="line">        &lt;!-- 设置安全管理器的安全数据源为自定义的 Realm --&gt;</div><div class="line">        &lt;property name="realm" ref="myRealm"/&gt;</div><div class="line">        &lt;!-- By default the servlet container sessions will be used.  Uncomment this line</div><div class="line">             to use shiro's native sessions (see the JavaDoc for more): --&gt;</div><div class="line">        &lt;!-- &lt;property name="sessionMode" value="native"/&gt; --&gt;</div><div class="line">        &lt;property name="cacheManager" ref="ehCacheManager"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    </div><div class="line">  </div><div class="line">   </div><div class="line">    &lt;!-- 配置 shiro 的 ehcache 缓存相关,这个缓存只和 Realm 相关 --&gt;</div><div class="line">    &lt;bean id="ehCacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 配置 Spring 的 EhCacheManagerFactoryBean ,须要 spring-context-support 的支持 --&gt;</div><div class="line">    &lt;bean id="ehCacheManagerFactoryBean" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt;</div><div class="line">        &lt;property name="configLocation" value="classpath:ehcache.xml"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 配置 Spring 的 EhCacheCacheManager,须要 spring-context-support 的支持 --&gt;</div><div class="line">    &lt;bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager"&gt;</div><div class="line">        &lt;property name="cacheManager" ref="ehCacheManagerFactoryBean"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>其中最主要的是filterChainDefinitions，这里声明了权限控制用户访问哪些url，而且访问是有顺序的，即执行了前者后者将不再执行，其中anon为匿名访问，authc为需要身份认证通过才可以访问，这里的内容较多，具体参考官方文档</p>
<p>最后只要通过前台页面提交数据，经过一系列流程，最终就可以完成权限控制了，事实上shiro的内容很多，而且很丰富，只有不断在实践中踩坑，学习，总结才能更好的认识和运用它</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考百度上说的&lt;a href=&quot;http://shiro.apache.org/download.html&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>设计模式原则笔记</title>
    <link href="http://www.myzwl.win/2017/05/11/jd1/"/>
    <id>http://www.myzwl.win/2017/05/11/jd1/</id>
    <published>2017-05-11T05:48:51.000Z</published>
    <updated>2017-06-30T02:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在编程语言中除了各种不同的设计模式外，它们也可以被抽出一些共性</p>
<p>开闭原则：一个软件实体应当对开展开放，对修改关闭（玉帝招安美猴王）</p>
<p>面向对象解释： 不予以更改的是抽象层，但是可以扩展的是实现层</p>
<p>对可变性的封装原则： 找到一个系统的可变因素，将之封装起来</p>
<p>继承应当是看做封装的方法，而不应该被认为是从一般对象方法到特殊对象的生成方法</p>
<p>里氏代换原则： 任何基类可以出现的地方，子类一定可以出现</p>
<p>两个类共同行为抽象到一个c类<br>B继承A改为聚合B（白马与黑马，正方形与长方形）</p>
<p>依赖倒转原则： 要依赖于抽象，不要依赖于实现<br>抽象类仅提供一个类型的部分实现，可以同时有抽象方法和具体方法<br>具体类不是用来继承的<br>如果两个具体类存在继承关系，要引入第三个类作为他们的共同的接口<br>抽象类应该拥有尽可能多共同代码<br>抽象类应当拥有尽可能少的数据</p>
<p>接口隔离原则： 应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</p>
<p>角色的合理划分<br>定制服务<br>接口污染</p>
<p>合成/聚合复用原则： 要尽量使用合成/聚合，而不是继承关系达到复用的目的<br>合成是值得聚合，聚合是引用的聚合<br>Is-A 代表一个类是另一个类的一种，Has-A代表一个类是另一个类的角色，而不是另一个类的特殊类（人与角色）</p>
<p>迪米特法则： 一个软件实体应当尽可能少的与其他实体发生相互作用</p>
<p>java接口： 一些方法特征的集合<br>没有接口会造成硬代码问题直接导致可插入性没有保证<br>java接口用来声明一个新的类型<br>单方法接口（如Runnable）<br>标识接口（serialzable）<br>常量接口</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编程语言中除了各种不同的设计模式外，它们也可以被抽出一些共性&lt;/p&gt;
&lt;p&gt;开闭原则：一个软件实体应当对开展开放，对修改关闭（玉帝招安美猴王）&lt;/p&gt;
&lt;p&gt;面向对象解释： 不予以更改的是抽象层，但是可以扩展的是实现层&lt;/p&gt;
&lt;p&gt;对可变性的封装原则： 找到一个系统的可
    
    </summary>
    
      <category term="java与设计" scheme="http://www.myzwl.win/categories/java%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java与设计" scheme="http://www.myzwl.win/source/tags/java%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>并发系列之四Guarded Suspension</title>
    <link href="http://www.myzwl.win/2017/04/13/thrd4/"/>
    <id>http://www.myzwl.win/2017/04/13/thrd4/</id>
    <published>2017-04-13T05:48:51.000Z</published>
    <updated>2017-04-20T11:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Guarded Suspension是指当现在并不适合马上执行某个操作时，就要求想要执行该操作的线程等待</p>
<h4 id="Guarded-Suspension"><a href="#Guarded-Suspension" class="headerlink" title="Guarded Suspension"></a>Guarded Suspension</h4><p>首先模拟一个案例<br>首先是表示请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public class Request &#123;</div><div class="line">private final String name;</div><div class="line"></div><div class="line">public Request(String name)&#123;</div><div class="line">	this.name=name;</div><div class="line">&#125;</div><div class="line">public String getName()&#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String toString()&#123;</div><div class="line">	return "[ Request"+name+"]";</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一次存放请求以待使用的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.LinkedList;</div><div class="line"></div><div class="line">public class RequestQueue &#123;</div><div class="line"></div><div class="line">  //构造链表，用来保存请求</div><div class="line">	private final LinkedList queue=new LinkedList&lt;&gt;();</div><div class="line">//有请求将最早的请求取出，没有则等待</div><div class="line">	public synchronized Request getRequest()&#123;</div><div class="line">		while(queue.size()&lt;=0)&#123;</div><div class="line">			try&#123;</div><div class="line">				wait();</div><div class="line">			&#125;catch(Exception e)&#123;</div><div class="line">				</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return (Request) queue.removeFirst();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//增加一个请求</div><div class="line">	public synchronized void putRequest(Request request)&#123;</div><div class="line">		queue.addLast(request);</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>送出请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class ClientThread extends Thread &#123;</div><div class="line">  //构造随机数，用来线程等待时间</div><div class="line">	private Random random;</div><div class="line">	//存放请求</div><div class="line">	private RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	public ClientThread(RequestQueue requestQueue,String name,long seed)&#123;</div><div class="line">		super(name);</div><div class="line">		this.requestQueue=requestQueue;</div><div class="line">		this.random=new Random(seed);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">//不断调用putrequest（），并且打印相关信息</div><div class="line">		for(int i=0;i&lt;10000;i++)&#123;</div><div class="line">			Request request=new Request("No ."+i);</div><div class="line">			System.out.println(Thread.currentThread().getName()+" Request:"+request);</div><div class="line">			requestQueue.putRequest(request);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(random.nextInt(1000));</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO: handle exception</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接收请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class ServerThread extends Thread &#123;</div><div class="line">	private Random random;</div><div class="line">	private RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	public ServerThread(RequestQueue requestQueue,String name,long seed)&#123;</div><div class="line">		super(name);</div><div class="line">		this.requestQueue=requestQueue;</div><div class="line">		this.random=new Random(seed);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">	//不断调用getrequest（）</div><div class="line">		for(int i=0;i&lt;10000;i++)&#123;</div><div class="line">			Request request=requestQueue.getRequest();</div><div class="line">			System.out.println(Thread.currentThread().getName()+" Handlet:"+request);</div><div class="line">			</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(random.nextInt(1000));</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO: handle exception</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后是测试<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RequestQueue requestQueue=new RequestQueue();</div><div class="line">		new ClientThread(requestQueue, "A", 1314520l).start();</div><div class="line">		new ServerThread(requestQueue, "B", 5201314l).start();</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>A Request:[ RequestNo .0]<br>B Handlet:[ RequestNo .0]<br>A Request:[ RequestNo .1]<br>B Handlet:[ RequestNo .1]<br>A Request:[ RequestNo .2]<br>B Handlet:[ RequestNo .2]<br>……</p>
</blockquote>
<p>从测试结果可以看出，当发送请求时，接受并处理<br>而其中的关键方法是getRequest（）中，当满足while里条件时，则调用wait，处于等待，直到收到通知，才从休息区出来，而这种一定要满足的条件，就称为Guarded Suspension的警戒条件</p>
<p>所以可将该模式抽象为如下<br>GuardedObject（被防伪的对象）参与者：当线程执行guardMethod时，只要满足警戒条件，就马上执行，当不成立时，就开始等待，而条件的成立与否，是与参与者的状态变化有关<br>guardMethod：防伪的方法<br>stateChangingMethod：状态改变的方法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Guarded Suspension是指当现在并不适合马上执行某个操作时，就要求想要执行该操作的线程等待&lt;/p&gt;
&lt;h4 id=&quot;Guard
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发系列之三Immutable</title>
    <link href="http://www.myzwl.win/2017/04/12/thrd3/"/>
    <id>http://www.myzwl.win/2017/04/12/thrd3/</id>
    <published>2017-04-12T05:48:51.000Z</published>
    <updated>2017-07-14T07:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>immutable是指永恒，不会改变的意思，就像java.lang.String类中，并没有提供任何改变字符串属性的方法</p>
<h4 id="immutable-Pattern"><a href="#immutable-Pattern" class="headerlink" title="immutable Pattern"></a>immutable Pattern</h4><p>首先模拟一个案例<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public final class Person &#123;</div><div class="line">//不允许修改的地址</div><div class="line">private final String address;</div><div class="line">//不允许修改的姓名</div><div class="line">private final String name;</div><div class="line">public Person(String name, String address) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.address = address;</div><div class="line">&#125;</div><div class="line">//有final就不会有set方法，控制外部对其的修改</div><div class="line">public String getAddress() &#123;</div><div class="line">	return address;</div><div class="line">&#125;</div><div class="line">public String getName() &#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String toString()&#123;</div><div class="line">	return "[ Person: name="+name+ ",address="+address+"]";</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是人的线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public class PersonThread extends Thread &#123;</div><div class="line"></div><div class="line">	private Person person;</div><div class="line"></div><div class="line">	public PersonThread(Person person) &#123;</div><div class="line">		this.person = person;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">		while(true)&#123;</div><div class="line">		//得到线程的名并打印出人的信息</div><div class="line">			System.out.println(Thread.currentThread().getName()+"prints"+person);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person person=new Person("A1","AA");</div><div class="line">	new PersonThread(person).start();</div><div class="line">	new PersonThread(person).start();</div><div class="line">	new PersonThread(person).start();</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>以下一直重复</p>
</blockquote>
<p>可以发现上面的字段都是final并且没有修改该字段的方法<br>正因为如此，所以就不需要使用synchronized来限制，这在性能上就大大提高了</p>
<h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><p>1.当实例产生后，状态不再变化时<br>2.实例需要共享，而且访问很频繁时</p>
<p>当然，有时也需要变与不变的转换，就像StringBuffer是一个线程不安全的类，在它的构造器中有String作为参数，而在String类中也有StringBuffer作为参数<br>另外像java中的基本类型boolean、int、long等都是immutable模式<br>该模式最大的优点就是实例的状态不会改变，所以没必要进行保护</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;immutable是指永恒，不会改变的意思，就像java.lang.String类中，并没有提供任何改变字符串属性的方法&lt;/p&gt;
&lt;h4 i
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发系列之二Single Threaded Execution</title>
    <link href="http://www.myzwl.win/2017/04/11/thrd2/"/>
    <id>http://www.myzwl.win/2017/04/11/thrd2/</id>
    <published>2017-04-11T03:48:51.000Z</published>
    <updated>2017-04-20T04:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Single Threaded Execution是指以一个线程执行，简单来说就是在多线程中限制同时只让一个线程运行</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>首先来模拟一个线程不安全的例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class Gate &#123;</div><div class="line"></div><div class="line">    //记录走过门的人数，默认为0</div><div class="line">	private int count=0;</div><div class="line">	//记录通过门的人的名字</div><div class="line">	private String name="nobody";</div><div class="line">	//记录通过门的人的地址</div><div class="line">	private String address="noplace";</div><div class="line">	</div><div class="line">	//穿越这道门使用的方法</div><div class="line">	public  void pass(String name,String address)&#123;</div><div class="line">		this.name=name;</div><div class="line">		this.address=address;</div><div class="line">		count++;</div><div class="line">		check();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//检查通过门的人的合法性，即人的名字和地址首字母是否相同</div><div class="line">	public void check()&#123;</div><div class="line">		if(name.charAt(0)!=address.charAt(0))&#123;</div><div class="line">			System.out.println("***broken***"+this.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//打印出人数、姓名、地址</div><div class="line">	public  String toString()&#123;</div><div class="line">		return "No."+count+":"+name+" ,"+address;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>目前上面的Gate类是线程不安全的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">//不断穿越门的行人</div><div class="line">public class UserThread extends Thread &#123;</div><div class="line">//用final限制门，姓名，地址不能重复</div><div class="line">private final Gate gate;</div><div class="line">private final String myaddress;</div><div class="line">private final String myname;</div><div class="line">public UserThread(Gate gate, String myname, String myaddress) &#123;</div><div class="line">	super();</div><div class="line">	this.gate = gate;</div><div class="line">	this.myname = myname;</div><div class="line">	this.myaddress = myaddress;</div><div class="line">&#125;</div><div class="line">//发生错误，即行人不合法，则处于死循环，并且执行toString方法</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">	System.out.println(myname+" BEGIN");</div><div class="line">while(true)&#123;</div><div class="line">	gate.pass(myname, myaddress);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">System.out.println("test begin:");</div><div class="line">	Gate gate=new Gate();</div><div class="line">	//构造三个行人</div><div class="line">	new UserThread(gate, "A1", "A2").start();</div><div class="line">	new UserThread(gate, "B1", "B2").start();</div><div class="line">	new UserThread(gate, "C1", "C2").start();</div></pre></td></tr></table></figure></p>
<p>测试结果（截取部分）</p>
<blockquote>
<p>test begin:<br>B1 BEGIN<br>A1 BEGIN<br><strong><em>broken</em></strong>No.1305356:A1 ,A2<br><strong><em>broken</em></strong>No.1347999:B1 ,B2<br><strong><em>broken</em></strong>No.1357011:A1 ,A2<br><strong><em>broken</em></strong>No.1370176:B1 ,B2<br><strong><em>broken</em></strong>No.1377075:B1 ,B2</p>
</blockquote>
<p>从结果来看，明显发生了错误，即出现了线程不安全，但是也有点不对劲</p>
<h4 id="为什么会出错了"><a href="#为什么会出错了" class="headerlink" title="为什么会出错了"></a>为什么会出错了</h4><blockquote>
<p>问题的出错地方就在Gate类中，因为其是线程不安全的，打个比方<br>    线程A1                  线程A2           this.name值            this.address值<br>   count++                  count++            之前的值                  之前的值<br> this.name=name                                  A1                     之前的值<br>                           this.name=name        A2                     之前的值<br>                           this.address=address  A2                       B2<br> this.address=address                            A1                       B2<br>  check（）                  check（）           A1                        B2</p>
</blockquote>
<p>  发生错误</p>
<p>  以上只是发生错误的一种情况，事实上只有当数据量非常大时，极有可能发生错误，所以才会出现错误的结果，并且是在count达到大数量的时候出现的<br>  那么如何修改了？<br>  因为发生在Gate类的pass和toString方法中，所以只要把这个两个方法声明为同步就可以了</p>
<blockquote>
<p>public synchronized void pass(String name,String address){}<br>  public synchronized String toString(){}</p>
</blockquote>
<p>  对应的测试结果</p>
<blockquote>
<p>test begin:<br>A1 BEGIN<br>B1 BEGIN<br>C1 BEGIN</p>
</blockquote>
<h4 id="归纳single-Threaded"><a href="#归纳single-Threaded" class="headerlink" title="归纳single Threaded"></a>归纳single Threaded</h4><p>上面例子的解决方案就是该模式的一种应用，可以将其抽象为以下几个参与者<br>SharedResource（共享资源）参与者：可有多个线程访问的类，如Gate<br>SafeMethod：从多个线程同时调用也不会发生问题<br>UnsafeMethod：从多个线程同时调用会发生问题，需要防范的方法<br>所以必须将上述不安全的方法加以同步锁，当时如果通过其他方法改变不安全方法中数据也会发生错误，就像大门上锁，但是窗户开着一样，所以有时也是一个隐患的问题</p>
<p>那么此种模式何时适用了？<br>多线程时、数据可被多个线程访问的时候、状态可能变化的时候、需要确保安全性的时候</p>
<h4 id="生命线与死锁"><a href="#生命线与死锁" class="headerlink" title="生命线与死锁"></a>生命线与死锁</h4><p>使用该模式，可能会发生死锁的危险<br>而死锁是指：两个线程分别获取了锁定，互相等待另一个线程解除锁定的线程。发生死锁时，哪个线程都无法继续执行下去，所以程序会失去生命线<br>最经典的死锁问题就是汤勺与叉子模型，问题大概是这样的<br>假设A与B同吃一碗面，盘子旁有一支汤勺与一支叉子，而吃面必须同时需要汤勺和叉子<br>而现在叉子被其中一人假设是A拿走，而汤勺被B拿走，就会造成如下现象：<br>A和B一直等待对方放下叉子（或者汤勺），即一直处于等待，僵持阶段，从而程序无法继续运行，故称为死锁现象</p>
<p>而只要上述模式达到下面的条件，就会出现死锁<br>1.具有多个SharedResource参与者<br>2.线程锁定一个SharedResource时，还没接触前就去锁定另一个SharedResource<br>3.获取SharedResource参与者的顺序不固定</p>
<p>当然只要破坏上述三个条件之一就可以避免死锁的发生</p>
<p>下面就开始模拟死锁<br>首先是表示餐具的类(这里只有叉子和汤勺)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class Tool &#123;</div><div class="line"></div><div class="line">	private final String name;</div><div class="line">	public Tool(String  name)&#123;</div><div class="line">		this.name=name;</div><div class="line">	&#125;</div><div class="line">	public String toString()&#123;</div><div class="line">		return "["+name+"]";</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>开始用餐的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class EaterThread extends Thread &#123;</div><div class="line">    </div><div class="line">    //用餐者名字</div><div class="line">	private String name;</div><div class="line">	//左手拿餐具</div><div class="line">	private final Tool lefthand;</div><div class="line">	//右手拿餐具</div><div class="line">	private final Tool righthand;</div><div class="line">	public EaterThread(String name, Tool lefthand, Tool righthand) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.lefthand = lefthand;</div><div class="line">		this.righthand = righthand;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">	  //不断吃</div><div class="line">		while(true)&#123;</div><div class="line">			eat();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void eat()&#123;</div><div class="line">		 //锁定左手获取餐具</div><div class="line">		synchronized (lefthand) &#123;</div><div class="line">		 //左手拿餐具</div><div class="line">			System.out.println(name+"takes up"+lefthand+"left.");</div><div class="line">		 //锁定右手拿餐具</div><div class="line">			synchronized (righthand) &#123;</div><div class="line">		 //右手拿餐具</div><div class="line">				System.out.println(name+" takes up"+righthand+"right.");</div><div class="line">		 //开吃</div><div class="line">				System.out.println(name+" is eating");</div><div class="line">		 //右手放下餐具</div><div class="line">				System.out.println(name+" puts down"+righthand+"right.");</div><div class="line">			&#125;</div><div class="line">		 //解除右手锁定锁，并且左手放下餐具</div><div class="line">			System.out.println(name+"puts down"+lefthand+"left.");</div><div class="line">		&#125;</div><div class="line">		//解除左手餐具的锁定</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   System.out.println("test begin:");</div><div class="line">Tool spoon=new Tool("Spoon");</div><div class="line">Tool fork=new Tool("Fork");</div><div class="line">new EaterThread("A", spoon, fork).start();</div><div class="line">new EaterThread("B", fork, spoon).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>test begin:<br>Atakes up[Spoon]left.<br>A takes up[Fork]right.<br>A is eating<br>A puts down[Fork]right.<br>Aputs down[Spoon]left.<br>Atakes up[Spoon]left.<br>A takes up[Fork]right.<br>A is eating<br>A puts down[Fork]right.<br>Aputs down[Spoon]left.<br>重复。。直到<br>Atakes up[Spoon]left.<br>Btakes up[Fork]left.<br>该处程序停止不动了，也就是a和b分别拿着汤勺和叉子，即处于死锁状态了。</p>
</blockquote>
<p>一种最简单的方法就是改变顺序，即以相同顺序拿餐具<br>即：</p>
<blockquote>
<p>Tool spoon=new Tool(“Spoon”);<br>    Tool fork=new Tool(“Fork”);<br>    new EaterThread(“A”, spoon, fork).start();<br>    new EaterThread(“B”, spoon,fork).start();</p>
</blockquote>
<p>最后程序就会一直进行下去，不过这样的话，前面的共享资源就不存在了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Single Threaded Execution是指以一个线程执行，简单来说就是在多线程中限制同时只让一个线程运行&lt;/p&gt;
&lt;h4 id=
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发系列一之初识java线程</title>
    <link href="http://www.myzwl.win/2017/04/10/thrd1/"/>
    <id>http://www.myzwl.win/2017/04/10/thrd1/</id>
    <published>2017-04-10T13:48:51.000Z</published>
    <updated>2017-04-18T15:47:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>曾在论坛中看过这样一句话，如果连多线程都不懂，别说自己学过java，可见多线程的重要性！</p>
<h4 id="何谓线程"><a href="#何谓线程" class="headerlink" title="何谓线程"></a>何谓线程</h4><p>简单来说，就像我们在执行一个程序时，他总按照顺序执行，如果从头到尾都没有分叉，也就是说总是一个流程，那么就可以看做单线程，并且程序执行的主体只有一个，所以，我们把正在执行程序的主体称为线程</p>
<p>当然，平时我们说的最多的就是多线程，顾名思义就是由一个以上的线程所构成的程序，比如文件处理，io请求处理及网络客户端发出的请求等等都可以看做多线程</p>
<h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>先看一个简单的例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest1;</div><div class="line"></div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">public class Mythread extends Thread &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;700;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mythread m=new Mythread();</div><div class="line">	  m.start();</div><div class="line">	  for(int i=0;i&lt;900;i++)&#123;</div><div class="line">	  System.out.print("lol!");</div><div class="line">	  &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>lol!lol!lol!lol!lol!lol!。。hello!hello!hello!hello!hello!。。lol!lol!lol!lol!lol!lol!</p>
</blockquote>
<p>然后在去认识上面程序，其中start方法会启动新的线程，然后再由这个新线程调用run方法，<br>当然也可以直接调用run方法</p>
<p>那么两者有什么区别了？<br>调用start方法会出现字符串交错，也就是并发，而run方法，就是等run方法执行完，在执行其它，显然不会出现交错现象<br>当然数据量小的话，出现的结果很难有说服力，所以并发模拟尽量使用大数量</p>
<h4 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h4><ol>
<li>利用thread的子类的实例，启动线程<br>正如前面模拟的程序，不过下面测试用两个线程<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new Mythread().start（）;</div><div class="line">new Mythread().start（）;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>显然两个线程操作两个对象，所以thread是线程安全的</p>
<ol>
<li>利用Runnable接口<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Mythread implements Runnable</div><div class="line">&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;700;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      Mythread m=new Mythread();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>这里主要向Runnable接口实现的实例作为参数传递给Thread，再启动线程，这里就有一个问题，因为不同线程操作一个对象，所以会造成线程不安全的问题，也就是脏数据</p>
<h4 id="线程的暂时停止"><a href="#线程的暂时停止" class="headerlink" title="线程的暂时停止"></a>线程的暂时停止</h4><p>利用Thread的sleep方法可暂时停止线程当前的操作，如<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">      public class Mythread implements Runnable</div><div class="line">&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;5;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>这里的参数是ms，所以1000就是1s了</p>
<h4 id="线程的共享互斥"><a href="#线程的共享互斥" class="headerlink" title="线程的共享互斥"></a>线程的共享互斥</h4><p>在程序里，多个线程可自由操作，就会造成一个线程还在执行，另一个线程就插进来执行，就会造成一些脏数据的产生<br>如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">       private int count=1000;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">	for(int i=0;i&lt;100;i++)&#123;</div><div class="line">		count--;</div><div class="line">		System.out.println("mythread"+(count));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     Mythread m=new Mythread();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：（取部分）</p>
<blockquote>
<p>mythread999<br>mythread997<br>mythread996<br>mythread995<br>mythread994</p>
</blockquote>
<p>显然出现了脏数据<br>要想使数据正确，一种方法是加同步锁，即一个线程在执行该操作时，其余线程无锁，则必须等待，直到该线程执行结束或者被挂起，才释放锁，然后在门外等待的线程依次执行，加锁，重复上述步骤<br>显然，就不会出现多个线程操作同一个对象了</p>
<p>java中通过声明synchronized关键字实现同步锁<br>如：</p>
<blockquote>
<p>public synchronized void run()</p>
</blockquote>
<p>则在执行run方法前加同步锁，控制线程，当然该关键字可以声明在任何方法前，包括静态方法<br>另外，它还有另外一种声明方式</p>
<blockquote>
<p>public  void run() {<br>        synchronized (xx.class) {<br>        }</p>
</blockquote>
<p>注意这里xx.class是操作该方法的那个类实现同步比如这里可以将</p>
<blockquote>
<p>synchronized (this) {}</p>
</blockquote>
<p>就是对本身这个类加锁控制了等同于上述的另一种写法</p>
<h4 id="线程的协调"><a href="#线程的协调" class="headerlink" title="线程的协调"></a>线程的协调</h4><p>如果有一个线程正在执行同步锁，而其他线程则要等待，这是典型的线程互斥现象<br>假如当该空间有空余时则写入数据，无空闲时间则等待（等待）<br>当该空间有空闲时，则通知等待的线程（通知）</p>
<p>这里是根据空间是否空闲为条件进行线程处理，java中通过wait（让线程等待），notify与notifyAll（启动等候中的线程）</p>
<p>我们可以把线程处于等待的地方形象的看做wait set（线程的休息室）</p>
<h4 id="wait-把线程放入休息室"><a href="#wait-把线程放入休息室" class="headerlink" title="wait-把线程放入休息室"></a>wait-把线程放入休息室</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">	private static int count=90;</div><div class="line">	</div><div class="line">public synchronized int s() throws InterruptedException&#123;</div><div class="line">	count--;</div><div class="line">	System.out.println("ok:"+count);</div><div class="line">	this.wait();</div><div class="line">	System.out.println("lockover");</div><div class="line">	return count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">	public  void run() &#123;	</div><div class="line">				try &#123;</div><div class="line">					s();</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>然后在测试中启动几个线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     Count m=new Count();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>ok:89<br>ok:88<br>ok:87</p>
</blockquote>
<p>一般为obj.wait（），而obj是某个对象的实例，也就是说该线程在obj的休息区<br>之后会自动释放锁，等待的线程开始执行</p>
<p>当然也有obj.wait（1000）；也可以设置在休息区等待的秒数，然后继续执行</p>
<p>测试结果：</p>
<blockquote>
<p>ok:89<br>ok:88<br>ok:87<br>lockover<br>lockover<br>lockover</p>
</blockquote>
<h4 id="notify方法-从休息区拿出线程"><a href="#notify方法-从休息区拿出线程" class="headerlink" title="notify方法-从休息区拿出线程"></a>notify方法-从休息区拿出线程</h4><p>一般为obj.notify（），即从obj的wait set里的线程中挑选一个，唤醒一个线程并退出该休息区<br>当然，这里有一个顺序，召唤该线程的那个线程执行完，释放锁后，那个在休息区的线程在执行</p>
<p>obj.notifyAll（），即从线程区中拿出所有线程</p>
<p>最后需要说一下的是wait、notify、notifyAll是Object的类方法，也就是所有类都能使用</p>
<p>由此可看出多线程的确是一个复杂而且很重要的东西！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;曾在论坛中看过这样一句话，如果连多线程都不懂，别说自己学过java，可见多线程的重要性！&lt;/p&gt;
&lt;h4 id=&quot;何谓线程&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>集合中的线程安全问题</title>
    <link href="http://www.myzwl.win/2017/04/07/thread2/"/>
    <id>http://www.myzwl.win/2017/04/07/thread2/</id>
    <published>2017-04-07T13:48:51.000Z</published>
    <updated>2017-04-08T15:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早在刚开始学习java se的时候，就遇到过这样问题，xxx是线程安全的，xxxx是线程不安全的，当时也是一脸蒙，只记住了结论。后来接触了单例才有一点了解</p>
<p>线程安全的：<br>vector、hashtable、stringbuffer等</p>
<p>非线程安全的：<br>arraylist、linkedlist、hashmap、StringBuilder等等</p>
<p>首先来模拟一个案例</p>
<p>测试集合类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static void test()  &#123;</div><div class="line">// 用来测试的List  </div><div class="line">   List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();  </div><div class="line">   </div><div class="line">   // 线程数量(1000)  </div><div class="line">   int threadCount = 1000;  </div><div class="line">   </div><div class="line">// 用来让主线程等待threadCount个子线程执行完毕  </div><div class="line">   CountDownLatch countDownLatch = new CountDownLatch(threadCount);  </div><div class="line">   </div><div class="line">    // 启动threadCount个子线程  </div><div class="line">   for(int i = 0; i &lt; threadCount; i++)  </div><div class="line">   &#123;  </div><div class="line">       Thread thread = new Thread(new Mythread(list,countDownLatch));  </div><div class="line">       thread.start();  </div><div class="line">   &#125;  </div><div class="line">   try  </div><div class="line">   &#123;  </div><div class="line">       // 主线程等待所有子线程执行完成，再向下执行  </div><div class="line">       countDownLatch.await();  </div><div class="line">   &#125;  </div><div class="line">   catch (InterruptedException e)  </div><div class="line">   &#123;  </div><div class="line">       e.printStackTrace();  </div><div class="line">   &#125;  </div><div class="line">   // List的size  </div><div class="line">   System.out.println(list.size());  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>自定义线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line">import java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line">public class Mythread implements Runnable &#123;</div><div class="line">	private List&lt;Object&gt; list;  </div><div class="line">	</div><div class="line">	private CountDownLatch countDownLatch; </div><div class="line">	public Mythread(List&lt;Object&gt; list,CountDownLatch countDownLatch)&#123;</div><div class="line">		  this.list = list; </div><div class="line">		  this.countDownLatch = countDownLatch;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		// 每个线程向List中添加100个元素  </div><div class="line">        for(int i = 0; i &lt; 100; i++)  </div><div class="line">        &#123;  </div><div class="line">            list.add(new Object());  </div><div class="line">        &#125;  </div><div class="line">     // 完成一个子线程  </div><div class="line">        countDownLatch.countDown();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">	 </div><div class="line">	 // 进行10次测试  </div><div class="line">        for(int i = 0; i &lt; 10; i++)  </div><div class="line">        &#123;  </div><div class="line">            test();  </div><div class="line">        &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>99873<br>99968<br>99955<br>100000<br>100000<br>100000<br>100000<br>Exception in thread “Thread-7516” java.lang.ArrayIndexOutOfBoundsException: 76327<br>    at java.util.ArrayList.add(ArrayList.java:441)<br>    at com.zwl.test.Mythread.run(Mythread.java:20)<br>    at java.lang.Thread.run(Thread.java:744)</p>
</blockquote>
<p>有时不会出现异常，但是list的长度不是最终期望的那样，显然是线程不安全的，<br>这里是arraylist，同样将其换成linkedlist，也可以改变list，变成其它，得到同样线程不安全结果</p>
<p>测试结果：</p>
<blockquote>
<p>100000<br>99783<br>100000<br>99945<br>99897<br>99996<br>99879<br>99971<br>100000<br>99899</p>
</blockquote>
<p>将其换成线程安全的，如</p>
<blockquote>
<p>List<object> list = new Vector<object>(); </object></object></p>
</blockquote>
<p>测试结果：</p>
<blockquote>
<p>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000</p>
</blockquote>
<p>当然集合中的线程不安全是多线程同时操作同一个对象，如果是不同类，就不存在线程安全问题</p>
<p>对于线程安全，一般通过线程同步来实现，即通过申明synchronized关键字</p>
<p>如，改一下之前的线程安全的例子number类</p>
<p>修改后的number类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class number &#123;</div><div class="line"></div><div class="line">	private int num=0; </div><div class="line"></div><div class="line">	public  void count()&#123;</div><div class="line">	</div><div class="line">		num++;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int getnumber()&#123;</div><div class="line">		return num;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是自定义线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Mythread implements Runnable &#123;</div><div class="line">	private number num;</div><div class="line">	</div><div class="line">	private CountDownLatch countDownLatch; </div><div class="line">	public Mythread(number num,CountDownLatch countDownLatch)&#123;</div><div class="line">		  this.num = num; </div><div class="line">		  this.countDownLatch = countDownLatch;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123; </div><div class="line">        for(int i = 0; i &lt; 100; i++)  </div><div class="line">        &#123;  </div><div class="line"> </div><div class="line">        	num.count();</div><div class="line">        	</div><div class="line">        &#125;  </div><div class="line">     // 完成一个子线程  </div><div class="line">        countDownLatch.countDown();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> public static void test()  &#123;</div><div class="line"></div><div class="line">   </div><div class="line">   number num=new number();</div><div class="line">   // 线程数量(1000)  </div><div class="line">   int threadCount = 1000;  </div><div class="line">   </div><div class="line">// 用来让主线程等待threadCount个子线程执行完毕  </div><div class="line">   CountDownLatch countDownLatch = new CountDownLatch(threadCount);  </div><div class="line">   </div><div class="line">   for(int i = 0; i &lt; threadCount; i++)  </div><div class="line">   &#123;  </div><div class="line">       Thread thread = new Thread(new Mythread(num,countDownLatch));  </div><div class="line">       thread.start();  </div><div class="line">   &#125;  </div><div class="line">   try  </div><div class="line">   &#123;  </div><div class="line">       // 主线程等待所有子线程执行完成，再向下执行  </div><div class="line">       countDownLatch.await();  </div><div class="line">   &#125;  </div><div class="line">   catch (InterruptedException e)  </div><div class="line">   &#123;  </div><div class="line">       e.printStackTrace();  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line">   System.out.println(num.getnumber());  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		 </div><div class="line">		 // 进行10次测试  </div><div class="line">	        for(int i = 0; i &lt; 10; i++)  </div><div class="line">	        &#123;  </div><div class="line">	            test();  </div><div class="line">	        &#125;  </div><div class="line">	 &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>100000<br>100000<br>100000<br>100000<br>99940<br>99300<br>100000<br>100000<br>100000<br>100000</p>
</blockquote>
<p>出现了线程不安全<br>可以通过对方法声明同步</p>
<blockquote>
<p>public synchronized void count(){}</p>
</blockquote>
<p>最后输出的书都是同一个数</p>
<p>最后不得不说，线程安全是一个很复杂的问题，有时候不注意就会出现数据上的各种问题！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;早在刚开始学习java se的时候，就遇到过这样问题，xxx是线程安全的，xxxx是线程不安全的，当时也是一脸蒙，只记住了结论。后来接触了单
    
    </summary>
    
      <category term="学习进阶" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="java集合" scheme="http://www.myzwl.win/source/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>初识线程安全与线程不安全</title>
    <link href="http://www.myzwl.win/2017/04/06/thread1/"/>
    <id>http://www.myzwl.win/2017/04/06/thread1/</id>
    <published>2017-04-06T13:48:51.000Z</published>
    <updated>2017-04-08T15:58:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于线程问题基本上贯穿学习的整个过程，像集合，servlet，structs，hibernate，spring等等，其都涉及到线程问题</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>什么是线程安全？<br>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>线程安全问题都是由全局变量及静态变量引起的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全</p>
<p>不妨来一个实例<br>首先是number类，里面有一个计数的全局和静态变量<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class number &#123;</div><div class="line"></div><div class="line">	private int num;</div><div class="line">	private static int count;</div><div class="line">	</div><div class="line">	public void count()&#123;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			num+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+num);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void countstatic()&#123;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			count+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+count);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然我们希望每个线程都能输出的结果是55就是线程安全</p>
<p>线面是测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class test &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	</div><div class="line">		Runnable runner=new Runnable() &#123;</div><div class="line">			number num=new number();</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				num.count();</div><div class="line">				System.out.println("statis:");</div><div class="line">				num.countstatic();</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			new Thread(runner).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里启动十个线程，依次通过run方法输出全局和静态变量的累加和，如果是线程安全的，则应该都是55</p>
<p>结果如下所示</p>
<blockquote>
<p>Thread-0:55<br>statis:<br>Thread-0:55<br>Thread-1:110<br>statis:<br>Thread-1:110<br>Thread-2:165<br>statis:<br>Thread-2:165<br>Thread-6:275<br>statis:<br>Thread-6:220<br>Thread-3:385<br>statis:<br>Thread-4:220<br>statis:<br>Thread-3:275<br>Thread-8:385<br>statis:<br>Thread-8:385<br>Thread-4:330<br>Thread-5:440<br>statis:<br>Thread-5:440<br>Thread-7:495<br>statis:<br>Thread-7:495<br>Thread-9:550<br>statis:<br>Thread-9:550</p>
</blockquote>
<p>发现不是线程安全的</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
<p>对于上面的线程不安全可以进行如下修改</p>
<p>解决方法：将全局变量变成局部变量（静态变量暂时不讨论）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void count()&#123;</div><div class="line">		int num = 0;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			num+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+num);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>最后所有的线程都输出了55</p>
<p>或者将new 的number放到run里面，变成局部的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">			public void run() &#123;</div><div class="line">				number num=new number();</div><div class="line">				num.count();</div><div class="line">				System.out.println("statis:");</div><div class="line">				num.countstatic();</div><div class="line">			&#125;</div><div class="line">		&#125;;</div></pre></td></tr></table></figure></p>
<p>最后也能保证了线程安全了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于线程问题基本上贯穿学习的整个过程，像集合，servlet，structs，hibernate，spring等等，其都涉及到线程问题&lt;/p
    
    </summary>
    
      <category term="学习进阶" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="java集合" scheme="http://www.myzwl.win/source/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>初识Linkedlist底层</title>
    <link href="http://www.myzwl.win/2017/04/05/linkedlist/"/>
    <id>http://www.myzwl.win/2017/04/05/linkedlist/</id>
    <published>2017-04-05T13:48:51.000Z</published>
    <updated>2017-04-08T12:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LinkedList底层是基于双端链表实现的，也就是说它具有指向其前驱与后继的引用，而且，在插入与删除数据时效率极高</p>
<p>至于它继承谁和实现什么接口，直接看源码</p>
<blockquote>
<p>public class LinkedList<e> extends AbstractSequentialList<e><br> implements List<e>, Deque<e>, Cloneable, java.io.Serializable</e></e></e></e></p>
</blockquote>
<p> 和ArrayList一样，从源码分析其add、get以及remove方法</p>
<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p> 首先通过MyEclipse进入LinkedList的源码</p>
<p> 找到add（）方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line"> //把e放在链表的最后一个位置</div><div class="line">       linkLast(e);</div><div class="line">       return true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到linkLast（）方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line">    * Pointer to last node.</div><div class="line">    * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line">    *            (last.next == null &amp;&amp; last.item != null)</div><div class="line">    */</div><div class="line">   transient Node&lt;E&gt; last; //链表最后一个结点的引用</div><div class="line"></div><div class="line">   transient Node&lt;E&gt; first; //链表第一个结点的引用</div><div class="line"></div><div class="line"></div><div class="line">void linkLast(E e) &#123;</div><div class="line">       //将l也指向最后一个结点</div><div class="line">       final Node&lt;E&gt; l = last;</div><div class="line"></div><div class="line">       //调用Node（Node&lt;E&gt; prev，E element，Node&lt;e&gt; next）构造方法</div><div class="line">       //其中prev为前驱结点，element为对象元素，next为后继结点</div><div class="line">       //这里构造新节点，并且是作为尾节点</div><div class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line"></div><div class="line">       //last结点指向newNode</div><div class="line">       last = newNode;</div><div class="line"></div><div class="line">       //如果l为空，则表示链表为空，直接把newNode作为首节点，否则放在l结点之后</div><div class="line">       if (l == null)</div><div class="line">           first = newNode;</div><div class="line">       else</div><div class="line">           l.next = newNode;</div><div class="line"></div><div class="line">        //链表的元素个数加一</div><div class="line">       size++;</div><div class="line"></div><div class="line">       //链表发生结构性修改的次数，这里主要指添加及删除操作</div><div class="line">       modCount++;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>以上便是add方法的源码，主要通过改变链表的前驱及后继引用来完成插入，可想而知，使用链表，使插入数据的速度异常快，相对顺序查找</p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>找到get方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line"></div><div class="line">     //检查index是否合法</div><div class="line">       checkElementIndex(index);</div><div class="line"></div><div class="line">     //如果合法就返回该节点位置的值</div><div class="line">       return node(index).item;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到checkElementIndex(int index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void checkElementIndex(int index) &#123;</div><div class="line">    //检查index是否合法</div><div class="line">       if (!isElementIndex(index))</div><div class="line">           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到isElementIndex(index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//判断index是否存在于链表中</div><div class="line">private boolean isElementIndex(int index) &#123;</div><div class="line">       return index &gt;= 0 &amp;&amp; index &lt; size;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到node(int index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Node&lt;E&gt; node(int index) &#123;</div><div class="line">    //index已在链表中</div><div class="line">    // assert isElementIndex(index);</div><div class="line">    //从第一个位置开始寻找，知道找到index的位置，最后返回该节点的位置</div><div class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        for (int i = 0; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        return x;</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    //从最后一个位置开始往前寻找该节点</div><div class="line">    else &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        for (int i = size - 1; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>linkedlist在查找时的效率非常低，就是因为它是从头或从尾部遍历链表，所以当数据量大时，造成效率低下</p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><p>找到remove方法</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public E remove(int index) &#123;</div><div class="line">      //检查index是否合法</div><div class="line">        checkElementIndex(index);</div><div class="line"></div><div class="line"></div><div class="line">        return unlink(node(index));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>找到unlink(node(index))方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> E unlink(Node&lt;E&gt; x) &#123;</div><div class="line">        // assert x != null;</div><div class="line">        //保存x节点的值</div><div class="line">        final E element = x.item;</div><div class="line">        //保存x节点的后继</div><div class="line">        final Node&lt;E&gt; next = x.next;</div><div class="line">        //保存x节点的前驱</div><div class="line">        final Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">       //如果前驱为空，则表明要移除的是第一个结点，在把first指向下一个节点</div><div class="line">        if (prev == null) &#123;</div><div class="line">            first = next;</div><div class="line">        &#125; else &#123;</div><div class="line">        	//否则把x前驱的后继指向x的后继，并把x前驱设置为null</div><div class="line">            prev.next = next;</div><div class="line">            x.prev = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"> //如果后继为空，则表明要移除的是最后一个结点，在把last引用指向x的前驱</div><div class="line">        if (next == null) &#123;</div><div class="line">            last = prev;</div><div class="line">        &#125; else &#123;</div><div class="line">            next.prev = prev;</div><div class="line">            x.next = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">//把x结点的值设置为null，保证x没有任何引用了</div><div class="line">        x.item = null;</div><div class="line"></div><div class="line"> //链表的size减一</div><div class="line">        size--;</div><div class="line"></div><div class="line">   //链表的结构性修改次数加一</div><div class="line">        modCount++;</div><div class="line"></div><div class="line">   //这里该节点移除之前以保存在element中，然后返回该节点</div><div class="line">        return element;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>至此，简单把上面三个方法的源码简单过了一遍<br>当然，还有一点不得不提的是LinkedList可以当做stack（栈），queue（队列）处理，因为它是双端链表，另外，在遍历时，有index &lt; (size &gt;&gt; 1)，即判断index与size/2比较，这样可以缩小范围，选择是从前遍历还是从后遍历，从而大大增加查找效率</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LinkedList底层是基于双端链表实现的，也就是说它具有指向其前驱与后继的引用，而且，在插入与删除数据时效率极高&lt;/p&gt;
&lt;p&gt;至于它继
    
    </summary>
    
      <category term="学习进阶" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="java集合" scheme="http://www.myzwl.win/source/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>hibernate之四:反向工程</title>
    <link href="http://www.myzwl.win/2017/04/04/hbm4/"/>
    <id>http://www.myzwl.win/2017/04/04/hbm4/</id>
    <published>2017-04-04T07:48:51.000Z</published>
    <updated>2017-04-08T04:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在运用持久层框架时，先前我们都是先通过建立对象—映射文件—数据库的方法，倘若数据库中的表非常多和复杂时，我们可以改变下开发顺序，即从数据库自动生成映射文件和对象，这样涉及表之间的关系，级联或者主外键约束就自动生成，更方便。一般我们用hibernate的反向工程达到此目的。</p>
<p>不多说，先模拟一个案例。<br>首先建立三张表user，picture，addr表，分别如下<br>User表<br><img src="/images/imgs3/1.gif" alt="Alt text"></p>
<p>Picture表<br><img src="/images/imgs3/2.gif" alt="Alt text"></p>
<p>外键<br><img src="/images/imgs3/3.gif" alt="Alt text"></p>
<p>这里的uid是外键对应user表的主键，并且只有当user的id删除时，对应uid相应的记录删除</p>
<p>Addr表<br><img src="/images/imgs3/4.gif" alt="Alt text"></p>
<p>外键<br><img src="/images/imgs3/5.gif" alt="Alt text"></p>
<p>通过myeclipse 提供 数据库浏览器连接到我们的mysql数据库<br><img src="/images/imgs3/6.gif" alt="Alt text"></p>
<p>然后点击右键，选择new，出现如下界面<br><img src="/images/imgs3/7.gif" alt="Alt text"></p>
<p>首先选择数据库，然后填写相关配置信息，其中Driver name随便取，添加jar包，然后点击test Driver，如股票成功，则表示与数据库连接成功，此外，可以选择保存密码，不然，后续操作一次，就要输入密码<br>直接点击finish，</p>
<p>接下来在MyEclipse中创建一个web工程，通过工具自身引入hibernate，具体步骤如下<br><img src="/images/imgs3/8.gif" alt="Alt text"></p>
<p><img src="/images/imgs3/9.gif" alt="Alt text"></p>
<p>选择之前配置好的sshe</p>
<p><img src="/images/imgs3/10.gif" alt="Alt text"></p>
<p>直接点结束，这样hibernate就引入了。</p>
<p>下面我们使用myeclipse提供的逆向工程，自动的创建对象类和对象关系映射文件<br>选中要反向的表<br><img src="/images/imgs3/11.gif" alt="Alt text"></p>
<p>注意我们可以事先在项目中新建一个包，用来存放映射对象和文件<br><img src="/images/imgs3/12.gif" alt="Alt text"></p>
<p>最后点击finish，则自动生成了。<br><img src="/images/imgs3/13.gif" alt="Alt text"></p>
<p>最后值得注意的是，这里只是模拟了三张表，有一对多和多对一关系，主外键及级联，这样就省得我们自己去配置了，因为hibernate的关系配置真的很麻烦！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在运用持久层框架时，先前我们都是先通过建立对象—映射文件—数据库的方法，倘若数据库中的表非常多和复杂时，我们可以改变下开发顺序，即从数据库自
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>hibernate之三:浅谈HQL和映射文件</title>
    <link href="http://www.myzwl.win/2017/04/03/hbm3/"/>
    <id>http://www.myzwl.win/2017/04/03/hbm3/</id>
    <published>2017-04-03T07:48:51.000Z</published>
    <updated>2017-04-08T04:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们想要精确的查找某一个数据库中的信息时，最理想的方法就是通过sql语句查询，一般hibernate中可以通过query接口来写语句进行查询，这个语句可以使sql，hql，当然推荐的是hql，事实上我认为hql和sql基本差不多</p>
<p>一：Query接口<br>    Query接口类型的对象可以对数据库操作,它可以使用Hql和原生SQL(native Sql)对数据库操作.官方推荐使用Hql语句<br>先来看一个例子</p>
<p>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">	public void selectone()&#123;</div><div class="line">	User u=(User)session.createQuery(" from User where id=1").uniqueResult();</div><div class="line">	System.out.println(u.getName());&#125;</div></pre></td></tr></table></figure></p>
<p>分析：这里用了uniqueResult()方法 ，如果我们检索一个对象，明确知道最多只有一个对象，则建议使用该方法:</p>
<p>如果是取出集合对象，则使用如下方法：<br>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void selectone()&#123;		</div><div class="line">List&lt;User&gt; list=session.createQuery("from User").list();</div><div class="line">     for(User user : list)&#123;</div><div class="line">	System.out.println(user.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此我们可以发现，使用list可以取出集合对象，同时方法里面写想要的hql语句</p>
<p>二：HQL简单语法<br>  HQL是面向对象的查询语言，与SQL不同，HQL中的对象名是区分大小写的；HQL中查的是对象而不是表，并且支持多态；HQL主要通过Query来操作，Query的创建方式：</p>
<blockquote>
<p>Query q = session.createQuery(hql);</p>
</blockquote>
<p>1：between.. and..<br>  测试代码：</p>
<blockquote>
<p>List<user> list=session.createQuery(“from User where id between 0 and 2”).list();</user></p>
</blockquote>
<p>2：in /not in</p>
<blockquote>
<p>List<user> list=session.createQuery(“from User where id in (1,2)”).list();</user></p>
</blockquote>
<p>其他如group by，having，聚集函数等都类似于sql语句，换汤不换药。</p>
<p>参数绑定：<br> 先看例子：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">org.hibernate.Query query= session.createQuery("from User where id between ? and ?");</div><div class="line">	      query.setInteger(0, 1);</div><div class="line">	      query.setInteger(1,2);</div><div class="line">	      List&lt;User&gt; list=query.list();</div><div class="line">	      for(User user : list)&#123;</div><div class="line">	  		System.out.println(user.getName());</div><div class="line">	  	&#125;</div></pre></td></tr></table></figure>
<p>主要通过set与？的形式来注入参数，注意这里第一个？对应set的序号为0<br>使用绑定参数的好处:<br>1.可读性好.<br>2.性能提高.<br>3.防止sql注入</p>
<p>HQL语句远不止这些，这里只简单介绍了其中一些，</p>
<p>三：映射文件的配置<br> 映射文件的内容繁多，这里只简单介绍其中一些常见属性。大体说来，映射文件主要对class的映射，还包括属性，属性又分为主键，普通属性和集合属性，甚至还有复合属性，每种属性都需要进行不同的配置。</p>
<p> 先从入门程序中的例子说起：</p>
<blockquote>
<p> <hibernate-mapping package="com.zwl.bean"></hibernate-mapping></p>
<class name="User" table="user">

</class></blockquote>
<p>其中：package : 表示该类在哪个包下，name : 表示类名 table 表示 该类和哪个表映射<br>同时在class内部可以配置各种属性</p>
<p>主键：<br> 主键就是持久化类中标识属性，用于唯一标识该对象，主要通过<id>进行设置，有三个常用属性：name，column，type。<br>  Name  ：表示类的哪个属性是主键   必须指定<br>Column：指定在数据库中主键对应的列明  不必须指定<br>  Type：与数据库中对应字段类型一致  不必须指定<br>例外：主键需指定主键生产策略，即generator，一般用于自增长，针对不同数据库，关键词不一样，由于是mysql，所以自增长选择increment<br>以上的代码表示：</id></p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;id name=<span class="string">"id"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;generator class=<span class="string">"increment"</span>&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div></pre></td></tr></table></figure>
<p>普通属性：<br>  使用<property>标签，该标签必须指定name属性，用于标记持久化类的属性名称。一般有如下常见属性：<br> Type，column，not-null（是否允许为空），lazy（是否支持延迟加载，默认为false不支持），<br>代码如下：</property></p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"name"</span> type=<span class="string">"java.lang.String"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"name"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"age"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"age"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当我们想要精确的查找某一个数据库中的信息时，最理想的方法就是通过sql语句查询，一般hibernate中可以通过query接口来写语句进行查
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>hibernate之二:核心类和接口</title>
    <link href="http://www.myzwl.win/2017/04/02/hbm2/"/>
    <id>http://www.myzwl.win/2017/04/02/hbm2/</id>
    <published>2017-04-02T07:48:51.000Z</published>
    <updated>2017-04-08T04:04:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们对数据进行持久化操作时，必然涉及到hibernate的一些核心类，而这些类是我们在增删改查之前必然要引用和加载的<br>先看总览图：<br><img src="/images/imgs2/26.gif" alt="Alt text"></p>
<p>一般情况下，是由下向上看。</p>
<p>一 ：hibernate.cfg.xml文件<br>①该文件主要用于指定各个参数,是hibernate核心文件<br>    ②默认放在src目录下，也可以放在别的目录下。<br>    ③指定连接数据库的驱动、用户名、密码、url、连接池..<br>    ④指定对象关系映射文件的位置.<br>    ⑤也可使用hibernate.properties文件来替代该文件.(推荐使用<br>hibernate.cfg.xml)。<br>  如：入门程序代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;hibernate-configuration&gt;</div><div class="line">	&lt;session-factory&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.driver_class"</span>&gt;com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span>&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.url"</span>&gt;jdbc:mysql:<span class="comment">//localhost:9806/sshe&lt;/property&gt;</span></div><div class="line">		&lt;property name=<span class="string">"connection.username"</span>&gt;root&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.password"</span>&gt;&lt;/property&gt;</div><div class="line">		&lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt;</div><div class="line">		&lt;property name=<span class="string">"show_sql"</span>&gt;true&lt;/property&gt;</div><div class="line">		&lt;!-- 配置数据库的方言/ --&gt;</div><div class="line">		&lt;property name=<span class="string">"dialect"</span>&gt;org<span class="selector-class">.hibernate</span><span class="selector-class">.dialect</span><span class="selector-class">.MySQL5InnoDBDialect</span>&lt;/property&gt;</div><div class="line">		 &lt;!-- 配置管理的对象映射文件 --&gt;</div><div class="line">		&lt;mapping resource=<span class="string">"com/zwl/bean/User.hbm.xml"</span>/&gt;</div><div class="line">	&lt;/session-factory&gt;</div><div class="line">&lt;/hibernate-configuration&gt;</div></pre></td></tr></table></figure></p>
<p>二：对象关系映射文件(*.hbm.xml)</p>
<p>  ①该文件主要作用是建立表和类的映射关系，是不可或缺的重要文件.<br>  ②一般放在其映射的类同一个目录下,但不是必须的。<br>  ③命名方式一般是 类名.hbm.xml,但不是必须的。<br>  ④示意图:<br><img src="/images/imgs2/27.gif" alt="Alt text"></p>
<p>如：入门程序代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;!-- package : 表示该类在哪个包下 --&gt;</div><div class="line">&lt;hibernate-mapping package=<span class="string">"com.zwl.bean"</span>&gt;</div><div class="line">&lt;!-- name : 表示类名 <span class="selector-tag">table</span> 表示 该类和哪个表映射 --&gt;</div><div class="line">	&lt;class name=<span class="string">"User"</span> table=<span class="string">"user"</span>&gt;</div><div class="line">		&lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt;</div><div class="line">		&lt;!-- name:表示类的哪个属性是主键 --&gt;</div><div class="line">		&lt;id name=<span class="string">"id"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;!-- 指定主键生成策略 --&gt;</div><div class="line">		&lt;generator class=<span class="string">"increment"</span>&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div><div class="line">		&lt;!-- property 里是普通属性 , column表示该属性映射到表中哪个字段 --&gt;</div><div class="line">		&lt;property name=<span class="string">"name"</span> type=<span class="string">"java.lang.String"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"name"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"age"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"age"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>三：Configuration 类<br>它的用处是:</p>
<ol>
<li>读取hibernate.cfg.xml</li>
<li>管理对象关系映射文件 <mapping resource="””"></mapping></li>
<li>加载hibernate 的驱动,url ,用户..</li>
<li>管理hibernate配置信息</li>
</ol>
<p>创建的代码：</p>
<blockquote>
<p>Configuration cf=new Configuration().configure();</p>
</blockquote>
<p>四：SessionFactory （会话工厂）<br>这是典型的工厂设计模式，其是用来生产session实例的，注意由于该工厂启动耗费内存，所以应该只被初始化一次，并且应该是线程安全的，所以应该用单例模式设计</p>
<p>归纳一下特点：<br>1 缓存sql语句和某些数据</p>
<p>2.在应用程序初始化的时候创建,是一个重量级的类(吃内存),一般<br>用单例模式保证一个应用中只需要一个 SessionFactory实例.</p>
<p>3.如果某个应用访问多个数据库，则要创建多个会话工厂实例,一般<br>是一个数据库一个会话工厂实例.</p>
<p>4.通过SessionFactory接口可以获得Session(会话)实例</p>
<p>创建的代码：</p>
<blockquote>
<p>SessionFactory sf=cf.buildSessionFactory();</p>
</blockquote>
<p>五：Session<br> 1.Session一个实例代表与数据库的一次操作<br>(当然一次操作可以是crud组合)</p>
<p> 2.Session实例通过SessionFactory获取，用完<br>需要关闭。</p>
<p> 3.Session是线程不同步的(不安全),因此要保证<br>在同一线程中使用,可以用getCurrentSessiong()。</p>
<p> 4.Session可以看做是持久化管理器,它是与持久<br>化操作相关的接口</p>
<p>如图所示：<br><img src="/images/imgs2/28.gif" alt="Alt text"></p>
<p>另外：有两种方式获得session<br>1：通过openSession()获取session<br>openSession() 是获取一个新的session<br>2 getCurrentSession ()<br>  getCurrentSession () 获取和当前线程绑定的session,换言之，在同一个线程中，我们获取的session是同一session,这样可以利于事务控制</p>
<p>创建的代码：</p>
<blockquote>
<p>Session s=sf.getCurrentSession();<br>//或者是: Session s=sf.openSession();</p>
</blockquote>
<p>如何选择<br>原则:<br>1.如果需要在同一线程中，保证使用同一个Session则，使用getCurrentSession()<br>2.如果在一个线程中，需要使用不同的Session,则使用opentSession()<br>通过 getCurrentSession() 获取的session在事务提交后，会自动关闭，通过openSession()获取的session则必须手动关闭<br>如果是通过getCurrentSession() 获取 sesssion ,进行查询需要事务提交</p>
<p>Session(会话)接口的几个重要方法<br>Session一般以对象的形式来操作<br>    1保存一个对象(记录)—save方法<br>    2删除一个对象(记录)—delete方法<br>    3查询一个对象(记录)—get/load方法<br>    4修改一个对象(记录)—update方法</p>
<p>如：入门程序中的代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Sava方法：User u=new User();</div><div class="line">	   u.setId(1);</div><div class="line">	  u.setName("hello world");</div><div class="line">	  u.setAge(21);</div><div class="line">	 session.save(u);</div><div class="line">	 t.commit();</div><div class="line"></div><div class="line"></div><div class="line">Delete方法：User u=(User)session.get(User.class, 1);</div><div class="line">		    session.delete(u);</div><div class="line">		    t.commit();</div></pre></td></tr></table></figure>
<p>一般情况下，我们从数据库中获取对象，可以通过session.get（或者session.load（）），那么他们有什么区别了？<br>1、get()方法直接返回实体类,如果查不到数据则返回null。load()会<br>    返回一个实体代理对象（当前这个对象可以自动转化为实体对象），<br>    但当代理对象被调用时，如果没有数据不存在，就会抛出个<br>    org.hibernate.ObjectNotFoundException异常</p>
<p>这里：可以将get看做单例中的饿汉式，而load相当于懒汉式</p>
<ol>
<li><p>load先到缓存(session缓存/二级缓存)中去查，如果没有则返回一个<br>代理对象（不马上到DB中去找），等后面使用这个代理对象操作的时<br>候，才到DB中查询,这就是我们常说的 load在默认情况下支持延迟加<br>载（lazy）</p>
</li>
<li><p>get先到缓存(session缓存/二级缓存)中去查，如果没有就到DB中去<br> 查（即马上发出sql）。总之，如果你确定DB中有这个对象就用<br> load(),不确定就用get()（这样效率高）</p>
</li>
</ol>
<p>这里有一点注意：默认lazy加载时不启用，所以如果要启用，则需要在映射文件中配置</p>
<blockquote>
 <class name="User" table="user" lazy="true">

</class></blockquote>
<p>六：Transaction(事务)接口<br>    事务简单的说,就是一组对数据库的操作集合,它们要么全部成功,要<br>么全部失败.这个可以保证数据的一致性,事务具有原子性。</p>
<p>创建的代码：</p>
<blockquote>
<p>Transaction ts=s.beginTransaction();<br> …<br>ts.commit();s.close()； </p>
</blockquote>
<p>注意：如果数据库的数据发生变化，一定需要数据提交</p>
<p>七：Criteria接口<br>如入门程序的查询：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;User&gt; list=session.createCriteria(User.class).list();</div><div class="line">		for(User user : list)&#123;</div><div class="line">			System.out.println(user.getName());</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>即通过面向对象的操作，返回该对象所有的集合</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当我们对数据进行持久化操作时，必然涉及到hibernate的一些核心类，而这些类是我们在增删改查之前必然要引用和加载的&lt;br&gt;先看总览图：&lt;
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>hibernate之一:hello world</title>
    <link href="http://www.myzwl.win/2017/04/01/hbm1/"/>
    <id>http://www.myzwl.win/2017/04/01/hbm1/</id>
    <published>2017-04-01T07:48:51.000Z</published>
    <updated>2017-04-08T04:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对一个框架的直观认识，往往是从一个hello world程序开始的。Hibernate是一个完全的ORM（Object Relationship Mapping）对象映射框架。实现了JDBC轻量级的封装，使得在进行JDBC开发的时候可以直接使用面向对象的思维进行开发，说白了hibernate框架的作业就是在java对象和关系数据库中作了一个映射，使得程序员不用再使用各种SQL语句</p>
<p>Hibernate有如下几个特点：<br>  1：完成了对JDBC的封装，不用再与各种connection打交道<br> 2：是一个持久层框架，即对数据库进行持久化操作<br> 3：是一个ORM框架，不用再与各种sql打交道</p>
<p>接下里就是hibernate入门程序，目的先有一个直观认识，不考虑其含义，只要把流程走一遍就完成了目的。这里用最简的方式完成入门程序</p>
<p>步骤一：创建一个java 工程</p>
<p>步骤二：建一个lib文件夹，并导入如下jar包，然后添加至项目中<br><img src="/images/imgs2/25.gif" alt="Alt text"></p>
<p>步骤三：在src目录下创建一个hibernate.cfg.xml配置文件，并编写，同时添加mysql驱动包<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</div><div class="line">	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</div><div class="line">	"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;</div><div class="line">&lt;!-- 该文件用于配置连接数据的种类,用户名，密码,ul ,驱动.. 连接池,二级缓存 --&gt;</div><div class="line">&lt;hibernate-configuration&gt;</div><div class="line">	&lt;session-factory&gt;</div><div class="line">		&lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;</div><div class="line">		&lt;property name="connection.url"&gt;jdbc:mysql://localhost:9806/sshe&lt;/property&gt;</div><div class="line">		&lt;property name="connection.username"&gt;root&lt;/property&gt;</div><div class="line">		&lt;property name="connection.password"&gt;yourpassword&lt;/property&gt;</div><div class="line">		&lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt;</div><div class="line">		&lt;property name="show_sql"&gt;true&lt;/property&gt;</div><div class="line">		&lt;!-- 配置数据库的方言/ --&gt;</div><div class="line">		&lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;</div><div class="line">	&lt;/session-factory&gt;</div><div class="line">&lt;/hibernate-configuration&gt;</div></pre></td></tr></table></figure></p>
<p>简单说明一下：上面的配置文件指明了一些必要的数据库连接属性，通过这些属性，hibernate可以连接上数据库，可以配置不同的数据库，其中配置数据库的方言指明所配置的是用哪种数据库</p>
<p>步骤四：创建bean对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.zwl.bean;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line"></div><div class="line">	private int age;</div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">。。。此处省略set与get方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里注意：利用hibernate框架时，鼓励我们为每张表设置主键，即为每个对象设置一个id，在映射时与表的id对应</p>
<p>步骤五：创建数据库表，这个步骤也可以在步骤四之前进行。<br>主要为id（主键，自增长），name、age</p>
<p>步骤六：编写表与对象的映射文件User.hbm.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!--该文件要清楚地表述出 类 和 表 的对应关系--&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</div><div class="line">	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">	"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line">&lt;!-- package : 表示该类在哪个包下 --&gt;</div><div class="line">&lt;hibernate-mapping package="com.zwl.bean"&gt;</div><div class="line">&lt;!-- name : 表示类名 table 表示 该类和哪个表映射 --&gt;</div><div class="line">	&lt;class name="User" table="user"&gt;</div><div class="line">		&lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt;</div><div class="line">		&lt;!-- name:表示类的哪个属性是主键 --&gt;</div><div class="line">		&lt;id name="id" type="java.lang.Integer"&gt;</div><div class="line">		&lt;!-- 指定主键生成策略 --&gt;</div><div class="line">		&lt;generator class="increment"&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div><div class="line">		&lt;!-- property 里是普通属性 , column表示该属性映射到表中哪个字段 --&gt;</div><div class="line">		&lt;property name="name" type="java.lang.String"&gt;</div><div class="line">		&lt;column name="name" not-null="false"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="age" type="java.lang.Integer"&gt;</div><div class="line">		&lt;column name="age" not-null="false"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>简单说明一下：上面已经简要说明了一些含义，这里先看做强加的概念，事实上这是比较完整的配置，当然这里并没有给出简化的配置。同时，该文件相当于在java对象和数据库表中作了一个映射，这样以后就可以通过操作java对象来间接操作表<br> 另外，该映射文件一般放在与相应的java对象同处一个文件夹下，并且命名满足规范XXX.hbm.xml，其中xxx就是java对象名，最后还要在hibernate核心配置文件中声明该映射，即加入如下代码：</p>
<blockquote>
 <mapping resource="com/zwl/bean/User.hbm.xml">

</mapping></blockquote>
<p> 步骤六：就是进行测试，实现插入数据的crud操作</p>
<p> 首先写一个工具类：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utils;</div><div class="line"></div><div class="line">import org.hibernate.SessionFactory;</div><div class="line">import org.hibernate.cfg.Configuration;</div><div class="line"></div><div class="line">public class HibernateUtils &#123;</div><div class="line">    private static final SessionFactory sessionFactory=BuildSessionFactory();</div><div class="line">    </div><div class="line">    private static SessionFactory BuildSessionFactory()&#123;</div><div class="line">    	try &#123;</div><div class="line">			return new Configuration().configure().buildSessionFactory();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			throw new ExceptionInInitializerError(e);</div><div class="line">		&#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	public static SessionFactory getSessionFactory()&#123;</div><div class="line">		return sessionFactory;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单说明一下，这里采用单例模式，目的是为了不要每次都加载配置，不然太耗费内存</p>
<p>接下来是测试类，首先是增加功能<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Usertest &#123;</div><div class="line"></div><div class="line">	SessionFactory sessionFactory=HibernateUtils.getSessionFactory();</div><div class="line">	Session session=sessionFactory.openSession();</div><div class="line">	Transaction t=session.beginTransaction();</div><div class="line"></div><div class="line">@Test</div><div class="line">public void save()&#123;</div><div class="line">	User u=new User();</div><div class="line">	u.setId(1);</div><div class="line">	u.setName("hello world");</div><div class="line">	u.setAge(21);</div><div class="line">	</div><div class="line">	session.save(u);</div><div class="line">	t.commit();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来是查询（遍历）<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//查询</div><div class="line">	@Test</div><div class="line">	public void select()&#123;</div><div class="line">		List&lt;User&gt; list=session.createCriteria(User.class).list();</div><div class="line">		for(User user : list)&#123;</div><div class="line">			System.out.println(user.getName());</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>最后是删除：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//删除</div><div class="line">	@Test</div><div class="line">	public void delete()&#123;</div><div class="line">		User u=(User)session.get(User.class, 1);</div><div class="line">		session.delete(u);</div><div class="line">		t.commit();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>修改这里就先不说了。<br>至此入门程序完成，意在了解hibernate的具体过程，有没有发现，到目前为止，我们都没有写sql语句，而都是对java对象进行操作，来操作表</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对一个框架的直观认识，往往是从一个hello world程序开始的。Hibernate是一个完全的ORM（Object Relationsh
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>struts2 之六:拦截器</title>
    <link href="http://www.myzwl.win/2017/03/31/structs6/"/>
    <id>http://www.myzwl.win/2017/03/31/structs6/</id>
    <published>2017-03-31T13:48:51.000Z</published>
    <updated>2017-04-07T10:30:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拦截器是structs2框架的核心功能，理解并使用拦截器有助于更灵活使用structs2.它像一个可插播的组件，围绕action和result进行，可以在方法调用之前、之后使用。通过structs2的工作流程，可以发现调用一个action之前之后有许多的拦截器，这些拦截器都通过后才可以执行具体的action。对与每一个拦截器来说，可以直接返回，从而终止余下的拦截器</p>
<p>以下，是structs工作原理图<br><img src="/images/imgs2/24.gif" alt="Alt text"></p>
<p>从图中可以看出，从一个具体的请求到action需要经过多个拦截器，action处理完成后，后续的拦截器会据需执行，最终到浏览器中。大概其工作流程如下</p>
<p>上述的servlet filters图示与实际有点不一样，其他一样（图不是现在版本）</p>
<p>一 首先请求发送给StrutsPrepareAndExecuteFilter（web.xml配置那个）</p>
<p>二：StrutsPrepareAndExecuteFilter判断该请求是否是一个structs2请求，如果是则进入第3步</p>
<p>三：如果是structs2请求，则把请求交给ActionProxy，是action代理类，ActionProxy创建一个Actioninvocation实例，并进行初始化</p>
<p>在执行具体的action之前，actionProxy会设计相关拦截器的调用<br>Action调用结束后，会根据structs.xml文件中action的result配置对象得到对应的返回结果。调用execute方法之后，执行后面的拦截器，把结果返回给浏览器</p>
<p>从整个请求处理过程来看，拦截器是处理的关键</p>
<p>下面将通过实现Interceptor接口来写一个简单的拦截器，<br>该接口有三个方法，init（），destroy（），intercept（），init（）在拦截器实例创建之后，intercept方法之前调用，主要用于初始化拦截器所需要的资源，destroy主要销毁初始化分配的资源，intercept方法则是在action之前调用，可以通过invocation对象获取action状态，从而根据状态的不同进行需要的拦截操作<br> 如下为一个简单的模拟案例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import com.opensymphony.xwork2.ActionInvocation;</div><div class="line">import com.opensymphony.xwork2.interceptor.Interceptor;</div><div class="line"></div><div class="line">public class lanji implements Interceptor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void destroy() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void init() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String intercept(ActionInvocation invocation) throws Exception &#123;</div><div class="line">		long start=System.currentTimeMillis();</div><div class="line">		String result=invocation.invoke();//没有拦截，正常执行</div><div class="line">		long end=System.currentTimeMillis();</div><div class="line">		System.out.println(end-start);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就需要在配置文件中配置<br>首先申明该拦截器<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;interceptors&gt;</div><div class="line">		&lt;interceptor name=<span class="string">"lanji"</span> class=<span class="string">"com.zwl.pojo.lanji"</span>&gt;&lt;/interceptor&gt;</div><div class="line">		&lt;/interceptors&gt;</div><div class="line">在action中引用</div><div class="line">&lt;action name=<span class="string">"ognlaction"</span> class=<span class="string">"com.zwl.action.ognlaction"</span>&gt;</div><div class="line">  &lt;interceptor-ref name=<span class="string">"lanji"</span>&gt;&lt;/interceptor-ref&gt;</div><div class="line">			 &lt;interceptor-ref name=<span class="string">"defaultStack"</span>&gt;&lt;/interceptor-ref&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>注意必须要带上默认拦截器</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;拦截器是structs2框架的核心功能，理解并使用拦截器有助于更灵活使用structs2.它像一个可插播的组件，围绕action和resul
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>struts2 之五:通用标签</title>
    <link href="http://www.myzwl.win/2017/03/30/structs5/"/>
    <id>http://www.myzwl.win/2017/03/30/structs5/</id>
    <published>2017-03-30T12:48:51.000Z</published>
    <updated>2017-04-07T10:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> Struts2框架为我们提供了许多标签，这些标签从总体上可以分为两类：通用标签和ui标签。而较常使用的是通用标签，通用标签又分为两类，数据标签和控制标签。数据标签用于访问值栈中的数据。控制标签用于控制呈现页面时数据执行流程。</p>
<p> 不过使用structs2标签，需要在jsp首部加入如下代码</p>
<blockquote>
<p> &lt;%@ taglib uri=”/struts-tags” prefix=”s” %&gt;</p>
</blockquote>
<p>数据标签<br> 主要用于访问actioncontext和值栈中的数据</p>
<p>一：property标签</p>
<blockquote>
<p>格式：<s:property value="””default=””" escape="”true|false”/"></s:property></p>
</blockquote>
<p>如果value中的内容为object，则Struts2都会把它解析成ognl表达式<br>     如果里面需要表示为字符串，则需要将内容用单引号括起来</p>
<p>1、  利用ognl表达式取值(例如：取值堆栈中的username值)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"username"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>2、  取值为字符串<br>需要将内容用单引号括起来<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"’username’"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>3、  设置默认值-default<br>如果一个对象值取不到，则可以使用default设置一个默认值。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"admin"</span> default=”管理员”/&gt;</div></pre></td></tr></table></figure></p>
<p>4、  设定HTML-escape<br>是否设置返回值为HTML原代码样式<br>true：解析返回值的html代码　false:原封不动返回值<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"'&lt;hr/&gt;'"</span> escape=<span class="string">"false"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>二、 set标签<br>注：var　用于设定变量名<br>     value 变量值(可以是ognl表达式)，也可以是字符串<br>         scope 就是的作用范围 request session page application action(默认)</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;li&gt;set 设定adminName值（默认为request 和 ActionContext）: &lt;s:set var=<span class="string">"adminName"</span>value=<span class="string">"username"</span> /&gt;&lt;/li&gt;</div><div class="line">      </div><div class="line">&lt;li&gt;set 从request取值: &lt;s:property value=<span class="string">"#request.adminName"</span> /&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;set 从ActionContext取值: &lt;s:property value=<span class="string">"#adminName"</span> /&gt;&lt;/li&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;li&gt;set 设定var，范围为ActionContext: &lt;s:set var=<span class="string">"adminPassword"</span> value=<span class="string">"password"</span>scope=<span class="string">"session"</span>/&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;set 使用#取值: &lt;s:property value=<span class="string">"#adminPassword"</span>/&gt; &lt;/li&gt;</div><div class="line">&lt;li&gt;set 从相应范围取值: &lt;s:property value=<span class="string">"#session.adminPassword"</span>/&gt; &lt;/li&gt;</div></pre></td></tr></table></figure>
<p>控制标签<br> 一： If  elseif  else<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">age = &lt;s:property value=<span class="string">"#parameters.age[0]"</span> /&gt; &lt;br /&gt;</div><div class="line">     &lt;s:set var=<span class="string">"age"</span> value=<span class="string">"#parameters.age[0]"</span> /&gt;</div><div class="line">     &lt;s:<span class="keyword">if</span> test=<span class="string">"#age &lt; 0"</span>&gt;wrong age!&lt;/s:<span class="keyword">if</span>&gt;</div><div class="line">     &lt;s:elseif test=<span class="string">"#parameters.age[0] &lt; 20"</span>&gt;too young!&lt;/s:elseif&gt;</div><div class="line">     &lt;s:<span class="keyword">else</span>&gt;yeah!&lt;/s:<span class="keyword">else</span>&gt;&lt;br /&gt;</div></pre></td></tr></table></figure></p>
<p>二：Iterator标签<br>一般格式如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> &lt;s:iterator value=<span class="string">"值"</span> var=<span class="string">"x"</span>&gt;</div><div class="line">&lt;s:property value=<span class="string">"#x.username"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>这个格式将集合里的内容取出<br>该属性一般有三个属性，id，status，value<br>其中value属性指定迭代的集合，status属性可以获得迭代中一个状态信息（比如索引值，是否是奇偶数等）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;s:iterator value="&#123;'aaa', 'bbb', 'ccc'&#125;" status="status"&gt;</div><div class="line">          &lt;s:property/&gt; |</div><div class="line">          遍历过的元素总数：&lt;s:property value="#status.count"/&gt; |</div><div class="line">          遍历过的元素索引：&lt;s:property value="#status.index"/&gt; |</div><div class="line">          当前是偶数？：&lt;s:property value="#status.even"/&gt; |</div><div class="line">          当前是奇数？：&lt;s:property value="#status.odd"/&gt; |</div><div class="line">          是第一个元素吗？：&lt;s:property value="#status.first"/&gt; |</div><div class="line">          是最后一个元素吗？：&lt;s:property value="#status.last"/&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt; Struts2框架为我们提供了许多标签，这些标签从总体上可以分为两类：通用标签和ui标签。而较常使用的是通用标签，通用标签又分为两类，数据
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>struts2 之四:OGNL表达式</title>
    <link href="http://www.myzwl.win/2017/03/29/structs4/"/>
    <id>http://www.myzwl.win/2017/03/29/structs4/</id>
    <published>2017-03-29T11:48:51.000Z</published>
    <updated>2017-04-07T10:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OGNL表达式的全称是 Object Graph Navigation Language，即 对象图导航语言，使用OGNL表达式可以使用简单的语法设置以及读取java对象的值</p>
<p>一般， <s:property value="””">　注意：  value里的内容称为ognl表达式，由于其功能强大，涉及东西太多，只做部分总结</s:property></p>
<p>下面就先模拟一个案例，首先需要几个模拟的对象类<br>首先是Dog类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private String name;</div><div class="line">   </div><div class="line">	public Dog(String name)&#123;</div><div class="line">		this.name=name;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Dog()&#123;&#125;</div><div class="line">此处省略set。。get方法</div></pre></td></tr></table></figure></p>
<p>然后是Cat类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private Dog friend;</div><div class="line">	</div><div class="line">	public String miaomiao()</div><div class="line">	&#123;</div><div class="line">		return "miaomiao";</div><div class="line">	&#125;</div><div class="line">此处省略set。。get方法</div></pre></td></tr></table></figure></p>
<p>接着是user类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private String msg;</div><div class="line"></div><div class="line">public user()&#123;&#125;</div><div class="line"></div><div class="line">public user(String msg)&#123;</div><div class="line">	this.msg=msg;</div><div class="line">&#125;</div><div class="line">此处省略set。。get方法</div></pre></td></tr></table></figure></p>
<p>在配置文件中，仍然不变</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">  &lt;global-results&gt;</div><div class="line">  &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">  &lt;/global-results&gt;</div><div class="line">  </div><div class="line">  &lt;action name=<span class="string">"ognlaction"</span> class=<span class="string">"com.zwl.action.ognlaction"</span>&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure>
<p>下面是action，思路是在action中一点一点加入模拟代码，在相应的jsp中将值回显出来<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class ognlaction extends ActionSupport&#123;</div><div class="line">  private String username;</div><div class="line">	public String execute() throws Exception &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return super.execute();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下面所以属性的set与get方法都将省略。。<br>首先是验证普通属性，对应jsp页面为</p>
<p>1：<li>访问值栈中的action的普通属性:</li></p>
<blockquote>
<p>username = <s:property value="username"> </s:property></p>
</blockquote>
<p>2：访问值栈中对象的普通属性(get set方法)：</p>
<blockquote>
<p>首先action增加 private user use;<br>对应jsp为：<s:property value="use.msg"></s:property></p>
</blockquote>
<p>3访问值栈中对象中的成员对象的普通属性(get set方法)</p>
<blockquote>
<p>首先action增加：private Cat cat;<br>对应jsp为：<s:property value="cat.friend.name"></s:property></p>
</blockquote>
<p>4访问值栈中对象的普通方法<br><s:property value="cat.miaomiao()"></s:property></p>
<p>5访问值栈中action的普通方法<br>首先action增加：public String m() {<br>             return “hello”;}<br>对应jsp为：<s:property value="m()"></s:property></p>
<p>6 OGNL表达式语言访问静态方法，需要在Struts2.xml配置文件如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;constant name=<span class="string">"struts.ognl.allowStaticMethodAccess"</span> value=<span class="string">"true"</span>&gt;&lt;/constant&gt;</div></pre></td></tr></table></figure>
<p>首先增加一个pojo类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class s &#123;</div><div class="line">	 public static String STR = "STATIC STRING";  </div><div class="line">	  public static String s() &#123;</div><div class="line">	     return "static method";  &#125;&#125;</div></pre></td></tr></table></figure>
<p>对应jsp：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;li&gt;访问静态方法：&lt;s:property value=<span class="string">"@com.zwl.pojo.s@s()"</span>/&gt;&lt;/li&gt;</div><div class="line">       &lt;li&gt;访问静态属性：&lt;s:property value=<span class="string">"@com.zwl.pojo.s@STR"</span>/&gt;&lt;/li&gt;</div><div class="line">       &lt;li&gt;访问Math类的静态方法：&lt;s:property value=<span class="string">"@@max(2,3)"</span> /&gt;&lt;/li&gt;</div></pre></td></tr></table></figure></p>
<p>注意使用@符号访问</p>
<p>7访问List中元素某个属性的集合中的特定值：<br>首先action增加<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private List&lt;user&gt; users=new ArrayList&lt;&gt;();</div><div class="line">public ognlaction()&#123;</div><div class="line">		users.add(new user("1"));</div><div class="line">		users.add(new user("2"));</div><div class="line">		users.add(new user("3"));</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>对应jsp为：<s:property value="users[0].msg"></s:property></p>
<p>8：访问Set中某个元素<br>首先action增加：</p>
<blockquote>
<p>private Set<dog> dogs = new HashSet<dog>();</dog></dog></p>
</blockquote>
<p>对应jsp为：<s:property value="dogs[1]"></s:property></p>
<p>9：访问Map中某个元素<br>首先action增加：</p>
<blockquote>
<p>private Map<string, dog=""> dogMap = new HashMap<string, dog="">();<br>  <li>访问Map中某个元素:<s:property value="dogMap['dog101']"></s:property></li><br>               <li>访问Map中所有的key:<s:property value="dogMap.keys"></s:property></li><br>       <li>访问Map中所有的value:<s:property value="dogMap.values"></s:property></li></string,></string,></p>
</blockquote>
<p>  10：调试：   <s:debug></s:debug><br>主要用来查看值栈。而值栈主要来存放对象的，类似于正常的栈，</p>
<p>以下为部分结果截图：<br><img src="/images/imgs2/23.gif" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;OGNL表达式的全称是 Object Graph Navigation Language，即 对象图导航语言，使用OGNL表达式可以使用简单
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>struts2 之三:result返回结果</title>
    <link href="http://www.myzwl.win/2017/03/28/structs3/"/>
    <id>http://www.myzwl.win/2017/03/28/structs3/</id>
    <published>2017-03-28T09:48:51.000Z</published>
    <updated>2017-04-07T10:29:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Structs2中的result是作为返回结果的，当一个action处理完之后返回字符串的结果码。框架可以根据这个返回的字符串，映射到指定的页面。Result元素可以分为两部分：一是结果映射，一部分是返回结果类型</p>
<p>结果映射<br>  Result有两个属性可以配置：name属性和type属性，其中name属性主要用来指定资源的逻辑名称，实际名称在标签内指定。Type属性就是result返回的类型，这两个属性不是必须的。其中默认情况下，name为success，type为dispatch（转发）<br>另外，result标签还有一个子标签param，该标签可以为result指定实际资源位置，其中属性name为必填，而当type为dispatch时，param可以省略不写</p>
<p>针对上面，不妨先模拟一个案例<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;result type=<span class="string">"dispatcher"</span>&gt;</div><div class="line">&lt;param name=<span class="string">"location"</span>&gt;/success.jsp&lt;/param&gt;</div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>这里的location是用于指示资源的位置，标签内的内容是参数的值</p>
<p>对应我们习惯写的形式为<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;result name=<span class="string">"success"</span>&gt;</div><div class="line">/success<span class="selector-class">.jsp</span></div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>结果类型：<br> 常用的有四种，dispatch、redirect、redirectAction和chain，其中dispatch相当于转发，redirect相当于重定向，redirectAction也是重定向，但是它是重定向到某个action，而chain则是利用action的链式处理</p>
<p>第一种：dispatch<br> 它是系统默认的结果类型，其有两个属性，localtion和parse，配置如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> &lt;result type=<span class="string">"dispatcher"</span>&gt;</div><div class="line">&lt;param name=<span class="string">"location"</span>&gt;/success.jsp&lt;/param&gt;</div><div class="line">&lt;param name=<span class="string">"parse"</span>&gt;true&lt;/param&gt;</div><div class="line">  &lt;/result&gt;</div></pre></td></tr></table></figure></p>
<p>其中parse是一个布尔类型，当为true时，表示解析localtion参数中的OGNL表达式，默认是true</p>
<p>第二种：redirect<br>  当使用该类型时，框架后台会使用response对象的sendRedirect方法进行重定向，下面先简单对比一下重定向与转发的区别：<br>一：重定向会发生两次请求，转发只会发生一次请求<br>      重定向的时候，浏览器的地址栏会发生变化，而转发的地址栏是无变化的<br>      重定向的实质是服务器告诉浏览器去另外的地方寻找资源，所以地址栏会发生变化，而转发则是在服务器内部发生的，所以地址栏不会发生变化<br>      由于重定向是两次请求，所以第二次请求的会话保存的信息是无效的，而转发的时候会话仍然有效，因为请求不变<br>      对于重定向中会话仍然有效的方法是在配置文件中使用OGNL表达式，将参数传递过去<br>对于以上内容，不妨一个实例来的具体点</p>
<p>首先是上面的dispatch<br>如之前的hello world入门程序，最终观察地址栏和参数是可以接收到的</p>
<p>当type为redirect时<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;result type=<span class="string">"redirect"</span>&gt;</div><div class="line">/success<span class="selector-class">.jsp</span></div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>观察地址栏是显示jsp的，但是参数是无法接收到的<br>那么如何解决了？<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;action name="helloworld" class="com.zwl.action.helloworld"&gt;</div><div class="line">  &lt;result name="success" type="redirect"&gt;</div><div class="line">/success.jsp?user=$&#123;use.msg&#125;</div><div class="line">  &lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>即带一个参数，注意此时的话，在success.jsp中值就不在值栈中了，因为不经过action，所以应该用如下方法取出<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;s:property value=<span class="string">"#parameters.user"</span>/&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>第三种：redirectAction，<br>其底层都是通过Response对象的sendRedirect方法进行重定向的，只不过它是重定向到某个action，所以如果一个action处理完之后还要交给另一个action据需处理，则使用该类型。<br>它的结果类型有两个参数，actionName（指定需要重定向的action）和namespace（指定action所在的命名空间，如果没有指定该参数，框架会从默认的namespace中去寻找）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">   &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">   &lt;result type=<span class="string">"redirectAction"</span>&gt;</div><div class="line">   &lt;param name=<span class="string">"actionName"</span>&gt;helloworld1&lt;/param&gt;</div><div class="line">   &lt;param name=<span class="string">"namespace"</span>&gt;/&lt;/param&gt;</div><div class="line">   &lt;/result&gt;</div><div class="line">   &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>第四种：chain<br>一样，也是跳转到某个action<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"r3"</span>&gt;</div><div class="line">        &lt;result type=<span class="string">"chain"</span>&gt;r1&lt;/result&gt;</div><div class="line">        &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>接下来，进行简单对比<br>Redirect和redirectAciton都是客户端跳转，<br>而dispatch和chain都是服务器端跳转</p>
<p>全局action：<br>当有多个action都需要返回某个页面的时候，就可以用到全局结果<br>即在同一个包下所有的action都共享该result，如下所示<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;global-results&gt;</div><div class="line">  &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">  &lt;/global-results&gt;</div><div class="line">  </div><div class="line">  &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.helloworld"</span>&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>仍然操作之前的步骤，结果仍能执行全局中的result</p>
<p>Namespace<br>Namespace决定了action的访问路径，默认为“”，可以接收所有路径的action，如果没有找到相应的namespace时，则使用namespace为空的action<br>Namespace可以写为/，或者/xxx,或者/xxx/yyy，对应的action访问路径为/index.action、/xxx/index.action、或者/xxx/yyy/index.action.<br>Namespace最好也用模块来进行命名</p>
<p><package>标签</package></p>
<p><package>是用来解决重名的问题，例如当系统的前台和后台都有一个action名叫hello，这时就需要用package来区分。    前台<package name="front">后台<package name="back"><br>struts2中的package与java的package是相同的作用的</package></package></package></p>
<p>访问Web元素<br>Action中的会话一般有三种request,session,application，但是他们都是map类型<br>一般情况下有四种方式可以获得</p>
<p>方法一：ActionContext方式<br>一般在Action类的构造方法、或execute()方法中获取<br>如下案例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class LoginAction1 extends ActionSupport&#123;</div><div class="line">  private Map request;</div><div class="line">  private Map session;</div><div class="line">  private Map application;</div><div class="line"></div><div class="line">  public LoginAction1() &#123;</div><div class="line">	  request=(Map) ActionContext.getContext().get("request");</div><div class="line">	  session=ActionContext.getContext().getSession();</div><div class="line">	  application=ActionContext.getContext().getApplication();</div><div class="line">  &#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public String execute() throws Exception &#123;</div><div class="line">	       request.put("r1", "r1");</div><div class="line">	       session.put("s1", "s1");</div><div class="line">	       application.put("a1", "a1");</div><div class="line"></div><div class="line">		return super.execute();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>然后在页面中可以通过标签或者java片段取出<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value="#request.r1"/&gt; | &lt;%=request.getAttribute("r1") %&gt; &lt;br /&gt;</div><div class="line">    &lt;s:property value="#session.s1"/&gt; | &lt;%=session.getAttribute("s1") %&gt; &lt;br /&gt;</div><div class="line">&lt;s:property value="#application.a1"/&gt; | &lt;%=application.getAttribute("a1") %&gt; &lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>方式二：Ioc(控制反转)—推荐使用<br>让Action类实现RequestAware、SessionAware、ApplicationAware接口，然后重写他们的set方法(setRequest、setSession、setApplication)，通过依赖注入、控制反转(原来自己控制，现在由别人来控制值。)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class LoginAction2 extends ActionSupport implements RequestAware,SessionAware, ApplicationAware &#123;</div><div class="line">    private Map&lt;String, Object&gt; request;</div><div class="line">    private Map&lt;String, Object&gt; session;</div><div class="line">    private Map&lt;String, Object&gt; application;</div><div class="line">  public String execute() &#123;</div><div class="line">       request.put("r1", "r1");</div><div class="line">       session.put("s1", "s1");</div><div class="line">       application.put("a1", "a1");</div><div class="line">       return SUCCESS;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void setRequest(Map&lt;String, Object&gt; request) &#123;</div><div class="line">       this.request = request;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void setSession(Map&lt;String, Object&gt; session) &#123;</div><div class="line">       this.session = session;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void setApplication(Map&lt;String, Object&gt; application) &#123;</div><div class="line">       this.application = application;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方式三：获取原类型<br>获取是的HttpServletRequest/HttpSession/ServletContext<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private HttpServletRequest request;</div><div class="line">    private HttpSession session;</div><div class="line">    private ServletContext application;</div><div class="line">    public LoginAction3() &#123;</div><div class="line">       request = ServletActionContext.getRequest();</div><div class="line">       session = request.getSession();</div><div class="line">       application = session.getServletContext();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>一般情况下只用前三种，第四种就不说了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Structs2中的result是作为返回结果的，当一个action处理完之后返回字符串的结果码。框架可以根据这个返回的字符串，映射到指定的
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>struts2 之二:action详解</title>
    <link href="http://www.myzwl.win/2017/03/27/structs2/"/>
    <id>http://www.myzwl.win/2017/03/27/structs2/</id>
    <published>2017-03-27T08:48:51.000Z</published>
    <updated>2017-04-07T10:29:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在structs2中，action是其核心功能，而使用structs2框架，主要都是围绕action进行，我们编写的action通常需要实现com.opensymphony.xwork2.Action接口，需要实现的方法时execute方法，但是在实际开发中，编写的action也可以不必实现action接口，而是直接创建一个普通的java类，并添加execute方法就可以，如入门程序的案例，还有一种方式就是继承ActionSupport类，其已经实现了action的execute方法，以上方式，后两者比较常用</p>
<p>接下来将在入门程序的基础上，来介绍action属性</p>
<p> 一：action属性<br>  Action中有一个映射框架，主要讲url映射到对应的action，action的配置主要在struts.xml文件中编写，</p>
<p>  以下是action的几个常见属性</p>
<blockquote>
<p>属性       是否必须       说明<br>Name       是           action的名字，用于匹配请求的url<br>Class        否           action实现类的完整类名<br>Method     否            调用action实现类中指定的方法</p>
</blockquote>
<p>需要注意的是，action的name属性有规范，即不允许出现.或者/或者-，另外我们来看看如果只配置一个name属性，class怎么加载？<br>理论上是框架会调用actionsupport类中的execute方法，该方法的实现仅仅是返回一个success，但是实际上去掉之后，入门程序中跳转正确，但是数据取不到，至少说明的确跳转正确，</p>
<p>下面对method属性进行说明<br>由之前我们知道通常action的作用是完成一个功能点，但是如果同时又crud方法，显然创建四个action就太麻烦了，这时候就可以使用method属性，至于怎么用，先看一个实例。<br>即对用户进行增删该查</p>
<p>首先是useraction.java</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import com.opensymphony.xwork2.ActionSupport;</div><div class="line"></div><div class="line">public class useraction extends ActionSupport&#123;</div><div class="line"></div><div class="line">	//查询</div><div class="line">	public String selectall()&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//更新</div><div class="line">	public String update()</div><div class="line">	&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//删除</div><div class="line">	public String delete()</div><div class="line">	&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//添加</div><div class="line">	public String add()&#123;</div><div class="line">		return SUCCESS;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里注意一下，在action中并不一定非要需要写execute方法，也可以自己指定需要的方法，但是必须要在Struts.xml中做相应的配置，如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">       &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"selectall"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">        &lt;action name=<span class="string">"helloworld1"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"update"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">        &lt;action name=<span class="string">"helloworld2"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"delete"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">        &lt;action name=<span class="string">"helloworld3"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"add"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">&lt;/package&gt;</div></pre></td></tr></table></figure></p>
<p>然后在前台页面写需要调用的action<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> &lt;<span class="selector-tag">form</span> action=<span class="string">"helloworld.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>显然我们发现用此种方法思路清晰，但是太啰嗦，这就是有时需要动态调用action，简称DMI，<br>先看一个例子，<br>首先是useraction1.java<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class useraction1 extends ActionSupport&#123;</div><div class="line"></div><div class="line">	private String msg;</div><div class="line">	</div><div class="line">	public String getMsg() &#123;</div><div class="line">		return msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setMsg(String msg) &#123;</div><div class="line">		this.msg = msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">		//查询</div><div class="line">		public String selectall()&#123;</div><div class="line">			return "selectall";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//更新</div><div class="line">		public String update()</div><div class="line">		&#123;</div><div class="line">			return "update";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//删除</div><div class="line">		public String delete()</div><div class="line">		&#123;</div><div class="line">			return "delete";</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//添加</div><div class="line">		public String add()&#123;</div><div class="line">			return "add";</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们可以通过自定义方法返回不同的值，然后通过result中name属性配置相应不同的值，来返回到不同的界面<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里是是否启用DMI方法，默认是关闭的</span></div><div class="line">&lt;constant name=<span class="string">"struts.enable.DynamicMethodInvocation"</span> value=<span class="string">"true"</span> /&gt; </div><div class="line"><span class="comment">//这里是否启用开发者模式，这样就不用每次重启服务器</span></div><div class="line">    &lt;constant name=<span class="string">"struts.devMode"</span> value=<span class="string">"true"</span> /&gt;</div><div class="line">    </div><div class="line">    &lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">     &lt;action name=<span class="string">"useraction1"</span> class=<span class="string">"com.zwl.action.useraction1"</span>&gt;</div><div class="line">     &lt;result name=<span class="string">"selectall"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;result name=<span class="string">"update"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;result name=<span class="string">"delete"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;result name=<span class="string">"add"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">     &lt;/action&gt;</div><div class="line">&lt;/package&gt;</div></pre></td></tr></table></figure></p>
<p>好了，配置文件也配置好了，接下来就是在页面中调用DMI方法，一般的格式是actionname!xxx.action<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"useraction1!delete.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>至此动态调用action已完成，接下来将是默认的action配置<br>默认的action<br>先看配置实例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;package name=<span class="string">"default"</span> namespace=<span class="string">"/"</span> extends=<span class="string">"struts-default"</span>&gt;</div><div class="line">    &lt;default-action-ref name=<span class="string">"helloworld"</span>&gt;&lt;/default-action-ref&gt;</div><div class="line"></div><div class="line">   &lt;action name=<span class="string">"helloworld"</span> class=<span class="string">"com.zwl.action.useraction"</span> method=<span class="string">"selectall"</span>&gt;</div><div class="line">       &lt;result name=<span class="string">"success"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>在表单中跳转到一个不存在的action时，则执行设置的默认action，这里需要注意的是每个namespace下，只能有一个默认的action，否则不知道执行那个默认的action</p>
<p>通配符映射<br> 使用通配符，可以将配置量降到最低，不过一定要实现约定好命名规范，即约定优于配置原则<br>在action配置中，<em>表示所有，可以匹配任意的字符，而{数字}表示第几个通配符，如
</em>_<em>，{1}表示第一个</em>，{2}表示第二个*<br>接下来模拟一个案例，如下所示<br>首先是action<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class useractionsave extends ActionSupport&#123;</div><div class="line">   </div><div class="line">	private String msg;</div><div class="line"></div><div class="line">	public String getMsg() &#123;</div><div class="line">		return msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setMsg(String msg) &#123;</div><div class="line">		this.msg = msg;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String save()&#123;</div><div class="line">		return "save";</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;action name=<span class="string">"useraction*"</span> class=<span class="string">"com.zwl.action.useraction&#123;1&#125;"</span> method=<span class="string">"&#123;1&#125;"</span>&gt;</div><div class="line">  &lt;result name=<span class="string">"save"</span>&gt;/success.jsp&lt;/result&gt;</div><div class="line">  &lt;/action&gt;</div><div class="line"></div><div class="line">&lt;<span class="selector-tag">form</span> action=<span class="string">"useractionsave.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>最后测试通过</p>
<p>最后介绍一下action的属性接受参数<br>事实上action中有三种方法</p>
<p>方法一：在Action添加成员属性接受参数<br>之前的案例都是采用这种方法的，就不多介绍了，不过值得注意的是，参数提交的名称必须和action的属性一致，并且要有set与get方法</p>
<p>方法二： 域模型(Domain Model)<br>就是先创建一个对象，通过在action中操作其属性来传递参数，相应的先建立一个user对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class user &#123;</div><div class="line">private String msg;</div><div class="line"></div><div class="line">public String getMsg() &#123;</div><div class="line">	return msg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setMsg(String msg) &#123;</div><div class="line">	this.msg = msg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">然后是action</div><div class="line">	private user use;</div><div class="line">	</div><div class="line">	public user getUse() &#123;</div><div class="line">		return use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setUse(user use) &#123;</div><div class="line">		this.use = use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String save()&#123;</div><div class="line">		return "save";</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要注意的是前台参数传递，是action中引用对象的那个属性，其它都一样<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;<span class="selector-tag">form</span> action=<span class="string">"useractionsave.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"use.msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>方法三： ModelDriven接收参数<br>使Action实现com.opensymphony.xwork2.ModelDriven<user>(在实现接口时需要使用泛型，否则使用时需要转型)中利用其getModel()方法返回对象模型，从而获得传入的参数。</user></p>
<p>参数被传入至Action后，会被ModelDriven对象根据参数名自动赋值给User对象相应的属性而生成User对象，并且由getModel()返回。那么我们在Action中就可以利用这个对象了。<br>注意：传入的参数名需要与对象模型中的成员属性一致。</p>
<p>这里在将上述案例中的action修改一下。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class useractionsave extends ActionSupport implements ModelDriven&lt;user&gt;&#123;</div><div class="line">public String save()&#123;</div><div class="line">		return "save";</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private user use=new user();</div><div class="line">	</div><div class="line">public user getUse() &#123;</div><div class="line">		return use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setUse(user use) &#123;</div><div class="line">		this.use = use;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public user getModel() &#123;</div><div class="line">	// TODO Auto-generated method stub</div><div class="line">	return use;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在structs2中，action是其核心功能，而使用structs2框架，主要都是围绕action进行，我们编写的action通常需要实现
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>struts2 之一:hello world</title>
    <link href="http://www.myzwl.win/2017/03/26/structs1/"/>
    <id>http://www.myzwl.win/2017/03/26/structs1/</id>
    <published>2017-03-26T07:48:51.000Z</published>
    <updated>2017-04-07T10:28:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Struts2框架是Apache基金组织下的一个开源框架，是基于MVC模式设计的web应用开发框架。它利用并扩展了java servlet API，鼓励开发者采用MVC架构。</p>
<p>当然本次不介绍strucs2的相关知识，只做一个快速入门案例，及环境搭建和将整个程序走一遍，最后完成hello world程序，也就是先有一个具体印象。</p>
<p>下载并解压struts2开发包，同时建立一个web工程</p>
<p>步骤一：<br> 为了方便，建议直接将开发包中的app下的web-inf下的lib里的文件夹里的jar包全部导入到项目的lib文件夹里</p>
<p>步骤二：编写web.xml文件。<br>一般情况下，我们将开发包中的web.xml复制下来，修改，并且放到web-inf目录下，保留下面内容<br><img src="/images/imgs2/21.gif" alt="Alt text"></p>
<p>步骤三：编写action类，也就是接受前台传过来的数据并进行相应处理和转发<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.zwl.action;</div><div class="line"></div><div class="line">public class helloworld &#123;</div><div class="line"></div><div class="line">	private String msg;</div><div class="line"></div><div class="line">	public String getMsg() &#123;</div><div class="line">		return msg;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setMsg(String msg) &#123;</div><div class="line">		this.msg = msg;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String execute()&#123;</div><div class="line">		return "success";</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>值得注意的是这里的msg要与前台表单里的name值一致，并且要有set和get方法，这样struct2就自动将前台表单输入的值赋给msg了，然后public String execute()，默认的转发方法，也就是说它返回的值要与result中的name属性设置的值一致，这样就可以跳转到相应界面了，当然这里要结合接下来的步骤才可以</p>
<p>步骤四：配置structs.xml文件，<br>直接将文档中该文件拷到src目录下，修改为如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line">&lt;!DOCTYPE struts PUBLIC</div><div class="line">	"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</div><div class="line">	"http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</div><div class="line"></div><div class="line">&lt;struts&gt;</div><div class="line"></div><div class="line">    &lt;package name="default" namespace="/" extends="struts-default"&gt;</div><div class="line">       &lt;action name="helloworld" class="com.zwl.action.helloworld"&gt;</div><div class="line">       &lt;result name="success"&gt;success.jsp&lt;/result&gt;</div><div class="line">       &lt;/action&gt;</div><div class="line">    &lt;/package&gt;</div><div class="line">&lt;/struts&gt;</div></pre></td></tr></table></figure></p>
<p>解释一下：package下name 和namespace就是为了区分重名，这里暂且不管，就按这种默认形式，action中name也就是我们表单提交的路径，class中是要加载的相应的action类，这里是helloworld，而result则是上述方法中返回的字符，里面为要跳转到success.jsp界面，因为这里是个入门程序，目的就是先具体体验。</p>
<p>步骤五：编写相应界面<br>首先是：index.jsp<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;<span class="selector-tag">form</span> action=<span class="string">"helloworld.action"</span>&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"text"</span> name=<span class="string">"msg"</span>/&gt;</div><div class="line">  &lt;<span class="selector-tag">input</span> type=<span class="string">"submit"</span>/&gt;</div><div class="line">  &lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>这里结合一下步骤三，只要输入一个文本，后台通过反射机制，自动获得（只要满足标准）该值，并保存在栈中</p>
<p>然后是success.jsp<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib uri="/struts-tags" prefix="s" %&gt;//因为用到structs标签，所以这是声明使用</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;s:property value="msg"/&gt;//取得后台传过来的输入的值</div><div class="line">  &lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>测试：在浏览器中输入到index.jsp。填表单，最后跳转到success.jsp中并取出值</p>
<p>至此，hello world入门程序算是完成了<br>至此，再把上述开发步骤总结一下：</p>
<p>1：准备jar包<br>2：在web.xml中配置structs2的相关过滤器配置<br>3：  开发action，针对不同的功能开发不同的action<br>4：在structs.xml中添加上一步骤开发的action相应的配置（页面跳转等等）<br>5：编写相应的页面</p>
<p>最后我们将整个过程抽象成一个结构图<br><img src="/images/imgs2/22.gif" alt="Alt text"></p>
<p>上述的控制器就是web.xml配置的那个，仔细对比一下整个程序，基本上mvc框架的总体过程就是这样了，当然，这里只是一个入门程序，所以所有的配置都是最简的，只有一个目的，那就是hello world！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Struts2框架是Apache基金组织下的一个开源框架，是基于MVC模式设计的web应用开发框架。它利用并扩展了java servlet 
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>基于struts2与easy ui的后台显示界面</title>
    <link href="http://www.myzwl.win/2017/03/25/easyui1/"/>
    <id>http://www.myzwl.win/2017/03/25/easyui1/</id>
    <published>2017-03-25T07:48:51.000Z</published>
    <updated>2017-04-07T10:28:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一直忙着做项目，已经好几天没写博客了。我认为提高自己的最好路径就是先把我知道的东西总结出来，再去从已知探索未知的东西，最后在总结下来。不多说，就用笔者最喜欢的struts2和easy ui来一个需求</p>
<p>利用easy ui的datagrid做一个后台界面（目前只是分页显示数据），并从数据库取出，大概如下界面<br><img src="/images/imgs2/19.gif" alt="Alt text"></p>
<p>在此之前，先简单介绍一下easy ui的特点（和大部分ui基本一样）<br>1.基于jquery 用户界面插件的集合；<br>2.为一些当前用于交互的js 应用提供必要的功能；<br>3.使用EasyUI 你不需要写很多的javascript 代码，通常只需要写HTML 标记来定义用<br>户界面即可；<br>4.支持HTML5；<br>5.开发产品时可节省时间和资源；<br>6.简单，但很强大；<br>7.支持扩展，可根据自己的需求扩展控件；<br>8.源代码加密</p>
<p>总之，在后台界面上easy ui是一个很好的选择</p>
<p>1.新建一个web工程</p>
<p>2.添加ssh整合jar包、gson.jar、mysql驱动包、easy ui的官方文档（ui文件夹）<br>里面有五个文件必须引入（并且有顺序，否则无法引用）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//引入EasyUI 核心UI 文件CSS</span></div><div class="line">  &lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"ui/themes/default/easyui.css"</span> &gt;</div><div class="line">   <span class="comment">//引入EasyUI 图标文件</span></div><div class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"ui/themes/icon.css"</span> &gt;</div><div class="line"><span class="comment">//引入jQuery 核心库</span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"ui/jquery-1.8.0.min.js"</span> &gt;&lt;/script&gt;</div><div class="line">   <span class="comment">//引入jQuery EasyUI 核心库</span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"ui/jquery.easyui.min.js"</span> &gt;&lt;/script&gt;</div><div class="line">   <span class="comment">//引入EasyUI 中文提示信息</span></div><div class="line">   &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"ui/locale/easyui-lang-zh_CN.js"</span> &gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>3.新建一个页面（先贴出代码）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"> &lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;</div><div class="line">&lt;%</div><div class="line">String path = request.getContextPath();</div><div class="line">String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";</div><div class="line">%&gt;</div><div class="line"></div><div class="line">&lt;!DOCTYPE HTML&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;base href="&lt;%=basePath%&gt;"&gt;</div><div class="line">    </div><div class="line">    &lt;title&gt;index&lt;/title&gt;</div><div class="line">    //加载easy ui</div><div class="line">&lt;link rel="stylesheet" type="text/css" href="ui/themes/default/easyui.css" &gt;</div><div class="line">	&lt;link rel="stylesheet" type="text/css" href="ui/themes/icon.css" &gt;</div><div class="line">	&lt;script type="text/javascript" src="ui/jquery-1.8.0.min.js" &gt;&lt;/script&gt;</div><div class="line">	&lt;script type="text/javascript" src="ui/jquery.easyui.min.js" &gt;&lt;/script&gt;</div><div class="line">    &lt;script type="text/javascript" src="ui/locale/easyui-lang-zh_CN.js" &gt;</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line"></div><div class="line">//页面初始化之前执行函数</div><div class="line">	$(function() &#123;</div><div class="line">		</div><div class="line">	 //调用easy ui的datagrid组件，显示json数据，也可以通过html方式加载，这里使用js加载方式</div><div class="line">		$('#admin_yhgl_datagrid').datagrid(&#123;</div><div class="line">			   </div><div class="line">			    //远程加载的json格式数据</div><div class="line">				  url: '$&#123;pageContext.request.contextPath&#125;/booksort!showdatagrid.action',</div><div class="line">				//组件宽度</div><div class="line">                  width : 1200,</div><div class="line">				// 是否可伸缩 	</div><div class="line">			    fitColumns : true,</div><div class="line">		//js对象数组，从后台获得total（总记录）和ids（对象数据集合）然后显示出来	</div><div class="line">columns : [[</div><div class="line">&#123;</div><div class="line">	//字段，与后台字段数据对应</div><div class="line">field : 'id',</div><div class="line"> //标题</div><div class="line">title : '排名',</div><div class="line">//是否排序</div><div class="line">sortable:true,</div><div class="line">//宽度</div><div class="line">width:80,</div><div class="line">//是否居中</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">field : 'barcode',</div><div class="line">title : '图书条形码',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">field : 'bookname',</div><div class="line">title : '图书名称',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'bookshelf',</div><div class="line">title : '书架',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'bookpublish',</div><div class="line">title : '出版社',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">field : 'bookauthor',</div><div class="line">title : '图书作者',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'bookprice',</div><div class="line">title : '定价',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&#123;</div><div class="line">field : 'borrowtime',</div><div class="line">title : '借阅次数',</div><div class="line">width:80,</div><div class="line">align:'center',</div><div class="line">&#125;,</div><div class="line">]],</div><div class="line"></div><div class="line">//是否有分页插件</div><div class="line">pagination : true,</div><div class="line">//每页显示记录数</div><div class="line">pageSize : 5,</div><div class="line">//设置记录数多少的选项设置</div><div class="line">pageList : [5, 10, 15, 20],</div><div class="line">//排序的字段</div><div class="line">sortName : 'id',</div><div class="line">			</div><div class="line">		&#125;);</div><div class="line">		</div><div class="line">		</div><div class="line">		&#125;);</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">//显示datagrid组件</div><div class="line">&lt;table id="admin_yhgl_datagrid"&gt;</div><div class="line">&lt;/table&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>目前还没有写后台，所以暂无数据加载显示</p>
<p>4 建表（为了方便直接截个图）<br><img src="/images/imgs2/20.gif" alt="Alt text"><br>然后随便加几个数据</p>
<p>5.编写pojo与映射文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class Book &#123;</div><div class="line">private String barcode;</div><div class="line">private String bookauthor;</div><div class="line">private String bookname;</div><div class="line">private String bookprice;</div><div class="line">private String bookpublish;</div><div class="line">private String bookshelf;</div><div class="line">private String booktype;</div><div class="line">private int borrowtime;</div><div class="line">private int id;</div><div class="line"></div><div class="line">省略set与get方法&#125;</div><div class="line"></div><div class="line">//映射文件</div><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line">&lt;!-- </div><div class="line">    Mapping file autogenerated by MyEclipse Persistence Tools</div><div class="line">--&gt;</div><div class="line">&lt;hibernate-mapping package="com.pojo"&gt;</div><div class="line">    &lt;class name="Book" table="book" &gt;</div><div class="line">        &lt;id name="id" &gt;</div><div class="line">            &lt;generator class="increment"&gt;&lt;/generator&gt;</div><div class="line">        &lt;/id&gt;</div><div class="line">        &lt;property name="bookname"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookauthor"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">      &lt;property name="barcode"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookprice"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookpublish"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="bookshelf"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="booktype"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">        &lt;property name="borrowtime"&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure>
<p>6.dao层service层接口<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public interface Basedao&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	</div><div class="line">	public List&lt;T&gt; find(String hql, int page, int rows);                             //分页时返回T对象集合</div><div class="line">	</div><div class="line">	</div><div class="line">	public Long count(String hql);                                                   //返回总记录数</div><div class="line">	</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface Basedaoservice &lt;T&gt;&#123;</div><div class="line"></div><div class="line">//Book的包装类，主要增加easy ui所需要的一些属性</div><div class="line">	public DataGrid datagrid(Tbook book);</div><div class="line">	</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>7.编写工具类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class DataGrid &#123;</div><div class="line"></div><div class="line">	private Long total = 0l;                   //总记录</div><div class="line">	private List rows = new ArrayList();       //datagrid需要的json数据加载数据</div><div class="line">	省略set与get方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Tbook &#123;</div><div class="line">       private String barcode;</div><div class="line">	private String bookauthor;</div><div class="line">	private String bookname;</div><div class="line">	private String bookprice;</div><div class="line">	private String bookpublish;</div><div class="line">	private String bookshelf;</div><div class="line">	private String booktype;</div><div class="line">	private int borrowtime;</div><div class="line">	private int id;</div><div class="line">	private String ids;          //前台被选中行的字符转</div><div class="line">	private String order;        //排序</div><div class="line">	private int page;            //多少页</div><div class="line">	private int rows;</div><div class="line">	private String sort;         //排序名</div><div class="line">。。。。。</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Character &#123;</div><div class="line"></div><div class="line">	public static HttpServletResponse Tojson() throws Exception&#123;</div><div class="line">		HttpServletResponse response=ServletActionContext.getResponse();</div><div class="line">		HttpServletRequest request=ServletActionContext.getRequest();</div><div class="line">		request.setCharacterEncoding("utf-8");</div><div class="line">		response.setCharacterEncoding("UTF-8");</div><div class="line">		response.setContentType("application/json; charset=utf-8");          //返回json数据</div><div class="line">	        response.setHeader("Cache-Control", "no-cache");                 //不要缓存</div><div class="line">	        response.setHeader("Pragma", "no-cache");  </div><div class="line">		PrintWriter out = response.getWriter();</div><div class="line">		return response;</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>8.实现类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class Basedaoimpl&lt;T&gt; extends HibernateDaoSupport  implements Basedao&lt;T&gt; &#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	public List&lt;T&gt; find(String hql, int page, int rows) &#123;</div><div class="line">	</div><div class="line">		Query q=this.getSession().createQuery(hql);</div><div class="line">		</div><div class="line">		return q.setFirstResult((page-1)*rows).setMaxResults(rows).list();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Long count(String hql) &#123;</div><div class="line">		Query q=this.getSession().createQuery(hql);</div><div class="line">		return (Long) q.uniqueResult();</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class Basedaoserviceimpl&lt;T&gt; implements Basedaoservice&lt;T&gt; &#123;</div><div class="line"></div><div class="line">	private Basedao&lt;T&gt; basedao;</div><div class="line">	</div><div class="line">	public Basedao&lt;T&gt; getBasedao() &#123;</div><div class="line">		return basedao;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setBasedao(Basedao&lt;T&gt; basedao) &#123;</div><div class="line">		this.basedao = basedao;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public DataGrid datagrid(Tbook book) &#123;</div><div class="line">	</div><div class="line">		DataGrid dg=new DataGrid();</div><div class="line">		//查询所有的book数据</div><div class="line">		 String hql="from Book b";</div><div class="line">      </div><div class="line">        //排序sql</div><div class="line">		 if(book.getSort()!=null)&#123;</div><div class="line">				hql += " order by " + book.getSort() + " " + book.getOrder();</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		//取出所有的book记录，放在集合汇总</div><div class="line">		 List&lt;Book&gt; l=(List&lt;Book&gt;) basedao.find(hql, book.getPage(), book.getRows());</div><div class="line">		 //查出所有记录数</div><div class="line">		 String totalHql = "select count(*) " + hql;</div><div class="line">	    </div><div class="line">	    //将book对象集合一次加进Tbook包装类集合</div><div class="line">		 List&lt;Tbook&gt; nl=new ArrayList&lt;Tbook&gt;();</div><div class="line">			if (l != null &amp;&amp; l.size() &gt; 0) &#123;</div><div class="line">				for(Book t:l)&#123;</div><div class="line">					Tbook u=new Tbook();</div><div class="line">					BeanUtils.copyProperties(t, u);</div><div class="line">					nl.add(u);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">				dg.setTotal(basedao.count(totalHql));</div><div class="line">				dg.setRows(nl);</div><div class="line">				return dg;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>9 action主题代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class booksort implements ModelDriven&lt;Tbook&gt; &#123;</div><div class="line"></div><div class="line">    //利用modaldriven包装Tbook</div><div class="line">	private Tbook book=new Tbook();</div><div class="line">	</div><div class="line">	private Basedaoservice&lt;Book&gt; basedaoservice;</div><div class="line">	</div><div class="line">	</div><div class="line">	public void showdatagrid() throws Exception&#123;</div><div class="line">		HttpServletResponse response=Character.Tojson();</div><div class="line">		Gson gson=new Gson();          //创建gson对象</div><div class="line">		response.getWriter().write(gson.toJson(basedaoservice.datagrid(book))); //将对象转为json数据</div><div class="line">	&#125;</div><div class="line">	</div><div class="line"></div><div class="line">	</div><div class="line">	public Basedaoservice&lt;Book&gt; getBasedaoservice() &#123;</div><div class="line">		return basedaoservice;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	public void setBasedaoservice(Basedaoservice&lt;Book&gt; basedaoservice) &#123;</div><div class="line">		this.basedaoservice = basedaoservice;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Tbook getModel() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return book;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>10 spring配置和structs配置（参考之前的博客）这里就不配置了，基本都是套路</p>
<p>至此就能加载数据了，当然easy ui在后台界面中的使用不仅方便而且强大，这也是笔者最喜欢使用easy ui的原因</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近一直忙着做项目，已经好几天没写博客了。我认为提高自己的最好路径就是先把我知道的东西总结出来，再去从已知探索未知的东西，最后在总结下来。不
    
    </summary>
    
      <category term="项目经验" scheme="http://www.myzwl.win/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
