<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2018-03-18T15:29:10.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM总结</title>
    <link href="http://www.myzwl.win/2018/03/14/dream_1/"/>
    <id>http://www.myzwl.win/2018/03/14/dream_1/</id>
    <published>2018-03-14T07:48:51.000Z</published>
    <updated>2018-03-18T15:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="jvm有哪些分区"><a href="#jvm有哪些分区" class="headerlink" title="jvm有哪些分区"></a><a href="https://www.myzwl.win/2017/10/23/jvm_1/">jvm有哪些分区</a></h4><p>类加载子系统、方法区、java堆、java虚拟机栈、本地方法栈、程序计数器、执行引擎</p>
<h4 id="对象如何创建"><a href="#对象如何创建" class="headerlink" title="对象如何创建"></a>对象如何创建</h4><p>常量池中类符号引用<br>指针碰撞<br>把Java堆中的内存一分为二，一边是所有用过的内存（这部分内存不能被分配了），一边是空闲的内存，是可以被分配的，这样的话，在可用于不可用的内存之间会有一个分割点指示器，那么为对象分配内存实际上就是从这个分界点指示器往空闲内存的一边拨动一段空间就可以了</p>
<p>空闲列表<br>已使用的内存与空闲内存可能是交叉在一起的，那么使用指针碰撞的方式分配内存就会产生问题，但是虚拟机维护着一张列表，这张列表记录了哪些区域的内存是可用的，那么在分配内存的时候就从选择可以容纳对象要求大小的内存区域分配给这个对象</p>
<p>对象头设置一些必要信息，从虚拟机的角度看，一个对象已经构造完成，但是从开发人员的角度看，还需要进行new对象之后初始化，接着执行init方法，到这里一个对象才算真正创建完毕</p>
<h4 id="jvm的内存布局"><a href="#jvm的内存布局" class="headerlink" title="jvm的内存布局"></a>jvm的内存布局</h4><p>对象头、实例数据和对齐填充<br>对象头又包括两部分信息，第一部分用于存储对象自身的运行时数据，比如哈希码、GC分代年龄，第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</p>
<p>实例数据部分是对象真真好存储的有效信息，也是程序代码中所定义的各种类型的字段内容</p>
<p>第三部分不是必然存在的，只是起到占位符的作用，因为HotspotVM规定对象的起始地址必须是8字节的整数倍。所以很有可能以上两部分的大小不够8字节的整数倍，那么这个字段就可以发挥作用了。</p>
<h4 id="java如何进行对象访问"><a href="#java如何进行对象访问" class="headerlink" title="java如何进行对象访问"></a>java如何进行对象访问</h4><p>主要是通过Java栈中的reference数据，通过这个reference数据只是一个指向对象的引用，<br>目前主流的对象访问方式主要由句柄和直接指针两种<br>通过句柄访问的话，会在Java堆中划分出一块句柄池，句柄池中句柄存放了对象的实例数据和类型指针，而reference数据则存放了句柄的地址引用。使用直接指针访问对象，那么reference数据存放的就是对象的地址<br>使用句柄访问的最大好处是reference中存储的稳定的句柄地址，当对象的地址发生了改变可以不用去关心。而直接指针的最大好处是速度更快，在于节省了一次指针定位的时间</p>
<h4 id="OOM是啥，分析及解决"><a href="#OOM是啥，分析及解决" class="headerlink" title="OOM是啥，分析及解决"></a>OOM是啥，分析及解决</h4><p>内存泄露：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。<br>内存溢出：申请的内存超出了JVM能提供的内存大小，此时称之为溢出</p>
<p>java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，堆大小可以通过虚拟机参数-Xms,-Xmx等修改</p>
<p>java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</p>
<p>java.lang.StackOverflowError：一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小</p>
<h4 id="jvm堆内存情况"><a href="#jvm堆内存情况" class="headerlink" title="jvm堆内存情况"></a><a href="https://www.myzwl.win/2017/10/23/jvm_2/">jvm堆内存情况</a></h4><p>堆内存中主要分为年轻代和老年代,主要分为Eden（对象都会在该区域内创建）同时也会在s0或s1中随机一个进行创建，经过一次GC后在s0和s1中使用复制算法保留存活下来的对象<br>流程：年轻代:通过标记-复制-清除（15次GC，老年代）<br>老年区:通过标记-清除-整理进行垃圾回收，如果老年代内存不足就会触发FULL GC.默认是占用了68%后收集（可通过-XX:CMSInitiatingOccupancyFraction=68设置），该GC非常影响性能</p>
<h4 id="什么是可达性分析"><a href="#什么是可达性分析" class="headerlink" title="什么是可达性分析"></a>什么是可达性分析</h4><p>是通过一系列的称为“GC Roots”的对象作为起始点，从这些起始点开始向下搜索，所走过的路径称为引用链，如果一个对象到GC Roots没有任何引用链，那么这个对象是不可用的，就是说，程序中没有谁引用了这个对象，所以可以说从根节点到叶子结点是不可达的<br>虚拟机栈（栈帧中本地变量表）中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中JNI（也就是native本地方法）引用的对象</p>
<h4 id="为什么需要两次标记"><a href="#为什么需要两次标记" class="headerlink" title="为什么需要两次标记"></a>为什么需要两次标记</h4><p>原因是如果一个对象没有与GC Roots结点相连，就会被第一次标记，而如果对象覆盖了finalize方法，并且在finalize方法中与某个对象建立了引用关系，那么第二次标记会失败，那么这个对象就会被移出“即将回收”的对象列表，移出之后这个对象就“活”了下来，如果在finalize方法中这个对相关仍然没有与一个对象建立引用关系，那么这个对象就真正死亡了</p>
<h4 id="方法区中的什么对象可以被回收"><a href="#方法区中的什么对象可以被回收" class="headerlink" title="方法区中的什么对象可以被回收"></a>方法区中的什么对象可以被回收</h4><p>方法区中的永久代的垃圾回收主要为两部分： 废弃常量和无用的类<br>废弃常量是指没有任何对象引用常量池中的某个对象，那么这个对象就会被回收，而对于常量池中的垃圾回收只要进行一次标记就可以进行判断<br>无用的类需要满足以下三个条件才可以宣判一个类的“死刑”：<br>1.该类的所有实例都已经被回收，也就是Java堆中不存在该类的实例<br>2.加载该类的ClassLoader已经被回收<br>3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p>
<h4 id="jvm堆参数简单说明"><a href="#jvm堆参数简单说明" class="headerlink" title="jvm堆参数简单说明"></a>jvm堆参数简单说明</h4><p>-XX 对于系统级别的jvm配置 配置日志信息 垃圾回收器类型<br>非 -XX的 基本都是对 应用层面上的配置<br>    启用 - 禁用<br>    -XX :PrintGC 使用这个参数，虚拟机启动后，只要遇到GC就会打印日志<br>    -XX: +UserSerialGC 配置串行回收器<br>    -XX:+PrintGCDetails：可以查看详细信息，包括各个区的情况<br>    -Xms: 设置java程序启动时初始堆大小<br>    -Xmx: 设置java程序能获得的最大堆大小<br>    -Xloggc:路径 ：将打印出来的日志信息保存至指定的路径<br>    -Xmn：设置堆的内存大小<br>    -XX:SurvivorRatio=m:n调整Eden和Survivor的比例为m:n</p>
<h4 id="有哪些垃圾收集器"><a href="#有哪些垃圾收集器" class="headerlink" title="有哪些垃圾收集器"></a>有哪些垃圾收集器</h4><p>Serial收集器: 它是一种单线程垃圾收集器，这就意味着在其进行垃圾收集的时候需要暂停其他的线程</p>
<p>ParNew收集器: 为Serial收集器的多线程版本,能够与CMS收集器配合工作</p>
<p>Parallel Scavenge收集器:<br>其使用的算法是复制算法，也是并行的多线程收集器（所谓”并行”，就是指多条垃圾收集线程同时工作，但是用户仍处于等待状态)<br>更关注可控制的吞吐量，吞吐量等于运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)。</p>
<p>Serial Old收集器:<br>Parallel Old收集器<br>CMS收集器:获取最短回收停顿时间。在注重服务器的响应速度，希望停顿时间最短<br>G1收集器: G1收集器将Java堆划分为多个大小相等的Region（独立区域），新生代与老年代都是一部分Region的集合，G1的收集范围则是这一个个Region</p>
<h4 id="java类加载机制如何"><a href="#java类加载机制如何" class="headerlink" title="java类加载机制如何"></a><a href="https://www.myzwl.win/2017/07/31/reflaction_1/">java类加载机制如何</a></h4><p>1.并非一次性加载<br>2.需要的时候加载（运行期动态加载）<br>3.static语句块在加载后执行一次<br>4.dynamic语句块每次new新的对象都会执行（等同于构造方法中语句）</p>
<p>jdk中有各种各样的ClassLoad将类加载进内存<br>一：bootstrap class loader<br>它是最核心的类用于加载java中核心的类<br>二:extesion class loader<br>三:application class loader<br>也就是说它是java的核心类用于加载用户自定义的类和其他类<br>四:other class loaders<br>SecureClassLoader、URLClassLoader等等，该类是其他加载类加载其它类</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;jvm有哪些分区&quot;&gt;&lt;a href=&quot;#jvm有哪些分区&quot; class=&quot;headerlink&quot; title=&quot;jvm有哪些分区&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.myzwl.win/2017/10/23/jvm_1/&quot;&gt;jvm有哪些分区&lt;/a&gt;
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>Java并发总结</title>
    <link href="http://www.myzwl.win/2018/03/14/dream_2/"/>
    <id>http://www.myzwl.win/2018/03/14/dream_2/</id>
    <published>2018-03-14T04:48:51.000Z</published>
    <updated>2018-03-18T15:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="描述一下线程池ThreadPoolExecutor"><a href="#描述一下线程池ThreadPoolExecutor" class="headerlink" title="描述一下线程池ThreadPoolExecutor"></a>描述一下线程池ThreadPoolExecutor</h4><p>corepoolsize：核心池的大小，默认情况下，在创建了线程池之后，线程池中线程数为0，<br>当有任务来之后，就会创建一个线程去执行任务，当线程池中线程数达到corepoolsize 后，<br>就把任务放在任务缓存队列中。<br>Maximumpoolsize:线程池中最多创建多少个线程。<br>Keeplivetime：线程没有任务执行时，最多保存多久的时间会终止，默认情况下，当线程<br>池中线程数&gt;corepoolsize 时，Keeplivetime 才起作用，直到线程数不大于corepoolsize。<br>workQueue:阻塞队列，用来存放等待被执行的任务<br>threadFactory:线程工厂，用来创建线程。</p>
<p>继承关系<br>Executor 接口<br>ExecutoServicer 接口<br>AbstractExecutoServicer 抽象类<br>ThreadPoolExecutor</p>
<p>线程池的状态<br>1.当线程池创建后，初始为running 状态<br>2.调用shutdown 方法后，处shutdown 状态，此时不再接受新的任务，等待已有的任务执<br>行完毕<br>3.调用shutdownnow 方法后，进入stop 状态，不再接受新的任务，并且会尝试终止正在<br>执行的任务。<br>4.当处于shotdown 或stop 状态，并且所有工作线程已经销毁，任务缓存队列已清空，线<br>程池被设为terminated 状态</p>
<p>当有任务提交到线程池之后的一些操作：<br>1.若当前线程池中线程数&lt;corepoolsize，则每来一个任务就创建一个线程去执行。</p>
<ol>
<li>若当前线程池中线程数&gt;=corepoolsize，会尝试将任务添加到任务缓存队列中去，若添<br>加成功，则任务会等待空闲线程将其取出执行，若添加失败，则尝试创建线程去执行这个任<br>务。</li>
<li>若当前线程池中线程数&gt;= Maximumpoolsize，则采取拒绝策略（有4 种，1）abortpolicy 丢<br>弃任务，抛出RejectedExecutionException 2 ）discardpolicy 拒绝执行，不抛异常3 ）<br>discardoldestpolicy 丢弃任务缓存队列中最老的任务，并且尝试重新提交新的任务4）<br>callerrunspolicy 有反馈机制，使任务提交的速度变慢）。</li>
</ol>
<h4 id="什么是死锁，手撕代码模拟"><a href="#什么是死锁，手撕代码模拟" class="headerlink" title="什么是死锁，手撕代码模拟"></a>什么是死锁，手撕代码模拟</h4><p>如哲学家进餐问题，每个哲学家都在等右边哲学家方上筷子，处于僵持等待状态，称为死锁。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class LockTest implements Runnable&#123;</div><div class="line">	public int flag=1;</div><div class="line">	 static Object o1=new Object(),o2=new Object();</div><div class="line">	   </div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println("flag="+flag);</div><div class="line">		 if(flag==1)&#123;</div><div class="line">		 synchronized (o1) &#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(5000);</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			synchronized (o2) &#123;</div><div class="line">				System.out.println("1");</div><div class="line">			&#125;</div><div class="line">		 &#125;	 </div><div class="line">		&#125;</div><div class="line">		if(flag==0)&#123;</div><div class="line">			 synchronized (o2) &#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(5000);</div><div class="line">					&#125; catch (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					synchronized (o1) &#123;</div><div class="line">						System.out.println("0");</div><div class="line">					&#125;</div><div class="line">				 &#125;	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LockTest lt1=new LockTest();</div><div class="line">		LockTest lt2=new LockTest();</div><div class="line">		 lt1.flag=1;</div><div class="line">		 lt2.flag=0;</div><div class="line">		  Thread t1=new Thread(lt1);</div><div class="line">		  Thread t2=new Thread(lt2);</div><div class="line">		  t1.start();</div><div class="line">		  t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="手撕模拟生产者"><a href="#手撕模拟生产者" class="headerlink" title="手撕模拟生产者"></a>手撕模拟生产者</h4><p>模拟一个生产者利用生产食物放到篮子里，而一个消费者从篮子里消费食物<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">public class Food &#123; //食物类</div><div class="line"> int id;</div><div class="line"> public Food(int id)&#123;</div><div class="line">	 this.id=id;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">public class UtilStack &#123;//工具，用来放食物</div><div class="line">	int index=0; //食物计数变量</div><div class="line">	Food[] arrFD=new Food[4]; //最多工具能放食物容量</div><div class="line">	</div><div class="line">	public synchronized void push(Food fd)&#123; //生产食物，必须加锁，保证生产过程不被打断</div><div class="line">		while(index==arrFD.length)</div><div class="line">		&#123;</div><div class="line">			try &#123;</div><div class="line">				System.out.println("full");</div><div class="line">				this.wait();  //生产满了，就去休息区休息，等待被唤醒</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		this.notify();//唤醒当前在休息区的线程</div><div class="line">		arrFD[index]=fd;</div><div class="line">		index++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public synchronized Food pop()&#123; //消费</div><div class="line">		while(index==0) //消费完了，进休息区</div><div class="line">			try &#123;</div><div class="line">				System.out.println("empty");</div><div class="line">				this.wait();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		this.notify();</div><div class="line">		index--;</div><div class="line">		return arrFD[index];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Producer implements Runnable&#123;//生产者</div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Producer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=new Food(i);</div><div class="line">			ss.push(fd);</div><div class="line">			System.out.println("生产了"+fd.id);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(1000);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Consumer implements Runnable&#123;//消费者</div><div class="line">	UtilStack ss=null;</div><div class="line">	</div><div class="line">	Consumer(UtilStack ss)&#123;</div><div class="line">		this.ss=ss;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;20;i++)</div><div class="line">		&#123;</div><div class="line">			Food fd=ss.pop();</div><div class="line">			System.out.println("消费了"+fd.id);</div><div class="line">		 try &#123;</div><div class="line">			Thread.sleep(2000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="线程的状态是什么"><a href="#线程的状态是什么" class="headerlink" title="线程的状态是什么"></a>线程的状态是什么</h4><p>在任意一个时间点，一个线程只能有且只有其中的一种状态<br>1）新建：创建后尚未启动的线程处于这种状态。<br>2）运行：包括了OS 中Running 和Ready 状态，也就是处于次状态的线程可能正在运行，<br>也可能正在等待cpu 为他分配执行时间。<br>3）无限期等待:处于这种状态的线程不会被分配cpu 执行时间，要等待其他线程显示唤<br>醒。以下方法会让线程进入无限期等待：1.没有设置timeout 的object.wait()方法2.没有设<br>置timeout 参数的Thread.join()方法3.LockSupport.park();<br>4）有限期的等待：处于这种状态的线程也不会被分配cpu 执行时间，不过无需等待被<br>其他线程显示唤醒，而是在一定时间后，他们会由os 自动唤醒1.设置了timeout 的<br>object.wait() 方法2. 设置了timeout 参数的Thread.join() 3.LockSupport.parkNanos()<br>4.LockSupport.parkUnit()<br>5）阻塞：线程被阻塞了与“等待状态”的区别是：阻塞状态在等待获取一个排它锁，<br>这个事件将在另外一个线程放弃这个锁的时候发生。等待状态在等待一段时间或者唤醒动<br>作。<br>6）结束：已终止线程的线程状态，线程已经结束执行</p>
<h4 id="synchronized（S）VS-lock（L）"><a href="#synchronized（S）VS-lock（L）" class="headerlink" title="synchronized（S）VS lock（L）"></a>synchronized（S）VS lock（L）</h4><p>1）L 是接口，S 是关键字<br>2）S 在发生异常时，会自动释放线程占有的锁，不会发生死锁。L 在发生异常时，若没<br>有主动通过unlock（）释放锁，则很有可能造成死锁。所以用lock 时要在finally 中释放锁。<br>3)L 可以当等待锁的线程响应中断，而S 不行，使用S 时，等待的线程将会一直等下去，<br>不能响应中断。<br>4）通过L 可以知道是否成功获得锁，S 不可以。<br>5）L 可以提高多个线程进行读写操作的效率。</p>
<h4 id="简单并发中方法总结"><a href="#简单并发中方法总结" class="headerlink" title="简单并发中方法总结"></a>简单并发中方法总结</h4><p>继承thread或者Runnable，调用run方法，start启动<br>sleep：暂时停止线程当前的操作<br>wait-把线程放入休息室<br>notify方法-从休息区拿出线程<br>notifyAll从线程区中拿出所有线程<br>Lock lock=new ReentrantLock();读写锁<br>ReadWriteLock rwLock=new ReentrantReadWriteLock()；读-读不互斥，读-写互斥，写-写互斥，并发性提高<br>CountDownLatch: 倒数计时器<br>ReenTrantLock ：公平锁：线程先来，先得到锁，可在构造函数中设置<br>join方法。该方法主要作用是在该线程中的run方法结束后，才往下执行<br>yield方法。这个是线程本身的调度方法，使用时你可以在run方法执行完毕时，调用该方法，告知你已可以出让内存资源。<br>关键字volatile 是轻量级的同步机制。<br>Volatile 变量对于all 线程的可见性，指当一条线程修改了这个变量的值，新值对于其他<br>线程来说是可见的、立即得知的。</p>
<h4 id="什么是同步与公平锁"><a href="#什么是同步与公平锁" class="headerlink" title="什么是同步与公平锁"></a>什么是同步与公平锁</h4><p>同步：多个线程并发访问共享数据时，保证共享数据在同一个时刻，只被一个（or 一<br>些，使用信号量）线程使用，而互斥是实现同步的一种手段，临界区，互斥量，信号量都是<br>主要的互斥实现方式。互斥是因，同步是果；互斥是方法，同步是目的</p>
<p>公平锁：（先申请先得到）多个线程在等待同一个锁时，必须按照申请锁的时间顺序<br>来依次获取，而非公平锁则不保证这一点。Synchronized 不是公平锁，reetrantlock 默认下也<br>是非公平的，但是在构造函数中，可以设置为公平的。</p>
<h4 id="描述一下java自带的锁机制"><a href="#描述一下java自带的锁机制" class="headerlink" title="描述一下java自带的锁机制"></a>描述一下java自带的锁机制</h4><p>在java 设计中，每一个对象自打娘胎里出来就带了一把看不见的锁，即monitor 锁,有一张记录表记录线程锁住状况，<br>锁主要有4 中状态：无锁状态、偏向状态、轻量级状态、重量级状态。他们会随着竞争<br>的激烈而逐渐升级，锁可以升级但不可以降级<br>轻量级锁：传统的锁是重量级锁，他是用系统的互斥量来实现。轻量级锁的本意是在没<br>有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗<br>Synchronized 用的锁时存在java 对象头里。对象头包含标记字段和类型指针<br>JVM 可以通过对象的元数据信息确定对象的大小，但是无法从数组的元数据来确定数组<br>的大小</p>
<h4 id="乐观锁VS-悲观锁"><a href="#乐观锁VS-悲观锁" class="headerlink" title="乐观锁VS 悲观锁"></a>乐观锁VS 悲观锁</h4><p>悲观锁：就是很悲观，每次去拿数据的时候都认为别人会修改，<br>所以每次在拿数据的时候都会上锁。这样别人想拿这个数据就会block 直到它拿到锁。传统<br>的关系型数据库就用到了很多这种机制，比如行锁，写锁等，都是在操作之前上锁<br>2）乐观锁：就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新<br>的时候会判断一下在此期间别人有没有去更新这个数据。适用于多读</p>
<h4 id="解释一下同步阻塞，异步等"><a href="#解释一下同步阻塞，异步等" class="headerlink" title="解释一下同步阻塞，异步等"></a>解释一下同步阻塞，异步等</h4><p>同步阻塞，用户空间的应用程序执行一个系统调用，这意味着应用程序会一直阻塞，直<br>到系统调用完成为止（数据传输完成或者发生错误）<br>同步非阻塞，设备以非阻塞形式打开，这意味着io 操作不会立刻完成，需要应用程序<br>调用多次来等待完成<br>同步和异步1）同步：发出一个调用时，在没有得到结果前，该调用就不返回，一旦返<br>回就有结果。2）异步：调用在发出之后就直接返回，所以没有返回结果，换句话说，当一<br>个异步调用发生后，调用者不会立即得到结果，而是在调用发生后，被调用者通过状态通知<br>来通知调用者，或者通过回调函数来处理这个调用<br>阻塞和非阻塞1）阻塞：调用结果返回之前，当前线程会被挂起，调用线程只有在得到<br>结果之后才会返回。2）非阻塞：不能立刻得到结果之前，该调用不会阻塞当前线程</p>
<p>BIO：同步并阻塞，一个连接一个线程，适用于链接数量小且固定的架构。<br>NIO：同步非阻塞：一个请求一个线程，客户端发送的链接请求都会注册到多路复用器<br>上，多路复用器轮训到链接有io 请求时才启动一个线程进行处理，适用于链接比较多，比<br>较短<br>AIO：异步非阻塞，一个有效请求一个线程，适用于链接数目多且长。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;描述一下线程池ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#描述一下线程池ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;描述一下线程池ThreadPoolExecutor&quot;&gt;&lt;/a&gt;描述一下线程池Thre
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>设计模式总结</title>
    <link href="http://www.myzwl.win/2018/03/14/dream_3/"/>
    <id>http://www.myzwl.win/2018/03/14/dream_3/</id>
    <published>2018-03-14T02:48:51.000Z</published>
    <updated>2018-03-18T15:48:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说说ioc与aop"><a href="#说说ioc与aop" class="headerlink" title="说说ioc与aop"></a>说说ioc与aop</h4><p>IOC 控制反转容器控制程序对象之间的关系，而不是传统实现中，有程序代码之间控制，<br>又名依赖注入。All 类的创建，销毁都由Spring 来控制，也就是说控制对象生命周期的不是<br>引用他的对象，而是Spring。对于某个对象而言，以前是他控制其他对象，现在是all 对象<br>都被spring 控制，这就叫控制反转<br>依赖注入的思想时通过反射机制实现的。在实例化一个类时，它通过反射调用类中的set<br>方法将事先保存在hashmap 中的类属性注入到类中<br>Spring 实现aop：<br>将那些与业务无关，却为业务模块所公共调用的逻辑或责任封装起来，称其<br>为aspect，便于减少系统的重复代码。使用模块技术，aop 把软件系统分为两个部分：核心<br>关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注<br>点。实现aop 的两大技术：1）采用动态代理，利用截取消息的方式，对该消息进行装饰，<br>以获取原有对象行为的执行。2）采用静态织入，引入特定的语法创建切面，从而可以使编<br>译器可在编译期间织入有关切面的代码。<br>JDK 动态代理，cglib 动态代理。<br>JDK 动态代理：其代理对象必须是某个接口的实现，他是通过在运行期间创建一个接口<br>的实现类来完成对目标对象的代理。核心类有：InnovactionHandler，Proxy。<br>Cgib 动态代理：实现原理类似于jdk 动态代理，只是他在运行期间生成的代理对象是针<br>对目标类扩展的子类。MethodInterceptor</p>
<h4 id="说说代理模式"><a href="#说说代理模式" class="headerlink" title="说说代理模式"></a><a href="https://www.myzwl.win/2017/03/14/dyproxy3/">说说代理模式</a></h4><p>静态代理与继承代理<br>动态代理，javac和反射取出动态类<br>反射<br>1）proxy 类：<br>类的静态方法用来生成动态代理的实例<br>2）innovationhandler 接口有一个invoke 方法，用来<br>集中处理在动态代理类对象的方法调用，通常在该方法中实现对委托类的代理访问，每次生<br>成动态代理对象时都要指定一个对应的调用处理器<br>CGlib 动态代理：jdk 代理机制只能代理<br>实现了接口的类，而没有实现接口的类不能用jdk 动态代理。CGlib 是针对类来实现代理，<br>他的原理是对指定的目标类生成一个子类，并且覆盖其中方法实现增强，因为采用的是继承，<br>所以不能对final 修饰的类进行代理，methodinterceptor </p>
<h4 id="代理模式和装饰模式的区别？"><a href="#代理模式和装饰模式的区别？" class="headerlink" title="代理模式和装饰模式的区别？"></a>代理模式和装饰模式的区别？</h4><p>代理是<br>在内部生成一个代理对象，构造函数参数为空。装饰的构造函数参数有一个对象，就是对这<br>个对象进行装饰。</p>
<h4 id="jdk-中的设计模式："><a href="#jdk-中的设计模式：" class="headerlink" title="jdk 中的设计模式："></a>jdk 中的设计模式：</h4><p>1）单例，比如Runtime 类；<br>2）静态工厂Interger a=Integer.valueOf(intor String);<br>3) 迭代器模式Collection.interator();<br>4) 原型设计模式,clone 方法；<br>5 ）适配器 inputStreamReader 和outputStreamWriter；<br>6）桥接模式，jdbc，抽象部分与实现相分离；<br>7）装饰模式Reader 和bufferedBeader；<br>8）代理，jdk 动态代理；<br>9）观察者observable 和observer；<br>10）责任链，classloader 的双亲委派模型；<br>11 ）组合，某个类型的方法同时也接收自身类型作为参数<br>java.util.list.addall(collection);<br>12)抽象工厂，一个创建新对象的方法，返回的是接口或抽象类<br>Connection c=DriverManager.getConnection();<br>13) 工厂方法，返回一个具体对象的方法Proxy.newProxyInstance;<br>14)解释器模式，该模式通常定义了一个语言的语法,java.util.pattern</p>
<h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a><a href="https://www.myzwl.win/2017/02/23/danli/">单例设计模式</a></h4><p>饿汉式、懒汉式<br>双锁机制<br>public static Singleton getInstance()<br> {<br>     if(singleton==null)<br>     {<br>         synchronized(Singleton.class)<br>         {<br>     if(singleton==null){<br>         singleton=new Singleton();<br>     }<br>         }<br>     }<br>     return singleton;<br> }</p>
<h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><a href="https://www.myzwl.win/2017/03/08/simplefactory/">简单工厂</a></h4><p> 数据库模型</p>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><a href="https://www.myzwl.win/2017/03/09/factory/">工厂方法</a></h4><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><a href="https://www.myzwl.win/2017/03/10/abstractfactory/">抽象工厂</a></h4><h4 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a><a href="https://www.myzwl.win/2017/03/10/observer/">观察者设计模式</a></h4><p> 推模型，也就是被观察者根据状态发生改变时将所有信息都主动通知观察者<br> 拉模型，即观察者主动向被观察者索要信息<br> 观察者模式应用场景<br>1、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变<br>2、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节</p>
<h4 id="职责链设计模式"><a href="#职责链设计模式" class="headerlink" title="职责链设计模式 "></a><a href="https://www.myzwl.win/2017/03/07/filter/">职责链设计模式 </a></h4><p>模拟过滤器</p>
<h4 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a><a href="https://www.myzwl.win/2017/03/06/iterator/">迭代器设计模式</a></h4><p>模拟集合Iterator</p>
<h4 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h4><p>开闭原则：一个软件实体应当对开展开放，对修改关闭（玉帝招安美猴王）<br>面向对象解释： 不予以更改的是抽象层，但是可以扩展的是实现层<br>对可变性的封装原则： 找到一个系统的可变因素，将之封装起来<br>里氏代换原则： 任何基类可以出现的地方，子类一定可以出现<br>依赖倒转原则： 要依赖于抽象，不要依赖于实现<br>接口隔离原则： 应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说说ioc与aop&quot;&gt;&lt;a href=&quot;#说说ioc与aop&quot; class=&quot;headerlink&quot; title=&quot;说说ioc与aop&quot;&gt;&lt;/a&gt;说说ioc与aop&lt;/h4&gt;&lt;p&gt;IOC 控制反转容器控制程序对象之间的关系，而不是传统实现中，有程序代码之间控制，&lt;
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>数据库总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_4/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_4/</id>
    <published>2018-03-13T11:48:51.000Z</published>
    <updated>2018-03-18T15:39:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="mysql-使用的引擎"><a href="#mysql-使用的引擎" class="headerlink" title="mysql 使用的引擎"></a>mysql 使用的引擎</h4><p>A:1)MyIsam 不支持事务，适用于选择密集型，插入密集型，mysql 默认的引擎<br>2)innodb 使用于更新密集型，支持事务，自动灾难恢复，行级锁，外键约束<br>3）memory 出发点是速度采用的逻辑存储介质是内存<br>4）merge 一组myisam 表的组合</p>
<h4 id="mysql-索引使用的是B-的数据结构"><a href="#mysql-索引使用的是B-的数据结构" class="headerlink" title="mysql 索引使用的是B+的数据结构"></a>mysql 索引使用的是B+的数据结构</h4><p>索引：用于提高数据访问速度的数据库对象。<br>优点：1）索引可以避免全表扫描；<br>2）对于非聚集索引，有些查询甚至可以不访问数据项；<br>3）聚集索引可以避免数据插入操作集中于表的最后一个数据页；<br>4）一些情况下，索引还可以避免排序。<br>虽然索引可以提高查询速度，但是他们也会导致数据库更新数据的性能下降，因为大部<br>分数据更新时需要同时更新索引。</p>
<h4 id="连接关联"><a href="#连接关联" class="headerlink" title="连接关联"></a>连接关联</h4><p>A 的id 和b 的parent_id 关联<br>1）内连接<br>Select a.<em>,b.</em>from a inner join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>2）左外链接（左表all 元素都有）<br>Select a.<em>,b.</em>from a left join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>3 王五null<br>3）右外链接（右表all 元素都有）<br>Select a.<em>,b.</em>from a right join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>Null 3 34 2<br>4）完全链接（返回左边和右表中所有行，若某行在另外一个表中无匹配，则另一表的<br>选择列表列包含空值）<br>Select a.<em>,b.</em>from a full join b on a.id=b. parent_id;<br>结果为：1 张三1 23 1<br>2 李四2 34 2<br>Null 3 34 2<br>3 王五null<br>Not in 的例子：<br>Select emp_no from emplyees where emp_no not in (select emp_no from dept_manager)</p>
<h4 id="共享锁VS-排他锁"><a href="#共享锁VS-排他锁" class="headerlink" title="共享锁VS 排他锁"></a>共享锁VS 排他锁</h4><p>1）共享锁，<br>又称读锁，若事务T 对数据对象A 加了S 锁，则是事务T 可以读A 但不能修改A，其它事务只能再对他加S 锁，而不能加X 锁，直到T 释放A 上的S 锁。这保证了其他事务可以读A，但在事务T 释放S 锁之前，不能对A 做任何操作<br>2）排他锁，<br>又称写锁，若事务T 对数据对象加X 锁，事务T 可以读A 也可以修改A，其他事务<br>不能对A 加任何锁，直到T 释放A 上的锁。这保证了，其他事务在T 释放A 上的锁之前不<br>能再读取和修改A。</p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>Serializable(串行化)：一个事务在执行过程中完全看不到其他事务对数据库所做的更新。<br>Repeatable Read(可重复读)：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务对已有记录的更新。<br>Read Commited（读已提交数据）：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的对已有记录的更新<br>Read Uncomitted（读未提交数据）：一个事务在执行过程中可以拷打其他事务没有提交的新插入的记录，而且能看到其他事务没有提交的对已有记录的更新。</p>
<h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>回答思路：事务是干什么的&gt;事务的ACID特性&gt;事务的隔离级别<br>事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取。事务的正确执行使得数据库从一种状态转换成另一种状态<br>原子性、隔离性、持久性<br>脏读：一个事务读到另一个事务为提交的更新数据。<br>虚读：一个事务读到另一个事务已提交的新插入的数据。<br>不可重复读：一个事务读到另一个事务已提交的更新数据</p>
<h4 id="数据库设计三范式是什么"><a href="#数据库设计三范式是什么" class="headerlink" title="数据库设计三范式是什么"></a>数据库设计三范式是什么</h4><p>第一范式：字段还可以再分吗？如过不能，则是符合1NF的设计。<br>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>也就是说主键列与非主键列遵循完全函数依赖关系<br>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。<br>也就是说非主键列之间没有传递函数依赖关系<br>打个比方，比如评论表，如果你将用户ID，用户头像都放在这留言表中，就是不合适的了。用户头像是依赖于用户ID，而不依赖该评论。</p>
<h4 id="悲观锁和乐观锁的比较"><a href="#悲观锁和乐观锁的比较" class="headerlink" title="悲观锁和乐观锁的比较"></a>悲观锁和乐观锁的比较</h4><p>面试思路：什么是锁，用来干什么&gt;悲观锁乐观锁各自特点&gt;优缺点比较和各自应用场景<br>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。<br>悲观锁:<br>简单来说悲观锁认什么操作都可以改变数据，所以在改数据就锁住（在sql语句中加上for update就可以了）<br>乐观锁：<br>简单来说乐观锁很乐观 所以修改数据库后锁住 （一般在数据库中加上一个字段区别历史版本和当前版本）<br>update t_goods<br>set status=2,version=version+1<br>where id=#{id} and version=#{version};<br>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<h4 id="mysql实现分页的优化sql语句"><a href="#mysql实现分页的优化sql语句" class="headerlink" title="mysql实现分页的优化sql语句"></a>mysql实现分页的优化sql语句</h4><p>面试思路：数据库分页的简单实现&gt;数据量变大时的优化方案<br>sql语句是LIMIT m,n其中m是当前页，n是从当前页数n个记录，如果参数为一个就是数n个记录<br>一般我们都会这样写:当数据达到百万级的时候会慢死<br>    SELECT FROM table ORDER BY id LIMIT 1000000, 10;<br>    优化一：<br>    SELECT FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10;<br>    速度可以提升到0.x秒了<br>    优化二：<br>    SELECT FROM table WHERE id BETWEEN 1000000 AND 1000010;<br>    比上面提升5到10倍<br>    另外，如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询<br>    SELECT FROM table WHERE id IN(10000, 100000, 1000000…);</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;mysql-使用的引擎&quot;&gt;&lt;a href=&quot;#mysql-使用的引擎&quot; class=&quot;headerlink&quot; title=&quot;mysql 使用的引擎&quot;&gt;&lt;/a&gt;mysql 使用的引擎&lt;/h4&gt;&lt;p&gt;A:1)MyIsam 不支持事务，适用于选择密集型，插入密集型，my
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_5/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_5/</id>
    <published>2018-03-13T08:48:51.000Z</published>
    <updated>2018-03-18T15:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线性表之顺序表"><a href="#线性表之顺序表" class="headerlink" title="线性表之顺序表"></a><a href="https://www.myzwl.win/2017/07/08/sjjg_1/">线性表之顺序表</a></h4><p>数组是顺序存储的随机存取结构，占用一组连续的存储单元，通过下标识别元素，元素地址是下标的线性函数，一个下标能唯一确定一个元素<br>模拟ArrayList</p>
<h4 id="线性表之单链表"><a href="#线性表之单链表" class="headerlink" title="线性表之单链表 "></a><a href="https://www.myzwl.win/2017/07/08/sjjg_2/">线性表之单链表 </a></h4><p>线性表的链式存储是用若干地址分散的存储单元存储数据元素，逻辑上相连的数据元素在物理位置上不一定相连，必须采用附加信息表示数据元素之间的关系，并且存储单元至少包含两部分-数据域和地址域<br>单链表中结点只有一个地址并且指向后继结点<br>模拟SinglyLinkenList</p>
<h4 id="线性表之双链表"><a href="#线性表之双链表" class="headerlink" title="线性表之双链表"></a><a href="https://www.myzwl.win/2017/07/08/sjjg_3/">线性表之双链表</a></h4><p>双链表的每个结点有两个地址域，分别指向它的前驱结点和后继结点</p>
<h4 id="串之字符串"><a href="#串之字符串" class="headerlink" title="串之字符串 "></a><a href="https://www.myzwl.win/2017/07/09/sjjg_4/">串之字符串 </a></h4><p>串是由n(n&gt;=0)个字符组成的有限序列，它是一种特殊的线性表。而子串是指串s中任意连续字符组成的一个子序列组成的串。同时，串的比较通常由其字符编码的相关规则比较</p>
<p>常量字符串String<br>字符串采用字符数组作为存储结构，并且采用顺序存储结构，不过String类一次性申请了固定的空间，同时由于其存储结构为最终型，所以string不提供删除，插入子串<br>变量字符串StringBuffer<br>该字符数组的容量总是大于串长，并且能够修改</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a><a href="https://www.myzwl.win/2017/07/10/sjjg_5/">栈</a></h4><p>栈是一种特殊的线性表，其特殊之处在于插入和删除操作的位置受到限制，而且插入和删除只允许在线性表的一端进行，特点是后进先出<br>顺序栈、链式栈</p>
<h4 id="顺序与链式队列"><a href="#顺序与链式队列" class="headerlink" title="顺序与链式队列"></a><a href="https://www.myzwl.win/2017/07/11/sjjg_6/">顺序与链式队列</a></h4><p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行。特点是先进先出。<br>顺序队列使用数组存储数据元素<br>1.当队列空时，设置队头、队尾下标front=rear=-1，<br>2.当第一个元素入队时，front=rear=0，同时改变两个下标<br>3.进行入队、出队操作，front、rear随之变化<br>4.当入队的元素个数（包括已出队元素）超出数组容量时，rear下标越界，数据溢出，但是，由于之前已有若干元素出队，数组前部以空出许多存储单元，所以这种溢出并不是因为存储空间不够而产生的，称为假溢出<br>所以顺序队列有两个缺点：假溢出和存储单元没有重复使用机制<br>顺序循环队列<br>相比较顺序队列，有如下不同<br>1.队头、队尾元素按照如下循环规律变化，其中length表示数组长度<br>front=（front+1)%length;<br>rear=(rear+1)%length;<br>所以可以看出front和rear的取值范围为0~length-1<br>链式队列</p>
<h4 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a><a href="https://www.myzwl.win/2017/07/14/sjjg_8/">树和二叉树</a></h4><p>基本术语<br>孩子优先遍历<br>兄弟优先遍历<br>完全二叉树和满二叉树<br>顺序与链式存储<br>模拟二叉树类</p>
<h4 id="hash散列表"><a href="#hash散列表" class="headerlink" title="hash散列表 "></a><a href="https://www.myzwl.win/2017/07/14/sjjg_9/">hash散列表 </a></h4><p>散列（hash）表是一种支持高效的查找、插入和删除操作的数据结构，它是针对查找效率接近O（1）而专门设计的。它根据元素的关键字确定元素的存储位置，而其中主要解决两个问题，设计散列函数和处理冲突<br>散列函数实质上是关键字集合到地址集合的映射，如果这种映射是一一对应的，则查找效率是O（1），但是由于散列表是一个压缩映射，即存储容量有限，即映射关系是多对一的映射，所以会产生冲突<br>除留余数法<br>该散列函数定义为hash（k）=k%p，函数结果范围为0~p-1，图示就是采用这种方法，而p取值为小于散列表长度的最大素数，如散列表长度分别为8,16,128，则对应的p（最大素数）分别为7,13,127<br>开放定址法<br>链地址法<br>模拟HashSet类</p>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a><a href="https://www.myzwl.win/2017/07/27/BSTSort_1/">二叉排序树</a></h4><p>原理<br>AVL树</p>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a><a href="https://www.myzwl.win/2017/07/30/huffman_1/">哈夫曼树</a></h4><p>基本术语<br>哈弗曼编码<br>压缩与解压原理</p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a><a href="https://www.myzwl.win/2017/08/01/graph_2/">图</a></h4><p>基本术语<br>邻接矩阵<br>深度（先序）<br>广度（层序）</p>
<h4 id="集合简单总结"><a href="#集合简单总结" class="headerlink" title="集合简单总结"></a>集合简单总结</h4><p>java集合主要分为以下三种类型：<br>Set(集)：集合中的对象不按特定方式排序，且没有重复对象。它的有些实现类能对集合中的对象按照特地方式排序。<br>List(列表)：集合中的对象按照索引位置排序，可以有重复对象，允许使用索引检索对象。<br>Map(映射)：集合中的每一个元素都包含一对键对象和值对象（key-value），集合中的键对象是不能重复的,它的一些实现类能对集合中的键对象进行排序。<br>注意这里的不能重复与比较hashcode和equals有关</p>
<p>Collection接口<br>Collection接口是Set、List、Queue接口的父接口，提供了多数集合常用的方法声明，包括 add()、remove()、contains() 、size() 、iterator() 等</p>
<p>List接口<br>它的特点是有序可重复，使用此接口能够精确的控制每个元素插入的位置用户能够使用索引来访问List中的元素并且允许有可重复的元素</p>
<p>ArrayList<br>底层实现是一个动态的数组，查询快，增删慢，线程不安全，效率高</p>
<p>LinkedList<br>底层实现是一个双向循环链表，查询慢，增删快，线程不安全，效率较高</p>
<p>Vector<br>是ArrlyList的线程安全版，底层同它基本一致，但是效率低，现在基本很少</p>
<p>Set接口<br>它的特点就是唯一性并且不允许出现重复元素和是无序的</p>
<p>hashSet<br>底层是基于哈希表实现的，而其核心就是先比较hashCode（）值是否相同（相当于索引），然后在用equals比较是否相同，从而确定元素是否重复，所以当不希望集合中有重复值，并且不关心元素之间的顺序时可以使用此类</p>
<p>LinkedHashSet<br>底层实现是使用链表和哈希表，它由链表保证元素有序，哈希表保证元素唯一，因此当不希望集合中有重复值，并且希望按照元素的插入顺序进行迭代遍历时可采用此类</p>
<p>TreeSet<br>底层实现是红黑树，也就是一种平衡AVL树，通过比较返回值是否是0来保证元素唯一性，并且通过自然排序来保证元素的排序（自然排序也就是让元素所属的类实现Comparable接口，比如abc排在abd前面，总之就是和插入顺序无关，只和元素本身的内容和特质有关）</p>
<p>Queue接口<br>它的特点就是队列，即用于保存将要执行的任务列表</p>
<p>LinkedList<br>实现了该接口，可以实现先进先出的队列</p>
<p>PriorityQueue<br>底层采用某种排序的单链表存储队列元素，用来创建自然排序的优先级队列</p>
<p>Map接口<br>Map关心的是唯一的标识符，也就是将唯一的键映射到某个元素，以键值对形式存储，键唯一，值可重复</p>
<p>HashMap<br>底层实现是基于哈希表依赖于hashCode（）和equals（）方法，线程不安全，允许key和value为NULL，效率高</p>
<p>Hashtable<br>HashMap的线程安全版，效率低，不允许key和value为NULL</p>
<p>LinkedHashMap<br>底层是由链表和哈希表组成，链表保证元素有序，哈希表保证元素唯一，所以当需要键值对，并且关心插入顺序时可采用它</p>
<p>TreeMap<br>底层是由红黑树实现，当需要键值对，并关心元素的自然排序时可采用它</p>
<p>Collections<br>内置了一些常见的集合算法，像排序，查找算法等</p>
<p>13.并发集合类是什么？<br>Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。</p>
<h4 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h4><p>每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素<br>2-3树、2-3-4树<br>B树、B+树、红黑树</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;线性表之顺序表&quot;&gt;&lt;a href=&quot;#线性表之顺序表&quot; class=&quot;headerlink&quot; title=&quot;线性表之顺序表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.myzwl.win/2017/07/08/sjjg_1/&quot;&gt;线性表之顺序表&lt;/a&gt;&lt;/h
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>java基础总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_6/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_6/</id>
    <published>2018-03-13T06:48:51.000Z</published>
    <updated>2018-03-18T15:44:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><a href="https://www.myzwl.win/2017/07/16/yc_1/">异常处理</a></h4><p>从大的角度说主要分成两类：Error类代表了编译和系统的错误，不允许捕获，也就是我们自己无法主动去处理它；Exception类代表了我们可捕获并且可自己可处理异常，而Exception有包括两类，一个是你必须要处理的异常，如某个类有throws异常了，在未进入运行期就必须处理，另一类就是Runtime Exception（运行期异常），就是只有在运行时（也就是编译成class文件）时才知道，这个异常可处理或不处理</p>
<p>try-catch-finally 规则<br>1）在finally语句块中发生了异常。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）关闭CPU。</p>
<h4 id="java-IO简单总结"><a href="#java-IO简单总结" class="headerlink" title="java IO简单总结 "></a><a href="https://www.myzwl.win/2017/07/23/IO_1/">java IO简单总结 </a></h4><p>流：数据在数据源（文件）和程序（内存）之间经历的路径<br>输入流：数据从数据源到内存的路径<br>输出流：数据从内存到数据源的路径<br>字节流：可以用于读写二进制文件及任何类型的byte，也就是一个字节一个的读<br>字符流：可以用于读写文本文件，不能操作二进制文件，也就是两个字节两个字节的读<br>2.根据数据流向不同分为：输入流和输出流<br>3。节点流和处理流<br>节点流：直接与数据源相连，读入或读出，可以发现使用该流过于频繁操作硬件，从而使读写很不方便<br>处理流：处理流和节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。<br>Object流的意思将是像一根节点流插入一根Object流管道，专门操作Object，而它必须实现Serializable接口，该接口的意思是可序列化，就是说将一个对象流序列化成子节流写进网络或者文件，比如说游戏存盘，有各个游戏的记录，如果以面向对象来写进管道，它的各个成员变量，会在内存中被序列化成二进制写进去，而Serializable接口无方法，它只是个标记接口，编译器看到实现该接口的类就知道它应该被序列化，同样有一个transient关键字，是使可序列化的某个属性变成透明，也就是它不能变成字节写进去，那个属性只能为默认属性写进去</p>
<h4 id="反射机制简单"><a href="#反射机制简单" class="headerlink" title="反射机制简单"></a>反射机制简单</h4><p>classLoad、Class、Methods</p>
<h4 id="java基本数据类型"><a href="#java基本数据类型" class="headerlink" title="java基本数据类型"></a>java基本数据类型</h4><p>byte、short、int、long、float、double、char、boolean</p>
<h4 id="能否重写构造方法"><a href="#能否重写构造方法" class="headerlink" title="能否重写构造方法"></a>能否重写构造方法</h4><p>重载构造方法是可以的。<br>但是重写则不可以，因为被重写的前提是被继承，而构造方法根本就不能被继承，所以谈不上被重写。只能调用父类的构造方法</p>
<h4 id="构造代码块和构造方法的执行顺序"><a href="#构造代码块和构造方法的执行顺序" class="headerlink" title="构造代码块和构造方法的执行顺序"></a>构造代码块和构造方法的执行顺序</h4><p>父类静态块-自身静态块-父类块-父类构造器-自身块-自身构造器</p>
<h4 id="说说-amp-与-amp-amp-的区别"><a href="#说说-amp-与-amp-amp-的区别" class="headerlink" title="说说&amp;与&amp;&amp;的区别"></a>说说&amp;与&amp;&amp;的区别</h4><p>&amp;与&amp;&amp;都可以用作逻辑与（and）的运算符<br>&amp;&amp;具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。而&amp;则会同时计算<br>&amp;可以作为位运算符，当&amp;两边表达式不是boolean时，&amp;表示按位与操作，通常使用Ox0f来与一个整数&amp;运算，来取该整数的最低4个bit位</p>
<h4 id="Overload与Override的区别？Overload的方法是否可以改变返回值的类型？"><a href="#Overload与Override的区别？Overload的方法是否可以改变返回值的类型？" class="headerlink" title="Overload与Override的区别？Overload的方法是否可以改变返回值的类型？"></a>Overload与Override的区别？Overload的方法是否可以改变返回值的类型？</h4><p>重载表示方法名相同，但是参数个数或类型不同）<br>重写表示子类中的方法可以与父亲中某个方法的名称和参数完全相同，通过子类创建实例调用父类这个方法，也就是相当于覆盖了父类的这个方法，但是当父类是private时相当于子类增加了一个全新的方法，就不存在覆盖了。并且子类应该比父类抛出更少的异常或者拥有更大的权限<br>如果参数名不同会改变返回类型，但是如果都一样肯定不会改变返回类型</p>
<h4 id="abstractclass和interface语法上有什么区别？"><a href="#abstractclass和interface语法上有什么区别？" class="headerlink" title="abstractclass和interface语法上有什么区别？"></a>abstractclass和interface语法上有什么区别？</h4><p>1.抽象类可以有构造方法，接口不能有构造方法<br>2.抽象类中可以有普通成员方法，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。<br>4.抽象类中的抽象方法访问类型可以是public、protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型<br>5.抽象类中可以包含静态方法，接口中不能包含静态方法<br>6.抽象类和接口类中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以是任意，但是接口中定义的变量只能是public static final类型<br>7一个类可以实现多个接口，但只能继承一个抽象类</p>
<h4 id="什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？"><a href="#什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？" class="headerlink" title="什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？"></a>什么是java序列化，如何实现java序列化？或者解释serializable接口的作用？</h4><p>将一个对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如将一个java对象存储到硬盘或者送给网络上的其他计算机，可以用代码把一个java对象变成某个格式的字节流在传输<br>如果要让java自动帮我们做，就需要实现serializable接口，编译的类才被writeObject方法操作，例如，在web中，如果对象被保存在了session中，tomcat在重启时要把session对象序列化到硬盘</p>
<h4 id="hashcode与equals"><a href="#hashcode与equals" class="headerlink" title="hashcode与equals"></a><a href="https://www.cnblogs.com/jesonjason/p/5492208.html" target="_blank" rel="external">hashcode与equals</a></h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;异常处理&quot;&gt;&lt;a href=&quot;#异常处理&quot; class=&quot;headerlink&quot; title=&quot;异常处理&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.myzwl.win/2017/07/16/yc_1/&quot;&gt;异常处理&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;从大的角度说主要分
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结</title>
    <link href="http://www.myzwl.win/2018/03/13/dream_7/"/>
    <id>http://www.myzwl.win/2018/03/13/dream_7/</id>
    <published>2018-03-13T04:48:51.000Z</published>
    <updated>2018-03-18T15:46:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1"><a href="#网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1" class="headerlink" title="网络编程简单总结(https://www.myzwl.win/2017/07/29/socket_1/)"></a>网络编程简单总结(<a href="https://www.myzwl.win/2017/07/29/socket_1/">https://www.myzwl.win/2017/07/29/socket_1/</a>)</h4><p>tcp/ip分层<br>链接层（ARP欺诈）-网络层（ip、icmp（ping））-传送层（tcp、udp）-应用层（POP3、Http、FTP，SSH、SMTP）<br>ip协议<br>ip层就是唯一确定了一台机器，就像我们住的房间地址一样，唯一确定了我们的住处<br>这里需要注意的是，ip地址由四位字节组成，每个字节由8位二进制组成，同时有a，b，c三类地址，如图由网络号和主机号组成，当然这是公网，如果是局域网的话，就需要配网关和子网掩码了，如192.168.1.1和255.255.0.0那么255.255就是确定了ip地址哪几位字节是网络号，如192.168就是网络号<br>TCP与UDP协议<br>tcp协议<br>有65536个端口 0号是保留端口<br>1-1024是固定端口<br>又叫有名端口，即被某些程序固定使用，一般程序员不使用。<br>22：SSH远程登录协议 23：telnet使用 21：ftp使用<br>25：smtp服务使用 80：iis使用 7：echo服务<br>1025-65535是动态端口<br>UDP协议<br>UDP向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接。<br>简单来说，就是只发一次数据，不管对方有没有接收到都不会再发了，但是有时候效率会很高，像网络拥堵时</p>
<p>url<br>统一资源定义符也被称为网页地址。Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL地址，这种地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是Internet上的站点，简单地说，URL就是Web地址，俗称“网址”，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法，如：<br><a href="http://www.sina.com:8080/index.html" target="_blank" rel="external">http://www.sina.com:8080/index.html</a><br>1、协议；2、ip地址(32位)；3、端口号(16位)0-65535；4、资源名称。</p>
<p>单工、半双工和全双工<br>Socket编程（模拟socket编程）</p>
<h4 id="tcp-如何保证传输的可靠性"><a href="#tcp-如何保证传输的可靠性" class="headerlink" title="tcp 如何保证传输的可靠性"></a>tcp 如何保证传输的可靠性</h4><p>tcp 是面向连接，可靠的字节流服务<br>面向连接意味着两个使用tcp 的应用（通常是一个客户端和一个服务器）在彼此交换数<br>据之前必须先建立一个tcp 连接。在一个tcp 连接中，仅有两方进行彼此通信，广播和多播<br>不能用于tcp。<br>Tcp 通过下列方式提供可靠性：<br>1）将应用数据分割为tcp 认为最合适发送的数据块；<br>2）超时重传：当tcp 发出一个段后，他启动一个定时器，等待目的端确认收到这个报<br>文段。若不能及时收到一个确认，将重发这个报文段。<br>3）当tcp 收到发自tcp 链接另一端的数据时，它将发送一个确认（对于收到的请求，给<br>出确认响应）。这个确认不是立即发送，通常将推迟几分之一秒（之所以推迟，可能是要对<br>包做完校验）；<br>4）若tcp 收到包，校验出包有错，丢弃报文段，不给出响应，tcp 发送端会超时重传；<br>5）对于失序数据进行重新排序，然后交给应用层（tcp 报文段作为ip 数据报进行传输，<br>而ip 数据报的到达会失序，因此tcp 报文段的到达也可能失序。若必要，tcp 将对收到的数<br>据进行重新排列，以正确的顺序交给应用层）。<br>6）对于重复数据，直接丢弃。<br>7）tcp 可以进行流量控制，防止较快主机致使较慢主机的缓冲区溢出<br>字节流服务：两个应用程序通过tcp 连接，tcp 不在字节中插入记录标识符，我们将这<br>种为字节流服务。<br>Tcp 对字节流的内容不做任何解释，tcp 不知道传输的字节流数据是二进制数据还是ascii<br>字符或其他类型数据，对字节流的解释由tcp 连接双方的应用层。</p>
<h4 id="简单描述一下https"><a href="#简单描述一下https" class="headerlink" title="简单描述一下https"></a>简单描述一下https</h4><p>https 其实是由两部分组成：http+ssl/tls，也就是在http 上又加了一层处理加密信息的<br>模块，服务端和客户端的信息传输都会通过tls 加密，传输的数据都是加密后的数据。加解<br>密过程：<br>1）客户端发起https 请求（就是用户在浏览器里输入一个https 网址，然后连接到server<br>的443 端口）<br>2）服务端的配置（采用https 协议的服务器必须要有一塔数字证书，可以自己制作，<br>也可以向组织申请，这套证书就是一对公钥和私钥）。<br>3）传输证书（这个证书就是公钥，只是包含了很多信息）<br>4）客户端解析证书（由客户端tls 完成，首先验证公钥是否有效，若发现异常，则弹出<br>一个警示框，提示证书存在问题，若无问题，则生成一个随机值，然后用证书对随机值进行<br>加密）<br>5）传输加密信息（这里传输的是加密后的随机值，目的是让服务端得到这个随机值，<br>以后客户端和服务端的通信就可以通过这个随机值来进行加密了）<br>6）服务端解密信息（服务端用私钥解密后得到了客户端传来的随机值，then 把内容通<br>过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混在一起，这样除非<br>知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法<br>够彪悍，私钥够复杂，数据就够安全）<br>7）传输加密的信息<br>8）客户端解密信息，用随机数来解。</p>
<p>短链接一般只会在client/server 间传递一次读写操作。<br>Tcp 保活功能，主要为服务器应用程序提供，服务器应用程序需要知道客户主机是否崩<br>溃，从而可以代表客户使用资源.<br>tcp 保护功能是探测长连接存活状况。<br>Tcp 的keep-alive 是检查当前tcp 是否还活着；http 的keep-alive 是让一个tcp 连接活多<br>久，他们是不同层次的概念。</p>
<p>a 发送给b 一个信息，但是a 不承认他发送了，防止这个可用数字签名<br>DNS 即使用tcp，又使用udp<br>https 若在浏览器端抓包，是可以看到数据的，并没有加密，抓到的是加密之前的</p>
<h4 id="http-请求过程——当我们在浏览器输入www-baidu-com，然后回车之后的详解"><a href="#http-请求过程——当我们在浏览器输入www-baidu-com，然后回车之后的详解" class="headerlink" title="http 请求过程——当我们在浏览器输入www.baidu.com，然后回车之后的详解"></a>http 请求过程——当我们在浏览器输入www.baidu.com，然后回车之后的详解</h4><p>1）域名解析（域名www.baidu.com 变为ip 地址）。<br>2）发起tcp 的三次握手，建立tcp 连接。浏<br>览器会以一个随机端口（1024-65535）向服务端的web 程序80 端口发起tcp 的连接.这个请<br>求（原始的http 请求，经过原始的tcp/ip 四层模型层层封装），到达服务器端后，进入网<br>卡，然后进入内核的协议栈（一层一层拨开），然后到达web 应用程序，最终建立了tcp/ip<br>链接。<br>3）建立tcp 连接后发起http 请求。<br>4）服务器响应http 请求，客户端得到html 代码。<br>服务器web 应用程序收到http 请求后，就开始处理请求，处理之后就返回给浏览器html<br>文件。<br>5）浏览器解析html 代码，并请求html 中的资源。<br>6）浏览器对页面进行渲染，并呈现给用户。</p>
<h4 id="什么是正向代理和反向代理"><a href="#什么是正向代理和反向代理" class="headerlink" title="什么是正向代理和反向代理"></a>什么是正向代理和反向代理</h4><p>正向代理：我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代<br>理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要哪<br>个无法访问的网站的内容，代理服务器取回来给我。server 不知道client。<br>反向代理：client 不知道server，并不是URL 中请求的那个资源，而是不知道从什么地方来<br>的。以代理服务器来接收internet 上的请求，然后将请求转发给内部网络的服务器，并将从<br>服务器上得到的结果返回给internet 上请求的客户，此时代理服务器对外就表现为一个服务<br>器。1）保证内网安全、2）负载均衡，nginx 通过proxy-pass-http 配置代理站点，upstream<br>实现负载均衡。</p>
<h4 id="怎么用udp-实现tcp"><a href="#怎么用udp-实现tcp" class="headerlink" title="怎么用udp 实现tcp"></a>怎么用udp 实现tcp</h4><p>由于在传输层udp 已经是不可靠的，那就要在应用层自己实现一<br>些保证可靠传输的机制，简单来说，要使用udp 来构建可靠的面向连接的数据传输，就要<br>实现类似于tcp 的超时重传（定时器），拥塞控制（滑动窗口），有序接收（添加包序号），<br>应答确认（ack 和seq）。目前已经有了实现udp 可靠运输的机制——udt：主要目的高速广<br>域网海量数据传输，他是应用层协议</p>
<p>Tcp：<br>1）流量控制：防止较快主机使较慢主机缓冲区溢出，是点对点；<br>2）拥塞控制：全局性，防止过多的数据注入网络。<br>tcp 采用滑动窗口进行流量控制，滑动窗口大小可变，窗口大小的单位是字节。</p>
<h4 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h4><p>在分布式集群中，对机器的添加和删除或机器故障后自动脱离集群，这些操作是分布式<br>集群管理最基本的功能，若采用常用的hash(object)%N 算法，那么在有机器添加或删除以后，<br>很多原有的数据就无法找到，所以出现一致性哈希算法——<br>1）环形hash 空间：按照常用的<br>hash 算法来将对应的key 哈希到一个具有232 个桶的空间，即（0-232 -1）的数字空间中，现<br>在我们将这些数字头尾相连，想象成一个闭合的环形。<br>2）把数据通过一定的hash 算法映射到环上。<br>3）将机器通过一定的hash 算法映射到环上。<br>4）节点按顺时针转动，遇到的第一个机器，就把数据放在该机器上</p>
<h4 id="Nginx负载均衡五种配置"><a href="#Nginx负载均衡五种配置" class="headerlink" title="Nginx负载均衡五种配置"></a>Nginx负载均衡五种配置</h4><p>1）轮询（默认），每个请求按时间顺序逐一分配到不同的后端服务器，如果后端<br>服务器down 掉，能自动剔除；<br>2）指定权重，指定轮询几率。权重越大，轮询几率越大，<br>用于后端服务器性能不均的情况。<br>3）ip 绑定ip_path，每个请求按访问ip 的哈希结果分配，<br>这样每个客户固定访问一个服务器，可以解决session 问题。<br>4）fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>5）url_hash 按访问的url 结果来分配请<br>求，使每个url 定位到同一个后端服务器。后端服务器为缓存时比较有效</p>
<h4 id="三次握手-手动画出图解"><a href="#三次握手-手动画出图解" class="headerlink" title="三次握手(手动画出图解)"></a>三次握手(手动画出图解)</h4><p> 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p>完成三次握手，客户端与服务器开始传送数据</p>
<p> 关闭TCP连接：改进的三次握手</p>
<p>对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：</p>
<p>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p>
<p>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p>
<p>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p>
<p>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放</p>
<h4 id="两次握手不行吗"><a href="#两次握手不行吗" class="headerlink" title="两次握手不行吗"></a>两次握手不行吗</h4><p>A发送报文滞留过长导致失效，然后b发送链接请求，A不理睬</p>
<h4 id="TIME-WAIT为什么是2MSL"><a href="#TIME-WAIT为什么是2MSL" class="headerlink" title="TIME-WAIT为什么是2MSL"></a>TIME-WAIT为什么是2MSL</h4><p>确保最后一个报文发到b，没有则重传<br>防止已失效的报文链接出现在本链接中</p>
<h4 id="为什么TCP释放连接需要四次"><a href="#为什么TCP释放连接需要四次" class="headerlink" title="为什么TCP释放连接需要四次"></a>为什么TCP释放连接需要四次</h4><p>  TCP建立连接要进行三次握手，而断开连接要进行四次。这是由于TCP的半关闭造成的。因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个方向的连接</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1&quot;&gt;&lt;a href=&quot;#网络编程简单总结-https-www-myzwl-win-2017-07-29-socket-1&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="自我救赎" scheme="http://www.myzwl.win/categories/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
    
      <category term="自我救赎" scheme="http://www.myzwl.win/source/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>系统V1.0简单说明</title>
    <link href="http://www.myzwl.win/2018/03/10/sys_1/"/>
    <id>http://www.myzwl.win/2018/03/10/sys_1/</id>
    <published>2018-03-10T07:48:51.000Z</published>
    <updated>2018-03-16T01:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>该系统很不完善，由于一个人的精力和时间有限，有很多考虑不周到的地方，很多地方算法复杂度高，模块耦合性高，部分设计模式设计不合理，代码规范不达标等等请谅解</p>
<h4 id="系统部分"><a href="#系统部分" class="headerlink" title="系统部分"></a>系统部分</h4><p>其次自己租了11台linux服务器，内存1G以上有6台，以下是之前的架构，由于时间关系，展示如下<br>系统架构(旧)<br><img src="/images/imgs6/1.png" alt="Alt text"><br>所用技术栈(旧)<br><img src="/images/imgs6/2.png" alt="Alt text"><br>系统部分说明(旧)<br><img src="/images/imgs6/1.jpg" alt="Alt text"></p>
<h4 id="困难与解决"><a href="#困难与解决" class="headerlink" title="困难与解决"></a>困难与解决</h4><p><strong>1.留言板的数据存储如何存储与取出算法实现</strong><br>按照自己之前的经验，一个人写一条留言就记录下，然后就是垂直式的记录，很明显存在很多问题<br><img src="/images/imgs6/2.jpg" alt="Alt text"><br>解决方法 :<br>将问题抽象成伪B树数据结构，节点数以固定，不需要记录<br><img src="/images/imgs6/3.png" alt="Alt text"><br>很明显这样嵌套下去，深度非常大，就是一颗斜二叉树，还有就是留言板目前最多需要楼中楼加上前端写不出来，所以深度固定为2并且最后一层放在一个栈里（按照时间排序）</p>
<p>如何有效率的取出数据?<br>按照首先的想法（sql不是很好，所以按照笨方法来考虑），因为这里记录的是结点，而最后需要的是用户名等信息，也就是说还需要查数据库转换(如果加个相关字段除外),<br>也就是遍历到所有结点o(n)，然后每个结点查数据库转换为相关信息o（n），而且查数据库的字段保存的内存也大，还要查数据库n次，所以如果数据量极大，效率很不高</p>
<p>解决办法:<br> 干脆就遍历一次，将遍历的结果只要用户名和id，然后放在一张哈希表中，然后分成两块，一块是得到所有顶层父节点集合，另一层是所有的孩子结点，然后构造一个栈，通过父节点找到其下所有孩子节点，放到栈中，然后将栈放到一个集合中，循环遍历放入，最后只要把这个集合交给前台就好了</p>
<p><strong>2. 如何实时显示在线登录人数?</strong><br>首先怎么才算登录人数，一般规定用户登录后才算，但是登陆后会出现几种情况，用户主动退出登录，长时间不点击和主动关闭浏览器都会导致会话失效，另外并发登录人数限制和管理员在线踢出用户都会影响登录人数<br>而一般的做法就是写个servlet会话监听器去监听登录，当有会话建立时并且已经成功登录和先判断该用户是否已经正在线，统计相关信息，然后就是退出浏览器只能等会话失效才算离线。用这种方法去做，简单，但是实时效果不是太好但是发现我得session是用shiro管理的，大部分应用离不开shiro，而且shiro的sessionId每次是不一样的，也就是说，同一用户登录，在缓存中通过用户名产生的会话id不一样，造成同一用户登录重新登录会变成不同用户而在线人数不对。<br>而另一种更好并且统计更准确的是利用redis缓存信息（遇到了瓶颈，也是这个sessionId每次不一样，但是如果把shiro换掉或者做成分布式可以解决），大概是这样的想法，现在redis中放两组key，根据需求一组存放登陆用户的SessionId与ClientUser的Json数据，另一组存放存放登录用户的UID与SessionId对于的数据，然后利用该监听器，，只要一有会话差生，就从redis登记表（封装各类实时统计的方法）中查看，以一定规则查看是否登录，这里可以判断是游客还是会员，然后记录相关登记信息等等，放在session中，这种统计方法更实时，统计内容更多，但是因为shiro的问题，最终统计很不准确，因为这个sessionId还必须是准确才行<br>解决办法：<br>干脆就用shiro的缓存来统计，得解决这个并发登录人数控制。Shiro是这样做的，规定同一账号最大会话数，实际上是放在一个缓存队列中，如果其大小超过该会话数，就踢出头或尾会话，在加入该会话，然后就是这个缓存队列是通过ehcache中命名用户名设置的，然后将其放在shiro拦截器，放在登录请求中，这是如果有会话被提出，但是本地缓存sessionDAO中任然有那个被踢掉的缓存，需要个监听器根据那个用户名得到sessionId然后踢掉，缓存同步。<br>还有一个就是强制用户退出，就是根据sessionId让session失效，logout就行了。<br>最后就是实时统计在线列表了，这里比较棘手的就是的就是那个强制退出的会话怎么清除，如果不清除，缓存中会得到空指针，最头疼的是服务器崩溃，利用缓存中的方法可以得到所有活跃的会话，包括失效的，然后就是通过异常，测试居然可以通过，得到失效的会话，然后就是通过sessionid判断，更新缓存，删掉那个失效的会话，最后就是活跃的会话了，而关闭浏览器通过缩短会话存活时间保证，主动退出和会话正常死亡通过监听器解决<br>最后就是复杂度太高导致效率低下，不能完全模拟实时统计，可以用心跳方式解决</p>
<p><strong>3. 如何高效率执行并发在线编程?</strong><br>这个最终的解决办法并不是很好，但是探索的过程总是充满乐趣.<br>首先要解决的问题是怎么才能实现在线编程，参考了jdk的动态代理。大概就是将代码变成字符串，然后拿到当前编译器进行编译，最后将编译的结果输出即可。如果不加以控制的话，最后如果并发量大的话，同时写入和读出造成错误，同时如何保证编译更有效。<br>首先就是解决并发问题，首先使用lock写锁，控制。假设是单线程执行，一个用户写完还必须按照时间等待，并发量高效率很低。很自然想到线程池，封装一个线程池工具类，创建一个编译线程任务类，然后就是按照线程创建时间创建不同的文件夹，每个文件夹来自不同的用户线程，这样就解决了记录问题，剩下就是怎么保证每个用户都知道自己执行哪个编译线程，然后拿到对应的编译结果（在这里遇到了瓶颈）<br><img src="/images/imgs6/4.png" alt="Alt text"></p>
<p>最终是可以并行执行编译，而不是串行等待，但是编译的结果随机发给了等待的用户，当然可以直接用synchronized控制同步，但是代价和执行效果就不怎么好了。</p>
<p>解决办法<br>最后直接用synchronized控制同步，也就没有必要使用线程池了，只要保证不同用户编译和返回的结果是正确就行了，最后将该功能做出微服务，利用dubbo管理，这样尽可能降低并发带来的性能问题</p>
<p><strong>4. 如何实现算法建模和保证数据高效回显？</strong><br><img src="/images/imgs6/3.jpg" alt="Alt text"><br>该表依赖于算法类型表，核心是func_index。而存储redis需要两个key，一个是该对象序列化存储，选择list类型存储，以索引作为信息搜索。另一个是该类型与一个字符串（记录算法类型）类型组合成一个新对象,选择string类型存储</p>
<p>大概的入库的流程是，通过时间随机生成索引，一定不重复，然后先入本地数据库，而那个pkId就是通过存入redis库的那个list类型key取得长度+1，不存在则为0，这样解决了pkId重复问题，接下来先存储list类型key，然后存储那个String，按照一定规则转换<br>而取出算法时，也是先从redis中取出，异常走本地数据库，而取出时，先将那个String转换为对象，按照索引’取出符合要求的<br>遇到的问题：<br>业务过于复杂，各种存入redis数据存储和取出出现异常，每个特定的算法建模太耗内存</p>
<p>解决办法：<br>将算法建模做成微服务，算法信息存储通过redis主从复制，解决加载慢问题，同时算法运行计算在不同机器执行，通过集群解决并发量大问题</p>
<p><strong>5.如何细粒度的控制url，保证游客也能访问而又安全？</strong><br>事实上shiro已经通过身份角色进行安全控制，而这里需要的是一个通用url除了最后确定信息加密不一样外，其余都差不多，并且可以权限控制。<br>     大概的想法是：首先建立两个枚举类，一个是记录目前存在可以注入的加密算法名称，另一个是记录需要加密的页面名称（知识为了记录，事实上用不到），然后是一个简单工厂类，根据通过加密的索引号，返回枚举类中相应的加密算法名，然后就是一个加密模板类，该类中的加密索引号在spring中注入，反射路径是封装的加密类<br>   接下来，利用反射动态得到该加密类，然后通过索引号在简单工厂中得到加密算法名称，最后反射类循环方法，一旦相等，执行该方法，最后得到加密解密后的字符串，<br>   最后来一个页面跳转中转站，通过传入jsp文件的分支和名称进行跳转，可以内部转发或者重定向。这样一方面就可以通过改url，控制游客登录后台，而又得不到相关信息，进行细粒度控制<br>   遇到的棘手问题:<br>因为有些加密算法是需要密钥的，而每次随机生成，必须同一对象才能解密，但是解密的时候就不是之前那个对象了，所以有需要密钥的都不能解密<br>解决办法:<br>选择其中不需要密钥并且是对称加密的算法</p>
<p><strong>6..业务逻辑重复代码太多，如何合理解耦?</strong><br>首先对于实体类规定一个base类，所有实体必须继承它。主要有两个原因，<br>第一个就是为了业务层解耦，只要传入这个base类就行<br>第二个根据需要加入相关字段，而不要重写包装类<br>然后业务层一个基础业务类，抽象共同方法<br>然后抽象出一个含分页信息的工具类，里面规定传入继承基础类的类，返回分页后的集合信息，同时统一设置了保存在request域中的信息，</p>
<p><strong>7.论坛核心表如何设计?</strong><br>  如果放在一张表里，控制起来很复杂，所以干脆设置成三张表<br>  即文章表、评论表和楼中楼表<br>并且文章表必须包含用户id，评论表包含文章id，用户id，被回复者id，楼中楼包含那三个和评论id，这样就可以精确的进行记录了。然后就是给文章表设置一个状态值，用于标识普通帖、精贴等，在取出的时候通过规定的业务关系取出数据。同时相关文章数据要同步到es服务器索引库进行搜索查询<br>遇到的困难：<br>业务过于复杂，需要考虑各种细节关系和各种可能的情况，同时前端弄不出来<br>解决方法：<br>按照算法的思想，各个击破，尽可能考虑每种情况，同时寻找第三方优秀模板</p>
<p><strong>8. 其他非业务的简单实现</strong><br>   1.利用拦截器在登录请求出进行黑名单判断和日志统计<br>   2.利用activeMQ将推送的消息放入到队列中，并且实时发送到有初始化webSocket的页面<br>   3.文章访问量统计按照ip和用户的访问表进行登记判断，以一天为准，凌晨自动清空访问表，并且访问量记录在文章表中</p>
<h4 id="最后说明"><a href="#最后说明" class="headerlink" title="最后说明"></a>最后说明</h4><p>感谢您的阅读</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;该系统很不完善，由于一个人的精力和时间有限，有很多考虑不周到的地方，很多地方算法复杂度高，模块耦合性高，部分设计模式设计不合理，代码规范不达
    
    </summary>
    
      <category term="毕业设计" scheme="http://www.myzwl.win/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="毕业设计" scheme="http://www.myzwl.win/source/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>我的大学自学java体系二</title>
    <link href="http://www.myzwl.win/2017/12/31/study_02/"/>
    <id>http://www.myzwl.win/2017/12/31/study_02/</id>
    <published>2017-12-31T06:48:51.000Z</published>
    <updated>2018-03-15T15:40:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束，趁着今年最后一天把大学学的关于java方面的知识总结一下，一方面是解放自己释放压力，另一方面激励自己尽快找到实习，稳定生活和压力</p>
<p><img src="/images/imgs5/1.svg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束，趁着今年最后一天把大学学的关于java方面的知识总结一下，一方面
    
    </summary>
    
      <category term="个人感想" scheme="http://www.myzwl.win/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="学习总结" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的大学自学java体系一</title>
    <link href="http://www.myzwl.win/2017/12/30/study_01/"/>
    <id>http://www.myzwl.win/2017/12/30/study_01/</id>
    <published>2017-12-30T06:48:51.000Z</published>
    <updated>2018-03-15T14:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束。<br>回顾这三年多生活，大学前一年基本迷迷茫茫，太多的课程，让人不知道如何去选择一个方向学习，基本很迷茫，有一次为了表示对物理的尊敬和兴趣，特地网上买了物理上下答案，晚上或者周末一有时间就去自习室刷题，刷完一本后，突然发现除了内心的满足感，到现在再也没碰过物理了，从上中学开始就一直对数学情由独钟，也因此错过很多很多机会和干过很多愚蠢的事，自己当时心里就想着干自己喜欢的事，于是乎，除了几门极个别的课，基本上全在研究数学，看大学老师录的数学视频，刷奥数题，上头时为了手写和推出一元三次和四次方程的含复根求根公式，连续好几天乐此不疲，然后一次很重要的人生考试被自己的糊涂和幼稚错过了（除了那两张象征荣誉的奥数证书，后来已经撕了，现在觉得当时太傻，太傻，太傻，也成为了自己的一个警醒），后来大学填报专业时，第一志愿写了数学专业，家里也希望当个数学老师算了，后来阴差阳错的调剂到软件工程专业，慢慢的，慢慢地也就淡忘了对数学的热情。大学里，也迷茫过，包夜上网玩游戏已达上百次，也是因为兴趣上头，后来想想身体健康才是最主要的，娱乐要有度。<br>大学真正开始学习是从c、c++开始，当时第一次接触c语言，真的很兴奋，基本上就一直做数学程序题，后来接触了c++，用vc6.0做mfc程序，然后就是一直对着c++ primer plus学习，当时也算是有了一个目标。后来，也是改变了我的学习方向的一个时间，到现在都记忆犹新。有一次室友有事，让我代替他上一节php公选课（时间2015-10-20），第一次接触web，服务器，突然发现这才是自己喜欢做的，自己被深深的震撼到了，当时他也布置了一个任务，做一个简单的网页含后台，回去后，就像发现新大陆一样，通过百度搭建了php环境和wampserver服务器，然后就是着了迷一样的弄，几天后弄出来了一个个人主页网站<br><img src="/images/imgs5/33.jpg" alt="Alt text"><br><img src="/images/imgs5/34.jpg" alt="Alt text"></p>
<p>突然之间感觉自己有了学习兴趣和方向，像着了迷一样的学习。后来2016年初做的几次兼职深深的意识到了，学习比干苦力看重眼前利益有用些，后来听说了java（学校是在2016年10月才开设的唯一一门java基础课，后续没了java相关了），开始一脚踏进了深深的深渊，开始疯狂的自学中至今</p>
<h4 id="感谢韩顺平老师"><a href="#感谢韩顺平老师" class="headerlink" title="感谢韩顺平老师"></a>感谢韩顺平老师</h4><p>刚开始在图书馆借了一本<21天学通java>,因为之前有c和数据结构等基础，所以学习起来也轻松，没几天就看完和动手码完了<br>，后来无意中接触了java吧，看到了传播智客韩顺平老师的视频分享，于是一口气下完了，不得不说韩老师是我的java启蒙老师，也很荣幸他的视频讲的很细致，每集时间很长，他的视频我连续花了四个多月才消化完，其中java se搞了两个月（到现在仍然觉得java基础仍不足），而每天像打了鸡血一样，一天真的12小时以上，哪也不去，就是对着电脑先仔细听他说完一级，然后看着笔记认真动手操作每一集的每一个代码（当时，真的不复制，就是自己从头敲到尾，遇到卡住的，回头再看视频回顾细节），然后按照自己的想法把它的功能改成自己的，一直都记着韩老师的一句话（把别人的知识通过自己的语言描述出来就是自己的知识，一定要实践），记得三月底的一次运动会，宿舍人要么回家了，要么出去玩了。当时自己选择留在宿舍学习(也就是为了完成韩顺平老师的项目)，就这样连续五天在各种情形下度过了，也许当时会感觉很孤独，但是总觉得在一个目标和兴趣下，一切都是那么充实。每天晚上，总会在睡觉前在手机上观看韩顺平老师的笔记到一两年，就这样早上7点起来，晚上2点睡，持续了大半年。这期间（现在想来）有些技术踩坑了，比如swing当时要求自己手写所有的，很认真的花很多时间学习struts1.xml四种解析情况自己手写模拟（现在忘光了），而最多最多的就是自己踩坑，抗压学习，遇到问题，然后通过耐心的百度，谷歌解决，每个学习的知识和技能都要转化为自己的语言应用，哪怕花时间去网站上找相关辅助代码，一定要还原真实情况。正是这段时间的学习，让我对软件开发有一个很深很深的认识，唯一的代价就是失眠和孤独。后来在四月初，数据库老师布置了一个任务，让我们做一个的数据库课程设计，事实上就不说了，后来也许是兴趣或者正好可以用上，自己花了一个星期（事实上每天就睡4,5个小时）自己一行一行的敲，做了一个基于swing的宿舍管理系统，这是自己第一次进行设计和编码，不知道当时拿给老师是有多兴奋~，后来老师说功能写的可以，就是太乱。当时也不懂软件工程，于是回去后又花了一个星期改了一个基于socket的宿舍管理系统，也许是当时太想把网络知识应用上，后来老师说我回去得看看软件工程。后来发现的确，盲目编码很不规范，然后当时就有一个心愿写一个网站的宿舍系统，而当时也是参考了韩老师的学生管理系统，又是一个月的努力，在五月份的时候，第一次写了一个基于纯servlet和mvc模式的宿舍系统，当时也许是太单纯了，自己拿了四张A4纸把每个类和流程都手写出来，然后去验收，然后向同学借了几台电脑去验收，也许是老师看我太认真了，说了一句（学校没几个像你这样的，然后让我帮她帮一个学校做一个网站），当时因为着迷技术，推掉了（直到2017年2月帮做另一个项目，已完成），后来也许就是这句话，自己越学越有劲，总之韩顺平老师的课程帮助了我许多许多</21天学通java></p>
<h4 id="那些充实的日子"><a href="#那些充实的日子" class="headerlink" title="那些充实的日子"></a>那些充实的日子</h4><p>后来6月初，有个达内来的ios七天校内实训，然后做一个tom猫小程序。当时，真的很兴奋，从一开始就抱着不学ios，自己做一个基于web的tom动画程序，然后后来就各种jsdom做了一个，后来演示时，他直接说我私底下给他看了过了（贼笑），期间也和他聊了聊，从java se聊到ssh和自己的项目，他说我这样可以去实习和然后工作了，当时，仍然以兴趣和沉迷技术，根本没有想那么多（现在后悔了，早点实习，早点有工作经验真的很有益，而且有明确的学习方向）。学完韩顺平老师的以后，也陆续发现还有许多优秀的讲师，像马士兵老师，于是以同样的方式学习，突然发现马老师，彻底改变了我的学习方式，而且他的课程讲的很深，像jdk源码，设计模式等等，总之马士兵老师的视频将近花了三个多月，也是收获最多的，在16年五月初的时候自己就有种打算写一个个人博客，于是乎花了将近两个月时间，写了第一个基于s2sh的个人博客，过程就不说了，也第一次接触到了外网访问，当时用的是nat123，将服务器架在自己电脑上，而且刚上限就被黑客黑了，自己机子成了肉鸡（贼笑），后来也许是自己太得意和想摆脱孤独，发在了空间，第一次感受到了温暖<br>当然，代价是很严重的，就是自己的精神很萎靡和严重缺少睡眠和每天都失眠，基本就是宅在房里，没有交流<br>再到后来，陆陆续续不断学习李炎灰老师的前端体系，easy ui创始人的视频（这个帮助真大），北风网的优秀视频，黑马东哥视频，和java123视频，最终以一个课程设计猎图网（按照软件工程编写文档）而结束了2016年的学习。<br>回忆起来，这一年真的很充实和苦有所得</p>
<h4 id="持久以恒"><a href="#持久以恒" class="headerlink" title="持久以恒"></a>持久以恒</h4><p>2017年开始，自己就开始写博客来记录学习和知识，早在2015年3月，自己建了一个c++群，不过里面人很少，刚开始是用文档记录发到群里分享，后来直接用hexo博客写，自己也租了一台阿里云服务器，部署自己的网站。而之前也是利用业余时间看看经典书籍，而这一年更是如此，也很少看视频了，基本以经典书籍学习，像设计模式，多线程，数据结构与算法等等，也许是精力不行了，也没有了之前疯狂的学习热情，后来在3月到5月一直帮一个学校做项目（过程太累），第一次感受到真实项目的复杂合自己一个人做的挑战，最后改编成了毕业设计。然后到了7月，自己也许是爆发最后一次的能量，整个暑假出门不超过几十次，花了一个月终于完成了自己的个人论坛项目，带着渴望不孤独的心情第二次发到了空间，然而在之前，因为自己太痴迷于技术，错过了好多推荐的机会，现在后悔都来不及。到九月份，突然发现，自己投的简历都石沉大海，一次面试对方说出了详情，我们不需要有自己想法的人，就算你自己苦思冥想设计算法最后还是调用第三方库，如谷歌、百度。而且现在培训这么多，别人几个月会各种分布式技术，各种技术集群，而且只要基本的增删改查和基本操作就够了，而且我们只要有工作经验的，也许是自己之前的学习热情过头惹怒了面试官加上简历上写的0工作经验和找实习，要么是培训机构要么没有机会，加上自己又要考驾照和精神不够好胡思乱想，于是从十月份开始彻底废了，每天沉迷游戏，动漫，电影，自暴自弃，甚至考虑转行等等，期间也偶尔兴趣来了学习一下技术，后来慢慢的发现，自己太单纯了，自己的目标是一名工程师，技术会用和深入学习的时间性价比是天壤之别，而且这是一个很现实的社会</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>慢慢的，人总是会变的现实，很感激大学里陪伴我的严蔚敏老师、韩顺平老师、马士兵老师、李炎灰老师和其他免费开源的优秀老师以及那些经典书籍的作者，是他们陪伴我度过了最充实的大学生活。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;不知不觉新的一年将开始，也意味着6月份之后美好的大学生活和学生时代即将结束。&lt;br&gt;回顾这三年多生活，大学前一年基本迷迷茫茫，太多的课程，让
    
    </summary>
    
      <category term="个人感想" scheme="http://www.myzwl.win/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="学习总结" scheme="http://www.myzwl.win/source/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>jvm总结之三:虚拟机堆参数</title>
    <link href="http://www.myzwl.win/2017/12/23/jvm_3/"/>
    <id>http://www.myzwl.win/2017/12/23/jvm_3/</id>
    <published>2017-12-23T07:48:51.000Z</published>
    <updated>2018-03-17T10:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>事实上，我们对堆内存的管理是可控的，可通过对jvm虚拟机相关堆内存参数设置进行控制</p>
<h4 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a>参数含义</h4><p>-XX 对于系统级别的jvm配置 配置日志信息 垃圾回收器类型<br>非 -XX的 基本都是对 应用层面上的配置</p>
<ul>
<li>启用 - 禁用<br>-XX :PrintGC 使用这个参数，虚拟机启动后，只要遇到GC就会打印日志<br>-XX: +UserSerialGC 配置串行回收器<br>-XX:+PrintGCDetails：可以查看详细信息，包括各个区的情况<br>-Xms: 设置java程序启动时初始堆大小<br>-Xmx: 设置java程序能获得的最大堆大小<br>-Xloggc:路径 ：将打印出来的日志信息保存至指定的路径<br>-Xmn：设置堆的内存大小<br>-XX:SurvivorRatio=m:n调整Eden和Survivor的比例为m:n</li>
</ul>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class test2 &#123;		</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	</div><div class="line">		//-Xms20m -Xmx20m -Xmn10 -XX:+PrintGCDetails -Xloggc:d:\gc1.log</div><div class="line">		</div><div class="line">				//查看GC信息</div><div class="line">				System.out.println("max memory:" + Runtime.getRuntime().maxMemory());</div><div class="line">				System.out.println("free memory:" + Runtime.getRuntime().freeMemory());</div><div class="line">				System.out.println("total memory:" + Runtime.getRuntime().totalMemory());</div><div class="line">				</div><div class="line">				byte[] b1 = new byte[1*1024*1024];</div><div class="line">				System.out.println("分配了1M");</div><div class="line">				System.out.println("max memory:" + Runtime.getRuntime().maxMemory());</div><div class="line">				System.out.println("free memory:" + Runtime.getRuntime().freeMemory());</div><div class="line">				System.out.println("total memory:" + Runtime.getRuntime().totalMemory());</div><div class="line">				</div><div class="line">				byte[] b2 = new byte[4*1024*1024];</div><div class="line">				System.out.println("分配了4M");</div><div class="line">				System.out.println("max memory:" + Runtime.getRuntime().maxMemory());</div><div class="line">				System.out.println("free memory:" + Runtime.getRuntime().freeMemory());</div><div class="line">				System.out.println("total memory:" + Runtime.getRuntime().totalMemory());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>Memory: 4k page, physical 2076596k(144200k free), swap 4923560k(620956k free)<br>CommandLine flags: -XX:InitialHeapSize=5242880 -XX:MaxHeapSize=20971520 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:-UseLargePagesIndividualAllocation<br>0.418: [GC (Allocation Failure) 0.418: [DefNew: 655K-&gt;192K(1856K), 0.0049031 secs] 655K-&gt;466K(5952K), 0.0052607 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]<br>0.448: [GC (Allocation Failure) 0.448: [DefNew: 1282K-&gt;0K(1856K), 0.0044827 secs]0.453: [Tenured: 1490K-&gt;1490K(4096K), 0.0033471 secs] 1557K-&gt;1490K(5952K), [Metaspace: 80K-&gt;80K(4480K)], 0.0083429 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]<br>Heap<br> def new generation   total 1920K, used 68K [0x03a00000, 0x03c10000, 0x040a0000)<br>  eden space 1728K,   3% used [0x03a00000, 0x03a111f8, 0x03bb0000)<br>  from space 192K,   0% used [0x03bb0000, 0x03bb0000, 0x03be0000)<br>  to   space 192K,   0% used [0x03be0000, 0x03be0000, 0x03c10000)<br> tenured generation   total 8196K, used 5586K [0x040a0000, 0x048a1000, 0x04e00000)<br>   the space 8196K,  68% used [0x040a0000, 0x04614b70, 0x04614c00, 0x048a1000)<br> Metaspace       used 80K, capacity 2242K, committed 2368K, reserved 4480K</p>
</blockquote>
<p>其中from、to分别为s0、s1区</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;事实上，我们对堆内存的管理是可控的，可通过对jvm虚拟机相关堆内存参数设置进行控制&lt;/p&gt;
&lt;h4 id=&quot;参数含义&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="jvm" scheme="http://www.myzwl.win/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://www.myzwl.win/source/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm总结之二:回收策略</title>
    <link href="http://www.myzwl.win/2017/12/22/jvm_2/"/>
    <id>http://www.myzwl.win/2017/12/22/jvm_2/</id>
    <published>2017-12-22T07:48:51.000Z</published>
    <updated>2018-03-17T10:29:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们知道垃圾回收的主要内存区域是堆和方法区，因为这两块区域的内存分配相对于其他区域具有不确定性，而分配内存一般有两种方法，即指针碰撞和空闲列表</p>
<h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><p>在堆内存中主要分为年轻代和老年代（具体后面再说），先说一下年轻代<br><img src="/images/imgs5/37.jpg" alt="Alt text"><br>如图，主要分为Eden（对象都会在该区域内创建）同时也会在s0或s1中随机一个进行创建，经过一次GC后在s0和s1中使用复制算法保留存活下来的对象，那么它是如何复制的了<br><img src="/images/imgs5/38.jpg" alt="Alt text"><br><img src="/images/imgs5/39.jpg" alt="Alt text"><br>大概流程就是将可回收的垃圾对象进行标记，然后复制存活的对象到另一块空白区域，依次类推<br>很显然这种复制方式很浪费空间，但是年轻代是生命周期很短的，换句话说，如果年轻代不够放了就会放到老年代，一般规定经过15次GC后的年轻代就会进入老年区（可通过-XX：MaxTenuringThreshold=15设置多少次为老年代），而老年区一般存放存活时间比较久的对象，通过标记-清除-整理进行垃圾回收，如果老年代内存不足就会触发FULL GC.默认是占用了68%后收集（可通过-XX:CMSInitiatingOccupancyFraction=68设置），该GC非常影响性能</p>
<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>我们知道垃圾回收算法可自行判断一个对象是否已经生命周期达到结束，从而将其视为垃圾进行回收。那么在此算法出现之前，出现过可达性分析算法进行垃圾回收<br>算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起始点，从这些起始点开始向下搜索，所走过的路径称为引用链，如果一个对象到GC Roots没有任何引用链，那么这个对象是不可用的，就是说，程序中没有谁引用了这个对象，所以可以说从根节点到叶子结点是不可达的<br>而以下对象可作为GC Roots对象：<br>虚拟机栈（栈帧中本地变量表）中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中JNI（也就是native本地方法）引用的对象</p>
<p>现在我们已经知道了通过可达性分析判断对象是否还可用，但是是不是不可达的对象都是不可用呢？答案是未必。原因在于要宣告一个对象的死亡，需要两次标记（为什么需要两次标记呢？原因是如果一个对象没有与GC Roots结点相连，就会被第一次标记，而如果对象覆盖了finalize方法，并且在finalize方法中与某个对象建立了引用关系，那么第二次标记会失败，那么这个对象就会被移出“即将回收”的对象列表，移出之后这个对象就“活”了下来，如果在finalize方法中这个对相关仍然没有与一个对象建立引用关系，那么这个对象就真正死亡了）。</p>
<h4 id="回收方法区中的对象"><a href="#回收方法区中的对象" class="headerlink" title="回收方法区中的对象"></a>回收方法区中的对象</h4><p>方法区中的永久代的垃圾回收主要为两部分： 废弃常量和无用的类<br>废弃常量是指没有任何对象引用常量池中的某个对象，那么这个对象就会被回收，而对于常量池中的垃圾回收只要进行一次标记就可以进行判断<br>无用的类需要满足以下三个条件才可以宣判一个类的“死刑”：<br>    1.该类的所有实例都已经被回收，也就是Java堆中不存在该类的实例<br>    2.加载该类的ClassLoader已经被回收<br>    3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;我们知道垃圾回收的主要内存区域是堆和方法区，因为这两块区域的内存分配相对于其他区域具有不确定性，而分配内存一般有两种方法，即指针碰撞和空闲列
    
    </summary>
    
      <category term="jvm" scheme="http://www.myzwl.win/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://www.myzwl.win/source/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm总结之一:java内存区域</title>
    <link href="http://www.myzwl.win/2017/12/21/jvm_1/"/>
    <id>http://www.myzwl.win/2017/12/21/jvm_1/</id>
    <published>2017-12-21T06:48:51.000Z</published>
    <updated>2018-03-17T10:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>引用百度文库上对java虚拟机的定义.<br>虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行</p>
<h4 id="重要组成部分"><a href="#重要组成部分" class="headerlink" title="重要组成部分"></a>重要组成部分</h4><p><img src="/images/imgs5/35.jpg" alt="Alt text"></p>
<p><font size="5">类加载子系统</font><br>负责从文件系统或者网络中加载class信息，加载的信息存放在一块称之为方法区的内存空间</p>
<p><font size="5">方法区</font><br>存放类信息、常量信息、常量池信息、包括字符串常量和数字常量等</p>
<p><font size="5">java堆</font><br>在虚拟机启动的时候创建，此内粗区域的唯一目的就是存放对象实例，是所有线程共享的，同时，这块内存区域也是垃圾收集器的主要区域，也被成为GC堆</p>
<p><font size="5">Java虚拟机栈</font><br>每个java虚拟机线程都有一个私有的栈，其生命周期与线程相同，它描述了Java的方法执行模型，每个方法执行时都会创建一个栈帧。会抛出StackOverFlowError和OOM</p>
<p><font size="5">本地方法栈</font><br>与Java虚拟机栈类似，最大的不同就是它是用于本地方法调用，同常用c语言编写</p>
<p><font size="5">直接内存</font><br>NIO库允许java使用直接内存，通常速度由于java堆</p>
<p><font size="5">程序计数器</font><br>程序计数器可以理解为当前线程执行的字节码的行号指示器，字节码解释器就是通哟改变这个值来获取需要执行的下一条需要执行的字节码指令。对于多线程来说，每条线程都有自己的程序计数器，这样各线程之间的计数器互不影响，这类内存区域也叫作“私有内存”（可以看到其实并不是私有的），之所以这么设计，是因为在多线程的情况下，完全可能出现线程中断的情况，那么当被中断的线程需要回复执行的时候，怎么知道上次该线程执行到哪里了呢？这就需要程序计数器发挥作用了，由于每个线程都有自己的程序计数器，这样当CPU重新调度该线程的时候，从其计数器中取出下一条的字节码执行指令，于是就可以继续执行了</p>
<p><font size="5">执行引擎</font><br>负责执行虚拟机的字节码,先进行编译成机器码后执行</p>
<h4 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h4><p>事实上，堆解决的是数据存储的问题，即数据怎么做，放在哪里，而栈解决的是程序的运行问题，即程序如何执行或者说如何处理数据，而方法区则是辅助堆栈的永久区，解决堆栈信息的产生,比如我们现在要创建一个student类实例<br><img src="/images/imgs5/36.jpg" alt="Alt text"><br>其中栈中存放的是对象的引用</p>
<h4 id="对象创建详细过程"><a href="#对象创建详细过程" class="headerlink" title="对象创建详细过程"></a>对象创建详细过程</h4><p>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有就执行下一步</p>
<p>检查通过后，虚拟机会为新生的对象分配内存，主要由两种内存分配策略，一种是指针碰撞，一种是空闲列表。所谓指针碰撞就是把Java堆中的内存一分为二，一边是所有用过的内存（这部分内存不能被分配了），一边是空闲的内存，是可以被分配的，这样的话，在可用于不可用的内存之间会有一个分割点指示器，那么为对象分配内存实际上就是从这个分界点指示器往空闲内存的一边拨动一段空间就可以了。而空闲列表则没有这个假设，已使用的内存与空闲内存可能是交叉在一起的，那么使用指针碰撞的方式分配内存就会产生问题，但是虚拟机维护着一张列表，这张列表记录了哪些区域的内存是可用的，那么在分配内存的时候就从选择可以容纳对象要求大小的内存区域分配给这个对象</p>
<p>虚拟机将分配到的内存空间都初始化为零（不包括对象头），这里的初始化不同于我们在Java中利用构造函数进行初始化的过程，这里的初始化时保证Java的一些原生数据类型在不重新赋值的时候就可以直接使用，程序在使用这些对象的时候可以直接使用零值。</p>
<p>接下来，虚拟机要对对象一些必要的设置，进行这些设置的目的是可以知道这些对象是哪个类的实例、对象的哈希码、对象的GC分代年龄等信息，这些信息都存储在对象头中。</p>
<p>上面这些工作完成之后，从虚拟机的角度看，一个对象已经构造完成，但是从开发人员的角度看，还需要进行new对象之后初始化，接着执行init方法，到这里一个对象才算真正创建完毕</p>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>主要包括三部分的信息：对象头、实例数据和对齐填充</p>
<p>对象头又包括两部分信息，第一部分用于存储对象自身的运行时数据，比如哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等；第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>实例数据部分是对象真真好存储的有效信息，也是程序代码中所定义的各种类型的字段内容</p>
<p>第三部分不是必然存在的，只是起到占位符的作用，因为HotspotVM规定对象的起始地址必须是8字节的整数倍。所以很有可能以上两部分的大小不够8字节的整数倍，那么这个字段就可以发挥作用了。</p>
<h4 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h4><p>主要是通过Java栈中的reference数据，通过这个reference数据只是一个指向对象的引用，那么对象的访问方式就可以不同。目前主流的对象访问方式主要由句柄和直接指针两种。通过句柄访问的话，会在Java堆中划分出一块句柄池，句柄池中句柄存放了对象的实例数据和类型指针，而reference数据则存放了句柄的地址引用。使用直接指针访问对象，那么reference数据存放的就是对象的地址<br>使用句柄访问的最大好处是reference中存储的稳定的句柄地址，当对象的地址发生了改变可以不用去关心。而直接指针的最大好处是速度更快，在于节省了一次指针定位的时间</p>
<h4 id="OOM异常分类"><a href="#OOM异常分类" class="headerlink" title="OOM异常分类"></a>OOM异常分类</h4><p>Java堆溢出<br>虚拟机栈和本地方法栈溢出<br>方法区和运行常量池溢出<br>本机直接内存溢出</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;引用百度文库上对java虚拟机的定义.&lt;br&gt;虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机
    
    </summary>
    
      <category term="jvm" scheme="http://www.myzwl.win/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://www.myzwl.win/source/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>FastDFS+Nginx搭建分布式图片服务器</title>
    <link href="http://www.myzwl.win/2017/12/20/fastdfs_1/"/>
    <id>http://www.myzwl.win/2017/12/20/fastdfs_1/</id>
    <published>2017-12-20T06:48:51.000Z</published>
    <updated>2018-01-04T13:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>FastDFS是用c语言编写的一款开源的分布式文件系统。充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。其流程如下所示<br><img src="/images/imgs5/28.jpg" alt="Alt text"><br>其中tracker相当于一个管家，在storager与client之间进行交流，最终图片存在storager中。<br>而在传统图片存储中，一般都存在某个服务器的目录中，如果要集群的话，并发量大的话，另一台服务器就访问不到了，所以需要一个专门的图片服务器</p>
<h4 id="上传与下载流程"><a href="#上传与下载流程" class="headerlink" title="上传与下载流程"></a>上传与下载流程</h4><p>上传<br><img src="/images/imgs5/29.jpg" alt="Alt text"><br>下载<br><img src="/images/imgs5/30.jpg" alt="Alt text"></p>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>一.上传需要的软件到linux上<br><img src="/images/imgs5/31.jpg" alt="Alt text"><br>二.linux上安装必要的环境<br>1.安装gcc sudo apt-get install gcc<br>2.安装libevent工具包(ubuntu 16.04不能直接使用命令安装，具体也是谷歌了很久绕一大串才能安装)<br>三.安装libfastcommon（这里将所有文件放在了/usr/local/fast目录下）<br>1.解压缩到相应目录下<br>2.进行编译和安装<br>./make.sh &amp;&amp; ./make.sh install<br>3.把/usr/lib64/libfastcommon.so文件向/usr/lib/下复制一份<br>四。安装Tracker服务<br>1、解压缩<br>2、./make.sh<br>3、./make.sh install<br>安装后在/usr/bin/目录下有以fdfs开头的文件都是编译出来的。<br>配置文件都放到/etc/fdfs文件夹<br>4、把/conf目录下的所有的配置文件都复制到/etc/fdfs下<br>5、配置tracker服务。修改/etc/fdfs/tracker.conf文件。<br>找到base_path=/home/yuqing/fastdfs<br>把后面的路径修改成你服务器上的路径，并且这个目录必须存在。我的是/usr/local/fast/fastdfs<br>6、启动tracker。/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf<br>重启使用命令：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart<br>五。安装storage服务<br>1、如果是在不同的服务器安装，第四步的1~4需要重新执行。<br>2、配置storage服务。修改/etc/fdfs/storage.conf文件<br>需要修改几处。<br>base_path与store_path0改成自己的，我的是/usr/local/fast/storage<br>tracker_server改成自己主机的ip：22122<br>3、启动storage服务。<br>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart<br>六。安装测试<br>1、修改配置文件/etc/fdfs/client.conf将其中的base_path与tracker_server修改<br>2、测试<br>/usr/bin/fdfs_test /etc/fdfs/client.conf upload anti-steal.jpg<br>如果成功的话会提示图片存储路径<br>七。搭建nginx提供http服务<br>上传fastdfs-nginx-module_v1.16.tar.gz<br>1、解压插件压缩包<br>2、修改/fastdfs-nginx-module/src/config文件，把其中的local去掉，同时如果你的是64位的把lib改成lib64<br>3、对nginx重新config<br>./configure \<br>–prefix=/usr/local/nginx \<br>–pid-path=/var/run/nginx/nginx.pid \<br>–lock-path=/var/lock/nginx.lock \<br>–error-log-path=/var/log/nginx/error.log \<br>–http-log-path=/var/log/nginx/access.log \<br>–with-http_gzip_static_module \<br>–http-client-body-temp-path=/var/temp/nginx/client \<br>–http-proxy-temp-path=/var/temp/nginx/proxy \<br>–http-fastcgi-temp-path=/var/temp/nginx/fastcgi \<br>–http-uwsgi-temp-path=/var/temp/nginx/uwsgi \<br>–http-scgi-temp-path=/var/temp/nginx/scgi \<br>–add-module=/usr/local/fast/fastdfs-nginx-module/src<br>注意最后一个是安装的路径，第一个是你自己的nginx路径<br>4、make<br>5、make install<br>6、把/fastdfs-nginx-module/src/mod_fastdfs.conf文件复制到/etc/fdfs目录下。修改<br>tracker_server=192.168.1.172:22122//改成自己的服务器ip地址<br>url_have_group_name = true //改为true，启动组<br>store_path0=/fastdfs/storage //改成自己的图片存储路径<br>7、nginx的配置<br>server {<br>        listen       80;<br>        server_name  localhost;</p>
<pre><code>location /group1/M00/{
        #root /home/FastDFS/fdfs_storage/data;
        ngx_fastdfs_module;
}
</code></pre><p>}<br>8、将libfdfsclient.so拷贝至/usr/lib下<br>cp /usr/lib64/libfdfsclient.so /usr/lib/<br>9.启动nginx</p>
<h4 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h4><p>事情并非一帆风顺的，其中有几个坑需要注意<br>1.如果你的是64位，一定要把上面说的lib改成lib64<br>2.主要上面修改的配置文件中有http.server_port=8888默认的，改成你在nginx中配置的，我配置的是80，就全部改成80，另外cliet那个配置文件是8080，页改成80，不然会出现404错误<br>3.增加权限，在nginx.conf中第一行增加user root；权限<br>最后利用上传时显示的图片地址在浏览器中进行访问即可<br><img src="/images/imgs5/32.jpg" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;FastDFS是用c语言编写的一款开源的分布式文件系统。充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用Fas
    
    </summary>
    
      <category term="分布式" scheme="http://www.myzwl.win/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="FastDFS" scheme="http://www.myzwl.win/source/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>pythonDiary_01之map与reduce</title>
    <link href="http://www.myzwl.win/2017/12/11/python_02/"/>
    <id>http://www.myzwl.win/2017/12/11/python_02/</id>
    <published>2017-12-11T06:48:51.000Z</published>
    <updated>2018-01-04T12:40:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br>比如：list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))<br>把这个list所有数字转为字符串</p>
<p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br>比方说对一个序列求和</p>
<blockquote>
<p>from functools import reduce<br>  def add(x, y):<br>  return x + y<br>reduce(add, [1, 3, 5, 7, 9])</p>
</blockquote>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>在一个有序集合，统计出现所有键的个数</p>
<blockquote>
<p>from functools import reduce<br>def func(lst):<br>  dic={}<br>  for k in lst:<br>   if not k in dic :<br>     dic[k]=1<br>   else :<br>     dic[k]+=1;<br>     return dic<br>lst=[1,1,2,3,2,3,3,5,6,7,7,6,5,5,5]<br>print(func(lst))<br>def func1(lst):<br> m=set(lst)<br> dic={}<br> for x in m:<br>    dic[x]=lst.count(x)<br> return dic<br>ls=[1,1,2,3,2,3,3,5,6,7,7,6,5,5,5]<br>print(func1(ls))<br>def func2(dic,p):<br>   if not p in dic :<br>     dic[p]=1<br>   else :<br>     dic[p]+=1;<br>     return dic<br>print(reduce(func2,ls,{}))</p>
</blockquote>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter()函数用于过滤序列。<br>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br>在一个list中，删掉偶数，只保留奇数，可以这么写：</p>
<blockquote>
<p>def is_odd(n):<br>    return n % 2 == 1<br>list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</p>
<h1 id="结果-1-5-9-15"><a href="#结果-1-5-9-15" class="headerlink" title="结果: [1, 5, 9, 15]"></a>结果: [1, 5, 9, 15]</h1></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator
    
    </summary>
    
      <category term="python" scheme="http://www.myzwl.win/categories/python/"/>
    
    
      <category term="python" scheme="http://www.myzwl.win/source/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pythonDiary_01之数据类型</title>
    <link href="http://www.myzwl.win/2017/12/10/python_01/"/>
    <id>http://www.myzwl.win/2017/12/10/python_01/</id>
    <published>2017-12-10T06:48:51.000Z</published>
    <updated>2017-12-24T05:20:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>人生苦短，我用python。最近为了丰富自己的技术栈，开始学习这门神奇的语言。我的是在linux环境下进行学习，参考了廖雪峰先生的教程进行学习，不多说，下面将介绍python中几种不熟悉的数据元素：列表、元组、字典、set</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表list是一种有序的集合，可以随时添加和删除其中的元素<br>1.1初始化列表</p>
<blockquote>
<p>list=[‘java’,’php’,’c’,’python’]</p>
</blockquote>
<p>1.2访问列表中的值<br>列表引用[索引号]，如list[0],下标从0开始，-1表示最后一个，依次类推</p>
<p>1.3更新列表<br>直接将列表中值重新赋值，如list[0]=‘c++’</p>
<p>1.4删除列表元素<br>del list[0]</p>
<p>1.5列表操作符</p>
<blockquote>
<p>[1,2]+[4,5]  #[1,2,4,5]<br>[‘h’]*4 #[‘h’,’h’,’h’,’h’]<br>1 in [1,2] #true<br>for yy in [‘x’,’y’] # ‘x’,’y’</p>
</blockquote>
<p>1.6列表截取</p>
<blockquote>
<p>list=[‘java’,’php’,’c’,’python’]<br>list[0] #java<br>list[-1] #python<br>list[1:3] # c python 其中list[：-1]默认第一个是从0开始，list[0:]最后一个不写默认是最后一个</p>
</blockquote>
<p>1.7列表函数与方法</p>
<blockquote>
<p>list.append(obj) #末尾添加新对象<br>list.count(obj)   #统计某个元素在列表中出现的次数<br>list.extend(seq)  #在列表末尾一次性追加里一个序列<br>list.index(obj)   #找出第一个匹配值的序列<br>list.insert(index,obj)  #指定索引位置插入<br>list.pop(index)       #按索引溢出列表中元素，默认最后一个<br>list.remove(obj)     #按值移除<br>list.reverse()      #倒转<br>list.sort()        #排序</p>
</blockquote>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组tuple和list非常类似，但是tuple一旦初始化就不能修改，而且元组使用（）定义，列表使用[]<br>初始化<br>tuple=(‘java’,’python’,’c’,’php’)<br>只有一个元素需要添加逗号<br>tuple=(‘java’,)<br>空元组<br>tuple=()</p>
<p>元组内置函数</p>
<blockquote>
<p>cmp(t1,t2) #比较两个元组元素<br>len(t)      #计算元组元素的个数<br>max(t)      #返回元组中元素最大值<br>min(t)      #。。最小值<br>tuple(seq)  #列表转化为元组</p>
</blockquote>
<p>其余操作和列表基本一致</p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度<br>1.1初始化字典<br>如dict={‘java’:’hello’,’c’:’world’,’python’:’hi’}<br>1.2 访问字典的值<br>dict[‘java’] #hello<br>1.3修改字典</p>
<blockquote>
<p>dict[‘java’]=’we’ #修改<br>dict[‘c++’]=’lol’ #增加<br>del dict[‘java’] #删除键<br>dict.clear()    #清空字典<br>del dict        #删除词典</p>
</blockquote>
<p>1.4字典内置函数</p>
<blockquote>
<p>1.cmp(dict1, dict2)<br>比较两个字典元素<br>2    len(dict)<br>计算字典元素个数，即键的总数。<br>3    str(dict)<br>输出字典可打印的字符串表示。<br>4    type(variable)<br>返回输入的变量类型，如果变量是字典就返回字典类型。<br>Python字典包含了以下内置方法：<br>1    dict.clear()<br>删除字典内所有元素<br>2    dict.copy()<br>返回一个字典的浅复制<br>3    dict.fromkeys(seq[, val])<br>创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值<br>4    dict.get(key, default=None)<br>返回指定键的值，如果值不在字典中返回default值<br>5    dict.has_key(key)<br>如果键在字典dict里返回true，否则返回false<br>6    dict.items()<br>以列表返回可遍历的(键, 值) 元组数组<br>7    dict.keys()<br>以列表返回一个字典所有的键<br>8    dict.setdefault(key, default=None)<br>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default<br>9    dict.update(dict2)<br>把字典dict2的键/值对更新到dict里<br>10    dict.values()<br>以列表返回字典中的所有值<br>11    pop(key[,default])<br>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。<br>12    popitem()<br>随机返回并删除字典中的一对键和值。</p>
</blockquote>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。<br>要创建一个set，需要提供一个list作为输入集合：<br>s = set([1, 2, 3])<br>其余和字典差不多</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;人生苦短，我用python。最近为了丰富自己的技术栈，开始学习这门神奇的语言。我的是在linux环境下进行学习，参考了廖雪峰先生的教程进行学
    
    </summary>
    
      <category term="python" scheme="http://www.myzwl.win/categories/python/"/>
    
    
      <category term="python" scheme="http://www.myzwl.win/source/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>solr笔记之二</title>
    <link href="http://www.myzwl.win/2017/11/10/solr_2/"/>
    <id>http://www.myzwl.win/2017/11/10/solr_2/</id>
    <published>2017-11-10T06:48:51.000Z</published>
    <updated>2017-12-18T10:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="solrj的基本使用"><a href="#solrj的基本使用" class="headerlink" title="solrj的基本使用"></a>solrj的基本使用</h4><p>环境准备<br>新建一个java工程，然后添加如下jar包<br><img src="/images/imgs5/27.jpg" alt="Alt text"><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//远程连接的solr服务器地址</div><div class="line">private static final String URL="http://111.230.246.33:8080/solr";</div><div class="line">	</div><div class="line">	public void search()throws Exception&#123;</div><div class="line">		//solr服务</div><div class="line">		SolrServer solr=new HttpSolrServer(URL);</div><div class="line">		//查询对象</div><div class="line">		SolrQuery query=new SolrQuery();</div><div class="line">		//设置查询条件,名称“q”是固定的且必须的</div><div class="line">		query.set("q", "title:zwl");</div><div class="line">		// 请求查询</div><div class="line">		QueryResponse res=solr.query(query);</div><div class="line">		// 查询结果</div><div class="line">		SolrDocumentList list=res.getResults();</div><div class="line">		// 查询文档总数</div><div class="line">		long num=list.getNumFound();</div><div class="line">		System.out.println(num);</div><div class="line">		for(SolrDocument sd :list)&#123;</div><div class="line">			String id=(String)sd.get("id");</div><div class="line">			//String title=(String)sd.get("title");</div><div class="line">			System.out.println(id);</div><div class="line">		//	System.out.println(title);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void del()throws Exception&#123;</div><div class="line">		SolrServer solr=new HttpSolrServer(URL);</div><div class="line">		solr.deleteById("5");</div><div class="line">		solr.commit();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void add() throws Exception&#123;</div><div class="line">		//实例化solr对象</div><div class="line">		SolrServer solr=new HttpSolrServer(URL);</div><div class="line">		SolrInputDocument doc1=new SolrInputDocument();</div><div class="line">		doc1.setField("id", "5");</div><div class="line">		doc1.setField("title", "dx");</div><div class="line">		solr.add(doc1);</div><div class="line">		solr.commit();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>注意：以上的索引都是在配置文件中已声明了，如：<br><!--IKAnalyzer Field--></p>
<p><field name="title_ik" type="text_ik" indexed="true" stored="true"></field></p>
<p><field name="content_ik" type="text_ik" indexed="true" stored="false" multivalued="true"><br>type可以为具体类型，也可以为一个分词器</field></p>
<h4 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h4><ol>
<li>q - 查询字符串，必须的，如果查询所有使用<em>:</em></li>
<li>fq - （filter<br>query）过虑查询，作用：在q查询符合结果中同时是fq查询符合的，例如product_price:[1 TO 20]<br>过滤查询价格从1到20的记录<br>3.sort - 排序，格式：sort=<field name="">+<desc|asc>[,<field name="">+<desc|asc>]…<br>如 product_price desc 按价格降序排序</desc|asc></field></desc|asc></field></li>
<li>start - 分页显示使用，开始记录下标，从0开始</li>
<li>rows - 指定返回结果最多有多少条记录，配合start来实现分页。</li>
<li>fl - 指定返回那些字段内容，用逗号或空格分隔多个<br>7.df-指定一个搜索Field</li>
<li>wt - (writer type)指定输出格式，可以有xml, json, php, phps, 后面solr<br>1.3增加的，要用通知我们，因为默认没有打开。</li>
<li>hl 是否高亮,设置高亮Field，设置格式前缀和后缀。<br>10 组合查询：使用and or等等</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;solrj的基本使用&quot;&gt;&lt;a href=&quot;#solrj的基本使用&quot; class=&quot;headerlink&quot; title=&quot;solrj的基本使用&quot;&gt;&lt;/a&gt;solrj的基本使用&lt;/h4&gt;&lt;p&gt;环境准备&lt;br&gt;新建一个java工程，然后添加如下jar包&lt;br&gt;&lt;img 
    
    </summary>
    
      <category term="solr" scheme="http://www.myzwl.win/categories/solr/"/>
    
    
      <category term="solr" scheme="http://www.myzwl.win/source/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>solr笔记之一</title>
    <link href="http://www.myzwl.win/2017/11/09/solr_1/"/>
    <id>http://www.myzwl.win/2017/11/09/solr_1/</id>
    <published>2017-11-09T06:48:51.000Z</published>
    <updated>2017-12-18T05:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>使用传统的数据库查询方式实现搜索无法满足一些高级需求，比如：搜索速度要快、搜索结果按相关度排序、搜索内容不固定，一般可以单独使用Lucene或者使用google或者百度接口或者使用solr实现全文检索。而solr是基于lucene，是一个服务器，在各方面都相对优越<br><img src="/images/imgs5/24.jpg" alt="Alt text"></p>
<h4 id="redis环境搭建"><a href="#redis环境搭建" class="headerlink" title="redis环境搭建"></a>redis环境搭建</h4><p>有如下步骤</p>
<blockquote>
<p>1.上传solr压缩包solr-4.10.3.tgz.tar到linux上<br>2.解压到/usr/local下，tar -zxvf solr-4.10.3.tgz.tar -C /usr/local/<br>3.进入目录: cd solr-4.10.3/example/webapps/<br>4.拷贝其下的war文件到tomcat的webapps中：cp solr.war /usr/local/tomcat/webapps/(tomcat启动，自动解压war包)<br>5.进入solr文件，修改其中一些文件: vim solr/WEB-INF/web.xml 找到nv-entry内容，解开注释，并修改solr/home的地址：我的是/usr/local/solr-4.10.3/example/solr<br>6.拷贝相关jar包到tomcat下 cd /usr/local/solr-4.10.3/example/lib/ext &amp;&amp; cp * /usr/local/tomcat/lib/<br>7.重启tomcat</p>
</blockquote>
<p>然后通过浏览器访问，如看到下面的solr主页即可<br><img src="/images/imgs5/25.jpg" alt="Alt text"><br>至此我们可以通过可视化页面对数据进行增删改查操作，其中solr是以id为标识的，并且根据不同的分词器进行分词，而索引字段是在服务器配置文件中已定义好的（可自定义）</p>
<h4 id="相关文件说明"><a href="#相关文件说明" class="headerlink" title="相关文件说明"></a>相关文件说明</h4><p>solrhome：目录中包括了运行solr实例的所有的配置文件和数据文件，是运行的主目录，可包括多个solrcore<br>solrcore：提供单独的搜索和索引服务<br>如可视化界面中的collection1</p>
<h4 id="solr索引"><a href="#solr索引" class="headerlink" title="solr索引"></a>solr索引</h4><p>schema.xml，在solrcore的conf目录下，它是solr数据表配置文件，它定义了加入索引的数据的数据类型。主要包括FiledTypes、Filed和其他的一些缺省设置<br><img src="/images/imgs5/26.jpg" alt="Alt text"><br>FieldType域类型<br>text_general是solr默认的域类型<br>子节点<br>name：是这个FieldType的名称<br>class：是Solr提供的包solr.TextField，solr.TextField<br>允许用户通过分析器来定制索引和查询，分析器包括一个分词器（tokenizer）<br>和多个过滤器（filter）<br>positionIncrementGap：可选属性，定义在同一个文档中此类型数据的空白<br>间隔，避免短语匹配错误，此值相当于Lucene的短语查询设置slop值，根据经<br>验设置为100。<br>在FieldType定义的时候最重要的就是定义这个类型的数据在建立索引和进<br>行查询的时候要使用的分析器analyzer,包括分词和过滤<br>索引分析器中：使用solr.StandardTokenizerFactory标准分词器，solr.StopFilte<br>rFactory停用词过滤器，solr.LowerCaseFilterFactory小写过滤器。<br>搜索分析器中：使用solr.StandardTokenizerFactory标准分词器，solr.StopFilte<br>rFactory停用词过滤器，这里还用到了solr.SynonymFilterFactory同义词过滤器</p>
<p>Field定义<br>在fields结点内定义具体的Field，filed定义包括name,type（为之前定义过的<br>各种FieldType）,indexed（是否被索引）,stored（是否被储存），multiValued（<br>是否存储多个值）等属性。<br>如下：</p>
<p><field name="name" type="text_general" indexed="true" stored="true"></field></p>
<p><field name="features" type="text_general" indexed="true" stored="true" multivalued="true"><br>multiValued：该Field如果要存储多个值时设置为true，solr允许一个Field存<br>储多个值，比如存储一个用户的好友id（多个），商品的图片（多个，大图和<br>小图），通过使用solr查询要看出返回给客户端是数组</field></p>
<p>uniqueKey<br>Solr中默认定义唯一主键key为id域，如下：<br>Solr在删除、更新索引时使用id域进行判断，也可以自定义唯一主键</p>
<p>copyField复制域<br>copyField复制域，可以将多个Field复制到一个Field中，以便进行统一的检索</p>
<p>dynamicField（动态字段）<br>动态字段就是不用指定具体的名称，只要定义字段名称的规则，例如定义<br>一个dynamicField，name<br>为*_i，定义它的type为text，那么在使用这个字段的时候，任何以_i结尾的字段<br>都被认为是符合这个定义的，例如：name_i，gender_i，school_i等</p>
<h4 id="配置中文分词器"><a href="#配置中文分词器" class="headerlink" title="配置中文分词器"></a>配置中文分词器</h4><p>具体步骤如下</p>
<blockquote>
<p>1.下载并解压IKAnalyzer<br>2.将IKAnalyzer2012FF_u1.jar拷贝到Tomcat的webapps/solr/WEB-INF/lib 下。<br>3在Tomcat的webapps/solr/WEB-INF/下创建classes目录<br>4.将IKAnalyzer.cfg.xml、ext_stopword.dic mydict.dic copy到Tomcat的webapps/solr/WEB-INF/classes<br>5.修改solr core的schema文件添加FieldType：<br><!-- IKAnalyzer--></p>
<p><fieldtype name="text_ik" class="solr.TextField"></fieldtype></p>
<p><analyzer type="index" ismaxwordlength="false" class="org.wltea.analyzer.lucene.IKAnalyzer"></analyzer></p>
<p><analyzer type="query" ismaxwordlength="true" class="org.wltea.analyzer.lucene.IKAnalyzer"><br><br>6.重启tomcat</analyzer></p>
</blockquote>
<p>这样配置后，中文分词就会有很好的分词效果</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;使用传统的数据库查询方式实现搜索无法满足一些高级需求，比如：搜索速度要快、搜索结果按相关度排序、搜索内容不固定，一般可以单独使用Lucene
    
    </summary>
    
      <category term="solr" scheme="http://www.myzwl.win/categories/solr/"/>
    
    
      <category term="solr" scheme="http://www.myzwl.win/source/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>FreeMarker笔记之基础知识</title>
    <link href="http://www.myzwl.win/2017/11/08/freemarker_1/"/>
    <id>http://www.myzwl.win/2017/11/08/freemarker_1/</id>
    <published>2017-11-08T06:48:51.000Z</published>
    <updated>2017-12-17T12:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>FreeMarker是一个模板引擎，一个基于模板生成文本输出的通用工具。简单比如来说，html作为只关心前台，无后台数据，而后台数据通过freemarker模板来定义数据，然后在html中取出数据</p>
<h4 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h4><p>不妨以一个hello world程序作为入门，然后在研究它<br>1.建立一个普通的java项目<br>2.引入freemarker.jar包<br>3.在项目目录下建立模板目录：templates<br>4.在templates目录下，建立一个xx.ftl文件，内容如下</p>
<blockquote>
<p>hello，${msg}</p>
</blockquote>
<p>5.然后建立一个测试类：</p>
<blockquote>
<p>public static void main(String[] args) throws Exception {<br>        //创建Freemarker配置实例<br>        Configuration cfg = new Configuration();<br>        cfg.setDirectoryForTemplateLoading(new File(“templates”));<br>        //创建数据模型<br>        Map root = new HashMap();<br>        root.put(“msg”, “world”);<br>        //加载模板文件<br>        Template t1 = cfg.getTemplate(“a.ftl”);<br>        //显示生成的数据,//将合并后的数据打印到控制台<br>        Writer out = new OutputStreamWriter(System.out);<br>        t1.process(root, out);<br>        out.flush();<br>    }</p>
</blockquote>
<p>输出结果：<br>hello，world</p>
<h4 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h4><p>不妨先看例子<br>测试类中添加如下语句<br>root.put(“random”, new Random().nextInt(100));</p>
<p>模板文件添加如下语句</p>
<blockquote>
<p>if语句测试：</p>
<h2 id="msg-是-lt-if-msg-”world”-gt-is-right-lt-if-gt"><a href="#msg-是-lt-if-msg-”world”-gt-is-right-lt-if-gt" class="headerlink" title="${msg}是&lt;#if msg==”world”&gt;is right&lt;/#if&gt;"></a>${msg}是&lt;#if msg==”world”&gt;is right&lt;/#if&gt;</h2><p>if else 语句测试：<br>&lt;#if random gt 60&gt;<br>    及格！<br>&lt;#else&gt;<br>    不及格！</p>
<h2 id="lt-if-gt"><a href="#lt-if-gt" class="headerlink" title="&lt;/#if&gt;"></a>&lt;/#if&gt;</h2><p>if else if else语句测试：<br>&lt;#if random gte 90&gt;<br>    优秀！<br>&lt;#elseif random gte 80&gt;<br>    良好！<br>&lt;#else&gt;<br>    一般！<br>&lt;/#if&gt;</p>
</blockquote>
<p>随机输出结果:<br>if语句测试：</p>
<h2 id="gt-world是is-right"><a href="#gt-world是is-right" class="headerlink" title="&gt;world是is right"></a>&gt;world是is right</h2><p>if else 语句测试：</p>
<pre><code>及格！
</code></pre><hr>
<p>if else if else语句测试：<br>    优秀！</p>
<p>其中运用了比较运算符</p>
<ol>
<li>=（或者==）： 判断两个值是否相等；</li>
<li>!=： 判断两个值是否不相等；<br>注： =和!=可以用作字符串、数值和日期的比较，但两边的数据类型必须相同。而且FreeMarker的比较是精确比较，不会忽略大小写及空格。</li>
<li><blockquote>
<p>（或者gt）： 大于</p>
</blockquote>
</li>
<li><blockquote>
<p>=（或者gte）： 大于等于</p>
</blockquote>
</li>
<li>&lt;（或者lt）： 小于</li>
<li>&lt;=（或者lte）： 小于等于<br>注： 上面这些比较运算符可以用于数字和日期，但不能用于字符串。大部分时候，使用gt比&gt;有更好的效果，因为FreeMarker会把&gt;解释成标签的结束字符。可以使用括号来避免这种情况，如：&lt;#if (x&gt;y)&gt;。</li>
</ol>
<h4 id="list指令"><a href="#list指令" class="headerlink" title="list指令"></a>list指令</h4><p>首先添加一个address类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Address &#123;</div><div class="line"></div><div class="line">	</div><div class="line">	private String country;</div><div class="line">	public String getCountry() &#123;</div><div class="line">		return country;</div><div class="line">	&#125;</div><div class="line">	public void setCountry(String country) &#123;</div><div class="line">		this.country = country;</div><div class="line">	&#125;</div><div class="line">	public String getCity() &#123;</div><div class="line">		return city;</div><div class="line">	&#125;</div><div class="line">	public void setCity(String city) &#123;</div><div class="line">		this.city = city;</div><div class="line">	&#125;</div><div class="line">	public Address(String country, String city) &#123;</div><div class="line">		super();</div><div class="line">		this.country = country;</div><div class="line">		this.city = city;</div><div class="line">	&#125;</div><div class="line">	private String city;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后测试类中添加如下语句</p>
<blockquote>
<p>List list = new ArrayList();<br>        list.add(new Address(“中国”,”北京”));<br>        list.add(new Address(“中国”,”上海”));<br>        list.add(new Address(“美国”,”纽约”));<br>        root.put(“lst”, list);</p>
</blockquote>
<p>模板文件添加如下</p>
<blockquote>
<p>测试list指令：<br>&lt;#list lst as temp &gt;<br>    <b>${temp.country}</b> <br><br>&lt;/#list&gt;</p>
</blockquote>
<h4 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h4><p>在templates目录下随便写一个文件，比如tt.txt，里面目前只有test字符<br>模板文件增加如下：<br>&lt;#include “tt.txt” /&gt;<br>将增加tt.txt里面的文本内容到该模板文件中</p>
<h4 id="macro指令"><a href="#macro指令" class="headerlink" title="macro指令"></a>macro指令</h4><p>该指令为宏指令，相当于定义函数和参数<br>第一个为函数名，后面为参数可有可无<br>如：</p>
<blockquote>
<p>&lt;#macro tt&gt;<br>hello<br>world<br>&lt;/#macro&gt;</p>
</blockquote>
<p>引用&lt;@tt /&gt;<br>输出结果<br>hello<br>world</p>
<p>定义待参宏指令<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-id">#macro</span> func <span class="selector-tag">a</span> b&gt;</div><div class="line">$&#123;a&#125;,$&#123;b&#125;</div><div class="line">&lt;/#macro&gt;</div><div class="line"></div><div class="line">&lt;@func a=<span class="string">'hello'</span> b=<span class="string">'world'</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>输出结果为hello，world</p>
<p>nested指令<br>该指定是插入引入的内容到相应位置如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-id">#macro</span> <span class="attribute">border</span>&gt; </div><div class="line"> before </div><div class="line">    &lt;#nested&gt; </div><div class="line">    after</div><div class="line">&lt;/#macro&gt;</div><div class="line"></div><div class="line">&lt;@<span class="attribute">border</span> &gt;now&lt;/@border&gt;</div></pre></td></tr></table></figure></p>
<p>输出结果为<br>before now after</p>
<p>命名空间<br>当运行 FTL 模板时，就会有使用 assign 和 macro 指令创建的变量的集合，当引用不同的模板，就需要使用import指令<br>比如创建如下b.ftl<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-id">#macro</span> copyright date&gt;</div><div class="line">  &lt;p&gt;Copyright (C) $&#123;date&#125; &lt;/p&gt; </div><div class="line">&lt;/#macro&gt; </div><div class="line">&lt;<span class="selector-id">#assign</span> mail = <span class="string">"zwl"</span>&gt;</div><div class="line"></div><div class="line">在测试模板中</div><div class="line">测试命名空间：</div><div class="line">&lt;<span class="selector-id">#import</span> <span class="string">"b.ftl"</span> as bb  /&gt;</div><div class="line">&lt;@bb<span class="selector-class">.copyright</span> date=<span class="string">"2013-2017"</span> /&gt;</div><div class="line">$&#123;bb.mail&#125;</div></pre></td></tr></table></figure></p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>一、直接指定值<br>直接指定值可以是字符串、数值、布尔值、集合及Map对象。</p>
<ol>
<li><p>字符串<br>直接指定字符串值使用单引号或双引号限定。字符串中可以使用转义字符”\”。如果字符串内有大量的特殊字符，则可以在引号的前面加上一个字母r，则字符串内的所有字符都将直接输出。</p>
</li>
<li><p>数值<br>数值可以直接输入，不需要引号。FreeMarker不支持科学计数法。</p>
</li>
<li><p>布尔值<br>直接使用true或false，不使用引号。</p>
</li>
<li><p>集合<br>集合用中括号包括，集合元素之间用逗号分隔。<br>使用数字范围也可以表示一个数字集合，如1..5等同于集合[1, 2, 3, 4, 5]；同样也可以用5..1来表示[5, 4, 3, 2, 1]。</p>
</li>
<li><p>Map对象<br>Map对象使用花括号包括，Map中的key-value对之间用冒号分隔，多组key-value对之间用逗号分隔。<br>注意：Map对象的key和value都是表达式，但key必须是字符串</p>
</li>
</ol>
<p>6.时间对象<br>如：root.put(“date1”, new Date());<br>输出:${date1?string(“yyyy-MM-dd HH:mm”)}<br>其中后面的为日期输出格式</p>
<ol>
<li>JAVABEAN的处理<br>Freemarker中对于javabean的处理跟EL表达式一致，类型可自动转化</li>
</ol>
<p>二、输出变量值<br>FreeMarker的表达式输出变量时，这些变量可以是顶层变量，也可以是Map对象的变量，还可以是集合中的变量，并可以使用点（.）语法来访问Java对象的属性。</p>
<ol>
<li>顶层变量<br>所谓顶层变量就是直接放在数据模型中的值。输出时直接用${variableName}即可</li>
</ol>
<p>输出集合元素<br>可 以根据集合元素的索引来输出集合元素，索引用中括号包括。如： 输出[“1”， “2”， “3”]这个名为number的集合，可以用${number[0]}来输出第一个数字。FreeMarker还支持用number[1..2]来表示原 集合的子集合[“2”， “3”]。</p>
<ol>
<li><p>输出Map元素<br>对于JavaBean实例，FreeMarker一样把它看作属性为key，属性值为value的Map对象。<br>输出Map对象时，可以使用点语法或中括号语法，如下面的几种写法的效果是一样的：</p>
<pre><code>book.author.name                                                                                book.author[&quot;name&quot;]                                                                              book[&quot;author&quot;].name                                                                            book[&quot;author&quot;][&quot;name&quot;]                                            
</code></pre><p>字符串操作</p>
</li>
<li>字符串连接<br>直接使用+连接<br>截取子串<br>截取子串可以根据字符串的索引来进行，如果指定一个索引值，则取得字符串该索引处的字符；如果指定两个索引值，则截取两个索引中间的字符串子串。如：<pre><code>&lt;#assign number=&quot;01234&quot;&gt;
${number[0]} &lt;#-- 输出字符0 --&gt;
${number[0..3]} &lt;#-- 输出子串“0123” --&gt;
</code></pre></li>
</ol>
<p>内建函数<br>FreeMarker提供了一些内建函数来转换输出，可以在任何变量后紧跟?，?后紧跟内建函数，就可以通过内建函数来转换输出变量。</p>
<p>字符串相关常用的内建函数：</p>
<ol>
<li>html： 对字符串进行HTML编码；</li>
<li>cap_first： 使字符串第一个字母大写；</li>
<li>lower_case： 将字符串转成小写；</li>
<li>upper_case： 将字符串转成大写；</li>
</ol>
<p>集合相关常用的内建函数：</p>
<ol>
<li>size： 获得集合中元素的个数；</li>
</ol>
<p>数字值相关常用的内建函数：</p>
<ol>
<li>int： 取得数字的整数部分。</li>
</ol>
<p>举例：<br>root.put(“htm2”, “<b>粗体</b>“);<br>内建函数：<br>${htm2?html}</p>
<p>其它类型<br>集合连接操作<br>Map连接操作<br>算术运算符<br>比较运算符<br>逻辑运算符<br>空值处理运算符</p>
<p>数据类型常见示例<br> 直接指定值<br>   字符串 ： “Foo”或 者’Foo’或”It’s \”quoted\””或r”C:\raw\string”<br>   数字：123.45<br>   布尔值：true, false<br>   序列：[“foo”, “bar”, 123.45], 1..100<br>   哈希表：{“name”:”green mouse”, “price”:150}<br>   检索变量    顶层变量：user<br>   从哈希表中检索数据：user.name, user[“name”]<br>   从序列中检索：products[5]<br>   特殊变量：.main<br>   字符串操作<br>   插值（或连接）：”Hello ${user}!”（或”Free” + “Marker”）<br>   获取一个字符：name[0]<br>   序列操作<br>   连接：users + [“guest”]<br>   序列切分：products[10..19]  或  products[5..]<br>   哈希表操作<br>   连接：passwords + {“joe”:”secret42”}<br>   算数运算: (x * 1.5 + 10) / 2 - y % 100<br>   比 较 运 算 ： x == y,   x != y,   x &lt; y,   x &gt; y,   x &gt;= y,   x &lt;= y,<br>x &lt; y,  等等<br>    逻辑操作：!registered &amp;&amp; (firstVisit || fromEurope)<br>    内建函数：name?upper_case<br>    方法调用：repeat(“What”, 3)<br>   处理不存在的值<br>   默认值：name!”unknown”  或者(user.name)!”unknown”  或者<br>name!  或者  (user.name)!<br>   检测不存在的值：name?? 或者(user.name)??</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;FreeMarker是一个模板引擎，一个基于模板生成文本输出的通用工具。简单比如来说，html作为只关心前台，无后台数据，而后台数据通过fr
    
    </summary>
    
      <category term="FreeMarker" scheme="http://www.myzwl.win/categories/FreeMarker/"/>
    
    
      <category term="FreeMarker" scheme="http://www.myzwl.win/source/tags/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记四之搭建伪集群</title>
    <link href="http://www.myzwl.win/2017/11/07/redis_4/"/>
    <id>http://www.myzwl.win/2017/11/07/redis_4/</id>
    <published>2017-11-07T06:48:51.000Z</published>
    <updated>2017-12-08T08:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在redis3.0之前，提供了哨兵的机制，即如果主服务器down掉，哨兵会监听到并且通知一个从服务器使其成为主服务器。但是可以通过集群解决这一问题，即分别分配多组不同的主从服务器，并且每次存储的业务数据不同与存储的机器也不一样，也就是真正的分布式系统，大大提高了容错率，由于笔者目前只有两台linux服务器，所以只是在其中一台上通过建立6个目录来模拟集群，真正的集群是将目录换成机器<br>不多说，实践是检验真理的唯一标准</p>
<h4 id="集群搭建步骤"><a href="#集群搭建步骤" class="headerlink" title="集群搭建步骤"></a>集群搭建步骤</h4><p>第一步：创建一个文件夹redis-cluster，然后在其下面分别创建6个文件夹如下：</p>
<blockquote>
<p>1.mkdir -p /usr/local/redis-cluster<br>2.mkdir 1001,mkdir 1002,mkdir 1003,mkdir 1004,mkdir 1005,mkdir 1006</p>
</blockquote>
<p>第二步：把之前的redis.conf配置文件分别copy到1001-1006文件夹下，然后需要修改下面信息，</p>
<blockquote>
<p>1.daemonize yes 后端启动<br>2 port 700*（分别对每个机器的端口号设置，注意每个文件夹这里不一样）</p>
<ol>
<li>bind 127.0.0.1(绑定当前机器的ip)</li>
<li>dir /usr/local/redis-cluster/700<em>/（指定数据文件的存放位置，每个文件夹对应不同文件）<br>5.cluster-enabled yes(启动集群模式)<br>6.cluster-config-file nodes700</em>.conf(集群的配置文件)<br>7.cluster-node-timeout 15000 集群失效时间<br>8.appendonly yes 开启aof日志方式</li>
</ol>
</blockquote>
<p>第三步：安装ruby（针对不同的linux版本，命令不一样）</p>
<blockquote>
<p>sudo apt-get install ruby<br> sudo apt-get install rubygems<br> gem install redis</p>
</blockquote>
<p> 第四步：分别启动6个redis实例，然后检查是否启动成功</p>
<blockquote>
<p>/usr/local/redis3/bin/redis-server /usr/local/redis-cluster/700*/redis.conf<br> 同时redis的同一个服务，但是对于的redis.conf不同<br> 查看是否启动成功<br> ps -ef | grep redis</p>
</blockquote>
<p> 第五步：找到redis的安装目录，在src下找到redis-trib.rb文件</p>
<blockquote>
<p>./redis-trib.rb create–replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006<br> 其中参数1是主从对应关系，也就说前面三个是主，后面三个是从，是1:1</p>
</blockquote>
<p> 第六步：检测集群是否成功<br> 使用命令netstat -tunp | grep redis<br> 如果出现上面几个端口，证明集群成功</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在redis3.0之前，提供了哨兵的机制，即如果主服务器down掉，哨兵会监听到并且通知一个从服务器使其成为主服务器。但是可以通过集群解决这
    
    </summary>
    
      <category term="分布式" scheme="http://www.myzwl.win/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="redis" scheme="http://www.myzwl.win/source/tags/redis/"/>
    
  </entry>
  
</feed>
