<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秒西</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.myzwl.win/"/>
  <updated>2017-07-16T01:05:18.000Z</updated>
  <id>http://www.myzwl.win/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shiro之会话管理</title>
    <link href="http://www.myzwl.win/2017/07/05/shiro_5/"/>
    <id>http://www.myzwl.win/2017/07/05/shiro_5/</id>
    <published>2017-07-05T05:48:51.000Z</published>
    <updated>2017-07-16T01:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shiro提供了完整的会话功能，不依赖于底层容器，即直接使用shiro的会话管理可以直接替换掉web容器的会话管理</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。</p>
<p><strong>获取会话</strong></p>
<blockquote>
<p>Subject subject = SecurityUtils.getSubject();<br>Session session = subject.getSession();  </p>
</blockquote>
<p><strong>获取当前会话的唯一标识</strong></p>
<blockquote>
<p>session.getId(); </p>
</blockquote>
<p><strong>获取当前Subject的主机地址</strong></p>
<blockquote>
<p>session.getHost();</p>
</blockquote>
<p><strong>获取/设置当前Session的过期时间</strong></p>
<blockquote>
<p>session.getTimeout();<br>session.setTimeout(毫秒); </p>
</blockquote>
<p><strong>获取会话的启动时间及最后访问时间</strong></p>
<blockquote>
<p>session.getStartTimestamp();<br>session.getLastAccessTime();</p>
</blockquote>
<p><strong>更新会话最后访问时间及销毁会话</strong></p>
<blockquote>
<p>session.touch();<br>session.stop();</p>
</blockquote>
<p>当Subject.logout()时会自动调用stop方法来销毁会话</p>
<p><strong>设置/获取/删除会话属性</strong></p>
<blockquote>
<p>session.setAttribute(“key”, “WORD”);<br>session.getAttribute(“key”);<br>session.removeAttribute(“key”); </p>
</blockquote>
<h4 id="会话管理器"><a href="#会话管理器" class="headerlink" title="会话管理器"></a>会话管理器</h4><p>会话管理器管理着应用中所有subject的会话的创建、维护、删除、失效、验证等工作。它是shiro的核心，顶层组件SecurityManager直接继承了SessionManager，且提供了SessionsSecurityManager实现直接把会话管理委托给相应的SessionManager，DefaultSecurityManager及DefaultWebSecurityManager默认SecurityManager都继承了SessionsSecurityManager。</p>
<p><strong>SecurityManager</strong></p>
<blockquote>
<p>Session start(SessionContext context); //启动会话<br>Session getSession(SessionKey key) throws SessionException; //根据会话Key获取会话 </p>
</blockquote>
<p><strong>WebSessionManager</strong></p>
<blockquote>
<p>boolean isServletContainerSessions();//是否使用Servlet容器的会话  </p>
</blockquote>
<p><strong>ValidatingSessionManager</strong></p>
<blockquote>
<p>void validateSessions();//验证所有会话是否过期 </p>
</blockquote>
<p><img src="/images/imgs4/5.gif" alt="Alt text"></p>
<p>Shiro提供了三个默认实现：</p>
<p>DefaultSessionManager：DefaultSecurityManager使用的默认实现，用于JavaSE环境；</p>
<p>ServletContainerSessionManager：DefaultWebSecurityManager使用的默认实现，用于Web环境，其直接使用Servlet容器的会话；</p>
<p>DefaultWebSessionManager：用于Web环境的实现，可以替代ServletContainerSessionManager，自己维护着会话，直接废弃了Servlet容器的会话管理。</p>
<p><strong>全局会话时间</strong><br>在web.xml中设置(单位：分钟)</p>
<blockquote>
<p><session-config><br>  <session-timeout>30</session-timeout><br></session-config> </p>
</blockquote>
<h4 id="会话监听器"><a href="#会话监听器" class="headerlink" title="会话监听器"></a>会话监听器</h4><p>会话监听器用于监听会话创建、过期及停止事件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MySessionListener1 implements SessionListener &#123;  </div><div class="line">     @Override  </div><div class="line">     public void onStart(Session session) &#123;//会话创建时触发  </div><div class="line">         System.out.println("会话创建：" + session.getId());  </div><div class="line">     &#125;  </div><div class="line">     @Override  </div><div class="line">     public void onExpiration(Session session) &#123;//会话过期时触发  </div><div class="line">         System.out.println("会话过期：" + session.getId());  </div><div class="line">     &#125;  </div><div class="line">     @Override  </div><div class="line">     public void onStop(Session session) &#123;//退出/会话过期时触发  </div><div class="line">         System.out.println("会话停止：" + session.getId());  </div><div class="line">     &#125;    </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>如果只想监听某一个事件，可以继承SessionListenerAdapter实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class MySessionListener2 extends SessionListenerAdapter &#123;  </div><div class="line">    @Override  </div><div class="line">    public void onStart(Session session) &#123;  </div><div class="line">        System.out.println("会话创建：" + session.getId());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="会话存储-持久化"><a href="#会话存储-持久化" class="headerlink" title="会话存储/持久化"></a>会话存储/持久化</h4><p>Shiro提供SessionDAO用于会话的CRUD</p>
<blockquote>
<pre><code>//如DefaultSessionManager在创建完session后会调用该方法；如保存到关系数据库/文件系统/NoSQL数据库；即可以实现会话的持久化；返回会话ID；主要此处返回的ID.equals(session.getId())；  
Serializable create(Session session);  
//根据会话ID获取会话  
Session readSession(Serializable sessionId) throws UnknownSessionException;  
//更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用  
void update(Session session) throws UnknownSessionException;  
//删除会话；当会话过期/会话停止（如用户退出时）会调用  
void delete(Session session);  
//获取当前所有活跃用户，如果用户量多此方法影响性能  
Collection&lt;Session&gt; getActiveSessions();   
</code></pre></blockquote>
<p><img src="/images/imgs4/6.gif" alt="Alt text"></p>
<p>AbstractSessionDAO提供了SessionDAO的基础实现，如生成会话ID等；CachingSessionDAO提供了对开发者透明的会话缓存的功能，只需要设置相应的CacheManager即可；MemorySessionDAO直接在内存中进行会话维护；而EnterpriseCacheSessionDAO提供了缓存功能的会话维护，默认情况下使用MapCache实现，内部使用ConcurrentHashMap保存缓存的会话。</p>
<pre><code>如果自定义实现SessionDAO，继承CachingSessionDAO即可
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class MySessionDAO extends CachingSessionDAO &#123;  </div><div class="line">    private JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate();  </div><div class="line">     protected Serializable doCreate(Session session) &#123;  </div><div class="line">        Serializable sessionId = generateSessionId(session);  </div><div class="line">        assignSessionId(session, sessionId);  </div><div class="line">        String sql = "insert into sessions(id, session) values(?,?)";  </div><div class="line">        jdbcTemplate.update(sql, sessionId, SerializableUtils.serialize(session));  </div><div class="line">        return session.getId();  </div><div class="line">    &#125;  </div><div class="line">protected void doUpdate(Session session) &#123;  </div><div class="line">    if(session instanceof ValidatingSession &amp;&amp; !((ValidatingSession)session).isValid()) &#123;  </div><div class="line">        return; //如果会话过期/停止 没必要再更新了  </div><div class="line">    &#125;  </div><div class="line">        String sql = "update sessions set session=? where id=?";  </div><div class="line">        jdbcTemplate.update(sql, SerializableUtils.serialize(session), session.getId());  </div><div class="line">    &#125;  </div><div class="line">    protected void doDelete(Session session) &#123;  </div><div class="line">        String sql = "delete from sessions where id=?";  </div><div class="line">        jdbcTemplate.update(sql, session.getId());  </div><div class="line">    &#125;  </div><div class="line">    protected Session doReadSession(Serializable sessionId) &#123;  </div><div class="line">        String sql = "select session from sessions where id=?";  </div><div class="line">        List&lt;String&gt; sessionStrList = jdbcTemplate.queryForList(sql, String.class, sessionId);  </div><div class="line">        if(sessionStrList.size() == 0) return null;  </div><div class="line">        return SerializableUtils.deserialize(sessionStrList.get(0));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h4><p>Shiro提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话，Shiro提供了会话验证调度器SessionValidationScheduler来验证</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//分页获取会话并验证  </div><div class="line">String sql = "select session from sessions limit ?,?";  </div><div class="line">int start = 0; //起始记录  </div><div class="line">int size = 20; //每页大小  </div><div class="line">List&lt;String&gt; sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);  </div><div class="line">while(sessionList.size() &gt; 0) &#123;  </div><div class="line">  for(String sessionStr : sessionList) &#123;  </div><div class="line">    try &#123;  </div><div class="line">      Session session = SerializableUtils.deserialize(sessionStr);  </div><div class="line">      Method validateMethod =   </div><div class="line">        ReflectionUtils.findMethod(AbstractValidatingSessionManager.class,   </div><div class="line">            "validate", Session.class, SessionKey.class);  </div><div class="line">      validateMethod.setAccessible(true);  </div><div class="line">      ReflectionUtils.invokeMethod(validateMethod,   </div><div class="line">        sessionManager, session, new DefaultSessionKey(session.getId()));  </div><div class="line">    &#125; catch (Exception e) &#123;  </div><div class="line">        //ignore  </div><div class="line">    &#125;  </div><div class="line">  &#125;  </div><div class="line"> start = start + size;  </div><div class="line">  sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>sessionFactory</strong><br>sessionFactory是创建会话的工厂，根据相应的Subject上下文信息来创建会话；默认提供了SimpleSessionFactory用来创建SimpleSession会话。<br>自定义一个session</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class OnlineSession extends SimpleSession &#123;  </div><div class="line">    public static enum OnlineStatus &#123;  </div><div class="line">        on_line("在线"), hidden("隐身"), force_logout("强制退出");  </div><div class="line">        private final String info;  </div><div class="line">        private OnlineStatus(String info) &#123;  </div><div class="line">            this.info = info;  </div><div class="line">        &#125;  </div><div class="line">        public String getInfo() &#123;  </div><div class="line">            return info;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    private String userAgent; //用户浏览器类型  </div><div class="line">    private OnlineStatus status = OnlineStatus.on_line; //在线状态  </div><div class="line">    private String systemHost; //用户登录时系统IP   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义SessionFactory<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class OnlineSessionFactory implements SessionFactory &#123;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public Session createSession(SessionContext initData) &#123;  </div><div class="line">        OnlineSession session = new OnlineSession();  </div><div class="line">        if (initData != null &amp;&amp; initData instanceof WebSessionContext) &#123;  </div><div class="line">            WebSessionContext sessionContext = (WebSessionContext) initData;  </div><div class="line">            HttpServletRequest request = (HttpServletRequest) sessionContext.getServletRequest();  </div><div class="line">            if (request != null) &#123;  </div><div class="line">                session.setHost(IpUtils.getIpAddr(request));  </div><div class="line">                session.setUserAgent(request.getHeader("User-Agent"));  </div><div class="line">                session.setSystemHost(request.getLocalAddr() + ":" + request.getLocalPort());  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return session;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;shiro提供了完整的会话功能，不依赖于底层容器，即直接使用shiro的会话管理可以直接替换掉web容器的会话管理&lt;/p&gt;
&lt;h4 id=&quot;
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro之jstl标签</title>
    <link href="http://www.myzwl.win/2017/07/04/shiro_4/"/>
    <id>http://www.myzwl.win/2017/07/04/shiro_4/</id>
    <published>2017-07-04T05:48:51.000Z</published>
    <updated>2017-07-15T12:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shiro提供了JSTL标签用于在页面进行权限控制</p>
<h4 id="导入标签库"><a href="#导入标签库" class="headerlink" title="导入标签库"></a>导入标签库</h4><blockquote>
<p>&lt;%@taglib prefix=”shiro” uri=”<a href="http://shiro.apache.org/tags" target="_blank" rel="external">http://shiro.apache.org/tags</a>“ %&gt; </p>
</blockquote>
<h4 id="各类标签"><a href="#各类标签" class="headerlink" title="各类标签"></a>各类标签</h4><p><strong>guest标签</strong></p>
<blockquote>
<p><shiro:guest><br>欢迎游客访问，<br></shiro:guest></p>
</blockquote>
<p>用户没有身份验证时显示相应信息，即游客访问信息</p>
<p><strong>user标签 </strong></p>
<blockquote>
<p>   <shiro:user><br>    欢迎[<shiro:principal>]登录<br>    </shiro:principal></shiro:user>   </p>
</blockquote>
<p>用户已经身份验证/记住我登录后显示相应的信息。</p>
<p><strong>authenticated标签 </strong></p>
<blockquote>
<p> shiro:authenticated&gt;<br>     </p>
</blockquote>
<p> 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。</p>
<p><strong>notAuthenticated标签</strong></p>
<blockquote>
<p>  <shiro:notauthenticated><br>     </shiro:notauthenticated></p>
</blockquote>
<p> 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证</p>
<p><strong>principal标签</strong></p>
<blockquote>
<shiro: principal="">

</shiro:></blockquote>
<p> 显示用户身份信息，默认调用Subject.getPrincipal()获取，即Primary Principal。</p>
<p><strong>hasRole标签</strong></p>
<blockquote>
<p> <shiro:hasrole name="admin"><br>    用户[<shiro:principal>]拥有角色admin<br><br>    </shiro:principal></shiro:hasrole></p>
</blockquote>
<p> 如果当前Subject有角色将显示body体内容</p>
<p><strong>hasAnyRoles标签</strong></p>
<blockquote>
<pre><code>&lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;    
   &lt;/shiro:hasAnyRoles&gt;   
</code></pre></blockquote>
<p> 如果当前Subject有任意一个角色（或的关系）将显示body体内容</p>
<p><strong>lacksRole标签</strong></p>
<blockquote>
<p>  <shiro:lacksrole name="abc"><br>     </shiro:lacksrole></p>
</blockquote>
<p> 如果当前Subject没有角色将显示body体内容</p>
<p><strong>hasPermission标签</strong></p>
<blockquote>
<p><shiro:haspermission name="user:create"><br>    </shiro:haspermission></p>
</blockquote>
<p> 如果当前Subject有权限将显示body体内容。</p>
<p><strong>lacksPermission标签</strong></p>
<blockquote>
<p> <shiro:lackspermission name="sss:create"><br>     </shiro:lackspermission> </p>
</blockquote>
<p> 如果当前Subject没有权限将显示body体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;shiro提供了JSTL标签用于在页面进行权限控制&lt;/p&gt;
&lt;h4 id=&quot;导入标签库&quot;&gt;&lt;a href=&quot;#导入标签库&quot; class=&quot;h
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro之拦截器机制</title>
    <link href="http://www.myzwl.win/2017/07/03/shiro_3/"/>
    <id>http://www.myzwl.win/2017/07/03/shiro_3/</id>
    <published>2017-07-03T05:48:51.000Z</published>
    <updated>2017-07-15T11:44:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Shiro使用了与Servlet一样的Filter接口进行扩展，还有拦截器是基于java的反射机制，如利用动态代理实现，而平时说的过滤器是基于回调函数的实现，在实现原理上有着本质的区别<br><img src="/images/imgs4/2.gif" alt="Alt text"></p>
<h4 id="拦截器介绍"><a href="#拦截器介绍" class="headerlink" title="拦截器介绍"></a>拦截器介绍</h4><p><strong>NameableFilter</strong><br>顾名思义，就是根据相应拦截器链组装拦截器的名字找到相应的拦截器实例</p>
<p><strong>OncePerRequestFilter</strong><br>该拦截器用于控制一次请求只能走一次拦截器链，默认是开启拦截的</p>
<p><strong>ShiroFilter</strong><br>是整个shiro的入口点，用于拦截需要安全控制的请求进行处理</p>
<p><strong>AdviceFilter</strong><br>该拦截器非常类似于struct中拦截器，同时支持AOP拦截</p>
<blockquote>
<p>boolean preHandle(ServletRequest request, ServletResponse response) throws Exception<br>void postHandle(ServletRequest request, ServletResponse response) throws Exception<br>void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception;  </p>
</blockquote>
<p>preHandler：类似于AOP中的前置增强；在拦截器链执行之前执行；如果返回true则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权）</p>
<p>postHandle：类似于AOP中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）；</p>
<p>afterCompletion：类似于AOP中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源（如解除Subject与线程的绑定之类的）；</p>
<p><strong>PathMatchingFilter</strong><br>提供了基于Ant风格的请求路径匹配功能及拦截器参数解析的功能，如“roles[admin,user]”自动根据“，”分割解析到一个路径参数配置并绑定到相应的路径：</p>
<blockquote>
<p>boolean pathsMatch(String path, ServletRequest request)<br>boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception </p>
</blockquote>
<p>pathsMatch：该方法用于path与请求路径进行匹配的方法；如果匹配返回true；</p>
<p>onPreHandle：在preHandle中，当pathsMatch匹配一个路径后，会调用opPreHandler方法并将路径绑定参数配置传给mappedValue；然后可以在这个方法中进行一些验证（如角色授权），如果验证失败可以返回false中断流程；默认返回true；也就是说子类可以只实现onPreHandle即可，无须实现preHandle。如果没有path与请求路径匹配，默认是通过的（即preHandle返回true）。</p>
<p><strong>AccessControlFilter</strong><br>提供了访问控制的基础功能</p>
<blockquote>
<pre><code>abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;  
boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;  
abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception;   
</code></pre></blockquote>
<pre><code>isAccessAllowed：表示是否允许访问；mappedValue就是[urls]配置中拦截器参数部分，如果允许访问返回true，否则false；
</code></pre><p>onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；如果返回false表示该拦截器实例已经处理了，将直接返回即可。</p>
<p>同时它还有一些扩展的功能</p>
<blockquote>
<p>void setLoginUrl(String loginUrl) //身份验证时使用，默认/login.jsp<br>String getLoginUrl()<br>Subject getSubject(ServletRequest request, ServletResponse response) //获取Subject实例<br>boolean isLoginRequest(ServletRequest request, ServletResponse response)//当前请求是否是登录请求<br>void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException //将当前请求保存起来并重定向到登录页面<br>void saveRequest(ServletRequest request) //将请求保存起来，如登录成功后再重定向回该请求<br>void redirectToLogin(ServletRequest request, ServletResponse response) //重定向到登录页面 </p>
</blockquote>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h4><p>在web容器中，先执行shiro的filter链，再执行servlet容器的filter链，同时shiro的ProxiedFilterChain对Servlet容器的FilterChain进行了代理</p>
<blockquote>
<p>FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain);</p>
</blockquote>
<h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><p>通过自定义拦截器可以扩展一些功能，如动态url-角色/权限访问控制，根据Subject身份信息获取用户信息绑定到Request（即设置通用数据）、验证码验证、在线用户信息的保存等等</p>
<p><strong>扩展OncePerRequestFilter</strong><br>OncePerRequestFilter保证一次请求只调用一次doFilterInternal<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MyOncePerRequestFilter extends OncePerRequestFilter&#123;</div><div class="line">	@Override</div><div class="line">	protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)</div><div class="line">			throws ServletException, IOException &#123;	</div><div class="line">		  System.out.println("once");</div><div class="line">		  chain.doFilter(request, response);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的ini配置文件中</p>
<blockquote>
<p>[filters]<br>myFilter1=com.shiro.web.MyOncePerRequestFilter<br>[urls]<br>/**=myFilter1</p>
</blockquote>
<p>其中[filters]声明拦截器，[urls]执行拦截器</p>
<p><strong>扩展AdviceFilter</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MyAdviceFilter extends AdviceFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">		System.out.println("pre");</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void postHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">	  System.out.println("postHandle");</div><div class="line">		super.postHandle(request, response);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception)</div><div class="line">			throws Exception &#123;</div><div class="line">		System.out.println("afterCompletion");</div><div class="line">		super.afterCompletion(request, response, exception);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>preHandle：进行请求的预处理，然后根据返回值决定是否继续处理（true：继续过滤器链）；可以通过它实现权限控制；</p>
<p>postHandle：执行完拦截器链之后正常返回后执行；</p>
<p>afterCompletion：不管最后有没有异常，afterCompletion都会执行，完成如清理资源功能。</p>
<p><strong>扩展PathMatchingFilter</strong><br>提供了url模式过滤的功能<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyPathMatchingFilter extends PathMatchingFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue)</div><div class="line">			throws Exception &#123;</div><div class="line">		</div><div class="line">		   System.out.println("url matches,config is " + Arrays.toString((String[])mappedValue));  </div><div class="line">	       return true;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>preHandle：会进行url模式与请求url进行匹配，如果匹配会调用onPreHandle；如果没有配置url模式/没有url模式匹配，默认直接返回true；</p>
<p>onPreHandle：如果url模式与请求url匹配，那么会执行onPreHandle，并把该拦截器配置的参数传入。默认什么不处理直接返回true。</p>
<p><strong>扩展AccessControlFilter</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MyAccessControlFilter extends AccessControlFilter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)</div><div class="line">			throws Exception &#123;</div><div class="line">		System.out.println("isAccessAllowed");  </div><div class="line">        return false;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123;</div><div class="line">		 System.out.println("访问拒绝也不自己处理，继续拦截器链的执行");  </div><div class="line">	        return true;  </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>isAccessAllowed：即是否允许访问，返回true表示允许；</p>
<p>onAccessDenied：表示访问拒绝时是否自己处理，如果返回true表示自己不处理且继续拦截器链执行，返回false表示自己已经处理了（比如重定向到另一个页面）</p>
<p>其中如果isAccessAllowed返回true，onAccessDenied将不执行，反之执行</p>
<h4 id="默认拦截器"><a href="#默认拦截器" class="headerlink" title="默认拦截器"></a>默认拦截器</h4><p>Shiro内置了很多默认的拦截器，比如身份验证、授权等相关的<br><img src="/images/imgs4/3.gif" alt="Alt text"><br><img src="/images/imgs4/4.gif" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Shiro使用了与Servlet一样的Filter接口进行扩展，还有拦截器是基于java的反射机制，如利用动态代理实现，而平时说的过滤器是基
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro之编码加密</title>
    <link href="http://www.myzwl.win/2017/07/02/shiro_2/"/>
    <id>http://www.myzwl.win/2017/07/02/shiro_2/</id>
    <published>2017-07-02T05:48:51.000Z</published>
    <updated>2017-07-14T12:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在涉及数据在网络上的传输时，都要将明文数据加密传输，并且通常情况下的加密都是不可逆的</p>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>shiro内部提供了base64和16进制字符串编码/解码的API支持，如下<br><strong>base64编码/解码</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     String str="123456";	</div><div class="line">String base64Encoded=Base64.encodeToString(str.getBytes());//加密</div><div class="line"> System.out.println(base64Encoded);</div><div class="line">  String str2=Base64.decodeToString(base64Encoded); //解密</div><div class="line">   System.out.println(str2);</div><div class="line">    System.out.println(str.equals(str2));</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>MTIzNDU2<br>123456<br>true</p>
</blockquote>
<p><strong>16进制字符串编码/解码</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     String str="123456";	</div><div class="line">String base64Encoded = Hex.encodeToString(str.getBytes());//加密</div><div class="line"> System.out.println(base64Encoded);</div><div class="line"> String str2 = new String(Hex.decode(base64Encoded.getBytes())); //解密</div><div class="line">   System.out.println(str2);</div><div class="line">    System.out.println(str.equals(str2));</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>313233343536<br>123456<br>true</p>
</blockquote>
<p><strong>byte与string编码/解码</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     String str="123456";</div><div class="line">     byte[] str3=CodecSupport.toBytes(str, "utf-8");  //变成byte数组</div><div class="line">System.out.println(str3);</div><div class="line">String str4=CodecSupport.toString(str3, "utf-8"); //编程String</div><div class="line">System.out.println(str4);</div></pre></td></tr></table></figure></p>
<p>输出结果</p>
<blockquote>
<p>[B@cd51c3<br>123456</p>
</blockquote>
<h4 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h4><p>该算法是一种不可逆的算法，如MD5，SHA等，一般该算法最好需要提供一个salt（盐）来增加破解难度，一般情况下的盐被设置为 密码+用户名+盐，这样只有系统知道盐值，更难被破解</p>
<p><strong>MD5散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  String str = "hello";  </div><div class="line">String salt = "world";  </div><div class="line">String md5 = new Md5Hash(str, salt,2).toString();</div><div class="line">System.out.println(md5);</div></pre></td></tr></table></figure></p>
<p>这里的2是散列次数，即迭代多少次，这里是2次</p>
<blockquote>
<p>556b1a232d4d63a2f3ab87c9535abe25</p>
</blockquote>
<p><strong>其它散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    String str = "hello";  </div><div class="line">String salt = "world";  </div><div class="line">String sha1 = new Sha256Hash(str, salt).toString(); </div><div class="line">String SHA1=new Sha1Hash(str, salt).toString();</div><div class="line">String SHA512=new Sha512Hash(str, salt).toString();</div><div class="line">System.out.println(sha1);</div><div class="line">System.out.println(SHA1);</div><div class="line">System.out.println(SHA512);</div></pre></td></tr></table></figure></p>
<p>相应的输入结果：</p>
<blockquote>
<p>5715790a892990382d98858c4aa38d0617151575<br>3e64afa1cb7d643aa36f63b8d092ad76b1f04ff557abbb3d05f5b9037abf68a6606a8885d51bec8f6f39ee7d0badd504241c3704e777a51c21a9723e285fb9b8</p>
</blockquote>
<p><strong>通用散列</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String simpleHash = new SimpleHash("SHA-1", str, salt).toString();</div></pre></td></tr></table></figure></p>
<p>其中第一个参数指定采用哪种算法<br>输出结果：</p>
<blockquote>
<p>5715790a892990382d98858c4aa38d0617151575</p>
</blockquote>
<p><strong>默认匹配</strong><br>Shiro提供了HashService，默认提供了DefaultHashService实现。<br>先来看下它的构造函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public DefaultHashService() &#123;</div><div class="line">        this.algorithmName = "SHA-512";//默认算法SHA-512</div><div class="line">        this.iterations = 1; //生成Hash值的迭代次数，默认1</div><div class="line">        this.generatePublicSalt = false; //是否生成公盐，默认false</div><div class="line">        this.rng = new SecureRandomNumberGenerator();//用于生成公盐</div><div class="line">    &#125;</div><div class="line">    String hex = randomNumberGenerator.nextBytes().toHex();//随机生成一个盐</div></pre></td></tr></table></figure></p>
<h4 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h4><p>Shiro还提供对称式加密/解密算法的支持，如AES、Blowfish等<br><strong>AES算法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">AesCipherService aesCipherService = new AesCipherService();</div><div class="line">      aesCipherService.setKeySize(128);//设置key长度</div><div class="line">      //生成key</div><div class="line">      Key key = aesCipherService.generateNewKey();</div><div class="line">      String text = "zwl";</div><div class="line">      //加密</div><div class="line">      String encrptText = aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();</div><div class="line">      //解密</div><div class="line">      String text2 = new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());</div><div class="line">        System.out.println(key.toString());</div><div class="line">      System.out.println(encrptText);</div><div class="line">    System.out.println(text2);</div></pre></td></tr></table></figure></p>
<p>而上面的key就相当于一把钥匙，只有了这把钥匙，就能解密<br>输出结果：</p>
<blockquote>
<p>javax.crypto.spec.SecretKeySpec@176a4<br>a316645482dff96d9c86c64adabc51dee5170232365a3c15dab941dc6b73c2ec<br>zwl</p>
</blockquote>
<p><strong>Blowfish算法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BlowfishCipherService blowfishCipherService = new BlowfishCipherService();</div><div class="line">        blowfishCipherService.setKeySize(128);</div><div class="line">        //生成key</div><div class="line">        Key key = blowfishCipherService.generateNewKey();</div><div class="line">        String text = "zwl";</div><div class="line">        //加密</div><div class="line">        String encrptText = blowfishCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();</div><div class="line">        //解密</div><div class="line">        String text2 = new String(blowfishCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes()); </div><div class="line">        System.out.println(key.toString());</div><div class="line">       System.out.println(encrptText);</div><div class="line">      System.out.println(text2);</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>javax.crypto.spec.SecretKeySpec@d97afa5c<br>8e7f6626884b7b429a1000286f4990a4<br>zwl</p>
</blockquote>
<h4 id="PasswordService-CredentialsMatcher"><a href="#PasswordService-CredentialsMatcher" class="headerlink" title="PasswordService/CredentialsMatcher"></a>PasswordService/CredentialsMatcher</h4><p>在用户输入明文密码时，shiro默认的实现方式如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public interface PasswordService &#123;  </div><div class="line">    //输入明文密码得到密文密码  </div><div class="line">    String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">    public interface CredentialsMatcher &#123;  </div><div class="line">    //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）  </div><div class="line">    boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Shiro默认提供了PasswordService实现DefaultPasswordService；CredentialsMatcher实现PasswordMatcher及HashedCredentialsMatcher</p>
<p>关于shiro的编码\加密是在是丰富多多彩，一般是学习中遇到采取查询相关的</p>
<h4 id="一个对称加密的算法"><a href="#一个对称加密的算法" class="headerlink" title="一个对称加密的算法"></a>一个对称加密的算法</h4><p>下面是在一个项目中使用到的工具类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div></pre></td><td class="code"><pre><div class="line">public class DesUtils &#123;</div><div class="line">	/** 字符串默认键值     */</div><div class="line">	  private static String strDefaultKey = "national";</div><div class="line"></div><div class="line">	  /** 加密工具     */</div><div class="line">	  private Cipher encryptCipher = null;</div><div class="line"></div><div class="line">	  /** 解密工具     */</div><div class="line">	  private Cipher decryptCipher = null;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 将byte数组转换为表示16进制值的字符串， 如：byte[]&#123;8,18&#125;转换为：0813， 和public static byte[]  </div><div class="line">	   * hexStr2ByteArr(String strIn) 互为可逆的转换过程  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需要转换的byte数组  </div><div class="line">	   * @return 转换后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   *             本方法不处理任何异常，所有异常全部抛出  </div><div class="line">	   */</div><div class="line">	  public static String byteArr2HexStr(byte[] arrB) throws Exception &#123;</div><div class="line">	    int iLen = arrB.length;</div><div class="line">	    // 每个byte用两个字符才能表示，所以字符串的长度是数组长度的两倍   </div><div class="line">	    StringBuffer sb = new StringBuffer(iLen * 2);</div><div class="line">	    for (int i = 0; i &lt; iLen; i++) &#123;</div><div class="line">	      int intTmp = arrB[i];</div><div class="line">	      // 把负数转换为正数   </div><div class="line">	      while (intTmp &lt; 0) &#123;</div><div class="line">	        intTmp = intTmp + 256;</div><div class="line">	      &#125;</div><div class="line">	      // 小于0F的数需要在前面补0   </div><div class="line">	      if (intTmp &lt; 16) &#123;</div><div class="line">	        sb.append("0");</div><div class="line">	      &#125;</div><div class="line">	      sb.append(Integer.toString(intTmp, 16));</div><div class="line">	    &#125;</div><div class="line">	    return sb.toString();</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 将表示16进制值的字符串转换为byte数组， 和public static String byteArr2HexStr(byte[] arrB)  </div><div class="line">	   * 互为可逆的转换过程  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需要转换的字符串  </div><div class="line">	   * @return 转换后的byte数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   *             本方法不处理任何异常，所有异常全部抛出  </div><div class="line">	   *  </div><div class="line">	   */</div><div class="line">	  public static byte[] hexStr2ByteArr(String strIn) throws Exception &#123;</div><div class="line">	    byte[] arrB = strIn.getBytes();</div><div class="line">	    int iLen = arrB.length;</div><div class="line"></div><div class="line">	    // 两个字符表示一个字节，所以字节数组长度是字符串长度除以2   </div><div class="line">	    byte[] arrOut = new byte[iLen / 2];</div><div class="line">	    for (int i = 0; i &lt; iLen; i = i + 2) &#123;</div><div class="line">	      String strTmp = new String(arrB, i, 2);</div><div class="line">	      arrOut[i / 2] = (byte) Integer.parseInt(strTmp, 16);</div><div class="line">	    &#125;</div><div class="line">	    return arrOut;</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 默认构造方法，使用默认密钥  </div><div class="line">	   *   </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public DesUtils() throws Exception &#123;</div><div class="line">	    this(strDefaultKey);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 指定密钥构造方法  </div><div class="line">	   *   </div><div class="line">	   * @param strKey  </div><div class="line">	   *            指定的密钥  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public DesUtils(String strKey) throws Exception &#123;</div><div class="line">	    //Security.addProvider(new com.sun.crypto.provider.SunJCE());</div><div class="line">	    Key key = getKey(strKey.getBytes());</div><div class="line"></div><div class="line">	    encryptCipher = Cipher.getInstance("DES");</div><div class="line">	    encryptCipher.init(Cipher.ENCRYPT_MODE, key);</div><div class="line"></div><div class="line">	    decryptCipher = Cipher.getInstance("DES");</div><div class="line">	    decryptCipher.init(Cipher.DECRYPT_MODE, key);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 加密字节数组  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需加密的字节数组  </div><div class="line">	   * @return 加密后的字节数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public byte[] encrypt(byte[] arrB) throws Exception &#123;</div><div class="line">	    return encryptCipher.doFinal(arrB);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 加密字符串  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需加密的字符串  </div><div class="line">	   * @return 加密后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public String encrypt(String strIn) throws Exception &#123;</div><div class="line">	    return byteArr2HexStr(encrypt(strIn.getBytes()));</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 解密字节数组  </div><div class="line">	   *   </div><div class="line">	   * @param arrB  </div><div class="line">	   *            需解密的字节数组  </div><div class="line">	   * @return 解密后的字节数组  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public byte[] decrypt(byte[] arrB) throws Exception &#123;</div><div class="line">	    return decryptCipher.doFinal(arrB);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 解密字符串  </div><div class="line">	   *   </div><div class="line">	   * @param strIn  </div><div class="line">	   *            需解密的字符串  </div><div class="line">	   * @return 解密后的字符串  </div><div class="line">	   * @throws Exception  </div><div class="line">	   */</div><div class="line">	  public String decrypt(String strIn) throws Exception &#123;</div><div class="line">	    return new String(decrypt(hexStr2ByteArr(strIn)));</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  /**  </div><div class="line">	   * 从指定字符串生成密钥，密钥所需的字节数组长度为8位 不足8位时后面补0，超出8位只取前8位  </div><div class="line">	   *   </div><div class="line">	   * @param arrBTmp  </div><div class="line">	   *            构成该字符串的字节数组  </div><div class="line">	   * @return 生成的密钥  </div><div class="line">	   * @throws java.lang.Exception  </div><div class="line">	   */</div><div class="line">	  private Key getKey(byte[] arrBTmp) throws Exception &#123;</div><div class="line">	    // 创建一个空的8位字节数组（默认值为0）   </div><div class="line">	    byte[] arrB = new byte[8];</div><div class="line"></div><div class="line">	    // 将原始字节数组转换为8位   </div><div class="line">	    for (int i = 0; i &lt; arrBTmp.length &amp;&amp; i &lt; arrB.length; i++) &#123;</div><div class="line">	      arrB[i] = arrBTmp[i];</div><div class="line">	    &#125;</div><div class="line"></div><div class="line">	    // 生成密钥   </div><div class="line">	    Key key = new javax.crypto.spec.SecretKeySpec(arrB, "DES");</div><div class="line"></div><div class="line">	    return key;</div><div class="line">	  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在涉及数据在网络上的传输时，都要将明文数据加密传输，并且通常情况下的加密都是不可逆的&lt;/p&gt;
&lt;h2 id=&quot;编码与解码&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>初识shiro</title>
    <link href="http://www.myzwl.win/2017/07/01/shiro_1/"/>
    <id>http://www.myzwl.win/2017/07/01/shiro_1/</id>
    <published>2017-07-01T05:48:51.000Z</published>
    <updated>2017-07-14T09:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考百度上说的<a href="http://shiro.apache.org/download.html" target="_blank" rel="external">Apache Shiro</a>是一个强大易用的java安全框架，提供了认证、授权、加密和会话管理功能，可以为任何应用提供安全保障，而其主要为解决以下四个问题：<br>1、 认证-用户身份识别，常被称为用户登录<br>2、 授权-访问控制<br>3、 密码加密-保护或隐藏数据防止被偷窥<br>4、 会话管理-每用户相关的时间敏感的状态</p>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>以下是从其官网上截取的原理图<br><img src="/images/imgs3/14.gif" alt="Alt text"></p>
<p>可以看出shiro的设计非常精妙，同时它不依赖于任何容器，即在java se和java ee中都可以使用，如果把shiro看做一个不透明的黑盒的话，即认证主体subject提供认证给security manager，其内部封装一些列细节方法去执行认证，这里的验证数据源可以是数据库的或者其他</p>
<p>下面将以用户的登录过程来模拟shiro的执行过程</p>
<p><img src="/images/imgs4/1.gif" alt="Alt text"></p>
<h4 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h4><p><strong>token令牌</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">   @RequestMapping("login")</div><div class="line">public ModelAndView login(@RequestParam("username") String username, @RequestParam("password") String password) &#123;</div><div class="line">	 UsernamePasswordToken token = new UsernamePasswordToken(username, password);</div><div class="line">        Subject subject = SecurityUtils.getSubject();</div><div class="line">        try &#123;</div><div class="line">            subject.login(token);</div><div class="line">        &#125; catch (IncorrectCredentialsException ice) &#123;</div><div class="line">            // 捕获密码错误异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "password error!");</div><div class="line">            return mv;</div><div class="line">        &#125; catch (UnknownAccountException uae) &#123;</div><div class="line">            // 捕获未知用户名异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "username error!");</div><div class="line">            return mv;</div><div class="line">        &#125; catch (ExcessiveAttemptsException eae) &#123;</div><div class="line">            // 捕获错误登录过多的异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "times error");</div><div class="line">            return mv;</div><div class="line">        &#125;</div><div class="line">        catch (AuthenticationException eae) &#123;</div><div class="line">            // 捕获错误登录过多的异常</div><div class="line">            ModelAndView mv = new ModelAndView("inner");</div><div class="line">            mv.addObject("message", "times error");</div><div class="line">            return mv;</div><div class="line">        &#125;</div><div class="line">        TUserEntity user=tUserService.queryObject(username);</div><div class="line">        subject.getSession().setAttribute("user", user);   </div><div class="line">         return new ModelAndView("index");	 </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这里该方法接收到前台传递过来的username和password信息，类比身份证，姓名是认证，但是身份证号码是作为认证的唯一凭证，只有身份证号码正确了，这个认证也就通过了，而这里的token可以理解为用户登录的令牌，里面记录着认证信息，然后交给shiro去验证<br> 接下来就是执行登录动作了</p>
<blockquote>
<p>SecurityUtils.setSecurityManager(securityManager); // 注入SecurityManager<br>Subject subject = SecurityUtils.getSubject(); // 获取Subject单例对象<br>subject.login(token); // 登陆</p>
</blockquote>
<p>其中SecurityManager是一个单例对象，即全局变量，接着SecurityUtils会自动绑定当前线程，获得subject主体，关于subject可以这样理解其包含两个信息:<br>Principals： 身份，可以是用户名，邮件，手机号码等等，用来标识一个登陆主体身份；<br>Credentials： 凭证，常见有密码，数字证书等等；<br>最后就是登陆了，最后通过验证token是否合法返回不同结果</p>
<h4 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h4><p>根据流程图，接下来security manager开始执行一系列的认证手段了，其中最主要的就是<br>AuthorizationInfo（角色权限认证），AuthenticationInfo（身份认证），可以简单这样理解，身份认证只是验证了这个subject的存在性，如果约定subject有某些权限，如管理员有删除或者访问某些url地址权限，而这个管理员就可以抽象为角色，也就是说权限是访问资源的权利集合，而角色是权限的集合</p>
<p>最后的realm域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色，权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源</p>
<p>一般情况下realm需要我们自定义去实现，因为shiro不知道哪些token是合法的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">  public class OAuth2Realm extends AuthorizingRealm&#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	private TUserService tUserService;</div><div class="line">	</div><div class="line">	/**</div><div class="line">     * 提供用户信息返回权限信息</div><div class="line">     */</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</div><div class="line">	</div><div class="line">		String username = (String) principals.getPrimaryPrincipal();</div><div class="line">		 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();</div><div class="line">		   TUserEntity user=tUserService.queryObject(username);</div><div class="line">	        // 根据id查询当前用户拥有的角色</div><div class="line">		  List&lt;TUserRoleEntity&gt; ture=tUserService.queryRole(user.getId());</div><div class="line">		   Set&lt;TRoleEntity&gt; roles=new HashSet&lt;TRoleEntity&gt;();</div><div class="line">		        for(TUserRoleEntity Tures:ture)&#123;</div><div class="line">		        	roles.add(tUserService.queryObject(Tures.getRoleId()));</div><div class="line">		        &#125;</div><div class="line">		        Set&lt;String&gt; roleNames=new HashSet&lt;String&gt;();</div><div class="line">		         for(TRoleEntity rolename : roles)&#123;</div><div class="line">		    	   roleNames.add(rolename.getRolename());</div><div class="line">		         &#125;</div><div class="line">		      // 将角色名称提供给info</div><div class="line">		      authorizationInfo.setRoles(roleNames);</div><div class="line">		return authorizationInfo;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">     * 提供账户信息返回认证信息</div><div class="line">     */</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</div><div class="line">		</div><div class="line">		String username=(String)token.getPrincipal();   // 获取用户名</div><div class="line">// String password = new String((char[])token.getCredentials()); 得到密码</div><div class="line"></div><div class="line">	UsernamePasswordToken t = (UsernamePasswordToken) token; //得到密码</div><div class="line">		String newPassword=new String(t.getPassword());</div><div class="line">		//根据用户名从数据库取出用户完整信息</div><div class="line">		 TUserEntity tuserEntity=tUserService.queryObject(username);</div><div class="line">		  if(tuserEntity!=null)&#123;</div><div class="line">			  //若存在，将此用户存放到登录认证info中    </div><div class="line">	            return new SimpleAuthenticationInfo(tuserEntity.getUsername(),tuserEntity.getPassword(), ByteSource.Util.bytes("zwl"), getName());  </div><div class="line">		  &#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>该realm类的结果就是根据token的合法性验证返回不同结果给相应的controller，目前只是从宏观上看了一个全过程，shiro是非常强大的，它的功能远不止如此</p>
<h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>缓存的本质就是将原本只能存储在内存中的数据通过算法保存到硬盘上，再根据需求依次取出。可以把缓存理解为一个Map对象，通过put保存对象，再通过get取回对象。这里使用的是Ehcache缓存框架。具体代码如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;ehcache name="es"&gt;</div><div class="line"></div><div class="line">    &lt;diskStore path="java.io.tmpdir"/&gt;</div><div class="line"></div><div class="line">    &lt;!--</div><div class="line">       name:缓存名称。</div><div class="line">       maxElementsInMemory：缓存最大个数。</div><div class="line">       eternal:对象是否永久有效，一但设置了，timeout将不起作用。</div><div class="line">       timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</div><div class="line">       timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</div><div class="line">       overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。</div><div class="line">       diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</div><div class="line">       maxElementsOnDisk：硬盘最大缓存个数。</div><div class="line">       diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</div><div class="line">       diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</div><div class="line">       memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</div><div class="line">       clearOnFlush：内存数量最大时是否清除。</div><div class="line">    --&gt;</div><div class="line"></div><div class="line">    &lt;defaultCache</div><div class="line">            maxEntriesLocalHeap="1000"</div><div class="line">            eternal="false"</div><div class="line">            timeToIdleSeconds="3600"</div><div class="line">            timeToLiveSeconds="3600"</div><div class="line">            overflowToDisk="false"&gt;</div><div class="line">    &lt;/defaultCache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-authenticationCache"</div><div class="line">           maxEntriesLocalHeap="1000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-authorizationCache"</div><div class="line">           maxEntriesLocalHeap="2000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">    &lt;cache name="shiro-userCache"</div><div class="line">           maxEntriesLocalHeap="2000"</div><div class="line">           eternal="false"</div><div class="line">           timeToIdleSeconds="600"</div><div class="line">           timeToLiveSeconds="600"</div><div class="line">           overflowToDisk="false"</div><div class="line">           statistics="true"&gt;</div><div class="line">    &lt;/cache&gt;</div><div class="line"></div><div class="line">&lt;/ehcache&gt;</div></pre></td></tr></table></figure></p>
<p>其中<diskstore path="java.io.tmpdir">可以指定缓存的路径，这里是临时路径</diskstore></p>
<h4 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h4><p>通常情况下散列和加密本质上都是一样的，即将一个Object变成一串无意义的字符串，不同点是经过散列的对象无法复原，是一个单向的过程，而加密是可以双向的，即加密与解密，所以如果忘记密码，只能进行修改密码操作，下面是在项目中用到的散列算法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private RandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator();</div><div class="line">private String algorithmName = "md5";</div><div class="line">private final int hashIterations = 2;</div><div class="line"></div><div class="line">public void encryptPassword(TUserEntity user) &#123;</div><div class="line">    // User对象包含最基本的字段Username和Password</div><div class="line">	String salt="zwl";</div><div class="line">    // 将用户的注册密码经过散列算法替换成一个不可逆的新密码保存进数据，散列过程使用了盐</div><div class="line">    String newPassword = new SimpleHash(algorithmName, user.getPassword(),</div><div class="line">            ByteSource.Util.bytes("zwl"), hashIterations).toHex();</div><div class="line">    user.setPassword(newPassword);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中algorithmName为指定运用何种算法，hashIterations为散列次数，也就是数学中的迭代，将前一个结果作为参数在运算一次，salt盐可以理解为有了盐，并且每个盐唯一确定一个散列值，最后产生的newPassword是经过如下类</p>
<blockquote>
<p>public SimpleHash(String algorithmName, Object source, Object salt, int hashIterations) </p>
</blockquote>
<p>四个参数分别标识算法名称，散列对象，散列使用的salt值，散列次数。</p>
<h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>匹配的功能就是用来匹配用户登录使用的令牌和数据库中保存的用户信息是否匹配。它的原始接口是CredentialsMatcher，一般情况下如果不自定义的话就会使用默认的实现类HashedCredentialsMatcher，如下是自定义的匹配<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher&#123;</div><div class="line"></div><div class="line">	// 声明一个缓存接口，这个接口是Shiro缓存管理的一部分，它的具体实现可以通过外部容器注入</div><div class="line">	 private Cache&lt;String, AtomicInteger&gt; passwordRetryCache;</div><div class="line">	 </div><div class="line">	 public RetryLimitHashedCredentialsMatcher(CacheManager cacheManager) &#123;</div><div class="line">	        passwordRetryCache = cacheManager.getCache("passwordRetryCache");</div><div class="line">	    &#125;</div><div class="line">	 </div><div class="line">	 @Override</div><div class="line">	    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123;</div><div class="line">		 String username = (String) token.getPrincipal();</div><div class="line">	        AtomicInteger retryCount = passwordRetryCache.get(username);</div><div class="line">	        if (retryCount == null) &#123;</div><div class="line">	            retryCount = new AtomicInteger(0);</div><div class="line">	            passwordRetryCache.put(username, retryCount);</div><div class="line">	        &#125;</div><div class="line">	        // 自定义一个验证过程：当用户连续输入密码错误5次以上禁止用户登录一段时间</div><div class="line">	        if (retryCount.incrementAndGet() &gt; 5) &#123;</div><div class="line">	            throw new ExcessiveAttemptsException();</div><div class="line">	        &#125;</div><div class="line">	        boolean match = super.doCredentialsMatch(token, info);</div><div class="line">	        if (match) &#123;</div><div class="line">	            passwordRetryCache.remove(username);</div><div class="line">	        &#125;</div><div class="line">	        return match;</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般情况下，匹配的异常的结果都会抛出相应的异常，如 DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等</p>
<p>而针对获得realm数据源的情况，会设置五张表，分别是用户表（存储用户名，密码，盐等）、角色表（角色名称，相关描述等）、权限表（权限名称，相关描述等）、用户-角色对应中间表（以用户ID和角色ID作为联合主键）、角色-权限对应中间表（以角色ID和权限ID作为联合主键），其中用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>用户的一次登录即为一次会话，即session，Shiro也可以代替Tomcat等容器管理会话。而针对会话，可以处理的情况太多了，如记录用户信息和行为等等，比如保存用户信息</p>
<blockquote>
<p>TUserEntity user=tUserService.queryObject(username);<br>    subject.getSession().setAttribute(“user”, user); </p>
</blockquote>
<h4 id="ssm-shiro集成"><a href="#ssm-shiro集成" class="headerlink" title="ssm+shiro集成"></a>ssm+shiro集成</h4><p>web.xml中的配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"</div><div class="line">         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee</div><div class="line">                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</div><div class="line">         version="3.0"&gt;</div><div class="line"></div><div class="line">    &lt;!-- 修改 Servlet 版本--&gt;</div><div class="line">    &lt;!-- 配置 DispatcherServlet--&gt;</div><div class="line">    &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</div><div class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">        &lt;init-param&gt;</div><div class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">            &lt;param-value&gt;</div><div class="line">                classpath:spring/spring-web.xml</div><div class="line">            &lt;/param-value&gt;</div><div class="line">        &lt;/init-param&gt;</div><div class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">        &lt;async-supported&gt;true&lt;/async-supported&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">    &lt;context-param&gt;</div><div class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;</div><div class="line">            classpath:spring/spring-service.xml,</div><div class="line">            classpath:spring/spring-dao.xml,</div><div class="line">            classpath:spring/spring-shiro.xml</div><div class="line">        &lt;/param-value&gt;</div><div class="line">    &lt;/context-param&gt;</div><div class="line"></div><div class="line">    &lt;listener&gt;</div><div class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</div><div class="line">    &lt;/listener&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;!-- 添加 Shiro 相关配置(应该去官网查询相应的配置信息) --&gt;</div><div class="line"></div><div class="line">    &lt;!-- The filter-name matches name of a 'shiroFilter' bean inside applicationContext.xml --&gt;</div><div class="line">    &lt;filter&gt;</div><div class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</div><div class="line">        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</div><div class="line">        &lt;init-param&gt;</div><div class="line">            &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;</div><div class="line">            &lt;param-value&gt;true&lt;/param-value&gt;</div><div class="line">        &lt;/init-param&gt;</div><div class="line">    &lt;/filter&gt;</div><div class="line"></div><div class="line">    &lt;filter-mapping&gt;</div><div class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</div><div class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">    &lt;/filter-mapping&gt;</div><div class="line"></div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>其中主要关心的是web容器将将Shiro的配置文件交给Spring监听器初始化以及配置了shiro的过滤等<br>这里shiro的配置都在spring-shiro.xml中配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">       xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">       xmlns:mvc="http://www.springframework.org/schema/mvc"</div><div class="line">       xsi:schemaLocation="</div><div class="line">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</div><div class="line">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</div><div class="line">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;!-- 声明一个密码匹配器 --&gt;</div><div class="line">    &lt;bean id="credentialsMatcher" class="com.hfsf.sys.oauth2.RetryLimitHashedCredentialsMatcher"&gt;</div><div class="line">        &lt;!-- 设置该密码匹配器使用的算法是 md5 --&gt;</div><div class="line">      &lt;property name="hashAlgorithmName" value="md5"/&gt;</div><div class="line">     &lt;property name="hashIterations" value="2" /&gt;</div><div class="line">      &lt;property name="storedCredentialsHexEncoded" value="true" /&gt; </div><div class="line">      &lt;constructor-arg ref="ehCacheManager" /&gt; </div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 声明一个自定义的 Realm --&gt;</div><div class="line">    &lt;bean id="myRealm" class="com.hfsf.sys.oauth2.OAuth2Realm"&gt;</div><div class="line">        &lt;!-- 将上面声明的密码匹配器注入到自定义 Realm 的属性中去 --&gt;</div><div class="line">        &lt;property name="credentialsMatcher" ref="credentialsMatcher"/&gt;</div><div class="line">        &lt;!-- 将自定义的权限匹配器注入到自定义 Realm 中 --&gt;</div><div class="line">        &lt;property name="permissionResolver" ref="permissionResolver"/&gt;</div><div class="line"></div><div class="line">        &lt;!-- 配置缓存相关 --&gt;</div><div class="line">        &lt;!-- 启用缓存 --&gt;</div><div class="line">        &lt;property name="cachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 开启认证缓存--&gt;</div><div class="line">        &lt;property name="authenticationCachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 指定认证缓存的名字(与 ehcache.xml 中声明的相同) --&gt;</div><div class="line">        &lt;property name="authenticationCacheName" value="shiro-authenticationCache"/&gt;</div><div class="line">        &lt;!--开启授权缓存--&gt;</div><div class="line">        &lt;property name="authorizationCachingEnabled" value="true"/&gt;</div><div class="line">        &lt;!-- 指定授权缓存的名字(与 ehcache.xml 中声明的相同) --&gt;</div><div class="line">        &lt;property name="authorizationCacheName" value="shiro-authorizationCache"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 自定义一个权限匹配器 --&gt;</div><div class="line">    &lt;bean id="permissionResolver" class="com.hfsf.sys.oauth2.UrlPermissionResolver"/&gt;</div><div class="line"></div><div class="line">    &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt;</div><div class="line">        &lt;property name="securityManager" ref="securityManager"/&gt;</div><div class="line">        &lt;!-- 如果认证不通过,浏览器通过 Get 方式请求到 /login 上 --&gt;</div><div class="line">        &lt;property name="loginUrl" value="/login.jsp"/&gt;</div><div class="line"></div><div class="line">        &lt;!-- override these for application-specific URLs if you like:</div><div class="line"></div><div class="line">        &lt;property name="successUrl" value="/home.jsp"/&gt;</div><div class="line">        &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; --&gt;</div><div class="line"> </div><div class="line">        &lt;!-- defined will be automatically acquired and available via its beanName in chain        --&gt;</div><div class="line">       </div><div class="line">        &lt;property name="filterChainDefinitions"&gt;</div><div class="line">            &lt;value&gt;</div><div class="line"></div><div class="line">               /authc/admin = roles[admin]</div><div class="line">                /authc/** = authc</div><div class="line">                /** = anon</div><div class="line">            &lt;/value&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 声明一个自定义的过滤器 --&gt;</div><div class="line">    &lt;bean id="resourceCheckFilter" class="com.hfsf.common.xss.ResourceCheckFilter"&gt;</div><div class="line">        &lt;!-- 为上面声明的自定义过滤器注入属性值 --&gt;</div><div class="line">        &lt;property name="errorUrl" value="/unAuthorization"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt;</div><div class="line">        &lt;!-- Single realm app.  If you have multiple realms, use the 'realms' property instead. --&gt;</div><div class="line">        &lt;!-- 设置安全管理器的安全数据源为自定义的 Realm --&gt;</div><div class="line">        &lt;property name="realm" ref="myRealm"/&gt;</div><div class="line">        &lt;!-- By default the servlet container sessions will be used.  Uncomment this line</div><div class="line">             to use shiro's native sessions (see the JavaDoc for more): --&gt;</div><div class="line">        &lt;!-- &lt;property name="sessionMode" value="native"/&gt; --&gt;</div><div class="line">        &lt;property name="cacheManager" ref="ehCacheManager"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    </div><div class="line">  </div><div class="line">   </div><div class="line">    &lt;!-- 配置 shiro 的 ehcache 缓存相关,这个缓存只和 Realm 相关 --&gt;</div><div class="line">    &lt;bean id="ehCacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 配置 Spring 的 EhCacheManagerFactoryBean ,须要 spring-context-support 的支持 --&gt;</div><div class="line">    &lt;bean id="ehCacheManagerFactoryBean" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt;</div><div class="line">        &lt;property name="configLocation" value="classpath:ehcache.xml"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 配置 Spring 的 EhCacheCacheManager,须要 spring-context-support 的支持 --&gt;</div><div class="line">    &lt;bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager"&gt;</div><div class="line">        &lt;property name="cacheManager" ref="ehCacheManagerFactoryBean"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>其中最主要的是filterChainDefinitions，这里声明了权限控制用户访问哪些url，而且访问是有顺序的，即执行了前者后者将不再执行，其中anon为匿名访问，authc为需要身份认证通过才可以访问，这里的内容较多，具体参考官方文档</p>
<p>最后只要通过前台页面提交数据，经过一系列流程，最终就可以完成权限控制了，事实上shiro的内容很多，而且很丰富，只有不断在实践中踩坑，学习，总结才能更好的认识和运用它</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考百度上说的&lt;a href=&quot;http://shiro.apache.org/download.html&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>设计模式原则笔记</title>
    <link href="http://www.myzwl.win/2017/05/11/jd1/"/>
    <id>http://www.myzwl.win/2017/05/11/jd1/</id>
    <published>2017-05-11T05:48:51.000Z</published>
    <updated>2017-06-30T02:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在编程语言中除了各种不同的设计模式外，它们也可以被抽出一些共性</p>
<p>开闭原则：一个软件实体应当对开展开放，对修改关闭（玉帝招安美猴王）</p>
<p>面向对象解释： 不予以更改的是抽象层，但是可以扩展的是实现层</p>
<p>对可变性的封装原则： 找到一个系统的可变因素，将之封装起来</p>
<p>继承应当是看做封装的方法，而不应该被认为是从一般对象方法到特殊对象的生成方法</p>
<p>里氏代换原则： 任何基类可以出现的地方，子类一定可以出现</p>
<p>两个类共同行为抽象到一个c类<br>B继承A改为聚合B（白马与黑马，正方形与长方形）</p>
<p>依赖倒转原则： 要依赖于抽象，不要依赖于实现<br>抽象类仅提供一个类型的部分实现，可以同时有抽象方法和具体方法<br>具体类不是用来继承的<br>如果两个具体类存在继承关系，要引入第三个类作为他们的共同的接口<br>抽象类应该拥有尽可能多共同代码<br>抽象类应当拥有尽可能少的数据</p>
<p>接口隔离原则： 应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</p>
<p>角色的合理划分<br>定制服务<br>接口污染</p>
<p>合成/聚合复用原则： 要尽量使用合成/聚合，而不是继承关系达到复用的目的<br>合成是值得聚合，聚合是引用的聚合<br>Is-A 代表一个类是另一个类的一种，Has-A代表一个类是另一个类的角色，而不是另一个类的特殊类（人与角色）</p>
<p>迪米特法则： 一个软件实体应当尽可能少的与其他实体发生相互作用</p>
<p>java接口： 一些方法特征的集合<br>没有接口会造成硬代码问题直接导致可插入性没有保证<br>java接口用来声明一个新的类型<br>单方法接口（如Runnable）<br>标识接口（serialzable）<br>常量接口</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编程语言中除了各种不同的设计模式外，它们也可以被抽出一些共性&lt;/p&gt;
&lt;p&gt;开闭原则：一个软件实体应当对开展开放，对修改关闭（玉帝招安美猴王）&lt;/p&gt;
&lt;p&gt;面向对象解释： 不予以更改的是抽象层，但是可以扩展的是实现层&lt;/p&gt;
&lt;p&gt;对可变性的封装原则： 找到一个系统的可
    
    </summary>
    
      <category term="java与设计" scheme="http://www.myzwl.win/categories/java%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java与设计" scheme="http://www.myzwl.win/source/tags/java%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Shiro之通过数据库验证身份</title>
    <link href="http://www.myzwl.win/2017/04/14/shiro1/"/>
    <id>http://www.myzwl.win/2017/04/14/shiro1/</id>
    <published>2017-04-14T05:48:51.000Z</published>
    <updated>2017-07-14T11:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考百度上说的<a href="http://shiro.apache.org/download.html" target="_blank" rel="external">Apache Shiro</a>是一个强大易用的java安全框架，提供了认证、授权、加密和会话管理功能，可以为任何应用提供安全保障，而其主要为解决以下四个问题：<br>1、 认证-用户身份识别，常被称为用户登录<br>2、 授权-访问控制<br>3、 密码加密-保护或隐藏数据防止被偷窥<br>4、 会话管理-每用户相关的时间敏感的状态</p>
<h4 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h4><p>以下是从其官网上截取的原理图<br><img src="/images/imgs3/14.gif" alt="Alt text"></p>
<h4 id="Subject认证主体"><a href="#Subject认证主体" class="headerlink" title="Subject认证主体"></a>Subject认证主体</h4><p>其中认证主体包含两个信息:<br>Principals： 身份，可以是用户名，邮件，手机号码等等，用来标识一个登陆主体身份；<br>Credentials： 凭证，常见有密码，数字证书等等；</p>
<h4 id="Realm-amp-JDBC-amp-Reaml"><a href="#Realm-amp-JDBC-amp-Reaml" class="headerlink" title="Realm&amp;JDBC&amp;Reaml"></a>Realm&amp;JDBC&amp;Reaml</h4><p>Realm：意思是域，Shiro从Reaml中获取验证数据；<br>Realm有很多种类，例如常见的jdbc realm</p>
<h4 id="码上有戏"><a href="#码上有戏" class="headerlink" title="码上有戏"></a>码上有戏</h4><p>1.在eclipse中新建一个maven工程，并且配置pom.xml<br>主要配置如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;dependencies&gt;</div><div class="line"></div><div class="line">  	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span>&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">1.2</span>.<span class="number">4</span>&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    </div><div class="line">    &lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">1.7</span>.<span class="number">12</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;c3p0&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;c3p0&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">0.9</span>.<span class="number">1.2</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;commons-logging&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">1.2</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;<span class="number">5.1</span>.<span class="number">37</span>&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line"></div><div class="line">  &lt;/dependencies&gt;</div></pre></td></tr></table></figure></p>
<p>主要有shiro的核心包、日志包，数据源及数据库连接包</p>
<ol>
<li>在resource包下新建jdbc_realm.ini用于配置从数据库中获取验证数据<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[main]   <span class="comment">//声明以下是代码片段</span></div><div class="line"><span class="comment">//相当于new了一个jdbcRealm类</span></div><div class="line">jdbcRealm=org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.realm</span><span class="selector-class">.jdbc</span><span class="selector-class">.JdbcRealm</span></div><div class="line"><span class="comment">//声明一个数据源，这里用了c3p0</span></div><div class="line">dataSource=com<span class="selector-class">.mchange</span><span class="selector-class">.v2</span><span class="selector-class">.c3p0</span><span class="selector-class">.ComboPooledDataSource</span></div><div class="line"><span class="comment">//声明驱动</span></div><div class="line">dataSource.driverClass=com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span></div><div class="line"><span class="comment">//声明url，其中localhost可更改为ip地址</span></div><div class="line">dataSource.jdbcUrl=jdbc:mysql:<span class="comment">//localhost:9806/db_shiro</span></div><div class="line"><span class="comment">//配置数据库用户名、密码</span></div><div class="line">dataSource.user=root</div><div class="line">dataSource.password=root</div><div class="line"><span class="comment">//添加数据源</span></div><div class="line">jdbcRealm.dataSource=<span class="variable">$dataSource</span></div><div class="line"><span class="comment">//添加数据域</span></div><div class="line">securityManager.realms=<span class="variable">$jdbcRealm</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里数据库中需要注意的是，数据库中的表名必须为users，并且字段必须为userName和password</p>
<ol>
<li>在src/main/java文件下新建一个HelloWorld类，目前数据这里手动构造一个<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package com.zwl.shiro;</div><div class="line"></div><div class="line">import org.apache.shiro.SecurityUtils;</div><div class="line">import org.apache.shiro.authc.AuthenticationException;</div><div class="line">import org.apache.shiro.authc.UsernamePasswordToken;</div><div class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</div><div class="line">import org.apache.shiro.mgt.SecurityManager;</div><div class="line">import org.apache.shiro.subject.Subject;</div><div class="line">import org.apache.shiro.util.Factory;</div><div class="line"></div><div class="line">public class HelloWorld &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//读取配置文件，初始化SecurityManager工厂</div><div class="line">	   Factory&lt;SecurityManager&gt; factory=new IniSecurityManagerFactory("classpath:jdbc_realm.ini");</div><div class="line">	    //获取SecurityManager实例</div><div class="line">	   SecurityManager securityManager=factory.getInstance();</div><div class="line">	   //把SecurityManager实例绑定到SecurityUtils</div><div class="line">	   SecurityUtils.setSecurityManager(securityManager);</div><div class="line">	   //得到当前执行的用户</div><div class="line">	   Subject currentUser=SecurityUtils.getSubject();</div><div class="line">	   //创建token令牌，用户名/密码</div><div class="line">	   UsernamePasswordToken token=new UsernamePasswordToken("admin", "123456");</div><div class="line">	   try &#123;</div><div class="line">		//身份认证</div><div class="line">		  currentUser.login(token);</div><div class="line">		  System.out.println("身份认证成功！");</div><div class="line">	&#125; catch (AuthenticationException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		System.out.println("身份认证失败！");</div><div class="line">	&#125;</div><div class="line">	        // 退出</div><div class="line">			currentUser.logout();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里通过更改token来模拟验证数据是否正确</p>
<p>相关源代码，已放在<a href="https://github.com/slycmiaoxi/slycmx.github.io/tree/b" target="_blank" rel="external">github</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考百度上说的&lt;a href=&quot;http://shiro.apache.org/download.html&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="安全框架" scheme="http://www.myzwl.win/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Shiro" scheme="http://www.myzwl.win/source/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>并发系列之四Guarded Suspension</title>
    <link href="http://www.myzwl.win/2017/04/13/thrd4/"/>
    <id>http://www.myzwl.win/2017/04/13/thrd4/</id>
    <published>2017-04-13T05:48:51.000Z</published>
    <updated>2017-04-20T11:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Guarded Suspension是指当现在并不适合马上执行某个操作时，就要求想要执行该操作的线程等待</p>
<h4 id="Guarded-Suspension"><a href="#Guarded-Suspension" class="headerlink" title="Guarded Suspension"></a>Guarded Suspension</h4><p>首先模拟一个案例<br>首先是表示请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public class Request &#123;</div><div class="line">private final String name;</div><div class="line"></div><div class="line">public Request(String name)&#123;</div><div class="line">	this.name=name;</div><div class="line">&#125;</div><div class="line">public String getName()&#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String toString()&#123;</div><div class="line">	return "[ Request"+name+"]";</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一次存放请求以待使用的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.LinkedList;</div><div class="line"></div><div class="line">public class RequestQueue &#123;</div><div class="line"></div><div class="line">  //构造链表，用来保存请求</div><div class="line">	private final LinkedList queue=new LinkedList&lt;&gt;();</div><div class="line">//有请求将最早的请求取出，没有则等待</div><div class="line">	public synchronized Request getRequest()&#123;</div><div class="line">		while(queue.size()&lt;=0)&#123;</div><div class="line">			try&#123;</div><div class="line">				wait();</div><div class="line">			&#125;catch(Exception e)&#123;</div><div class="line">				</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return (Request) queue.removeFirst();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//增加一个请求</div><div class="line">	public synchronized void putRequest(Request request)&#123;</div><div class="line">		queue.addLast(request);</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>送出请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class ClientThread extends Thread &#123;</div><div class="line">  //构造随机数，用来线程等待时间</div><div class="line">	private Random random;</div><div class="line">	//存放请求</div><div class="line">	private RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	public ClientThread(RequestQueue requestQueue,String name,long seed)&#123;</div><div class="line">		super(name);</div><div class="line">		this.requestQueue=requestQueue;</div><div class="line">		this.random=new Random(seed);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">//不断调用putrequest（），并且打印相关信息</div><div class="line">		for(int i=0;i&lt;10000;i++)&#123;</div><div class="line">			Request request=new Request("No ."+i);</div><div class="line">			System.out.println(Thread.currentThread().getName()+" Request:"+request);</div><div class="line">			requestQueue.putRequest(request);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(random.nextInt(1000));</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO: handle exception</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接收请求的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class ServerThread extends Thread &#123;</div><div class="line">	private Random random;</div><div class="line">	private RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	public ServerThread(RequestQueue requestQueue,String name,long seed)&#123;</div><div class="line">		super(name);</div><div class="line">		this.requestQueue=requestQueue;</div><div class="line">		this.random=new Random(seed);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">	//不断调用getrequest（）</div><div class="line">		for(int i=0;i&lt;10000;i++)&#123;</div><div class="line">			Request request=requestQueue.getRequest();</div><div class="line">			System.out.println(Thread.currentThread().getName()+" Handlet:"+request);</div><div class="line">			</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(random.nextInt(1000));</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO: handle exception</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后是测试<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RequestQueue requestQueue=new RequestQueue();</div><div class="line">		new ClientThread(requestQueue, "A", 1314520l).start();</div><div class="line">		new ServerThread(requestQueue, "B", 5201314l).start();</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>A Request:[ RequestNo .0]<br>B Handlet:[ RequestNo .0]<br>A Request:[ RequestNo .1]<br>B Handlet:[ RequestNo .1]<br>A Request:[ RequestNo .2]<br>B Handlet:[ RequestNo .2]<br>……</p>
</blockquote>
<p>从测试结果可以看出，当发送请求时，接受并处理<br>而其中的关键方法是getRequest（）中，当满足while里条件时，则调用wait，处于等待，直到收到通知，才从休息区出来，而这种一定要满足的条件，就称为Guarded Suspension的警戒条件</p>
<p>所以可将该模式抽象为如下<br>GuardedObject（被防伪的对象）参与者：当线程执行guardMethod时，只要满足警戒条件，就马上执行，当不成立时，就开始等待，而条件的成立与否，是与参与者的状态变化有关<br>guardMethod：防伪的方法<br>stateChangingMethod：状态改变的方法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Guarded Suspension是指当现在并不适合马上执行某个操作时，就要求想要执行该操作的线程等待&lt;/p&gt;
&lt;h4 id=&quot;Guard
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发系列之三Immutable</title>
    <link href="http://www.myzwl.win/2017/04/12/thrd3/"/>
    <id>http://www.myzwl.win/2017/04/12/thrd3/</id>
    <published>2017-04-12T05:48:51.000Z</published>
    <updated>2017-07-14T07:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>immutable是指永恒，不会改变的意思，就像java.lang.String类中，并没有提供任何改变字符串属性的方法</p>
<h4 id="immutable-Pattern"><a href="#immutable-Pattern" class="headerlink" title="immutable Pattern"></a>immutable Pattern</h4><p>首先模拟一个案例<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public final class Person &#123;</div><div class="line">//不允许修改的地址</div><div class="line">private final String address;</div><div class="line">//不允许修改的姓名</div><div class="line">private final String name;</div><div class="line">public Person(String name, String address) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.address = address;</div><div class="line">&#125;</div><div class="line">//有final就不会有set方法，控制外部对其的修改</div><div class="line">public String getAddress() &#123;</div><div class="line">	return address;</div><div class="line">&#125;</div><div class="line">public String getName() &#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String toString()&#123;</div><div class="line">	return "[ Person: name="+name+ ",address="+address+"]";</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是人的线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest3;</div><div class="line"></div><div class="line">public class PersonThread extends Thread &#123;</div><div class="line"></div><div class="line">	private Person person;</div><div class="line"></div><div class="line">	public PersonThread(Person person) &#123;</div><div class="line">		this.person = person;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">		while(true)&#123;</div><div class="line">		//得到线程的名并打印出人的信息</div><div class="line">			System.out.println(Thread.currentThread().getName()+"prints"+person);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person person=new Person("A1","AA");</div><div class="line">	new PersonThread(person).start();</div><div class="line">	new PersonThread(person).start();</div><div class="line">	new PersonThread(person).start();</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>Thread-2prints[ Person: name=A1,address=AA]<br>以下一直重复</p>
</blockquote>
<p>可以发现上面的字段都是final并且没有修改该字段的方法<br>正因为如此，所以就不需要使用synchronized来限制，这在性能上就大大提高了</p>
<h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><p>1.当实例产生后，状态不再变化时<br>2.实例需要共享，而且访问很频繁时</p>
<p>当然，有时也需要变与不变的转换，就像StringBuffer是一个线程不安全的类，在它的构造器中有String作为参数，而在String类中也有StringBuffer作为参数<br>另外像java中的基本类型boolean、int、long等都是immutable模式<br>该模式最大的优点就是实例的状态不会改变，所以没必要进行保护</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;immutable是指永恒，不会改变的意思，就像java.lang.String类中，并没有提供任何改变字符串属性的方法&lt;/p&gt;
&lt;h4 i
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发系列之二Single Threaded Execution</title>
    <link href="http://www.myzwl.win/2017/04/11/thrd2/"/>
    <id>http://www.myzwl.win/2017/04/11/thrd2/</id>
    <published>2017-04-11T03:48:51.000Z</published>
    <updated>2017-04-20T04:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Single Threaded Execution是指以一个线程执行，简单来说就是在多线程中限制同时只让一个线程运行</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>首先来模拟一个线程不安全的例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class Gate &#123;</div><div class="line"></div><div class="line">    //记录走过门的人数，默认为0</div><div class="line">	private int count=0;</div><div class="line">	//记录通过门的人的名字</div><div class="line">	private String name="nobody";</div><div class="line">	//记录通过门的人的地址</div><div class="line">	private String address="noplace";</div><div class="line">	</div><div class="line">	//穿越这道门使用的方法</div><div class="line">	public  void pass(String name,String address)&#123;</div><div class="line">		this.name=name;</div><div class="line">		this.address=address;</div><div class="line">		count++;</div><div class="line">		check();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//检查通过门的人的合法性，即人的名字和地址首字母是否相同</div><div class="line">	public void check()&#123;</div><div class="line">		if(name.charAt(0)!=address.charAt(0))&#123;</div><div class="line">			System.out.println("***broken***"+this.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//打印出人数、姓名、地址</div><div class="line">	public  String toString()&#123;</div><div class="line">		return "No."+count+":"+name+" ,"+address;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>目前上面的Gate类是线程不安全的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">//不断穿越门的行人</div><div class="line">public class UserThread extends Thread &#123;</div><div class="line">//用final限制门，姓名，地址不能重复</div><div class="line">private final Gate gate;</div><div class="line">private final String myaddress;</div><div class="line">private final String myname;</div><div class="line">public UserThread(Gate gate, String myname, String myaddress) &#123;</div><div class="line">	super();</div><div class="line">	this.gate = gate;</div><div class="line">	this.myname = myname;</div><div class="line">	this.myaddress = myaddress;</div><div class="line">&#125;</div><div class="line">//发生错误，即行人不合法，则处于死循环，并且执行toString方法</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">	System.out.println(myname+" BEGIN");</div><div class="line">while(true)&#123;</div><div class="line">	gate.pass(myname, myaddress);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">System.out.println("test begin:");</div><div class="line">	Gate gate=new Gate();</div><div class="line">	//构造三个行人</div><div class="line">	new UserThread(gate, "A1", "A2").start();</div><div class="line">	new UserThread(gate, "B1", "B2").start();</div><div class="line">	new UserThread(gate, "C1", "C2").start();</div></pre></td></tr></table></figure></p>
<p>测试结果（截取部分）</p>
<blockquote>
<p>test begin:<br>B1 BEGIN<br>A1 BEGIN<br><strong><em>broken</em></strong>No.1305356:A1 ,A2<br><strong><em>broken</em></strong>No.1347999:B1 ,B2<br><strong><em>broken</em></strong>No.1357011:A1 ,A2<br><strong><em>broken</em></strong>No.1370176:B1 ,B2<br><strong><em>broken</em></strong>No.1377075:B1 ,B2</p>
</blockquote>
<p>从结果来看，明显发生了错误，即出现了线程不安全，但是也有点不对劲</p>
<h4 id="为什么会出错了"><a href="#为什么会出错了" class="headerlink" title="为什么会出错了"></a>为什么会出错了</h4><blockquote>
<p>问题的出错地方就在Gate类中，因为其是线程不安全的，打个比方<br>    线程A1                  线程A2           this.name值            this.address值<br>   count++                  count++            之前的值                  之前的值<br> this.name=name                                  A1                     之前的值<br>                           this.name=name        A2                     之前的值<br>                           this.address=address  A2                       B2<br> this.address=address                            A1                       B2<br>  check（）                  check（）           A1                        B2</p>
</blockquote>
<p>  发生错误</p>
<p>  以上只是发生错误的一种情况，事实上只有当数据量非常大时，极有可能发生错误，所以才会出现错误的结果，并且是在count达到大数量的时候出现的<br>  那么如何修改了？<br>  因为发生在Gate类的pass和toString方法中，所以只要把这个两个方法声明为同步就可以了</p>
<blockquote>
<p>public synchronized void pass(String name,String address){}<br>  public synchronized String toString(){}</p>
</blockquote>
<p>  对应的测试结果</p>
<blockquote>
<p>test begin:<br>A1 BEGIN<br>B1 BEGIN<br>C1 BEGIN</p>
</blockquote>
<h4 id="归纳single-Threaded"><a href="#归纳single-Threaded" class="headerlink" title="归纳single Threaded"></a>归纳single Threaded</h4><p>上面例子的解决方案就是该模式的一种应用，可以将其抽象为以下几个参与者<br>SharedResource（共享资源）参与者：可有多个线程访问的类，如Gate<br>SafeMethod：从多个线程同时调用也不会发生问题<br>UnsafeMethod：从多个线程同时调用会发生问题，需要防范的方法<br>所以必须将上述不安全的方法加以同步锁，当时如果通过其他方法改变不安全方法中数据也会发生错误，就像大门上锁，但是窗户开着一样，所以有时也是一个隐患的问题</p>
<p>那么此种模式何时适用了？<br>多线程时、数据可被多个线程访问的时候、状态可能变化的时候、需要确保安全性的时候</p>
<h4 id="生命线与死锁"><a href="#生命线与死锁" class="headerlink" title="生命线与死锁"></a>生命线与死锁</h4><p>使用该模式，可能会发生死锁的危险<br>而死锁是指：两个线程分别获取了锁定，互相等待另一个线程解除锁定的线程。发生死锁时，哪个线程都无法继续执行下去，所以程序会失去生命线<br>最经典的死锁问题就是汤勺与叉子模型，问题大概是这样的<br>假设A与B同吃一碗面，盘子旁有一支汤勺与一支叉子，而吃面必须同时需要汤勺和叉子<br>而现在叉子被其中一人假设是A拿走，而汤勺被B拿走，就会造成如下现象：<br>A和B一直等待对方放下叉子（或者汤勺），即一直处于等待，僵持阶段，从而程序无法继续运行，故称为死锁现象</p>
<p>而只要上述模式达到下面的条件，就会出现死锁<br>1.具有多个SharedResource参与者<br>2.线程锁定一个SharedResource时，还没接触前就去锁定另一个SharedResource<br>3.获取SharedResource参与者的顺序不固定</p>
<p>当然只要破坏上述三个条件之一就可以避免死锁的发生</p>
<p>下面就开始模拟死锁<br>首先是表示餐具的类(这里只有叉子和汤勺)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class Tool &#123;</div><div class="line"></div><div class="line">	private final String name;</div><div class="line">	public Tool(String  name)&#123;</div><div class="line">		this.name=name;</div><div class="line">	&#125;</div><div class="line">	public String toString()&#123;</div><div class="line">		return "["+name+"]";</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>开始用餐的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest2;</div><div class="line"></div><div class="line">public class EaterThread extends Thread &#123;</div><div class="line">    </div><div class="line">    //用餐者名字</div><div class="line">	private String name;</div><div class="line">	//左手拿餐具</div><div class="line">	private final Tool lefthand;</div><div class="line">	//右手拿餐具</div><div class="line">	private final Tool righthand;</div><div class="line">	public EaterThread(String name, Tool lefthand, Tool righthand) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.lefthand = lefthand;</div><div class="line">		this.righthand = righthand;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void run()&#123;</div><div class="line">	  //不断吃</div><div class="line">		while(true)&#123;</div><div class="line">			eat();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void eat()&#123;</div><div class="line">		 //锁定左手获取餐具</div><div class="line">		synchronized (lefthand) &#123;</div><div class="line">		 //左手拿餐具</div><div class="line">			System.out.println(name+"takes up"+lefthand+"left.");</div><div class="line">		 //锁定右手拿餐具</div><div class="line">			synchronized (righthand) &#123;</div><div class="line">		 //右手拿餐具</div><div class="line">				System.out.println(name+" takes up"+righthand+"right.");</div><div class="line">		 //开吃</div><div class="line">				System.out.println(name+" is eating");</div><div class="line">		 //右手放下餐具</div><div class="line">				System.out.println(name+" puts down"+righthand+"right.");</div><div class="line">			&#125;</div><div class="line">		 //解除右手锁定锁，并且左手放下餐具</div><div class="line">			System.out.println(name+"puts down"+lefthand+"left.");</div><div class="line">		&#125;</div><div class="line">		//解除左手餐具的锁定</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   System.out.println("test begin:");</div><div class="line">Tool spoon=new Tool("Spoon");</div><div class="line">Tool fork=new Tool("Fork");</div><div class="line">new EaterThread("A", spoon, fork).start();</div><div class="line">new EaterThread("B", fork, spoon).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>test begin:<br>Atakes up[Spoon]left.<br>A takes up[Fork]right.<br>A is eating<br>A puts down[Fork]right.<br>Aputs down[Spoon]left.<br>Atakes up[Spoon]left.<br>A takes up[Fork]right.<br>A is eating<br>A puts down[Fork]right.<br>Aputs down[Spoon]left.<br>重复。。直到<br>Atakes up[Spoon]left.<br>Btakes up[Fork]left.<br>该处程序停止不动了，也就是a和b分别拿着汤勺和叉子，即处于死锁状态了。</p>
</blockquote>
<p>一种最简单的方法就是改变顺序，即以相同顺序拿餐具<br>即：</p>
<blockquote>
<p>Tool spoon=new Tool(“Spoon”);<br>    Tool fork=new Tool(“Fork”);<br>    new EaterThread(“A”, spoon, fork).start();<br>    new EaterThread(“B”, spoon,fork).start();</p>
</blockquote>
<p>最后程序就会一直进行下去，不过这样的话，前面的共享资源就不存在了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Single Threaded Execution是指以一个线程执行，简单来说就是在多线程中限制同时只让一个线程运行&lt;/p&gt;
&lt;h4 id=
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发系列一之初识java线程</title>
    <link href="http://www.myzwl.win/2017/04/10/thrd1/"/>
    <id>http://www.myzwl.win/2017/04/10/thrd1/</id>
    <published>2017-04-10T13:48:51.000Z</published>
    <updated>2017-04-18T15:47:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>曾在论坛中看过这样一句话，如果连多线程都不懂，别说自己学过java，可见多线程的重要性！</p>
<h4 id="何谓线程"><a href="#何谓线程" class="headerlink" title="何谓线程"></a>何谓线程</h4><p>简单来说，就像我们在执行一个程序时，他总按照顺序执行，如果从头到尾都没有分叉，也就是说总是一个流程，那么就可以看做单线程，并且程序执行的主体只有一个，所以，我们把正在执行程序的主体称为线程</p>
<p>当然，平时我们说的最多的就是多线程，顾名思义就是由一个以上的线程所构成的程序，比如文件处理，io请求处理及网络客户端发出的请求等等都可以看做多线程</p>
<h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>先看一个简单的例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utest1;</div><div class="line"></div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">public class Mythread extends Thread &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;700;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mythread m=new Mythread();</div><div class="line">	  m.start();</div><div class="line">	  for(int i=0;i&lt;900;i++)&#123;</div><div class="line">	  System.out.print("lol!");</div><div class="line">	  &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果</p>
<blockquote>
<p>lol!lol!lol!lol!lol!lol!。。hello!hello!hello!hello!hello!。。lol!lol!lol!lol!lol!lol!</p>
</blockquote>
<p>然后在去认识上面程序，其中start方法会启动新的线程，然后再由这个新线程调用run方法，<br>当然也可以直接调用run方法</p>
<p>那么两者有什么区别了？<br>调用start方法会出现字符串交错，也就是并发，而run方法，就是等run方法执行完，在执行其它，显然不会出现交错现象<br>当然数据量小的话，出现的结果很难有说服力，所以并发模拟尽量使用大数量</p>
<h4 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h4><ol>
<li>利用thread的子类的实例，启动线程<br>正如前面模拟的程序，不过下面测试用两个线程<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new Mythread().start（）;</div><div class="line">new Mythread().start（）;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>显然两个线程操作两个对象，所以thread是线程安全的</p>
<ol>
<li>利用Runnable接口<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Mythread implements Runnable</div><div class="line">&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;700;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      Mythread m=new Mythread();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>这里主要向Runnable接口实现的实例作为参数传递给Thread，再启动线程，这里就有一个问题，因为不同线程操作一个对象，所以会造成线程不安全的问题，也就是脏数据</p>
<h4 id="线程的暂时停止"><a href="#线程的暂时停止" class="headerlink" title="线程的暂时停止"></a>线程的暂时停止</h4><p>利用Thread的sleep方法可暂时停止线程当前的操作，如<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">      public class Mythread implements Runnable</div><div class="line">&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i=0;i&lt;5;i++)&#123;</div><div class="line">	System.out.print("hello!");</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(1000);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>这里的参数是ms，所以1000就是1s了</p>
<h4 id="线程的共享互斥"><a href="#线程的共享互斥" class="headerlink" title="线程的共享互斥"></a>线程的共享互斥</h4><p>在程序里，多个线程可自由操作，就会造成一个线程还在执行，另一个线程就插进来执行，就会造成一些脏数据的产生<br>如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">       private int count=1000;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">	for(int i=0;i&lt;100;i++)&#123;</div><div class="line">		count--;</div><div class="line">		System.out.println("mythread"+(count));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     Mythread m=new Mythread();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：（取部分）</p>
<blockquote>
<p>mythread999<br>mythread997<br>mythread996<br>mythread995<br>mythread994</p>
</blockquote>
<p>显然出现了脏数据<br>要想使数据正确，一种方法是加同步锁，即一个线程在执行该操作时，其余线程无锁，则必须等待，直到该线程执行结束或者被挂起，才释放锁，然后在门外等待的线程依次执行，加锁，重复上述步骤<br>显然，就不会出现多个线程操作同一个对象了</p>
<p>java中通过声明synchronized关键字实现同步锁<br>如：</p>
<blockquote>
<p>public synchronized void run()</p>
</blockquote>
<p>则在执行run方法前加同步锁，控制线程，当然该关键字可以声明在任何方法前，包括静态方法<br>另外，它还有另外一种声明方式</p>
<blockquote>
<p>public  void run() {<br>        synchronized (xx.class) {<br>        }</p>
</blockquote>
<p>注意这里xx.class是操作该方法的那个类实现同步比如这里可以将</p>
<blockquote>
<p>synchronized (this) {}</p>
</blockquote>
<p>就是对本身这个类加锁控制了等同于上述的另一种写法</p>
<h4 id="线程的协调"><a href="#线程的协调" class="headerlink" title="线程的协调"></a>线程的协调</h4><p>如果有一个线程正在执行同步锁，而其他线程则要等待，这是典型的线程互斥现象<br>假如当该空间有空余时则写入数据，无空闲时间则等待（等待）<br>当该空间有空闲时，则通知等待的线程（通知）</p>
<p>这里是根据空间是否空闲为条件进行线程处理，java中通过wait（让线程等待），notify与notifyAll（启动等候中的线程）</p>
<p>我们可以把线程处于等待的地方形象的看做wait set（线程的休息室）</p>
<h4 id="wait-把线程放入休息室"><a href="#wait-把线程放入休息室" class="headerlink" title="wait-把线程放入休息室"></a>wait-把线程放入休息室</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">	private static int count=90;</div><div class="line">	</div><div class="line">public synchronized int s() throws InterruptedException&#123;</div><div class="line">	count--;</div><div class="line">	System.out.println("ok:"+count);</div><div class="line">	this.wait();</div><div class="line">	System.out.println("lockover");</div><div class="line">	return count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">	public  void run() &#123;	</div><div class="line">				try &#123;</div><div class="line">					s();</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>然后在测试中启动几个线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     Count m=new Count();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div><div class="line">new Thread(m).start();</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>ok:89<br>ok:88<br>ok:87</p>
</blockquote>
<p>一般为obj.wait（），而obj是某个对象的实例，也就是说该线程在obj的休息区<br>之后会自动释放锁，等待的线程开始执行</p>
<p>当然也有obj.wait（1000）；也可以设置在休息区等待的秒数，然后继续执行</p>
<p>测试结果：</p>
<blockquote>
<p>ok:89<br>ok:88<br>ok:87<br>lockover<br>lockover<br>lockover</p>
</blockquote>
<h4 id="notify方法-从休息区拿出线程"><a href="#notify方法-从休息区拿出线程" class="headerlink" title="notify方法-从休息区拿出线程"></a>notify方法-从休息区拿出线程</h4><p>一般为obj.notify（），即从obj的wait set里的线程中挑选一个，唤醒一个线程并退出该休息区<br>当然，这里有一个顺序，召唤该线程的那个线程执行完，释放锁后，那个在休息区的线程在执行</p>
<p>obj.notifyAll（），即从线程区中拿出所有线程</p>
<p>最后需要说一下的是wait、notify、notifyAll是Object的类方法，也就是所有类都能使用</p>
<p>由此可看出多线程的确是一个复杂而且很重要的东西！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;曾在论坛中看过这样一句话，如果连多线程都不懂，别说自己学过java，可见多线程的重要性！&lt;/p&gt;
&lt;h4 id=&quot;何谓线程&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="并发编程" scheme="http://www.myzwl.win/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.myzwl.win/source/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>集合中的线程安全问题</title>
    <link href="http://www.myzwl.win/2017/04/07/thread2/"/>
    <id>http://www.myzwl.win/2017/04/07/thread2/</id>
    <published>2017-04-07T13:48:51.000Z</published>
    <updated>2017-04-08T15:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早在刚开始学习java se的时候，就遇到过这样问题，xxx是线程安全的，xxxx是线程不安全的，当时也是一脸蒙，只记住了结论。后来接触了单例才有一点了解</p>
<p>线程安全的：<br>vector、hashtable、stringbuffer等</p>
<p>非线程安全的：<br>arraylist、linkedlist、hashmap、StringBuilder等等</p>
<p>首先来模拟一个案例</p>
<p>测试集合类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static void test()  &#123;</div><div class="line">// 用来测试的List  </div><div class="line">   List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();  </div><div class="line">   </div><div class="line">   // 线程数量(1000)  </div><div class="line">   int threadCount = 1000;  </div><div class="line">   </div><div class="line">// 用来让主线程等待threadCount个子线程执行完毕  </div><div class="line">   CountDownLatch countDownLatch = new CountDownLatch(threadCount);  </div><div class="line">   </div><div class="line">    // 启动threadCount个子线程  </div><div class="line">   for(int i = 0; i &lt; threadCount; i++)  </div><div class="line">   &#123;  </div><div class="line">       Thread thread = new Thread(new Mythread(list,countDownLatch));  </div><div class="line">       thread.start();  </div><div class="line">   &#125;  </div><div class="line">   try  </div><div class="line">   &#123;  </div><div class="line">       // 主线程等待所有子线程执行完成，再向下执行  </div><div class="line">       countDownLatch.await();  </div><div class="line">   &#125;  </div><div class="line">   catch (InterruptedException e)  </div><div class="line">   &#123;  </div><div class="line">       e.printStackTrace();  </div><div class="line">   &#125;  </div><div class="line">   // List的size  </div><div class="line">   System.out.println(list.size());  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>自定义线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line">import java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line">public class Mythread implements Runnable &#123;</div><div class="line">	private List&lt;Object&gt; list;  </div><div class="line">	</div><div class="line">	private CountDownLatch countDownLatch; </div><div class="line">	public Mythread(List&lt;Object&gt; list,CountDownLatch countDownLatch)&#123;</div><div class="line">		  this.list = list; </div><div class="line">		  this.countDownLatch = countDownLatch;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		// 每个线程向List中添加100个元素  </div><div class="line">        for(int i = 0; i &lt; 100; i++)  </div><div class="line">        &#123;  </div><div class="line">            list.add(new Object());  </div><div class="line">        &#125;  </div><div class="line">     // 完成一个子线程  </div><div class="line">        countDownLatch.countDown();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">	 </div><div class="line">	 // 进行10次测试  </div><div class="line">        for(int i = 0; i &lt; 10; i++)  </div><div class="line">        &#123;  </div><div class="line">            test();  </div><div class="line">        &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>99873<br>99968<br>99955<br>100000<br>100000<br>100000<br>100000<br>Exception in thread “Thread-7516” java.lang.ArrayIndexOutOfBoundsException: 76327<br>    at java.util.ArrayList.add(ArrayList.java:441)<br>    at com.zwl.test.Mythread.run(Mythread.java:20)<br>    at java.lang.Thread.run(Thread.java:744)</p>
</blockquote>
<p>有时不会出现异常，但是list的长度不是最终期望的那样，显然是线程不安全的，<br>这里是arraylist，同样将其换成linkedlist，也可以改变list，变成其它，得到同样线程不安全结果</p>
<p>测试结果：</p>
<blockquote>
<p>100000<br>99783<br>100000<br>99945<br>99897<br>99996<br>99879<br>99971<br>100000<br>99899</p>
</blockquote>
<p>将其换成线程安全的，如</p>
<blockquote>
<p>List<object> list = new Vector<object>(); </object></object></p>
</blockquote>
<p>测试结果：</p>
<blockquote>
<p>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000<br>100000</p>
</blockquote>
<p>当然集合中的线程不安全是多线程同时操作同一个对象，如果是不同类，就不存在线程安全问题</p>
<p>对于线程安全，一般通过线程同步来实现，即通过申明synchronized关键字</p>
<p>如，改一下之前的线程安全的例子number类</p>
<p>修改后的number类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class number &#123;</div><div class="line"></div><div class="line">	private int num=0; </div><div class="line"></div><div class="line">	public  void count()&#123;</div><div class="line">	</div><div class="line">		num++;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int getnumber()&#123;</div><div class="line">		return num;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是自定义线程<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Mythread implements Runnable &#123;</div><div class="line">	private number num;</div><div class="line">	</div><div class="line">	private CountDownLatch countDownLatch; </div><div class="line">	public Mythread(number num,CountDownLatch countDownLatch)&#123;</div><div class="line">		  this.num = num; </div><div class="line">		  this.countDownLatch = countDownLatch;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123; </div><div class="line">        for(int i = 0; i &lt; 100; i++)  </div><div class="line">        &#123;  </div><div class="line"> </div><div class="line">        	num.count();</div><div class="line">        	</div><div class="line">        &#125;  </div><div class="line">     // 完成一个子线程  </div><div class="line">        countDownLatch.countDown();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程测试类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> public static void test()  &#123;</div><div class="line"></div><div class="line">   </div><div class="line">   number num=new number();</div><div class="line">   // 线程数量(1000)  </div><div class="line">   int threadCount = 1000;  </div><div class="line">   </div><div class="line">// 用来让主线程等待threadCount个子线程执行完毕  </div><div class="line">   CountDownLatch countDownLatch = new CountDownLatch(threadCount);  </div><div class="line">   </div><div class="line">   for(int i = 0; i &lt; threadCount; i++)  </div><div class="line">   &#123;  </div><div class="line">       Thread thread = new Thread(new Mythread(num,countDownLatch));  </div><div class="line">       thread.start();  </div><div class="line">   &#125;  </div><div class="line">   try  </div><div class="line">   &#123;  </div><div class="line">       // 主线程等待所有子线程执行完成，再向下执行  </div><div class="line">       countDownLatch.await();  </div><div class="line">   &#125;  </div><div class="line">   catch (InterruptedException e)  </div><div class="line">   &#123;  </div><div class="line">       e.printStackTrace();  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line">   System.out.println(num.getnumber());  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		 </div><div class="line">		 // 进行10次测试  </div><div class="line">	        for(int i = 0; i &lt; 10; i++)  </div><div class="line">	        &#123;  </div><div class="line">	            test();  </div><div class="line">	        &#125;  </div><div class="line">	 &#125;</div></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>100000<br>100000<br>100000<br>100000<br>99940<br>99300<br>100000<br>100000<br>100000<br>100000</p>
</blockquote>
<p>出现了线程不安全<br>可以通过对方法声明同步</p>
<blockquote>
<p>public synchronized void count(){}</p>
</blockquote>
<p>最后输出的书都是同一个数</p>
<p>最后不得不说，线程安全是一个很复杂的问题，有时候不注意就会出现数据上的各种问题！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;早在刚开始学习java se的时候，就遇到过这样问题，xxx是线程安全的，xxxx是线程不安全的，当时也是一脸蒙，只记住了结论。后来接触了单
    
    </summary>
    
      <category term="学习进阶" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="java集合" scheme="http://www.myzwl.win/source/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>初识线程安全与线程不安全</title>
    <link href="http://www.myzwl.win/2017/04/06/thread1/"/>
    <id>http://www.myzwl.win/2017/04/06/thread1/</id>
    <published>2017-04-06T13:48:51.000Z</published>
    <updated>2017-04-08T15:58:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于线程问题基本上贯穿学习的整个过程，像集合，servlet，structs，hibernate，spring等等，其都涉及到线程问题</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>什么是线程安全？<br>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>线程安全问题都是由全局变量及静态变量引起的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全</p>
<p>不妨来一个实例<br>首先是number类，里面有一个计数的全局和静态变量<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class number &#123;</div><div class="line"></div><div class="line">	private int num;</div><div class="line">	private static int count;</div><div class="line">	</div><div class="line">	public void count()&#123;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			num+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+num);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void countstatic()&#123;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			count+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+count);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然我们希望每个线程都能输出的结果是55就是线程安全</p>
<p>线面是测试类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package com.zwl.test;</div><div class="line"></div><div class="line">public class test &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	</div><div class="line">		Runnable runner=new Runnable() &#123;</div><div class="line">			number num=new number();</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				num.count();</div><div class="line">				System.out.println("statis:");</div><div class="line">				num.countstatic();</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			new Thread(runner).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里启动十个线程，依次通过run方法输出全局和静态变量的累加和，如果是线程安全的，则应该都是55</p>
<p>结果如下所示</p>
<blockquote>
<p>Thread-0:55<br>statis:<br>Thread-0:55<br>Thread-1:110<br>statis:<br>Thread-1:110<br>Thread-2:165<br>statis:<br>Thread-2:165<br>Thread-6:275<br>statis:<br>Thread-6:220<br>Thread-3:385<br>statis:<br>Thread-4:220<br>statis:<br>Thread-3:275<br>Thread-8:385<br>statis:<br>Thread-8:385<br>Thread-4:330<br>Thread-5:440<br>statis:<br>Thread-5:440<br>Thread-7:495<br>statis:<br>Thread-7:495<br>Thread-9:550<br>statis:<br>Thread-9:550</p>
</blockquote>
<p>发现不是线程安全的</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
<p>对于上面的线程不安全可以进行如下修改</p>
<p>解决方法：将全局变量变成局部变量（静态变量暂时不讨论）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void count()&#123;</div><div class="line">		int num = 0;</div><div class="line">		for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">			num+=i;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName()+":"+num);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>最后所有的线程都输出了55</p>
<p>或者将new 的number放到run里面，变成局部的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">			public void run() &#123;</div><div class="line">				number num=new number();</div><div class="line">				num.count();</div><div class="line">				System.out.println("statis:");</div><div class="line">				num.countstatic();</div><div class="line">			&#125;</div><div class="line">		&#125;;</div></pre></td></tr></table></figure></p>
<p>最后也能保证了线程安全了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于线程问题基本上贯穿学习的整个过程，像集合，servlet，structs，hibernate，spring等等，其都涉及到线程问题&lt;/p
    
    </summary>
    
      <category term="学习进阶" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="java集合" scheme="http://www.myzwl.win/source/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>初识Linkedlist底层</title>
    <link href="http://www.myzwl.win/2017/04/05/linkedlist/"/>
    <id>http://www.myzwl.win/2017/04/05/linkedlist/</id>
    <published>2017-04-05T13:48:51.000Z</published>
    <updated>2017-04-08T12:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LinkedList底层是基于双端链表实现的，也就是说它具有指向其前驱与后继的引用，而且，在插入与删除数据时效率极高</p>
<p>至于它继承谁和实现什么接口，直接看源码</p>
<blockquote>
<p>public class LinkedList<e> extends AbstractSequentialList<e><br> implements List<e>, Deque<e>, Cloneable, java.io.Serializable</e></e></e></e></p>
</blockquote>
<p> 和ArrayList一样，从源码分析其add、get以及remove方法</p>
<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p> 首先通过MyEclipse进入LinkedList的源码</p>
<p> 找到add（）方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line"> //把e放在链表的最后一个位置</div><div class="line">       linkLast(e);</div><div class="line">       return true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到linkLast（）方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line">    * Pointer to last node.</div><div class="line">    * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line">    *            (last.next == null &amp;&amp; last.item != null)</div><div class="line">    */</div><div class="line">   transient Node&lt;E&gt; last; //链表最后一个结点的引用</div><div class="line"></div><div class="line">   transient Node&lt;E&gt; first; //链表第一个结点的引用</div><div class="line"></div><div class="line"></div><div class="line">void linkLast(E e) &#123;</div><div class="line">       //将l也指向最后一个结点</div><div class="line">       final Node&lt;E&gt; l = last;</div><div class="line"></div><div class="line">       //调用Node（Node&lt;E&gt; prev，E element，Node&lt;e&gt; next）构造方法</div><div class="line">       //其中prev为前驱结点，element为对象元素，next为后继结点</div><div class="line">       //这里构造新节点，并且是作为尾节点</div><div class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line"></div><div class="line">       //last结点指向newNode</div><div class="line">       last = newNode;</div><div class="line"></div><div class="line">       //如果l为空，则表示链表为空，直接把newNode作为首节点，否则放在l结点之后</div><div class="line">       if (l == null)</div><div class="line">           first = newNode;</div><div class="line">       else</div><div class="line">           l.next = newNode;</div><div class="line"></div><div class="line">        //链表的元素个数加一</div><div class="line">       size++;</div><div class="line"></div><div class="line">       //链表发生结构性修改的次数，这里主要指添加及删除操作</div><div class="line">       modCount++;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>以上便是add方法的源码，主要通过改变链表的前驱及后继引用来完成插入，可想而知，使用链表，使插入数据的速度异常快，相对顺序查找</p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>找到get方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line"></div><div class="line">     //检查index是否合法</div><div class="line">       checkElementIndex(index);</div><div class="line"></div><div class="line">     //如果合法就返回该节点位置的值</div><div class="line">       return node(index).item;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到checkElementIndex(int index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void checkElementIndex(int index) &#123;</div><div class="line">    //检查index是否合法</div><div class="line">       if (!isElementIndex(index))</div><div class="line">           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到isElementIndex(index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//判断index是否存在于链表中</div><div class="line">private boolean isElementIndex(int index) &#123;</div><div class="line">       return index &gt;= 0 &amp;&amp; index &lt; size;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>找到node(int index)方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Node&lt;E&gt; node(int index) &#123;</div><div class="line">    //index已在链表中</div><div class="line">    // assert isElementIndex(index);</div><div class="line">    //从第一个位置开始寻找，知道找到index的位置，最后返回该节点的位置</div><div class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        for (int i = 0; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        return x;</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    //从最后一个位置开始往前寻找该节点</div><div class="line">    else &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        for (int i = size - 1; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>linkedlist在查找时的效率非常低，就是因为它是从头或从尾部遍历链表，所以当数据量大时，造成效率低下</p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><p>找到remove方法</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public E remove(int index) &#123;</div><div class="line">      //检查index是否合法</div><div class="line">        checkElementIndex(index);</div><div class="line"></div><div class="line"></div><div class="line">        return unlink(node(index));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>找到unlink(node(index))方法<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> E unlink(Node&lt;E&gt; x) &#123;</div><div class="line">        // assert x != null;</div><div class="line">        //保存x节点的值</div><div class="line">        final E element = x.item;</div><div class="line">        //保存x节点的后继</div><div class="line">        final Node&lt;E&gt; next = x.next;</div><div class="line">        //保存x节点的前驱</div><div class="line">        final Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">       //如果前驱为空，则表明要移除的是第一个结点，在把first指向下一个节点</div><div class="line">        if (prev == null) &#123;</div><div class="line">            first = next;</div><div class="line">        &#125; else &#123;</div><div class="line">        	//否则把x前驱的后继指向x的后继，并把x前驱设置为null</div><div class="line">            prev.next = next;</div><div class="line">            x.prev = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"> //如果后继为空，则表明要移除的是最后一个结点，在把last引用指向x的前驱</div><div class="line">        if (next == null) &#123;</div><div class="line">            last = prev;</div><div class="line">        &#125; else &#123;</div><div class="line">            next.prev = prev;</div><div class="line">            x.next = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">//把x结点的值设置为null，保证x没有任何引用了</div><div class="line">        x.item = null;</div><div class="line"></div><div class="line"> //链表的size减一</div><div class="line">        size--;</div><div class="line"></div><div class="line">   //链表的结构性修改次数加一</div><div class="line">        modCount++;</div><div class="line"></div><div class="line">   //这里该节点移除之前以保存在element中，然后返回该节点</div><div class="line">        return element;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>至此，简单把上面三个方法的源码简单过了一遍<br>当然，还有一点不得不提的是LinkedList可以当做stack（栈），queue（队列）处理，因为它是双端链表，另外，在遍历时，有index &lt; (size &gt;&gt; 1)，即判断index与size/2比较，这样可以缩小范围，选择是从前遍历还是从后遍历，从而大大增加查找效率</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LinkedList底层是基于双端链表实现的，也就是说它具有指向其前驱与后继的引用，而且，在插入与删除数据时效率极高&lt;/p&gt;
&lt;p&gt;至于它继
    
    </summary>
    
      <category term="学习进阶" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="java集合" scheme="http://www.myzwl.win/source/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>hibernate之四:反向工程</title>
    <link href="http://www.myzwl.win/2017/04/04/hbm4/"/>
    <id>http://www.myzwl.win/2017/04/04/hbm4/</id>
    <published>2017-04-04T07:48:51.000Z</published>
    <updated>2017-04-08T04:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在运用持久层框架时，先前我们都是先通过建立对象—映射文件—数据库的方法，倘若数据库中的表非常多和复杂时，我们可以改变下开发顺序，即从数据库自动生成映射文件和对象，这样涉及表之间的关系，级联或者主外键约束就自动生成，更方便。一般我们用hibernate的反向工程达到此目的。</p>
<p>不多说，先模拟一个案例。<br>首先建立三张表user，picture，addr表，分别如下<br>User表<br><img src="/images/imgs3/1.gif" alt="Alt text"></p>
<p>Picture表<br><img src="/images/imgs3/2.gif" alt="Alt text"></p>
<p>外键<br><img src="/images/imgs3/3.gif" alt="Alt text"></p>
<p>这里的uid是外键对应user表的主键，并且只有当user的id删除时，对应uid相应的记录删除</p>
<p>Addr表<br><img src="/images/imgs3/4.gif" alt="Alt text"></p>
<p>外键<br><img src="/images/imgs3/5.gif" alt="Alt text"></p>
<p>通过myeclipse 提供 数据库浏览器连接到我们的mysql数据库<br><img src="/images/imgs3/6.gif" alt="Alt text"></p>
<p>然后点击右键，选择new，出现如下界面<br><img src="/images/imgs3/7.gif" alt="Alt text"></p>
<p>首先选择数据库，然后填写相关配置信息，其中Driver name随便取，添加jar包，然后点击test Driver，如股票成功，则表示与数据库连接成功，此外，可以选择保存密码，不然，后续操作一次，就要输入密码<br>直接点击finish，</p>
<p>接下来在MyEclipse中创建一个web工程，通过工具自身引入hibernate，具体步骤如下<br><img src="/images/imgs3/8.gif" alt="Alt text"></p>
<p><img src="/images/imgs3/9.gif" alt="Alt text"></p>
<p>选择之前配置好的sshe</p>
<p><img src="/images/imgs3/10.gif" alt="Alt text"></p>
<p>直接点结束，这样hibernate就引入了。</p>
<p>下面我们使用myeclipse提供的逆向工程，自动的创建对象类和对象关系映射文件<br>选中要反向的表<br><img src="/images/imgs3/11.gif" alt="Alt text"></p>
<p>注意我们可以事先在项目中新建一个包，用来存放映射对象和文件<br><img src="/images/imgs3/12.gif" alt="Alt text"></p>
<p>最后点击finish，则自动生成了。<br><img src="/images/imgs3/13.gif" alt="Alt text"></p>
<p>最后值得注意的是，这里只是模拟了三张表，有一对多和多对一关系，主外键及级联，这样就省得我们自己去配置了，因为hibernate的关系配置真的很麻烦！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在运用持久层框架时，先前我们都是先通过建立对象—映射文件—数据库的方法，倘若数据库中的表非常多和复杂时，我们可以改变下开发顺序，即从数据库自
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>hibernate之三:浅谈HQL和映射文件</title>
    <link href="http://www.myzwl.win/2017/04/03/hbm3/"/>
    <id>http://www.myzwl.win/2017/04/03/hbm3/</id>
    <published>2017-04-03T07:48:51.000Z</published>
    <updated>2017-04-08T04:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们想要精确的查找某一个数据库中的信息时，最理想的方法就是通过sql语句查询，一般hibernate中可以通过query接口来写语句进行查询，这个语句可以使sql，hql，当然推荐的是hql，事实上我认为hql和sql基本差不多</p>
<p>一：Query接口<br>    Query接口类型的对象可以对数据库操作,它可以使用Hql和原生SQL(native Sql)对数据库操作.官方推荐使用Hql语句<br>先来看一个例子</p>
<p>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">	public void selectone()&#123;</div><div class="line">	User u=(User)session.createQuery(" from User where id=1").uniqueResult();</div><div class="line">	System.out.println(u.getName());&#125;</div></pre></td></tr></table></figure></p>
<p>分析：这里用了uniqueResult()方法 ，如果我们检索一个对象，明确知道最多只有一个对象，则建议使用该方法:</p>
<p>如果是取出集合对象，则使用如下方法：<br>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void selectone()&#123;		</div><div class="line">List&lt;User&gt; list=session.createQuery("from User").list();</div><div class="line">     for(User user : list)&#123;</div><div class="line">	System.out.println(user.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此我们可以发现，使用list可以取出集合对象，同时方法里面写想要的hql语句</p>
<p>二：HQL简单语法<br>  HQL是面向对象的查询语言，与SQL不同，HQL中的对象名是区分大小写的；HQL中查的是对象而不是表，并且支持多态；HQL主要通过Query来操作，Query的创建方式：</p>
<blockquote>
<p>Query q = session.createQuery(hql);</p>
</blockquote>
<p>1：between.. and..<br>  测试代码：</p>
<blockquote>
<p>List<user> list=session.createQuery(“from User where id between 0 and 2”).list();</user></p>
</blockquote>
<p>2：in /not in</p>
<blockquote>
<p>List<user> list=session.createQuery(“from User where id in (1,2)”).list();</user></p>
</blockquote>
<p>其他如group by，having，聚集函数等都类似于sql语句，换汤不换药。</p>
<p>参数绑定：<br> 先看例子：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">org.hibernate.Query query= session.createQuery("from User where id between ? and ?");</div><div class="line">	      query.setInteger(0, 1);</div><div class="line">	      query.setInteger(1,2);</div><div class="line">	      List&lt;User&gt; list=query.list();</div><div class="line">	      for(User user : list)&#123;</div><div class="line">	  		System.out.println(user.getName());</div><div class="line">	  	&#125;</div></pre></td></tr></table></figure>
<p>主要通过set与？的形式来注入参数，注意这里第一个？对应set的序号为0<br>使用绑定参数的好处:<br>1.可读性好.<br>2.性能提高.<br>3.防止sql注入</p>
<p>HQL语句远不止这些，这里只简单介绍了其中一些，</p>
<p>三：映射文件的配置<br> 映射文件的内容繁多，这里只简单介绍其中一些常见属性。大体说来，映射文件主要对class的映射，还包括属性，属性又分为主键，普通属性和集合属性，甚至还有复合属性，每种属性都需要进行不同的配置。</p>
<p> 先从入门程序中的例子说起：</p>
<blockquote>
<p> <hibernate-mapping package="com.zwl.bean"></hibernate-mapping></p>
<class name="User" table="user">

</class></blockquote>
<p>其中：package : 表示该类在哪个包下，name : 表示类名 table 表示 该类和哪个表映射<br>同时在class内部可以配置各种属性</p>
<p>主键：<br> 主键就是持久化类中标识属性，用于唯一标识该对象，主要通过<id>进行设置，有三个常用属性：name，column，type。<br>  Name  ：表示类的哪个属性是主键   必须指定<br>Column：指定在数据库中主键对应的列明  不必须指定<br>  Type：与数据库中对应字段类型一致  不必须指定<br>例外：主键需指定主键生产策略，即generator，一般用于自增长，针对不同数据库，关键词不一样，由于是mysql，所以自增长选择increment<br>以上的代码表示：</id></p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;id name=<span class="string">"id"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;generator class=<span class="string">"increment"</span>&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div></pre></td></tr></table></figure>
<p>普通属性：<br>  使用<property>标签，该标签必须指定name属性，用于标记持久化类的属性名称。一般有如下常见属性：<br> Type，column，not-null（是否允许为空），lazy（是否支持延迟加载，默认为false不支持），<br>代码如下：</property></p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;property name=<span class="string">"name"</span> type=<span class="string">"java.lang.String"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"name"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"age"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"age"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当我们想要精确的查找某一个数据库中的信息时，最理想的方法就是通过sql语句查询，一般hibernate中可以通过query接口来写语句进行查
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>hibernate之二:核心类和接口</title>
    <link href="http://www.myzwl.win/2017/04/02/hbm2/"/>
    <id>http://www.myzwl.win/2017/04/02/hbm2/</id>
    <published>2017-04-02T07:48:51.000Z</published>
    <updated>2017-04-08T04:04:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们对数据进行持久化操作时，必然涉及到hibernate的一些核心类，而这些类是我们在增删改查之前必然要引用和加载的<br>先看总览图：<br><img src="/images/imgs2/26.gif" alt="Alt text"></p>
<p>一般情况下，是由下向上看。</p>
<p>一 ：hibernate.cfg.xml文件<br>①该文件主要用于指定各个参数,是hibernate核心文件<br>    ②默认放在src目录下，也可以放在别的目录下。<br>    ③指定连接数据库的驱动、用户名、密码、url、连接池..<br>    ④指定对象关系映射文件的位置.<br>    ⑤也可使用hibernate.properties文件来替代该文件.(推荐使用<br>hibernate.cfg.xml)。<br>  如：入门程序代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;hibernate-configuration&gt;</div><div class="line">	&lt;session-factory&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.driver_class"</span>&gt;com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span>&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.url"</span>&gt;jdbc:mysql:<span class="comment">//localhost:9806/sshe&lt;/property&gt;</span></div><div class="line">		&lt;property name=<span class="string">"connection.username"</span>&gt;root&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"connection.password"</span>&gt;&lt;/property&gt;</div><div class="line">		&lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt;</div><div class="line">		&lt;property name=<span class="string">"show_sql"</span>&gt;true&lt;/property&gt;</div><div class="line">		&lt;!-- 配置数据库的方言/ --&gt;</div><div class="line">		&lt;property name=<span class="string">"dialect"</span>&gt;org<span class="selector-class">.hibernate</span><span class="selector-class">.dialect</span><span class="selector-class">.MySQL5InnoDBDialect</span>&lt;/property&gt;</div><div class="line">		 &lt;!-- 配置管理的对象映射文件 --&gt;</div><div class="line">		&lt;mapping resource=<span class="string">"com/zwl/bean/User.hbm.xml"</span>/&gt;</div><div class="line">	&lt;/session-factory&gt;</div><div class="line">&lt;/hibernate-configuration&gt;</div></pre></td></tr></table></figure></p>
<p>二：对象关系映射文件(*.hbm.xml)</p>
<p>  ①该文件主要作用是建立表和类的映射关系，是不可或缺的重要文件.<br>  ②一般放在其映射的类同一个目录下,但不是必须的。<br>  ③命名方式一般是 类名.hbm.xml,但不是必须的。<br>  ④示意图:<br><img src="/images/imgs2/27.gif" alt="Alt text"></p>
<p>如：入门程序代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;!-- package : 表示该类在哪个包下 --&gt;</div><div class="line">&lt;hibernate-mapping package=<span class="string">"com.zwl.bean"</span>&gt;</div><div class="line">&lt;!-- name : 表示类名 <span class="selector-tag">table</span> 表示 该类和哪个表映射 --&gt;</div><div class="line">	&lt;class name=<span class="string">"User"</span> table=<span class="string">"user"</span>&gt;</div><div class="line">		&lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt;</div><div class="line">		&lt;!-- name:表示类的哪个属性是主键 --&gt;</div><div class="line">		&lt;id name=<span class="string">"id"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;!-- 指定主键生成策略 --&gt;</div><div class="line">		&lt;generator class=<span class="string">"increment"</span>&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div><div class="line">		&lt;!-- property 里是普通属性 , column表示该属性映射到表中哪个字段 --&gt;</div><div class="line">		&lt;property name=<span class="string">"name"</span> type=<span class="string">"java.lang.String"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"name"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name=<span class="string">"age"</span> type=<span class="string">"java.lang.Integer"</span>&gt;</div><div class="line">		&lt;column name=<span class="string">"age"</span> not-null=<span class="string">"false"</span>/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>三：Configuration 类<br>它的用处是:</p>
<ol>
<li>读取hibernate.cfg.xml</li>
<li>管理对象关系映射文件 <mapping resource="””"></mapping></li>
<li>加载hibernate 的驱动,url ,用户..</li>
<li>管理hibernate配置信息</li>
</ol>
<p>创建的代码：</p>
<blockquote>
<p>Configuration cf=new Configuration().configure();</p>
</blockquote>
<p>四：SessionFactory （会话工厂）<br>这是典型的工厂设计模式，其是用来生产session实例的，注意由于该工厂启动耗费内存，所以应该只被初始化一次，并且应该是线程安全的，所以应该用单例模式设计</p>
<p>归纳一下特点：<br>1 缓存sql语句和某些数据</p>
<p>2.在应用程序初始化的时候创建,是一个重量级的类(吃内存),一般<br>用单例模式保证一个应用中只需要一个 SessionFactory实例.</p>
<p>3.如果某个应用访问多个数据库，则要创建多个会话工厂实例,一般<br>是一个数据库一个会话工厂实例.</p>
<p>4.通过SessionFactory接口可以获得Session(会话)实例</p>
<p>创建的代码：</p>
<blockquote>
<p>SessionFactory sf=cf.buildSessionFactory();</p>
</blockquote>
<p>五：Session<br> 1.Session一个实例代表与数据库的一次操作<br>(当然一次操作可以是crud组合)</p>
<p> 2.Session实例通过SessionFactory获取，用完<br>需要关闭。</p>
<p> 3.Session是线程不同步的(不安全),因此要保证<br>在同一线程中使用,可以用getCurrentSessiong()。</p>
<p> 4.Session可以看做是持久化管理器,它是与持久<br>化操作相关的接口</p>
<p>如图所示：<br><img src="/images/imgs2/28.gif" alt="Alt text"></p>
<p>另外：有两种方式获得session<br>1：通过openSession()获取session<br>openSession() 是获取一个新的session<br>2 getCurrentSession ()<br>  getCurrentSession () 获取和当前线程绑定的session,换言之，在同一个线程中，我们获取的session是同一session,这样可以利于事务控制</p>
<p>创建的代码：</p>
<blockquote>
<p>Session s=sf.getCurrentSession();<br>//或者是: Session s=sf.openSession();</p>
</blockquote>
<p>如何选择<br>原则:<br>1.如果需要在同一线程中，保证使用同一个Session则，使用getCurrentSession()<br>2.如果在一个线程中，需要使用不同的Session,则使用opentSession()<br>通过 getCurrentSession() 获取的session在事务提交后，会自动关闭，通过openSession()获取的session则必须手动关闭<br>如果是通过getCurrentSession() 获取 sesssion ,进行查询需要事务提交</p>
<p>Session(会话)接口的几个重要方法<br>Session一般以对象的形式来操作<br>    1保存一个对象(记录)—save方法<br>    2删除一个对象(记录)—delete方法<br>    3查询一个对象(记录)—get/load方法<br>    4修改一个对象(记录)—update方法</p>
<p>如：入门程序中的代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Sava方法：User u=new User();</div><div class="line">	   u.setId(1);</div><div class="line">	  u.setName("hello world");</div><div class="line">	  u.setAge(21);</div><div class="line">	 session.save(u);</div><div class="line">	 t.commit();</div><div class="line"></div><div class="line"></div><div class="line">Delete方法：User u=(User)session.get(User.class, 1);</div><div class="line">		    session.delete(u);</div><div class="line">		    t.commit();</div></pre></td></tr></table></figure>
<p>一般情况下，我们从数据库中获取对象，可以通过session.get（或者session.load（）），那么他们有什么区别了？<br>1、get()方法直接返回实体类,如果查不到数据则返回null。load()会<br>    返回一个实体代理对象（当前这个对象可以自动转化为实体对象），<br>    但当代理对象被调用时，如果没有数据不存在，就会抛出个<br>    org.hibernate.ObjectNotFoundException异常</p>
<p>这里：可以将get看做单例中的饿汉式，而load相当于懒汉式</p>
<ol>
<li><p>load先到缓存(session缓存/二级缓存)中去查，如果没有则返回一个<br>代理对象（不马上到DB中去找），等后面使用这个代理对象操作的时<br>候，才到DB中查询,这就是我们常说的 load在默认情况下支持延迟加<br>载（lazy）</p>
</li>
<li><p>get先到缓存(session缓存/二级缓存)中去查，如果没有就到DB中去<br> 查（即马上发出sql）。总之，如果你确定DB中有这个对象就用<br> load(),不确定就用get()（这样效率高）</p>
</li>
</ol>
<p>这里有一点注意：默认lazy加载时不启用，所以如果要启用，则需要在映射文件中配置</p>
<blockquote>
 <class name="User" table="user" lazy="true">

</class></blockquote>
<p>六：Transaction(事务)接口<br>    事务简单的说,就是一组对数据库的操作集合,它们要么全部成功,要<br>么全部失败.这个可以保证数据的一致性,事务具有原子性。</p>
<p>创建的代码：</p>
<blockquote>
<p>Transaction ts=s.beginTransaction();<br> …<br>ts.commit();s.close()； </p>
</blockquote>
<p>注意：如果数据库的数据发生变化，一定需要数据提交</p>
<p>七：Criteria接口<br>如入门程序的查询：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;User&gt; list=session.createCriteria(User.class).list();</div><div class="line">		for(User user : list)&#123;</div><div class="line">			System.out.println(user.getName());</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>即通过面向对象的操作，返回该对象所有的集合</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当我们对数据进行持久化操作时，必然涉及到hibernate的一些核心类，而这些类是我们在增删改查之前必然要引用和加载的&lt;br&gt;先看总览图：&lt;
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>hibernate之一:hello world</title>
    <link href="http://www.myzwl.win/2017/04/01/hbm1/"/>
    <id>http://www.myzwl.win/2017/04/01/hbm1/</id>
    <published>2017-04-01T07:48:51.000Z</published>
    <updated>2017-04-08T04:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对一个框架的直观认识，往往是从一个hello world程序开始的。Hibernate是一个完全的ORM（Object Relationship Mapping）对象映射框架。实现了JDBC轻量级的封装，使得在进行JDBC开发的时候可以直接使用面向对象的思维进行开发，说白了hibernate框架的作业就是在java对象和关系数据库中作了一个映射，使得程序员不用再使用各种SQL语句</p>
<p>Hibernate有如下几个特点：<br>  1：完成了对JDBC的封装，不用再与各种connection打交道<br> 2：是一个持久层框架，即对数据库进行持久化操作<br> 3：是一个ORM框架，不用再与各种sql打交道</p>
<p>接下里就是hibernate入门程序，目的先有一个直观认识，不考虑其含义，只要把流程走一遍就完成了目的。这里用最简的方式完成入门程序</p>
<p>步骤一：创建一个java 工程</p>
<p>步骤二：建一个lib文件夹，并导入如下jar包，然后添加至项目中<br><img src="/images/imgs2/25.gif" alt="Alt text"></p>
<p>步骤三：在src目录下创建一个hibernate.cfg.xml配置文件，并编写，同时添加mysql驱动包<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</div><div class="line">	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</div><div class="line">	"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;</div><div class="line">&lt;!-- 该文件用于配置连接数据的种类,用户名，密码,ul ,驱动.. 连接池,二级缓存 --&gt;</div><div class="line">&lt;hibernate-configuration&gt;</div><div class="line">	&lt;session-factory&gt;</div><div class="line">		&lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;</div><div class="line">		&lt;property name="connection.url"&gt;jdbc:mysql://localhost:9806/sshe&lt;/property&gt;</div><div class="line">		&lt;property name="connection.username"&gt;root&lt;/property&gt;</div><div class="line">		&lt;property name="connection.password"&gt;yourpassword&lt;/property&gt;</div><div class="line">		&lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt;</div><div class="line">		&lt;property name="show_sql"&gt;true&lt;/property&gt;</div><div class="line">		&lt;!-- 配置数据库的方言/ --&gt;</div><div class="line">		&lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;</div><div class="line">	&lt;/session-factory&gt;</div><div class="line">&lt;/hibernate-configuration&gt;</div></pre></td></tr></table></figure></p>
<p>简单说明一下：上面的配置文件指明了一些必要的数据库连接属性，通过这些属性，hibernate可以连接上数据库，可以配置不同的数据库，其中配置数据库的方言指明所配置的是用哪种数据库</p>
<p>步骤四：创建bean对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.zwl.bean;</div><div class="line"></div><div class="line">public class User &#123;</div><div class="line"></div><div class="line">	private int age;</div><div class="line">	private int id;</div><div class="line">	private String name;</div><div class="line">。。。此处省略set与get方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里注意：利用hibernate框架时，鼓励我们为每张表设置主键，即为每个对象设置一个id，在映射时与表的id对应</p>
<p>步骤五：创建数据库表，这个步骤也可以在步骤四之前进行。<br>主要为id（主键，自增长），name、age</p>
<p>步骤六：编写表与对象的映射文件User.hbm.xml<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;!--该文件要清楚地表述出 类 和 表 的对应关系--&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</div><div class="line">	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">	"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line">&lt;!-- package : 表示该类在哪个包下 --&gt;</div><div class="line">&lt;hibernate-mapping package="com.zwl.bean"&gt;</div><div class="line">&lt;!-- name : 表示类名 table 表示 该类和哪个表映射 --&gt;</div><div class="line">	&lt;class name="User" table="user"&gt;</div><div class="line">		&lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt;</div><div class="line">		&lt;!-- name:表示类的哪个属性是主键 --&gt;</div><div class="line">		&lt;id name="id" type="java.lang.Integer"&gt;</div><div class="line">		&lt;!-- 指定主键生成策略 --&gt;</div><div class="line">		&lt;generator class="increment"&gt;</div><div class="line">		&lt;/generator&gt;</div><div class="line">		&lt;/id&gt;</div><div class="line">		&lt;!-- property 里是普通属性 , column表示该属性映射到表中哪个字段 --&gt;</div><div class="line">		&lt;property name="name" type="java.lang.String"&gt;</div><div class="line">		&lt;column name="name" not-null="false"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">		&lt;property name="age" type="java.lang.Integer"&gt;</div><div class="line">		&lt;column name="age" not-null="false"/&gt;</div><div class="line">		&lt;/property&gt;</div><div class="line">	&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>简单说明一下：上面已经简要说明了一些含义，这里先看做强加的概念，事实上这是比较完整的配置，当然这里并没有给出简化的配置。同时，该文件相当于在java对象和数据库表中作了一个映射，这样以后就可以通过操作java对象来间接操作表<br> 另外，该映射文件一般放在与相应的java对象同处一个文件夹下，并且命名满足规范XXX.hbm.xml，其中xxx就是java对象名，最后还要在hibernate核心配置文件中声明该映射，即加入如下代码：</p>
<blockquote>
 <mapping resource="com/zwl/bean/User.hbm.xml">

</mapping></blockquote>
<p> 步骤六：就是进行测试，实现插入数据的crud操作</p>
<p> 首先写一个工具类：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.zwl.utils;</div><div class="line"></div><div class="line">import org.hibernate.SessionFactory;</div><div class="line">import org.hibernate.cfg.Configuration;</div><div class="line"></div><div class="line">public class HibernateUtils &#123;</div><div class="line">    private static final SessionFactory sessionFactory=BuildSessionFactory();</div><div class="line">    </div><div class="line">    private static SessionFactory BuildSessionFactory()&#123;</div><div class="line">    	try &#123;</div><div class="line">			return new Configuration().configure().buildSessionFactory();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			throw new ExceptionInInitializerError(e);</div><div class="line">		&#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	public static SessionFactory getSessionFactory()&#123;</div><div class="line">		return sessionFactory;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单说明一下，这里采用单例模式，目的是为了不要每次都加载配置，不然太耗费内存</p>
<p>接下来是测试类，首先是增加功能<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Usertest &#123;</div><div class="line"></div><div class="line">	SessionFactory sessionFactory=HibernateUtils.getSessionFactory();</div><div class="line">	Session session=sessionFactory.openSession();</div><div class="line">	Transaction t=session.beginTransaction();</div><div class="line"></div><div class="line">@Test</div><div class="line">public void save()&#123;</div><div class="line">	User u=new User();</div><div class="line">	u.setId(1);</div><div class="line">	u.setName("hello world");</div><div class="line">	u.setAge(21);</div><div class="line">	</div><div class="line">	session.save(u);</div><div class="line">	t.commit();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来是查询（遍历）<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//查询</div><div class="line">	@Test</div><div class="line">	public void select()&#123;</div><div class="line">		List&lt;User&gt; list=session.createCriteria(User.class).list();</div><div class="line">		for(User user : list)&#123;</div><div class="line">			System.out.println(user.getName());</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>最后是删除：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//删除</div><div class="line">	@Test</div><div class="line">	public void delete()&#123;</div><div class="line">		User u=(User)session.get(User.class, 1);</div><div class="line">		session.delete(u);</div><div class="line">		t.commit();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>修改这里就先不说了。<br>至此入门程序完成，意在了解hibernate的具体过程，有没有发现，到目前为止，我们都没有写sql语句，而都是对java对象进行操作，来操作表</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对一个框架的直观认识，往往是从一个hello world程序开始的。Hibernate是一个完全的ORM（Object Relationsh
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>struts2 之六:拦截器</title>
    <link href="http://www.myzwl.win/2017/03/31/structs6/"/>
    <id>http://www.myzwl.win/2017/03/31/structs6/</id>
    <published>2017-03-31T13:48:51.000Z</published>
    <updated>2017-04-07T10:30:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拦截器是structs2框架的核心功能，理解并使用拦截器有助于更灵活使用structs2.它像一个可插播的组件，围绕action和result进行，可以在方法调用之前、之后使用。通过structs2的工作流程，可以发现调用一个action之前之后有许多的拦截器，这些拦截器都通过后才可以执行具体的action。对与每一个拦截器来说，可以直接返回，从而终止余下的拦截器</p>
<p>以下，是structs工作原理图<br><img src="/images/imgs2/24.gif" alt="Alt text"></p>
<p>从图中可以看出，从一个具体的请求到action需要经过多个拦截器，action处理完成后，后续的拦截器会据需执行，最终到浏览器中。大概其工作流程如下</p>
<p>上述的servlet filters图示与实际有点不一样，其他一样（图不是现在版本）</p>
<p>一 首先请求发送给StrutsPrepareAndExecuteFilter（web.xml配置那个）</p>
<p>二：StrutsPrepareAndExecuteFilter判断该请求是否是一个structs2请求，如果是则进入第3步</p>
<p>三：如果是structs2请求，则把请求交给ActionProxy，是action代理类，ActionProxy创建一个Actioninvocation实例，并进行初始化</p>
<p>在执行具体的action之前，actionProxy会设计相关拦截器的调用<br>Action调用结束后，会根据structs.xml文件中action的result配置对象得到对应的返回结果。调用execute方法之后，执行后面的拦截器，把结果返回给浏览器</p>
<p>从整个请求处理过程来看，拦截器是处理的关键</p>
<p>下面将通过实现Interceptor接口来写一个简单的拦截器，<br>该接口有三个方法，init（），destroy（），intercept（），init（）在拦截器实例创建之后，intercept方法之前调用，主要用于初始化拦截器所需要的资源，destroy主要销毁初始化分配的资源，intercept方法则是在action之前调用，可以通过invocation对象获取action状态，从而根据状态的不同进行需要的拦截操作<br> 如下为一个简单的模拟案例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import com.opensymphony.xwork2.ActionInvocation;</div><div class="line">import com.opensymphony.xwork2.interceptor.Interceptor;</div><div class="line"></div><div class="line">public class lanji implements Interceptor &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void destroy() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void init() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String intercept(ActionInvocation invocation) throws Exception &#123;</div><div class="line">		long start=System.currentTimeMillis();</div><div class="line">		String result=invocation.invoke();//没有拦截，正常执行</div><div class="line">		long end=System.currentTimeMillis();</div><div class="line">		System.out.println(end-start);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就需要在配置文件中配置<br>首先申明该拦截器<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;interceptors&gt;</div><div class="line">		&lt;interceptor name=<span class="string">"lanji"</span> class=<span class="string">"com.zwl.pojo.lanji"</span>&gt;&lt;/interceptor&gt;</div><div class="line">		&lt;/interceptors&gt;</div><div class="line">在action中引用</div><div class="line">&lt;action name=<span class="string">"ognlaction"</span> class=<span class="string">"com.zwl.action.ognlaction"</span>&gt;</div><div class="line">  &lt;interceptor-ref name=<span class="string">"lanji"</span>&gt;&lt;/interceptor-ref&gt;</div><div class="line">			 &lt;interceptor-ref name=<span class="string">"defaultStack"</span>&gt;&lt;/interceptor-ref&gt;</div><div class="line">  &lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>注意必须要带上默认拦截器</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;拦截器是structs2框架的核心功能，理解并使用拦截器有助于更灵活使用structs2.它像一个可插播的组件，围绕action和resul
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>struts2 之五:通用标签</title>
    <link href="http://www.myzwl.win/2017/03/30/structs5/"/>
    <id>http://www.myzwl.win/2017/03/30/structs5/</id>
    <published>2017-03-30T12:48:51.000Z</published>
    <updated>2017-04-07T10:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> Struts2框架为我们提供了许多标签，这些标签从总体上可以分为两类：通用标签和ui标签。而较常使用的是通用标签，通用标签又分为两类，数据标签和控制标签。数据标签用于访问值栈中的数据。控制标签用于控制呈现页面时数据执行流程。</p>
<p> 不过使用structs2标签，需要在jsp首部加入如下代码</p>
<blockquote>
<p> &lt;%@ taglib uri=”/struts-tags” prefix=”s” %&gt;</p>
</blockquote>
<p>数据标签<br> 主要用于访问actioncontext和值栈中的数据</p>
<p>一：property标签</p>
<blockquote>
<p>格式：<s:property value="””default=””" escape="”true|false”/"></s:property></p>
</blockquote>
<p>如果value中的内容为object，则Struts2都会把它解析成ognl表达式<br>     如果里面需要表示为字符串，则需要将内容用单引号括起来</p>
<p>1、  利用ognl表达式取值(例如：取值堆栈中的username值)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"username"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>2、  取值为字符串<br>需要将内容用单引号括起来<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"’username’"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>3、  设置默认值-default<br>如果一个对象值取不到，则可以使用default设置一个默认值。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"admin"</span> default=”管理员”/&gt;</div></pre></td></tr></table></figure></p>
<p>4、  设定HTML-escape<br>是否设置返回值为HTML原代码样式<br>true：解析返回值的html代码　false:原封不动返回值<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;s:property value=<span class="string">"'&lt;hr/&gt;'"</span> escape=<span class="string">"false"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>二、 set标签<br>注：var　用于设定变量名<br>     value 变量值(可以是ognl表达式)，也可以是字符串<br>         scope 就是的作用范围 request session page application action(默认)</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;li&gt;set 设定adminName值（默认为request 和 ActionContext）: &lt;s:set var=<span class="string">"adminName"</span>value=<span class="string">"username"</span> /&gt;&lt;/li&gt;</div><div class="line">      </div><div class="line">&lt;li&gt;set 从request取值: &lt;s:property value=<span class="string">"#request.adminName"</span> /&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;set 从ActionContext取值: &lt;s:property value=<span class="string">"#adminName"</span> /&gt;&lt;/li&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;li&gt;set 设定var，范围为ActionContext: &lt;s:set var=<span class="string">"adminPassword"</span> value=<span class="string">"password"</span>scope=<span class="string">"session"</span>/&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;set 使用#取值: &lt;s:property value=<span class="string">"#adminPassword"</span>/&gt; &lt;/li&gt;</div><div class="line">&lt;li&gt;set 从相应范围取值: &lt;s:property value=<span class="string">"#session.adminPassword"</span>/&gt; &lt;/li&gt;</div></pre></td></tr></table></figure>
<p>控制标签<br> 一： If  elseif  else<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">age = &lt;s:property value=<span class="string">"#parameters.age[0]"</span> /&gt; &lt;br /&gt;</div><div class="line">     &lt;s:set var=<span class="string">"age"</span> value=<span class="string">"#parameters.age[0]"</span> /&gt;</div><div class="line">     &lt;s:<span class="keyword">if</span> test=<span class="string">"#age &lt; 0"</span>&gt;wrong age!&lt;/s:<span class="keyword">if</span>&gt;</div><div class="line">     &lt;s:elseif test=<span class="string">"#parameters.age[0] &lt; 20"</span>&gt;too young!&lt;/s:elseif&gt;</div><div class="line">     &lt;s:<span class="keyword">else</span>&gt;yeah!&lt;/s:<span class="keyword">else</span>&gt;&lt;br /&gt;</div></pre></td></tr></table></figure></p>
<p>二：Iterator标签<br>一般格式如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> &lt;s:iterator value=<span class="string">"值"</span> var=<span class="string">"x"</span>&gt;</div><div class="line">&lt;s:property value=<span class="string">"#x.username"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>这个格式将集合里的内容取出<br>该属性一般有三个属性，id，status，value<br>其中value属性指定迭代的集合，status属性可以获得迭代中一个状态信息（比如索引值，是否是奇偶数等）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;s:iterator value="&#123;'aaa', 'bbb', 'ccc'&#125;" status="status"&gt;</div><div class="line">          &lt;s:property/&gt; |</div><div class="line">          遍历过的元素总数：&lt;s:property value="#status.count"/&gt; |</div><div class="line">          遍历过的元素索引：&lt;s:property value="#status.index"/&gt; |</div><div class="line">          当前是偶数？：&lt;s:property value="#status.even"/&gt; |</div><div class="line">          当前是奇数？：&lt;s:property value="#status.odd"/&gt; |</div><div class="line">          是第一个元素吗？：&lt;s:property value="#status.first"/&gt; |</div><div class="line">          是最后一个元素吗？：&lt;s:property value="#status.last"/&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt; Struts2框架为我们提供了许多标签，这些标签从总体上可以分为两类：通用标签和ui标签。而较常使用的是通用标签，通用标签又分为两类，数据
    
    </summary>
    
      <category term="学习总结" scheme="http://www.myzwl.win/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="五大框架" scheme="http://www.myzwl.win/source/tags/%E4%BA%94%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
